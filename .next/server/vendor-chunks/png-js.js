/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/png-js";
exports.ids = ["vendor-chunks/png-js"];
exports.modules = {

/***/ "(rsc)/./node_modules/png-js/png-node.js":
/*!*****************************************!*\
  !*** ./node_modules/png-js/png-node.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * MIT LICENSE\n * Copyright (c) 2011 Devon Govett\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\n * software and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons\n * to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or\n * substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */ const fs = __webpack_require__(/*! fs */ \"fs\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nmodule.exports = class PNG {\n    static decode(path, fn) {\n        return fs.readFile(path, function(err, file) {\n            const png = new PNG(file);\n            return png.decode((pixels)=>fn(pixels));\n        });\n    }\n    static load(path) {\n        const file = fs.readFileSync(path);\n        return new PNG(file);\n    }\n    constructor(data){\n        let i;\n        this.data = data;\n        this.pos = 8; // Skip the default header\n        this.palette = [];\n        this.imgData = [];\n        this.transparency = {};\n        this.text = {};\n        while(true){\n            const chunkSize = this.readUInt32();\n            let section = \"\";\n            for(i = 0; i < 4; i++){\n                section += String.fromCharCode(this.data[this.pos++]);\n            }\n            switch(section){\n                case \"IHDR\":\n                    // we can grab  interesting values from here (like width, height, etc)\n                    this.width = this.readUInt32();\n                    this.height = this.readUInt32();\n                    this.bits = this.data[this.pos++];\n                    this.colorType = this.data[this.pos++];\n                    this.compressionMethod = this.data[this.pos++];\n                    this.filterMethod = this.data[this.pos++];\n                    this.interlaceMethod = this.data[this.pos++];\n                    break;\n                case \"PLTE\":\n                    this.palette = this.read(chunkSize);\n                    break;\n                case \"IDAT\":\n                    for(i = 0; i < chunkSize; i++){\n                        this.imgData.push(this.data[this.pos++]);\n                    }\n                    break;\n                case \"tRNS\":\n                    // This chunk can only occur once and it must occur after the\n                    // PLTE chunk and before the IDAT chunk.\n                    this.transparency = {};\n                    switch(this.colorType){\n                        case 3:\n                            // Indexed color, RGB. Each byte in this chunk is an alpha for\n                            // the palette index in the PLTE (\"palette\") chunk up until the\n                            // last non-opaque entry. Set up an array, stretching over all\n                            // palette entries which will be 0 (opaque) or 1 (transparent).\n                            this.transparency.indexed = this.read(chunkSize);\n                            var short = 255 - this.transparency.indexed.length;\n                            if (short > 0) {\n                                for(i = 0; i < short; i++){\n                                    this.transparency.indexed.push(255);\n                                }\n                            }\n                            break;\n                        case 0:\n                            // Greyscale. Corresponding to entries in the PLTE chunk.\n                            // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n                            this.transparency.grayscale = this.read(chunkSize)[0];\n                            break;\n                        case 2:\n                            // True color with proper alpha channel.\n                            this.transparency.rgb = this.read(chunkSize);\n                            break;\n                    }\n                    break;\n                case \"tEXt\":\n                    var text = this.read(chunkSize);\n                    var index = text.indexOf(0);\n                    var key = String.fromCharCode.apply(String, text.slice(0, index));\n                    this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n                    break;\n                case \"IEND\":\n                    // we've got everything we need!\n                    switch(this.colorType){\n                        case 0:\n                        case 3:\n                        case 4:\n                            this.colors = 1;\n                            break;\n                        case 2:\n                        case 6:\n                            this.colors = 3;\n                            break;\n                    }\n                    this.hasAlphaChannel = [\n                        4,\n                        6\n                    ].includes(this.colorType);\n                    var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n                    this.pixelBitlength = this.bits * colors;\n                    switch(this.colors){\n                        case 1:\n                            this.colorSpace = \"DeviceGray\";\n                            break;\n                        case 3:\n                            this.colorSpace = \"DeviceRGB\";\n                            break;\n                    }\n                    this.imgData = new Buffer(this.imgData);\n                    return;\n                    break;\n                default:\n                    // unknown (or unimportant) section, skip it\n                    this.pos += chunkSize;\n            }\n            this.pos += 4; // Skip the CRC\n            if (this.pos > this.data.length) {\n                throw new Error(\"Incomplete or corrupt PNG file\");\n            }\n        }\n    }\n    read(bytes) {\n        const result = new Array(bytes);\n        for(let i = 0; i < bytes; i++){\n            result[i] = this.data[this.pos++];\n        }\n        return result;\n    }\n    readUInt32() {\n        const b1 = this.data[this.pos++] << 24;\n        const b2 = this.data[this.pos++] << 16;\n        const b3 = this.data[this.pos++] << 8;\n        const b4 = this.data[this.pos++];\n        return b1 | b2 | b3 | b4;\n    }\n    readUInt16() {\n        const b1 = this.data[this.pos++] << 8;\n        const b2 = this.data[this.pos++];\n        return b1 | b2;\n    }\n    decodePixels(fn) {\n        return zlib.inflate(this.imgData, (err, data)=>{\n            if (err) {\n                throw err;\n            }\n            const { width, height } = this;\n            const pixelBytes = this.pixelBitlength / 8;\n            const pixels = new Buffer(width * height * pixelBytes);\n            const { length } = data;\n            let pos = 0;\n            function pass(x0, y0, dx, dy, singlePass = false) {\n                const w = Math.ceil((width - x0) / dx);\n                const h = Math.ceil((height - y0) / dy);\n                const scanlineLength = pixelBytes * w;\n                const buffer = singlePass ? pixels : new Buffer(scanlineLength * h);\n                let row = 0;\n                let c = 0;\n                while(row < h && pos < length){\n                    var byte, col, i, left, upper;\n                    switch(data[pos++]){\n                        case 0:\n                            for(i = 0; i < scanlineLength; i++){\n                                buffer[c++] = data[pos++];\n                            }\n                            break;\n                        case 1:\n                            for(i = 0; i < scanlineLength; i++){\n                                byte = data[pos++];\n                                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                                buffer[c++] = (byte + left) % 256;\n                            }\n                            break;\n                        case 2:\n                            for(i = 0; i < scanlineLength; i++){\n                                byte = data[pos++];\n                                col = (i - i % pixelBytes) / pixelBytes;\n                                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                                buffer[c++] = (upper + byte) % 256;\n                            }\n                            break;\n                        case 3:\n                            for(i = 0; i < scanlineLength; i++){\n                                byte = data[pos++];\n                                col = (i - i % pixelBytes) / pixelBytes;\n                                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n                            }\n                            break;\n                        case 4:\n                            for(i = 0; i < scanlineLength; i++){\n                                var paeth, upperLeft;\n                                byte = data[pos++];\n                                col = (i - i % pixelBytes) / pixelBytes;\n                                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                                if (row === 0) {\n                                    upper = upperLeft = 0;\n                                } else {\n                                    upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                                    upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                                }\n                                const p = left + upper - upperLeft;\n                                const pa = Math.abs(p - left);\n                                const pb = Math.abs(p - upper);\n                                const pc = Math.abs(p - upperLeft);\n                                if (pa <= pb && pa <= pc) {\n                                    paeth = left;\n                                } else if (pb <= pc) {\n                                    paeth = upper;\n                                } else {\n                                    paeth = upperLeft;\n                                }\n                                buffer[c++] = (byte + paeth) % 256;\n                            }\n                            break;\n                        default:\n                            throw new Error(`Invalid filter algorithm: ${data[pos - 1]}`);\n                    }\n                    if (!singlePass) {\n                        let pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n                        let bufferPos = row * scanlineLength;\n                        for(i = 0; i < w; i++){\n                            for(let j = 0; j < pixelBytes; j++)pixels[pixelsPos++] = buffer[bufferPos++];\n                            pixelsPos += (dx - 1) * pixelBytes;\n                        }\n                    }\n                    row++;\n                }\n            }\n            if (this.interlaceMethod === 1) {\n                /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */ pass(0, 0, 8, 8); // 1\n                pass(4, 0, 8, 8); // 2\n                pass(0, 4, 4, 8); // 3\n                pass(2, 0, 4, 4); // 4\n                pass(0, 2, 2, 4); // 5\n                pass(1, 0, 2, 2); // 6\n                pass(0, 1, 1, 2); // 7\n            } else {\n                pass(0, 0, 1, 1, true);\n            }\n            return fn(pixels);\n        });\n    }\n    decodePalette() {\n        const { palette } = this;\n        const { length } = palette;\n        const transparency = this.transparency.indexed || [];\n        const ret = new Buffer(transparency.length + length);\n        let pos = 0;\n        let c = 0;\n        for(let i = 0; i < length; i += 3){\n            var left;\n            ret[pos++] = palette[i];\n            ret[pos++] = palette[i + 1];\n            ret[pos++] = palette[i + 2];\n            ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n        }\n        return ret;\n    }\n    copyToImageData(imageData, pixels) {\n        let j, k;\n        let { colors } = this;\n        let palette = null;\n        let alpha = this.hasAlphaChannel;\n        if (this.palette.length) {\n            palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n            colors = 4;\n            alpha = true;\n        }\n        const data = imageData.data || imageData;\n        const { length } = data;\n        const input = palette || pixels;\n        let i = j = 0;\n        if (colors === 1) {\n            while(i < length){\n                k = palette ? pixels[i / 4] * 4 : j;\n                const v = input[k++];\n                data[i++] = v;\n                data[i++] = v;\n                data[i++] = v;\n                data[i++] = alpha ? input[k++] : 255;\n                j = k;\n            }\n        } else {\n            while(i < length){\n                k = palette ? pixels[i / 4] * 4 : j;\n                data[i++] = input[k++];\n                data[i++] = input[k++];\n                data[i++] = input[k++];\n                data[i++] = alpha ? input[k++] : 255;\n                j = k;\n            }\n        }\n    }\n    decode(fn) {\n        const ret = new Buffer(this.width * this.height * 4);\n        return this.decodePixels((pixels)=>{\n            this.copyToImageData(ret, pixels);\n            return fn(ret);\n        });\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcG5nLWpzL3BuZy1ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FFRCxNQUFNQSxLQUFLQyxtQkFBT0EsQ0FBQztBQUNuQixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUVyQkUsT0FBT0MsT0FBTyxHQUFHLE1BQU1DO0lBQ3JCLE9BQU9DLE9BQU9DLElBQUksRUFBRUMsRUFBRSxFQUFFO1FBQ3RCLE9BQU9SLEdBQUdTLFFBQVEsQ0FBQ0YsTUFBTSxTQUFTRyxHQUFHLEVBQUVDLElBQUk7WUFDekMsTUFBTUMsTUFBTSxJQUFJUCxJQUFJTTtZQUNwQixPQUFPQyxJQUFJTixNQUFNLENBQUNPLENBQUFBLFNBQVVMLEdBQUdLO1FBQ2pDO0lBQ0Y7SUFFQSxPQUFPQyxLQUFLUCxJQUFJLEVBQUU7UUFDaEIsTUFBTUksT0FBT1gsR0FBR2UsWUFBWSxDQUFDUjtRQUM3QixPQUFPLElBQUlGLElBQUlNO0lBQ2pCO0lBRUFLLFlBQVlDLElBQUksQ0FBRTtRQUNoQixJQUFJQztRQUNKLElBQUksQ0FBQ0QsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0UsR0FBRyxHQUFHLEdBQUcsMEJBQTBCO1FBRXhDLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7UUFDakIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsRUFBRTtRQUNqQixJQUFJLENBQUNDLFlBQVksR0FBRyxDQUFDO1FBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLENBQUM7UUFFYixNQUFPLEtBQU07WUFDWCxNQUFNQyxZQUFZLElBQUksQ0FBQ0MsVUFBVTtZQUNqQyxJQUFJQyxVQUFVO1lBQ2QsSUFBS1IsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7Z0JBQ3RCUSxXQUFXQyxPQUFPQyxZQUFZLENBQUMsSUFBSSxDQUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDRSxHQUFHLEdBQUc7WUFDdEQ7WUFFQSxPQUFRTztnQkFDTixLQUFLO29CQUNILHNFQUFzRTtvQkFDdEUsSUFBSSxDQUFDRyxLQUFLLEdBQUcsSUFBSSxDQUFDSixVQUFVO29CQUM1QixJQUFJLENBQUNLLE1BQU0sR0FBRyxJQUFJLENBQUNMLFVBQVU7b0JBQzdCLElBQUksQ0FBQ00sSUFBSSxHQUFHLElBQUksQ0FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxHQUFHO29CQUNqQyxJQUFJLENBQUNhLFNBQVMsR0FBRyxJQUFJLENBQUNmLElBQUksQ0FBQyxJQUFJLENBQUNFLEdBQUcsR0FBRztvQkFDdEMsSUFBSSxDQUFDYyxpQkFBaUIsR0FBRyxJQUFJLENBQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDRSxHQUFHLEdBQUc7b0JBQzlDLElBQUksQ0FBQ2UsWUFBWSxHQUFHLElBQUksQ0FBQ2pCLElBQUksQ0FBQyxJQUFJLENBQUNFLEdBQUcsR0FBRztvQkFDekMsSUFBSSxDQUFDZ0IsZUFBZSxHQUFHLElBQUksQ0FBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUNFLEdBQUcsR0FBRztvQkFDNUM7Z0JBRUYsS0FBSztvQkFDSCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJLENBQUNnQixJQUFJLENBQUNaO29CQUN6QjtnQkFFRixLQUFLO29CQUNILElBQUtOLElBQUksR0FBR0EsSUFBSU0sV0FBV04sSUFBSzt3QkFDOUIsSUFBSSxDQUFDRyxPQUFPLENBQUNnQixJQUFJLENBQUMsSUFBSSxDQUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxHQUFHO29CQUN6QztvQkFDQTtnQkFFRixLQUFLO29CQUNILDZEQUE2RDtvQkFDN0Qsd0NBQXdDO29CQUN4QyxJQUFJLENBQUNHLFlBQVksR0FBRyxDQUFDO29CQUNyQixPQUFRLElBQUksQ0FBQ1UsU0FBUzt3QkFDcEIsS0FBSzs0QkFDSCw4REFBOEQ7NEJBQzlELCtEQUErRDs0QkFDL0QsOERBQThEOzRCQUM5RCwrREFBK0Q7NEJBQy9ELElBQUksQ0FBQ1YsWUFBWSxDQUFDZ0IsT0FBTyxHQUFHLElBQUksQ0FBQ0YsSUFBSSxDQUFDWjs0QkFDdEMsSUFBSWUsUUFBUSxNQUFNLElBQUksQ0FBQ2pCLFlBQVksQ0FBQ2dCLE9BQU8sQ0FBQ0UsTUFBTTs0QkFDbEQsSUFBSUQsUUFBUSxHQUFHO2dDQUNiLElBQUtyQixJQUFJLEdBQUdBLElBQUlxQixPQUFPckIsSUFBSztvQ0FDMUIsSUFBSSxDQUFDSSxZQUFZLENBQUNnQixPQUFPLENBQUNELElBQUksQ0FBQztnQ0FDakM7NEJBQ0Y7NEJBQ0E7d0JBQ0YsS0FBSzs0QkFDSCx5REFBeUQ7NEJBQ3pELG9EQUFvRDs0QkFDcEQsSUFBSSxDQUFDZixZQUFZLENBQUNtQixTQUFTLEdBQUcsSUFBSSxDQUFDTCxJQUFJLENBQUNaLFVBQVUsQ0FBQyxFQUFFOzRCQUNyRDt3QkFDRixLQUFLOzRCQUNILHdDQUF3Qzs0QkFDeEMsSUFBSSxDQUFDRixZQUFZLENBQUNvQixHQUFHLEdBQUcsSUFBSSxDQUFDTixJQUFJLENBQUNaOzRCQUNsQztvQkFDSjtvQkFDQTtnQkFFRixLQUFLO29CQUNILElBQUlELE9BQU8sSUFBSSxDQUFDYSxJQUFJLENBQUNaO29CQUNyQixJQUFJbUIsUUFBUXBCLEtBQUtxQixPQUFPLENBQUM7b0JBQ3pCLElBQUlDLE1BQU1sQixPQUFPQyxZQUFZLENBQUNrQixLQUFLLENBQUNuQixRQUFRSixLQUFLd0IsS0FBSyxDQUFDLEdBQUdKO29CQUMxRCxJQUFJLENBQUNwQixJQUFJLENBQUNzQixJQUFJLEdBQUdsQixPQUFPQyxZQUFZLENBQUNrQixLQUFLLENBQ3hDbkIsUUFDQUosS0FBS3dCLEtBQUssQ0FBQ0osUUFBUTtvQkFFckI7Z0JBRUYsS0FBSztvQkFDSCxnQ0FBZ0M7b0JBQ2hDLE9BQVEsSUFBSSxDQUFDWCxTQUFTO3dCQUNwQixLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzs0QkFDSCxJQUFJLENBQUNnQixNQUFNLEdBQUc7NEJBQ2Q7d0JBQ0YsS0FBSzt3QkFDTCxLQUFLOzRCQUNILElBQUksQ0FBQ0EsTUFBTSxHQUFHOzRCQUNkO29CQUNKO29CQUVBLElBQUksQ0FBQ0MsZUFBZSxHQUFHO3dCQUFDO3dCQUFHO3FCQUFFLENBQUNDLFFBQVEsQ0FBQyxJQUFJLENBQUNsQixTQUFTO29CQUNyRCxJQUFJZ0IsU0FBUyxJQUFJLENBQUNBLE1BQU0sR0FBSSxLQUFJLENBQUNDLGVBQWUsR0FBRyxJQUFJO29CQUN2RCxJQUFJLENBQUNFLGNBQWMsR0FBRyxJQUFJLENBQUNwQixJQUFJLEdBQUdpQjtvQkFFbEMsT0FBUSxJQUFJLENBQUNBLE1BQU07d0JBQ2pCLEtBQUs7NEJBQ0gsSUFBSSxDQUFDSSxVQUFVLEdBQUc7NEJBQ2xCO3dCQUNGLEtBQUs7NEJBQ0gsSUFBSSxDQUFDQSxVQUFVLEdBQUc7NEJBQ2xCO29CQUNKO29CQUVBLElBQUksQ0FBQy9CLE9BQU8sR0FBRyxJQUFJZ0MsT0FBTyxJQUFJLENBQUNoQyxPQUFPO29CQUN0QztvQkFDQTtnQkFFRjtvQkFDRSw0Q0FBNEM7b0JBQzVDLElBQUksQ0FBQ0YsR0FBRyxJQUFJSztZQUNoQjtZQUVBLElBQUksQ0FBQ0wsR0FBRyxJQUFJLEdBQUcsZUFBZTtZQUU5QixJQUFJLElBQUksQ0FBQ0EsR0FBRyxHQUFHLElBQUksQ0FBQ0YsSUFBSSxDQUFDdUIsTUFBTSxFQUFFO2dCQUMvQixNQUFNLElBQUljLE1BQU07WUFDbEI7UUFDRjtJQUNGO0lBRUFsQixLQUFLbUIsS0FBSyxFQUFFO1FBQ1YsTUFBTUMsU0FBUyxJQUFJQyxNQUFNRjtRQUN6QixJQUFLLElBQUlyQyxJQUFJLEdBQUdBLElBQUlxQyxPQUFPckMsSUFBSztZQUM5QnNDLE1BQU0sQ0FBQ3RDLEVBQUUsR0FBRyxJQUFJLENBQUNELElBQUksQ0FBQyxJQUFJLENBQUNFLEdBQUcsR0FBRztRQUNuQztRQUNBLE9BQU9xQztJQUNUO0lBRUEvQixhQUFhO1FBQ1gsTUFBTWlDLEtBQUssSUFBSSxDQUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxHQUFHLElBQUk7UUFDcEMsTUFBTXdDLEtBQUssSUFBSSxDQUFDMUMsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxHQUFHLElBQUk7UUFDcEMsTUFBTXlDLEtBQUssSUFBSSxDQUFDM0MsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxHQUFHLElBQUk7UUFDcEMsTUFBTTBDLEtBQUssSUFBSSxDQUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQ0UsR0FBRyxHQUFHO1FBQ2hDLE9BQU91QyxLQUFLQyxLQUFLQyxLQUFLQztJQUN4QjtJQUVBQyxhQUFhO1FBQ1gsTUFBTUosS0FBSyxJQUFJLENBQUN6QyxJQUFJLENBQUMsSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSTtRQUNwQyxNQUFNd0MsS0FBSyxJQUFJLENBQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDRSxHQUFHLEdBQUc7UUFDaEMsT0FBT3VDLEtBQUtDO0lBQ2Q7SUFFQUksYUFBYXZELEVBQUUsRUFBRTtRQUNmLE9BQU9OLEtBQUs4RCxPQUFPLENBQUMsSUFBSSxDQUFDM0MsT0FBTyxFQUFFLENBQUNYLEtBQUtPO1lBQ3RDLElBQUlQLEtBQUs7Z0JBQ1AsTUFBTUE7WUFDUjtZQUVBLE1BQU0sRUFBRW1CLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUcsSUFBSTtZQUM5QixNQUFNbUMsYUFBYSxJQUFJLENBQUNkLGNBQWMsR0FBRztZQUV6QyxNQUFNdEMsU0FBUyxJQUFJd0MsT0FBT3hCLFFBQVFDLFNBQVNtQztZQUMzQyxNQUFNLEVBQUV6QixNQUFNLEVBQUUsR0FBR3ZCO1lBQ25CLElBQUlFLE1BQU07WUFFVixTQUFTK0MsS0FBS0MsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxhQUFhLEtBQUs7Z0JBQzlDLE1BQU1DLElBQUlDLEtBQUtDLElBQUksQ0FBQyxDQUFDN0MsUUFBUXNDLEVBQUMsSUFBS0U7Z0JBQ25DLE1BQU1NLElBQUlGLEtBQUtDLElBQUksQ0FBQyxDQUFDNUMsU0FBU3NDLEVBQUMsSUFBS0U7Z0JBQ3BDLE1BQU1NLGlCQUFpQlgsYUFBYU87Z0JBQ3BDLE1BQU1LLFNBQVNOLGFBQWExRCxTQUFTLElBQUl3QyxPQUFPdUIsaUJBQWlCRDtnQkFDakUsSUFBSUcsTUFBTTtnQkFDVixJQUFJQyxJQUFJO2dCQUNSLE1BQU9ELE1BQU1ILEtBQUt4RCxNQUFNcUIsT0FBUTtvQkFDOUIsSUFBSXdDLE1BQU1DLEtBQUsvRCxHQUFHZ0UsTUFBTUM7b0JBQ3hCLE9BQVFsRSxJQUFJLENBQUNFLE1BQU07d0JBQ2pCLEtBQUs7NEJBQ0gsSUFBS0QsSUFBSSxHQUFHQSxJQUFJMEQsZ0JBQWdCMUQsSUFBSztnQ0FDbkMyRCxNQUFNLENBQUNFLElBQUksR0FBRzlELElBQUksQ0FBQ0UsTUFBTTs0QkFDM0I7NEJBQ0E7d0JBRUYsS0FBSzs0QkFDSCxJQUFLRCxJQUFJLEdBQUdBLElBQUkwRCxnQkFBZ0IxRCxJQUFLO2dDQUNuQzhELE9BQU8vRCxJQUFJLENBQUNFLE1BQU07Z0NBQ2xCK0QsT0FBT2hFLElBQUkrQyxhQUFhLElBQUlZLE1BQU0sQ0FBQ0UsSUFBSWQsV0FBVztnQ0FDbERZLE1BQU0sQ0FBQ0UsSUFBSSxHQUFHLENBQUNDLE9BQU9FLElBQUcsSUFBSzs0QkFDaEM7NEJBQ0E7d0JBRUYsS0FBSzs0QkFDSCxJQUFLaEUsSUFBSSxHQUFHQSxJQUFJMEQsZ0JBQWdCMUQsSUFBSztnQ0FDbkM4RCxPQUFPL0QsSUFBSSxDQUFDRSxNQUFNO2dDQUNsQjhELE1BQU0sQ0FBQy9ELElBQUtBLElBQUkrQyxVQUFVLElBQUtBO2dDQUMvQmtCLFFBQ0VMLE9BQ0FELE1BQU0sQ0FDSixDQUFDQyxNQUFNLEtBQUtGLGlCQUNWSyxNQUFNaEIsYUFDTC9DLElBQUkrQyxXQUNSO2dDQUNIWSxNQUFNLENBQUNFLElBQUksR0FBRyxDQUFDSSxRQUFRSCxJQUFHLElBQUs7NEJBQ2pDOzRCQUNBO3dCQUVGLEtBQUs7NEJBQ0gsSUFBSzlELElBQUksR0FBR0EsSUFBSTBELGdCQUFnQjFELElBQUs7Z0NBQ25DOEQsT0FBTy9ELElBQUksQ0FBQ0UsTUFBTTtnQ0FDbEI4RCxNQUFNLENBQUMvRCxJQUFLQSxJQUFJK0MsVUFBVSxJQUFLQTtnQ0FDL0JpQixPQUFPaEUsSUFBSStDLGFBQWEsSUFBSVksTUFBTSxDQUFDRSxJQUFJZCxXQUFXO2dDQUNsRGtCLFFBQ0VMLE9BQ0FELE1BQU0sQ0FDSixDQUFDQyxNQUFNLEtBQUtGLGlCQUNWSyxNQUFNaEIsYUFDTC9DLElBQUkrQyxXQUNSO2dDQUNIWSxNQUFNLENBQUNFLElBQUksR0FBRyxDQUFDQyxPQUFPUCxLQUFLVyxLQUFLLENBQUMsQ0FBQ0YsT0FBT0MsS0FBSSxJQUFLLEVBQUMsSUFBSzs0QkFDMUQ7NEJBQ0E7d0JBRUYsS0FBSzs0QkFDSCxJQUFLakUsSUFBSSxHQUFHQSxJQUFJMEQsZ0JBQWdCMUQsSUFBSztnQ0FDbkMsSUFBSW1FLE9BQU9DO2dDQUNYTixPQUFPL0QsSUFBSSxDQUFDRSxNQUFNO2dDQUNsQjhELE1BQU0sQ0FBQy9ELElBQUtBLElBQUkrQyxVQUFVLElBQUtBO2dDQUMvQmlCLE9BQU9oRSxJQUFJK0MsYUFBYSxJQUFJWSxNQUFNLENBQUNFLElBQUlkLFdBQVc7Z0NBRWxELElBQUlhLFFBQVEsR0FBRztvQ0FDYkssUUFBUUcsWUFBWTtnQ0FDdEIsT0FBTztvQ0FDTEgsUUFDRU4sTUFBTSxDQUNKLENBQUNDLE1BQU0sS0FBS0YsaUJBQ1ZLLE1BQU1oQixhQUNML0MsSUFBSStDLFdBQ1I7b0NBQ0hxQixZQUNFTCxPQUNBSixNQUFNLENBQ0osQ0FBQ0MsTUFBTSxLQUFLRixpQkFDVixDQUFDSyxNQUFNLEtBQUtoQixhQUNYL0MsSUFBSStDLFdBQ1I7Z0NBQ0w7Z0NBRUEsTUFBTXNCLElBQUlMLE9BQU9DLFFBQVFHO2dDQUN6QixNQUFNRSxLQUFLZixLQUFLZ0IsR0FBRyxDQUFDRixJQUFJTDtnQ0FDeEIsTUFBTVEsS0FBS2pCLEtBQUtnQixHQUFHLENBQUNGLElBQUlKO2dDQUN4QixNQUFNUSxLQUFLbEIsS0FBS2dCLEdBQUcsQ0FBQ0YsSUFBSUQ7Z0NBRXhCLElBQUlFLE1BQU1FLE1BQU1GLE1BQU1HLElBQUk7b0NBQ3hCTixRQUFRSDtnQ0FDVixPQUFPLElBQUlRLE1BQU1DLElBQUk7b0NBQ25CTixRQUFRRjtnQ0FDVixPQUFPO29DQUNMRSxRQUFRQztnQ0FDVjtnQ0FFQVQsTUFBTSxDQUFDRSxJQUFJLEdBQUcsQ0FBQ0MsT0FBT0ssS0FBSSxJQUFLOzRCQUNqQzs0QkFDQTt3QkFFRjs0QkFDRSxNQUFNLElBQUkvQixNQUFNLENBQUMsMEJBQTBCLEVBQUVyQyxJQUFJLENBQUNFLE1BQU0sRUFBRSxDQUFDLENBQUM7b0JBQ2hFO29CQUVBLElBQUksQ0FBQ29ELFlBQVk7d0JBQ2YsSUFBSXFCLFlBQVksQ0FBQyxDQUFDeEIsS0FBS1UsTUFBTVIsRUFBQyxJQUFLekMsUUFBUXNDLEVBQUMsSUFBS0Y7d0JBQ2pELElBQUk0QixZQUFZZixNQUFNRjt3QkFDdEIsSUFBSzFELElBQUksR0FBR0EsSUFBSXNELEdBQUd0RCxJQUFLOzRCQUN0QixJQUFLLElBQUk0RSxJQUFJLEdBQUdBLElBQUk3QixZQUFZNkIsSUFDOUJqRixNQUFNLENBQUMrRSxZQUFZLEdBQUdmLE1BQU0sQ0FBQ2dCLFlBQVk7NEJBQzNDRCxhQUFhLENBQUN2QixLQUFLLEtBQUtKO3dCQUMxQjtvQkFDRjtvQkFFQWE7Z0JBQ0Y7WUFDRjtZQUVBLElBQUksSUFBSSxDQUFDM0MsZUFBZSxLQUFLLEdBQUc7Z0JBQzlCOzs7Ozs7Ozs7UUFTQSxHQUNBK0IsS0FBSyxHQUFHLEdBQUcsR0FBRyxJQUFJLElBQUk7Z0JBQ3RCQSxLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSTtnQkFDdEJBLEtBQUssR0FBRyxHQUFHLEdBQUcsSUFBSSxJQUFJO2dCQUN0QkEsS0FBSyxHQUFHLEdBQUcsR0FBRyxJQUFJLElBQUk7Z0JBQ3RCQSxLQUFLLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSTtnQkFDdEJBLEtBQUssR0FBRyxHQUFHLEdBQUcsSUFBSSxJQUFJO2dCQUN0QkEsS0FBSyxHQUFHLEdBQUcsR0FBRyxJQUFJLElBQUk7WUFDeEIsT0FBTztnQkFDTEEsS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHO1lBQ25CO1lBRUEsT0FBTzFELEdBQUdLO1FBQ1o7SUFDRjtJQUVBa0YsZ0JBQWdCO1FBQ2QsTUFBTSxFQUFFM0UsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUN4QixNQUFNLEVBQUVvQixNQUFNLEVBQUUsR0FBR3BCO1FBQ25CLE1BQU1FLGVBQWUsSUFBSSxDQUFDQSxZQUFZLENBQUNnQixPQUFPLElBQUksRUFBRTtRQUNwRCxNQUFNMEQsTUFBTSxJQUFJM0MsT0FBTy9CLGFBQWFrQixNQUFNLEdBQUdBO1FBQzdDLElBQUlyQixNQUFNO1FBQ1YsSUFBSTRELElBQUk7UUFFUixJQUFLLElBQUk3RCxJQUFJLEdBQUdBLElBQUlzQixRQUFRdEIsS0FBSyxFQUFHO1lBQ2xDLElBQUlnRTtZQUNKYyxHQUFHLENBQUM3RSxNQUFNLEdBQUdDLE9BQU8sQ0FBQ0YsRUFBRTtZQUN2QjhFLEdBQUcsQ0FBQzdFLE1BQU0sR0FBR0MsT0FBTyxDQUFDRixJQUFJLEVBQUU7WUFDM0I4RSxHQUFHLENBQUM3RSxNQUFNLEdBQUdDLE9BQU8sQ0FBQ0YsSUFBSSxFQUFFO1lBQzNCOEUsR0FBRyxDQUFDN0UsTUFBTSxHQUFHLENBQUMrRCxPQUFPNUQsWUFBWSxDQUFDeUQsSUFBSSxLQUFLLE9BQU9HLE9BQU87UUFDM0Q7UUFFQSxPQUFPYztJQUNUO0lBRUFDLGdCQUFnQkMsU0FBUyxFQUFFckYsTUFBTSxFQUFFO1FBQ2pDLElBQUlpRixHQUFHSztRQUNQLElBQUksRUFBRW5ELE1BQU0sRUFBRSxHQUFHLElBQUk7UUFDckIsSUFBSTVCLFVBQVU7UUFDZCxJQUFJZ0YsUUFBUSxJQUFJLENBQUNuRCxlQUFlO1FBRWhDLElBQUksSUFBSSxDQUFDN0IsT0FBTyxDQUFDb0IsTUFBTSxFQUFFO1lBQ3ZCcEIsVUFDRSxJQUFJLENBQUNpRixlQUFlLElBQUssS0FBSSxDQUFDQSxlQUFlLEdBQUcsSUFBSSxDQUFDTixhQUFhLEVBQUM7WUFDckUvQyxTQUFTO1lBQ1RvRCxRQUFRO1FBQ1Y7UUFFQSxNQUFNbkYsT0FBT2lGLFVBQVVqRixJQUFJLElBQUlpRjtRQUMvQixNQUFNLEVBQUUxRCxNQUFNLEVBQUUsR0FBR3ZCO1FBQ25CLE1BQU1xRixRQUFRbEYsV0FBV1A7UUFDekIsSUFBSUssSUFBSzRFLElBQUk7UUFFYixJQUFJOUMsV0FBVyxHQUFHO1lBQ2hCLE1BQU85QixJQUFJc0IsT0FBUTtnQkFDakIyRCxJQUFJL0UsVUFBVVAsTUFBTSxDQUFDSyxJQUFJLEVBQUUsR0FBRyxJQUFJNEU7Z0JBQ2xDLE1BQU1TLElBQUlELEtBQUssQ0FBQ0gsSUFBSTtnQkFDcEJsRixJQUFJLENBQUNDLElBQUksR0FBR3FGO2dCQUNadEYsSUFBSSxDQUFDQyxJQUFJLEdBQUdxRjtnQkFDWnRGLElBQUksQ0FBQ0MsSUFBSSxHQUFHcUY7Z0JBQ1p0RixJQUFJLENBQUNDLElBQUksR0FBR2tGLFFBQVFFLEtBQUssQ0FBQ0gsSUFBSSxHQUFHO2dCQUNqQ0wsSUFBSUs7WUFDTjtRQUNGLE9BQU87WUFDTCxNQUFPakYsSUFBSXNCLE9BQVE7Z0JBQ2pCMkQsSUFBSS9FLFVBQVVQLE1BQU0sQ0FBQ0ssSUFBSSxFQUFFLEdBQUcsSUFBSTRFO2dCQUNsQzdFLElBQUksQ0FBQ0MsSUFBSSxHQUFHb0YsS0FBSyxDQUFDSCxJQUFJO2dCQUN0QmxGLElBQUksQ0FBQ0MsSUFBSSxHQUFHb0YsS0FBSyxDQUFDSCxJQUFJO2dCQUN0QmxGLElBQUksQ0FBQ0MsSUFBSSxHQUFHb0YsS0FBSyxDQUFDSCxJQUFJO2dCQUN0QmxGLElBQUksQ0FBQ0MsSUFBSSxHQUFHa0YsUUFBUUUsS0FBSyxDQUFDSCxJQUFJLEdBQUc7Z0JBQ2pDTCxJQUFJSztZQUNOO1FBQ0Y7SUFDRjtJQUVBN0YsT0FBT0UsRUFBRSxFQUFFO1FBQ1QsTUFBTXdGLE1BQU0sSUFBSTNDLE9BQU8sSUFBSSxDQUFDeEIsS0FBSyxHQUFHLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2xELE9BQU8sSUFBSSxDQUFDaUMsWUFBWSxDQUFDbEQsQ0FBQUE7WUFDdkIsSUFBSSxDQUFDb0YsZUFBZSxDQUFDRCxLQUFLbkY7WUFDMUIsT0FBT0wsR0FBR3dGO1FBQ1o7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvcG5nLWpzL3BuZy1ub2RlLmpzPzNiNDEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIE1JVCBMSUNFTlNFXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgRGV2b24gR292ZXR0XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzXG4gKiBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmVcbiAqIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnNcbiAqIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvclxuICogc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HXG4gKiBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBORyB7XG4gIHN0YXRpYyBkZWNvZGUocGF0aCwgZm4pIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24oZXJyLCBmaWxlKSB7XG4gICAgICBjb25zdCBwbmcgPSBuZXcgUE5HKGZpbGUpO1xuICAgICAgcmV0dXJuIHBuZy5kZWNvZGUocGl4ZWxzID0+IGZuKHBpeGVscykpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGxvYWQocGF0aCkge1xuICAgIGNvbnN0IGZpbGUgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCk7XG4gICAgcmV0dXJuIG5ldyBQTkcoZmlsZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgbGV0IGk7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnBvcyA9IDg7IC8vIFNraXAgdGhlIGRlZmF1bHQgaGVhZGVyXG5cbiAgICB0aGlzLnBhbGV0dGUgPSBbXTtcbiAgICB0aGlzLmltZ0RhdGEgPSBbXTtcbiAgICB0aGlzLnRyYW5zcGFyZW5jeSA9IHt9O1xuICAgIHRoaXMudGV4dCA9IHt9O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IHRoaXMucmVhZFVJbnQzMigpO1xuICAgICAgbGV0IHNlY3Rpb24gPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgc2VjdGlvbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZGF0YVt0aGlzLnBvcysrXSk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoc2VjdGlvbikge1xuICAgICAgICBjYXNlICdJSERSJzpcbiAgICAgICAgICAvLyB3ZSBjYW4gZ3JhYiAgaW50ZXJlc3RpbmcgdmFsdWVzIGZyb20gaGVyZSAobGlrZSB3aWR0aCwgaGVpZ2h0LCBldGMpXG4gICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMucmVhZFVJbnQzMigpO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5yZWFkVUludDMyKCk7XG4gICAgICAgICAgdGhpcy5iaXRzID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgICAgICAgIHRoaXMuY29sb3JUeXBlID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5maWx0ZXJNZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgdGhpcy5pbnRlcmxhY2VNZXRob2QgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUExURSc6XG4gICAgICAgICAgdGhpcy5wYWxldHRlID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSURBVCc6XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNodW5rU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmltZ0RhdGEucHVzaCh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0Uk5TJzpcbiAgICAgICAgICAvLyBUaGlzIGNodW5rIGNhbiBvbmx5IG9jY3VyIG9uY2UgYW5kIGl0IG11c3Qgb2NjdXIgYWZ0ZXIgdGhlXG4gICAgICAgICAgLy8gUExURSBjaHVuayBhbmQgYmVmb3JlIHRoZSBJREFUIGNodW5rLlxuICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5ID0ge307XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAvLyBJbmRleGVkIGNvbG9yLCBSR0IuIEVhY2ggYnl0ZSBpbiB0aGlzIGNodW5rIGlzIGFuIGFscGhhIGZvclxuICAgICAgICAgICAgICAvLyB0aGUgcGFsZXR0ZSBpbmRleCBpbiB0aGUgUExURSAoXCJwYWxldHRlXCIpIGNodW5rIHVwIHVudGlsIHRoZVxuICAgICAgICAgICAgICAvLyBsYXN0IG5vbi1vcGFxdWUgZW50cnkuIFNldCB1cCBhbiBhcnJheSwgc3RyZXRjaGluZyBvdmVyIGFsbFxuICAgICAgICAgICAgICAvLyBwYWxldHRlIGVudHJpZXMgd2hpY2ggd2lsbCBiZSAwIChvcGFxdWUpIG9yIDEgKHRyYW5zcGFyZW50KS5cbiAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZCA9IHRoaXMucmVhZChjaHVua1NpemUpO1xuICAgICAgICAgICAgICB2YXIgc2hvcnQgPSAyNTUgLSB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKHNob3J0ID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzaG9ydDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkLnB1c2goMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8vIEdyZXlzY2FsZS4gQ29ycmVzcG9uZGluZyB0byBlbnRyaWVzIGluIHRoZSBQTFRFIGNodW5rLlxuICAgICAgICAgICAgICAvLyBHcmV5IGlzIHR3byBieXRlcywgcmFuZ2UgMCAuLiAoMiBeIGJpdC1kZXB0aCkgLSAxXG4gICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbmN5LmdyYXlzY2FsZSA9IHRoaXMucmVhZChjaHVua1NpemUpWzBdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gVHJ1ZSBjb2xvciB3aXRoIHByb3BlciBhbHBoYSBjaGFubmVsLlxuICAgICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW5jeS5yZ2IgPSB0aGlzLnJlYWQoY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RFWHQnOlxuICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5yZWFkKGNodW5rU2l6ZSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGV4dC5pbmRleE9mKDApO1xuICAgICAgICAgIHZhciBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdGV4dC5zbGljZSgwLCBpbmRleCkpO1xuICAgICAgICAgIHRoaXMudGV4dFtrZXldID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgICAgICAgIFN0cmluZyxcbiAgICAgICAgICAgIHRleHQuc2xpY2UoaW5kZXggKyAxKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSUVORCc6XG4gICAgICAgICAgLy8gd2UndmUgZ290IGV2ZXJ5dGhpbmcgd2UgbmVlZCFcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuY29sb3JUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHRoaXMuY29sb3JzID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHRoaXMuY29sb3JzID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5oYXNBbHBoYUNoYW5uZWwgPSBbNCwgNl0uaW5jbHVkZXModGhpcy5jb2xvclR5cGUpO1xuICAgICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycyArICh0aGlzLmhhc0FscGhhQ2hhbm5lbCA/IDEgOiAwKTtcbiAgICAgICAgICB0aGlzLnBpeGVsQml0bGVuZ3RoID0gdGhpcy5iaXRzICogY29sb3JzO1xuXG4gICAgICAgICAgc3dpdGNoICh0aGlzLmNvbG9ycykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSAnRGV2aWNlR3JheSc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB0aGlzLmNvbG9yU3BhY2UgPSAnRGV2aWNlUkdCJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5pbWdEYXRhID0gbmV3IEJ1ZmZlcih0aGlzLmltZ0RhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIHVua25vd24gKG9yIHVuaW1wb3J0YW50KSBzZWN0aW9uLCBza2lwIGl0XG4gICAgICAgICAgdGhpcy5wb3MgKz0gY2h1bmtTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyArPSA0OyAvLyBTa2lwIHRoZSBDUkNcblxuICAgICAgaWYgKHRoaXMucG9zID4gdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGxldGUgb3IgY29ycnVwdCBQTkcgZmlsZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlYWQoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoYnl0ZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXM7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVhZFVJbnQzMigpIHtcbiAgICBjb25zdCBiMSA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAyNDtcbiAgICBjb25zdCBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCAxNjtcbiAgICBjb25zdCBiMyA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXSA8PCA4O1xuICAgIGNvbnN0IGI0ID0gdGhpcy5kYXRhW3RoaXMucG9zKytdO1xuICAgIHJldHVybiBiMSB8IGIyIHwgYjMgfCBiNDtcbiAgfVxuXG4gIHJlYWRVSW50MTYoKSB7XG4gICAgY29uc3QgYjEgPSB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPDwgODtcbiAgICBjb25zdCBiMiA9IHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICByZXR1cm4gYjEgfCBiMjtcbiAgfVxuXG4gIGRlY29kZVBpeGVscyhmbikge1xuICAgIHJldHVybiB6bGliLmluZmxhdGUodGhpcy5pbWdEYXRhLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgICAgY29uc3QgcGl4ZWxCeXRlcyA9IHRoaXMucGl4ZWxCaXRsZW5ndGggLyA4O1xuXG4gICAgICBjb25zdCBwaXhlbHMgPSBuZXcgQnVmZmVyKHdpZHRoICogaGVpZ2h0ICogcGl4ZWxCeXRlcyk7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTtcbiAgICAgIGxldCBwb3MgPSAwO1xuXG4gICAgICBmdW5jdGlvbiBwYXNzKHgwLCB5MCwgZHgsIGR5LCBzaW5nbGVQYXNzID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgdyA9IE1hdGguY2VpbCgod2lkdGggLSB4MCkgLyBkeCk7XG4gICAgICAgIGNvbnN0IGggPSBNYXRoLmNlaWwoKGhlaWdodCAtIHkwKSAvIGR5KTtcbiAgICAgICAgY29uc3Qgc2NhbmxpbmVMZW5ndGggPSBwaXhlbEJ5dGVzICogdztcbiAgICAgICAgY29uc3QgYnVmZmVyID0gc2luZ2xlUGFzcyA/IHBpeGVscyA6IG5ldyBCdWZmZXIoc2NhbmxpbmVMZW5ndGggKiBoKTtcbiAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgIGxldCBjID0gMDtcbiAgICAgICAgd2hpbGUgKHJvdyA8IGggJiYgcG9zIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGJ5dGUsIGNvbCwgaSwgbGVmdCwgdXBwZXI7XG4gICAgICAgICAgc3dpdGNoIChkYXRhW3BvcysrXSkge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyBOb25lXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOiAvLyBTdWJcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IGJ1ZmZlcltjIC0gcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgYnVmZmVyW2MrK10gPSAoYnl0ZSArIGxlZnQpICUgMjU2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6IC8vIFVwXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIGNvbCA9IChpIC0gKGkgJSBwaXhlbEJ5dGVzKSkgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIHVwcGVyID1cbiAgICAgICAgICAgICAgICAgIHJvdyAmJlxuICAgICAgICAgICAgICAgICAgYnVmZmVyW1xuICAgICAgICAgICAgICAgICAgICAocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgY29sICogcGl4ZWxCeXRlcyArXG4gICAgICAgICAgICAgICAgICAgICAgKGkgJSBwaXhlbEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbYysrXSA9ICh1cHBlciArIGJ5dGUpICUgMjU2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6IC8vIEF2ZXJhZ2VcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjYW5saW5lTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgY29sID0gKGkgLSAoaSAlIHBpeGVsQnl0ZXMpKSAvIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGkgPCBwaXhlbEJ5dGVzID8gMCA6IGJ1ZmZlcltjIC0gcGl4ZWxCeXRlc107XG4gICAgICAgICAgICAgICAgdXBwZXIgPVxuICAgICAgICAgICAgICAgICAgcm93ICYmXG4gICAgICAgICAgICAgICAgICBidWZmZXJbXG4gICAgICAgICAgICAgICAgICAgIChyb3cgLSAxKSAqIHNjYW5saW5lTGVuZ3RoICtcbiAgICAgICAgICAgICAgICAgICAgICBjb2wgKiBwaXhlbEJ5dGVzICtcbiAgICAgICAgICAgICAgICAgICAgICAoaSAlIHBpeGVsQnl0ZXMpXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKGJ5dGUgKyBNYXRoLmZsb29yKChsZWZ0ICsgdXBwZXIpIC8gMikpICUgMjU2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQ6IC8vIFBhZXRoXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY2FubGluZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZXRoLCB1cHBlckxlZnQ7XG4gICAgICAgICAgICAgICAgYnl0ZSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIGNvbCA9IChpIC0gKGkgJSBwaXhlbEJ5dGVzKSkgLyBwaXhlbEJ5dGVzO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBpIDwgcGl4ZWxCeXRlcyA/IDAgOiBidWZmZXJbYyAtIHBpeGVsQnl0ZXNdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJvdyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgdXBwZXIgPSB1cHBlckxlZnQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB1cHBlciA9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltcbiAgICAgICAgICAgICAgICAgICAgICAocm93IC0gMSkgKiBzY2FubGluZUxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wgKiBwaXhlbEJ5dGVzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpICUgcGl4ZWxCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgIHVwcGVyTGVmdCA9XG4gICAgICAgICAgICAgICAgICAgIGNvbCAmJlxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbXG4gICAgICAgICAgICAgICAgICAgICAgKHJvdyAtIDEpICogc2NhbmxpbmVMZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbCAtIDEpICogcGl4ZWxCeXRlcyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaSAlIHBpeGVsQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IGxlZnQgKyB1cHBlciAtIHVwcGVyTGVmdDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYSA9IE1hdGguYWJzKHAgLSBsZWZ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYiA9IE1hdGguYWJzKHAgLSB1cHBlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcGMgPSBNYXRoLmFicyhwIC0gdXBwZXJMZWZ0KTtcblxuICAgICAgICAgICAgICAgIGlmIChwYSA8PSBwYiAmJiBwYSA8PSBwYykge1xuICAgICAgICAgICAgICAgICAgcGFldGggPSBsZWZ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGIgPD0gcGMpIHtcbiAgICAgICAgICAgICAgICAgIHBhZXRoID0gdXBwZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBhZXRoID0gdXBwZXJMZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1ZmZlcltjKytdID0gKGJ5dGUgKyBwYWV0aCkgJSAyNTY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWx0ZXIgYWxnb3JpdGhtOiAke2RhdGFbcG9zIC0gMV19YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzaW5nbGVQYXNzKSB7XG4gICAgICAgICAgICBsZXQgcGl4ZWxzUG9zID0gKCh5MCArIHJvdyAqIGR5KSAqIHdpZHRoICsgeDApICogcGl4ZWxCeXRlcztcbiAgICAgICAgICAgIGxldCBidWZmZXJQb3MgPSByb3cgKiBzY2FubGluZUxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwaXhlbEJ5dGVzOyBqKyspXG4gICAgICAgICAgICAgICAgcGl4ZWxzW3BpeGVsc1BvcysrXSA9IGJ1ZmZlcltidWZmZXJQb3MrK107XG4gICAgICAgICAgICAgIHBpeGVsc1BvcyArPSAoZHggLSAxKSAqIHBpeGVsQnl0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW50ZXJsYWNlTWV0aG9kID09PSAxKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgMSA2IDQgNiAyIDYgNCA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICAgNSA2IDUgNiA1IDYgNSA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICAgMyA2IDQgNiAzIDYgNCA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICAgNSA2IDUgNiA1IDYgNSA2XG4gICAgICAgICAgNyA3IDcgNyA3IDcgNyA3XG4gICAgICAgICovXG4gICAgICAgIHBhc3MoMCwgMCwgOCwgOCk7IC8vIDFcbiAgICAgICAgcGFzcyg0LCAwLCA4LCA4KTsgLy8gMlxuICAgICAgICBwYXNzKDAsIDQsIDQsIDgpOyAvLyAzXG4gICAgICAgIHBhc3MoMiwgMCwgNCwgNCk7IC8vIDRcbiAgICAgICAgcGFzcygwLCAyLCAyLCA0KTsgLy8gNVxuICAgICAgICBwYXNzKDEsIDAsIDIsIDIpOyAvLyA2XG4gICAgICAgIHBhc3MoMCwgMSwgMSwgMik7IC8vIDdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhc3MoMCwgMCwgMSwgMSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihwaXhlbHMpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVjb2RlUGFsZXR0ZSgpIHtcbiAgICBjb25zdCB7IHBhbGV0dGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHBhbGV0dGU7XG4gICAgY29uc3QgdHJhbnNwYXJlbmN5ID0gdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZCB8fCBbXTtcbiAgICBjb25zdCByZXQgPSBuZXcgQnVmZmVyKHRyYW5zcGFyZW5jeS5sZW5ndGggKyBsZW5ndGgpO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGxldCBjID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIHZhciBsZWZ0O1xuICAgICAgcmV0W3BvcysrXSA9IHBhbGV0dGVbaV07XG4gICAgICByZXRbcG9zKytdID0gcGFsZXR0ZVtpICsgMV07XG4gICAgICByZXRbcG9zKytdID0gcGFsZXR0ZVtpICsgMl07XG4gICAgICByZXRbcG9zKytdID0gKGxlZnQgPSB0cmFuc3BhcmVuY3lbYysrXSkgIT0gbnVsbCA/IGxlZnQgOiAyNTU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGNvcHlUb0ltYWdlRGF0YShpbWFnZURhdGEsIHBpeGVscykge1xuICAgIGxldCBqLCBrO1xuICAgIGxldCB7IGNvbG9ycyB9ID0gdGhpcztcbiAgICBsZXQgcGFsZXR0ZSA9IG51bGw7XG4gICAgbGV0IGFscGhhID0gdGhpcy5oYXNBbHBoYUNoYW5uZWw7XG5cbiAgICBpZiAodGhpcy5wYWxldHRlLmxlbmd0aCkge1xuICAgICAgcGFsZXR0ZSA9XG4gICAgICAgIHRoaXMuX2RlY29kZWRQYWxldHRlIHx8ICh0aGlzLl9kZWNvZGVkUGFsZXR0ZSA9IHRoaXMuZGVjb2RlUGFsZXR0ZSgpKTtcbiAgICAgIGNvbG9ycyA9IDQ7XG4gICAgICBhbHBoYSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhIHx8IGltYWdlRGF0YTtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gZGF0YTtcbiAgICBjb25zdCBpbnB1dCA9IHBhbGV0dGUgfHwgcGl4ZWxzO1xuICAgIGxldCBpID0gKGogPSAwKTtcblxuICAgIGlmIChjb2xvcnMgPT09IDEpIHtcbiAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGsgPSBwYWxldHRlID8gcGl4ZWxzW2kgLyA0XSAqIDQgOiBqO1xuICAgICAgICBjb25zdCB2ID0gaW5wdXRbaysrXTtcbiAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgZGF0YVtpKytdID0gdjtcbiAgICAgICAgZGF0YVtpKytdID0gYWxwaGEgPyBpbnB1dFtrKytdIDogMjU1O1xuICAgICAgICBqID0gaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgayA9IHBhbGV0dGUgPyBwaXhlbHNbaSAvIDRdICogNCA6IGo7XG4gICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IGlucHV0W2srK107XG4gICAgICAgIGRhdGFbaSsrXSA9IGFscGhhID8gaW5wdXRbaysrXSA6IDI1NTtcbiAgICAgICAgaiA9IGs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGVjb2RlKGZuKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEJ1ZmZlcih0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiA0KTtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVQaXhlbHMocGl4ZWxzID0+IHtcbiAgICAgIHRoaXMuY29weVRvSW1hZ2VEYXRhKHJldCwgcGl4ZWxzKTtcbiAgICAgIHJldHVybiBmbihyZXQpO1xuICAgIH0pO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInpsaWIiLCJtb2R1bGUiLCJleHBvcnRzIiwiUE5HIiwiZGVjb2RlIiwicGF0aCIsImZuIiwicmVhZEZpbGUiLCJlcnIiLCJmaWxlIiwicG5nIiwicGl4ZWxzIiwibG9hZCIsInJlYWRGaWxlU3luYyIsImNvbnN0cnVjdG9yIiwiZGF0YSIsImkiLCJwb3MiLCJwYWxldHRlIiwiaW1nRGF0YSIsInRyYW5zcGFyZW5jeSIsInRleHQiLCJjaHVua1NpemUiLCJyZWFkVUludDMyIiwic2VjdGlvbiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIndpZHRoIiwiaGVpZ2h0IiwiYml0cyIsImNvbG9yVHlwZSIsImNvbXByZXNzaW9uTWV0aG9kIiwiZmlsdGVyTWV0aG9kIiwiaW50ZXJsYWNlTWV0aG9kIiwicmVhZCIsInB1c2giLCJpbmRleGVkIiwic2hvcnQiLCJsZW5ndGgiLCJncmF5c2NhbGUiLCJyZ2IiLCJpbmRleCIsImluZGV4T2YiLCJrZXkiLCJhcHBseSIsInNsaWNlIiwiY29sb3JzIiwiaGFzQWxwaGFDaGFubmVsIiwiaW5jbHVkZXMiLCJwaXhlbEJpdGxlbmd0aCIsImNvbG9yU3BhY2UiLCJCdWZmZXIiLCJFcnJvciIsImJ5dGVzIiwicmVzdWx0IiwiQXJyYXkiLCJiMSIsImIyIiwiYjMiLCJiNCIsInJlYWRVSW50MTYiLCJkZWNvZGVQaXhlbHMiLCJpbmZsYXRlIiwicGl4ZWxCeXRlcyIsInBhc3MiLCJ4MCIsInkwIiwiZHgiLCJkeSIsInNpbmdsZVBhc3MiLCJ3IiwiTWF0aCIsImNlaWwiLCJoIiwic2NhbmxpbmVMZW5ndGgiLCJidWZmZXIiLCJyb3ciLCJjIiwiYnl0ZSIsImNvbCIsImxlZnQiLCJ1cHBlciIsImZsb29yIiwicGFldGgiLCJ1cHBlckxlZnQiLCJwIiwicGEiLCJhYnMiLCJwYiIsInBjIiwicGl4ZWxzUG9zIiwiYnVmZmVyUG9zIiwiaiIsImRlY29kZVBhbGV0dGUiLCJyZXQiLCJjb3B5VG9JbWFnZURhdGEiLCJpbWFnZURhdGEiLCJrIiwiYWxwaGEiLCJfZGVjb2RlZFBhbGV0dGUiLCJpbnB1dCIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/png-js/png-node.js\n");

/***/ })

};
;