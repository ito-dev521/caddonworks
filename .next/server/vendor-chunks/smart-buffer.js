"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smart-buffer";
exports.ids = ["vendor-chunks/smart-buffer"];
exports.modules = {

/***/ "(rsc)/./node_modules/smart-buffer/build/smartbuffer.js":
/*!********************************************************!*\
  !*** ./node_modules/smart-buffer/build/smartbuffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/smart-buffer/build/utils.js\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = \"utf8\";\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */ constructor(options){\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                } else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n            // Check for initial Buffer\n            } else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                } else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            } else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        } else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== \"undefined\") {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */ static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */ static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */ static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */ static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigInt64BE\");\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigInt64LE\");\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64BE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64BE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64LE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigInt64LE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigUInt64BE\");\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */ readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check(\"readBigUInt64LE\");\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64BE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64BE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64LE\");\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check(\"writeBigUInt64LE\");\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */ readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */ writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */ insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */ readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === \"number\") {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        } else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== \"undefined\") {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */ readStringNT(encoding) {\n        if (typeof encoding !== \"undefined\") {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for(let i = this._readOffset; i < this.length; i++){\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */ writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === \"number\" ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */ readBuffer(length) {\n        if (typeof length !== \"undefined\") {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === \"number\" ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */ readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for(let i = this._readOffset; i < this.length; i++){\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */ writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== \"undefined\") {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === \"number\" ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */ clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */ set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */ get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */ set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */ get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */ set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */ get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */ toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */ toString(encoding) {\n        const encodingVal = typeof encoding === \"string\" ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */ destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */ _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === \"number\") {\n            offsetVal = arg3;\n        // Check for encoding\n        } else if (typeof arg3 === \"string\") {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === \"string\") {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        } else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        } else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === \"number\") {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            } else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */ _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        } else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        } else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === \"number\") {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            } else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */ ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== \"undefined\") {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */ ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        } else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */ _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */ _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = oldLength * 3 / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */ _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === \"number\" ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === \"undefined\") {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */ _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */ _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === \"number\") {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === \"number\" ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === \"number\") {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        } else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer; //# sourceMappingURL=smartbuffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3NtYXJ0YnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLGlFQUFTO0FBQ2pDLGtEQUFrRDtBQUNsRCxNQUFNQywyQkFBMkI7QUFDakMsa0VBQWtFO0FBQ2xFLE1BQU1DLCtCQUErQjtBQUNyQyxNQUFNQztJQUNGOzs7O0tBSUMsR0FDREMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxTQUFTLEdBQUdMO1FBQ2pCLElBQUksQ0FBQ00sWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUlOLFlBQVlPLG9CQUFvQixDQUFDTCxVQUFVO1lBQzNDLHNCQUFzQjtZQUN0QixJQUFJQSxRQUFRTSxRQUFRLEVBQUU7Z0JBQ2xCWixRQUFRYSxhQUFhLENBQUNQLFFBQVFNLFFBQVE7Z0JBQ3RDLElBQUksQ0FBQ0osU0FBUyxHQUFHRixRQUFRTSxRQUFRO1lBQ3JDO1lBQ0EsaUNBQWlDO1lBQ2pDLElBQUlOLFFBQVFRLElBQUksRUFBRTtnQkFDZCxJQUFJZCxRQUFRZSxlQUFlLENBQUNULFFBQVFRLElBQUksS0FBS1IsUUFBUVEsSUFBSSxHQUFHLEdBQUc7b0JBQzNELElBQUksQ0FBQ0UsS0FBSyxHQUFHQyxPQUFPQyxXQUFXLENBQUNaLFFBQVFRLElBQUk7Z0JBQ2hELE9BQ0s7b0JBQ0QsTUFBTSxJQUFJSyxNQUFNbkIsUUFBUW9CLE1BQU0sQ0FBQ0Msd0JBQXdCO2dCQUMzRDtZQUNBLDJCQUEyQjtZQUMvQixPQUNLLElBQUlmLFFBQVFnQixJQUFJLEVBQUU7Z0JBQ25CLElBQUlMLE9BQU9NLFFBQVEsQ0FBQ2pCLFFBQVFnQixJQUFJLEdBQUc7b0JBQy9CLElBQUksQ0FBQ04sS0FBSyxHQUFH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O1FBQzNCK0csS0FBS0UsSUFBSSxDQUFDLElBQUksQ0FBQ2pJLEtBQUssRUFBRWpCLE9BQU9pQztRQUM3QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDdkIsWUFBWSxJQUFJdUk7UUFDckIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7S0FXQyxHQUNEckcsa0JBQWtCb0csSUFBSSxFQUFFQyxRQUFRLEVBQUVqSixLQUFLLEVBQUVpQyxNQUFNLEVBQUU7UUFDN0MsMENBQTBDO1FBQzFDLElBQUksT0FBT0EsV0FBVyxVQUFVO1lBQzVCLGdFQUFnRTtZQUNoRSxJQUFJQSxTQUFTLEdBQUc7Z0JBQ1osTUFBTSxJQUFJYixNQUFNbkIsUUFBUW9CLE1BQU0sQ0FBQzhILDJCQUEyQjtZQUM5RDtZQUNBbEosUUFBUW9HLGdCQUFnQixDQUFDcEU7UUFDN0I7UUFDQSx1REFBdUQ7UUFDdkQsTUFBTWdHLFlBQVksT0FBT2hHLFdBQVcsV0FBV0EsU0FBUyxJQUFJLENBQUN2QixZQUFZO1FBQ3pFLDBFQUEwRTtRQUMxRSxJQUFJLENBQUMwSCxnQkFBZ0IsQ0FBQ2EsVUFBVWhCO1FBQ2hDZSxLQUFLRSxJQUFJLENBQUMsSUFBSSxDQUFDakksS0FBSyxFQUFFakIsT0FBT2lJO1FBQzdCLG1GQUFtRjtRQUNuRixJQUFJLE9BQU9oRyxXQUFXLFVBQVU7WUFDNUIsSUFBSSxDQUFDdkIsWUFBWSxHQUFHc0YsS0FBS3NDLEdBQUcsQ0FBQyxJQUFJLENBQUM1SCxZQUFZLEVBQUV1SCxZQUFZZ0I7UUFDaEUsT0FDSztZQUNELG1HQUFtRztZQUNuRyxJQUFJLENBQUN2SSxZQUFZLElBQUl1STtRQUN6QjtRQUNBLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQWxKLG1CQUFtQixHQUFHTSxhQUN0Qix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zbWFydC1idWZmZXIvYnVpbGQvc21hcnRidWZmZXIuanM/M2Y0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIFRoZSBkZWZhdWx0IEJ1ZmZlciBzaXplIGlmIG9uZSBpcyBub3QgcHJvdmlkZWQuXG5jb25zdCBERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUgPSA0MDk2O1xuLy8gVGhlIGRlZmF1bHQgc3RyaW5nIGVuY29kaW5nIHRvIHVzZSBmb3IgcmVhZGluZy93cml0aW5nIHN0cmluZ3MuXG5jb25zdCBERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HID0gJ3V0ZjgnO1xuY2xhc3MgU21hcnRCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7IFNtYXJ0QnVmZmVyT3B0aW9ucyB9IFRoZSBTbWFydEJ1ZmZlck9wdGlvbnMgdG8gYXBwbHkgdG8gdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBERUZBVUxUX1NNQVJUQlVGRkVSX0VOQ09ESU5HO1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAoU21hcnRCdWZmZXIuaXNTbWFydEJ1ZmZlck9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgZW5jb2RpbmdcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgICAgICAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgaW5pdGlhbCBzaXplIGxlbmd0aFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsc18xLmlzRmluaXRlSW50ZWdlcihvcHRpb25zLnNpemUpICYmIG9wdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShvcHRpb25zLnNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuRVJST1JTLklOVkFMSURfU01BUlRCVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBpbml0aWFsIEJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5idWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmJ1ZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBvcHRpb25zLmJ1ZmY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gb3B0aW9ucy5idWZmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShERUZBVUxUX1NNQVJUQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBwYXNzZWQgYnV0IGl0J3Mgbm90IGEgU21hcnRCdWZmZXJPcHRpb25zIG9iamVjdFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsc18xLkVSUk9SUy5JTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgZGVmYXVsdCB0byBzYW5lIG9wdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2J1ZmYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoREVGQVVMVF9TTUFSVEJVRkZFUl9TSVpFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIGludGVybmFsIEJ1ZmZlciBzaXplIGFuZCBvcHRpb25hbCBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplIHsgTnVtYmVyIH0gVGhlIHNpemUgb2YgdGhlIGludGVybmFsIEJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7IFNtYXJ0QnVmZmVyIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNpemUoc2l6ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHtcbiAgICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmdcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRCdWZmZXIgaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWQgQnVmZmVyIGFuZCBvcHRpb25hbCBlbmNvZGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBidWZmZXIgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHVzZSBhcyB0aGUgaW50ZXJuYWwgQnVmZmVyIHZhbHVlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU21hcnRCdWZmZXIgfVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmYsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyh7XG4gICAgICAgICAgICBidWZmOiBidWZmLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNtYXJ0QnVmZmVyIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkIFNtYXJ0QnVmZmVyT3B0aW9ucyBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgeyBTbWFydEJ1ZmZlck9wdGlvbnMgfSBUaGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjcmVhdGluZyB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIGNoZWNraW5nIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiBvYmplY3QgaXMgYSBTbWFydEJ1ZmZlck9wdGlvbnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBpc1NtYXJ0QnVmZmVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhc3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIChjYXN0T3B0aW9ucyAmJlxuICAgICAgICAgICAgKGNhc3RPcHRpb25zLmVuY29kaW5nICE9PSB1bmRlZmluZWQgfHwgY2FzdE9wdGlvbnMuc2l6ZSAhPT0gdW5kZWZpbmVkIHx8IGNhc3RPcHRpb25zLmJ1ZmYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICAvLyBTaWduZWQgaW50ZWdlcnNcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQ4IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4LCAxLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQxNkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MTZCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQxNkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MTZMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFLCAyLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQzMkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MzJCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBJbnQzMkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkSW50MzJMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFLCA0LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIEJpZ0ludDY0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdJbnQ2NEJFKG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3JlYWRCaWdJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdJbnQ2NExFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgQmlnSW50IH1cbiAgICAgKi9cbiAgICByZWFkQmlnSW50NjRMRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUsIDgsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQ4IHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDgsIDEsIHZhbHVlLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQ4IHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQ4KHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4LCAxLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDE2QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDE2QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDE2QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gSW50MTZMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gSW50MTZMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0SW50MTZMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMiwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBJbnQzMkJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBJbnQzMkJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIEludDMyTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIEludDMyTEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEludDMyTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUsIDQsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdJbnQ2NEJFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQmlnSW50IH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEJpZ0ludDY0QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ0ludDY0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdJbnQ2NExFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQmlnSW50IH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlQmlnSW50NjRMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIEludDY0TEUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IEJpZ0ludCB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ0ludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvLyBVbnNpZ25lZCBJbnRlZ2Vyc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQ4IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDgob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDgsIDEsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQxNkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDE2QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUsIDIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQxNkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDE2TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUsIDIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQzMkJFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDMyQkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGFuIFVJbnQzMkxFIHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbiBvciBhbiBvcHRpb25hbGx5IHByb3ZpZGVkIG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZGF0YSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICByZWFkVUludDMyTEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUsIDQsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQmlnVUludDY0QkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBCaWdJbnQgfVxuICAgICAqL1xuICAgIHJlYWRCaWdVSW50NjRCRShvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCdyZWFkQmlnVUludDY0QkUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBCaWdVSW50NjRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IEJpZ0ludCB9XG4gICAgICovXG4gICAgcmVhZEJpZ1VJbnQ2NExFKG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3JlYWRCaWdVSW50NjRMRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFLCA4LCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDggdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDggdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQ4KHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCwgMSwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MTZCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQxNkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MTZCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDE2QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFLCAyLCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGFuIFVJbnQxNkxFIHZhbHVlIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uIChvciBhdCBvcHRpb25hbCBvZmZzZXQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIHdyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGFuIFVJbnQxNkxFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRVSW50MTZMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYW4gVUludDMyQkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gVUludDMyQkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydFVJbnQzMkJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhbiBVSW50MzJMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVVJbnQzMkxFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhbiBVSW50MzJMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0VUludDMyTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQmlnVUludDY0QkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaygnd3JpdGVCaWdVSW50NjRCRScpO1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgQmlnVUludDY0QkUgdmFsdWUgYXQgdGhlIGdpdmVuIG9mZnNldCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gaW5zZXJ0IHRoZSB2YWx1ZSBhdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhpc1xuICAgICAqL1xuICAgIGluc2VydEJpZ1VJbnQ2NEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NEJFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUsIDgsIHZhbHVlLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCaWdVSW50NjRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJpZ1VJbnQ2NExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKCd3cml0ZUJpZ1VJbnQ2NExFJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBCaWdVSW50NjRMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0QmlnVUludDY0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmJpZ0ludEFuZEJ1ZmZlckludDY0Q2hlY2soJ3dyaXRlQmlnVUludDY0TEUnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8vIEZsb2F0aW5nIFBvaW50XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRmxvYXRCRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEZsb2F0QkUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRmxvYXRMRSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24gb3IgYW4gb3B0aW9uYWxseSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byByZWFkIGRhdGEgZnJvbSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7IE51bWJlciB9XG4gICAgICovXG4gICAgcmVhZEZsb2F0TEUob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkTnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSwgNCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRmxvYXRCRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBGbG9hdEJFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRGbG9hdEJFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRmxvYXRMRSB2YWx1ZSB0byB0aGUgY3VycmVudCB3cml0ZSBwb3NpdGlvbiAob3IgYXQgb3B0aW9uYWwgb2Zmc2V0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9IFRoZSB2YWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUZsb2F0TEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JpdGVOdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSwgNCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBGbG9hdExFIHZhbHVlIGF0IHRoZSBnaXZlbiBvZmZzZXQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgdmFsdWUgYXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRGbG9hdExFKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydE51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gRG91YmxlIEZsb2F0aW5nIFBvaW50XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRG91YmxFQkUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWREb3VibGVCRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gRG91YmxlTEUgdmFsdWUgZnJvbSB0aGUgY3VycmVudCByZWFkIHBvc2l0aW9uIG9yIGFuIG9wdGlvbmFsbHkgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gcmVhZCBkYXRhIGZyb20gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlYWREb3VibGVMRShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWROdW1iZXJWYWx1ZShCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSwgOCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRG91YmxlQkUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVEb3VibGVCRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBEb3VibGVCRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RG91YmxlQkUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgRG91YmxlTEUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24gKG9yIGF0IG9wdGlvbmFsIG9mZnNldCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBOdW1iZXIgfSBUaGUgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVEb3VibGVMRSh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU51bWJlclZhbHVlKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBEb3VibGVMRSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgTnVtYmVyIH0gVGhlIHZhbHVlIHRvIGluc2VydC5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHZhbHVlIGF0LlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0RG91YmxlTEUodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0TnVtYmVyVmFsdWUoQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLy8gU3RyaW5nc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgU3RyaW5nIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcxIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkIGFzIGEgU3RyaW5nLCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvclxuICAgICAqICAgICAgICAgICAgIHRoZSBzdHJpbmcgKERlZmF1bHRzIHRvIGluc3RhbmNlIGxldmVsIGVuY29kaW5nKS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU3RyaW5nIH1cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nKGFyZzEsIGVuY29kaW5nKSB7XG4gICAgICAgIGxldCBsZW5ndGhWYWw7XG4gICAgICAgIC8vIExlbmd0aCBwcm92aWRlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrTGVuZ3RoVmFsdWUoYXJnMSk7XG4gICAgICAgICAgICBsZW5ndGhWYWwgPSBNYXRoLm1pbihhcmcxLCB0aGlzLmxlbmd0aCAtIHRoaXMuX3JlYWRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSBhcmcxO1xuICAgICAgICAgICAgbGVuZ3RoVmFsID0gdGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGVuY29kaW5nXG4gICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCB0aGlzLl9yZWFkT2Zmc2V0ICsgbGVuZ3RoVmFsKS50b1N0cmluZyhlbmNvZGluZyB8fCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgKz0gbGVuZ3RoVmFsO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIGluc2VydCB0aGUgc3RyaW5nIGF0LlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgaW5zZXJ0U3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3RyaW5nKHZhbHVlLCB0cnVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBTdHJpbmcgfSBUaGUgU3RyaW5nIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIGF0LCBvciB0aGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7IFN0cmluZyB9IFRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UgZm9yIHdyaXRpbmcgc3RyaW5ncyAoZGVmYXVsdHMgdG8gaW5zdGFuY2UgZW5jb2RpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVTdHJpbmcodmFsdWUsIGFyZzIsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVTdHJpbmcodmFsdWUsIGZhbHNlLCBhcmcyLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZyBmcm9tIHRoZSBjdXJyZW50IHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgc3RyaW5nIChEZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgU3RyaW5nIH1cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nTlQoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG51bGwgY2hhcmFjdGVyIHBvc2l0aW9uIHRvIHRoZSBlbmQgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBudWxsUG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBudWxsIGNoYXJhY3RlciAoaWYgb25lIGlzIG5vdCBmb3VuZCwgZGVmYXVsdCBmcm9tIGFib3ZlIGlzIHVzZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZbaV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxsUG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHN0cmluZyB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgbnVsbFBvcyk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgcmVhZCBvZmZzZXRcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IG51bGxQb3MgKyAxO1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoZW5jb2RpbmcgfHwgdGhpcy5fZW5jb2RpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIGFyZzIgeyBOdW1iZXIgfCBTdHJpbmcgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8sIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRTdHJpbmdOVCh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gV3JpdGUgVmFsdWVzXG4gICAgICAgIHRoaXMuaW5zZXJ0U3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5pbnNlcnRVSW50OCgweDAwLCBvZmZzZXQgKyB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgbnVsbC10ZXJtaW5hdGVkIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFN0cmluZyB9IFRoZSBTdHJpbmcgdmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHBhcmFtIGFyZzIgeyBOdW1iZXIgfCBTdHJpbmcgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBzdHJpbmcgdG8sIG9yIHRoZSBCdWZmZXJFbmNvZGluZyB0byB1c2UuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHsgU3RyaW5nIH0gVGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBzdHJpbmdzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBlbmNvZGluZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZVN0cmluZ05UKHZhbHVlLCBhcmcyLCBlbmNvZGluZykge1xuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy53cml0ZVN0cmluZyh2YWx1ZSwgYXJnMiwgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndyaXRlVUludDgoMHgwMCwgdHlwZW9mIGFyZzIgPT09ICdudW1iZXInID8gYXJnMiArIHZhbHVlLmxlbmd0aCA6IHRoaXMud3JpdGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQnVmZmVyc1xuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgQnVmZmVyIGZyb20gdGhlIGludGVybmFsIHJlYWQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiBkYXRhIHRvIHJlYWQgYXMgYSBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICByZWFkQnVmZmVyKGxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tMZW5ndGhWYWx1ZShsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aFZhbCA9IHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInID8gbGVuZ3RoIDogdGhpcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZFBvaW50ID0gTWF0aC5taW4odGhpcy5sZW5ndGgsIHRoaXMuX3JlYWRPZmZzZXQgKyBsZW5ndGhWYWwpO1xuICAgICAgICAvLyBSZWFkIGJ1ZmZlciB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2J1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgZW5kUG9pbnQpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHJlYWQgb2Zmc2V0XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBlbmRQb2ludDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBCdWZmZXIgdG8gdGhlIGN1cnJlbnQgd3JpdGUgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCdWZmZXIodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgdHJ1ZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQnVmZmVyIHRvIHRoZSBjdXJyZW50IHdyaXRlIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgQnVmZmVyIHRvLlxuICAgICAqXG4gICAgICogQHJldHVybiB0aGlzXG4gICAgICovXG4gICAgd3JpdGVCdWZmZXIodmFsdWUsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQnVmZmVyKHZhbHVlLCBmYWxzZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudWxsLXRlcm1pbmF0ZWQgQnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgcmVhZCBwb2lzaXRvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBCdWZmZXIgfVxuICAgICAqL1xuICAgIHJlYWRCdWZmZXJOVCgpIHtcbiAgICAgICAgLy8gU2V0IG51bGwgY2hhcmFjdGVyIHBvc2l0aW9uIHRvIHRoZSBlbmQgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICAgIGxldCBudWxsUG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBudWxsIGNoYXJhY3RlciAoaWYgb25lIGlzIG5vdCBmb3VuZCwgZGVmYXVsdCBmcm9tIGFib3ZlIGlzIHVzZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1ZmZbaV0gPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxsUG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFkIHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCBudWxsUG9zKTtcbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIEJ1ZmZlciByZWFkIG9mZnNldFxuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gbnVsbFBvcyArIDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG51bGwtdGVybWluYXRlZCBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICBpbnNlcnRCdWZmZXJOVCh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy5pbnNlcnRCdWZmZXIodmFsdWUsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0VUludDgoMHgwMCwgb2Zmc2V0ICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIG51bGwtdGVybWluYXRlZCBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoaXNcbiAgICAgKi9cbiAgICB3cml0ZUJ1ZmZlck5UKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2tzIGZvciB2YWxpZCBudW1iZXJpYyB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBWYWx1ZXNcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcih2YWx1ZSwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KDB4MDAsIHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0ICsgdmFsdWUubGVuZ3RoIDogdGhpcy5fd3JpdGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZSB0byBpdHMgb3JpZ2luYWwgZW1wdHkgc3RhdGUuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJlbWFpbmluZyBkYXRhIGxlZnQgdG8gYmUgcmVhZCBmcm9tIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBOdW1iZXIgfVxuICAgICAqL1xuICAgIHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCByZWFkIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICBnZXQgcmVhZE9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlYWQgb2Zmc2V0IHZhbHVlIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSAtIFRoZSBvZmZzZXQgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldCByZWFkT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGJvdW5kcy5cbiAgICAgICAgdXRpbHNfMS5jaGVja1RhcmdldE9mZnNldChvZmZzZXQsIHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdyaXRlIG9mZnNldCB2YWx1ZSBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgTnVtYmVyIH1cbiAgICAgKi9cbiAgICBnZXQgd3JpdGVPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgd3JpdGUgb2Zmc2V0IHZhbHVlIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSAtIFRoZSBvZmZzZXQgdmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldCB3cml0ZU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja09mZnNldFZhbHVlKG9mZnNldCk7XG4gICAgICAgIC8vIENoZWNrIGZvciBib3VuZHMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tUYXJnZXRPZmZzZXQob2Zmc2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZXQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyBCdWZmZXJFbmNvZGluZyB9IFRoZSBzdHJpbmcgQnVmZmVyIGVuY29kaW5nIGN1cnJlbnRseSBzZXQuXG4gICAgICovXG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmluZyBlbmNvZGluZyBvZiB0aGUgU21hcnRCdWZmZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBCdWZmZXJFbmNvZGluZyB9IFRoZSBzdHJpbmcgQnVmZmVyIGVuY29kaW5nIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXQgZW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgdXRpbHNfMS5jaGVja0VuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdW5kZXJseWluZyBpbnRlcm5hbCBCdWZmZXIuIChUaGlzIGluY2x1ZGVzIHVubWFuYWdlZCBkYXRhIGluIHRoZSBCdWZmZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsgQnVmZmVyIH0gVGhlIEJ1ZmZlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXQgaW50ZXJuYWxCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJuYWwgbWFuYWdlZCBCdWZmZXIgKEluY2x1ZGVzIG1hbmFnZWQgZGF0YSBvbmx5KVxuICAgICAqXG4gICAgICogQHBhcmFtIHsgQnVmZmVyIH1cbiAgICAgKi9cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmYuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBTdHJpbmcgdmFsdWUgb2YgdGhlIGludGVybmFsIG1hbmFnZWQgQnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gZGlzcGxheSB0aGUgQnVmZmVyIGFzIChkZWZhdWx0cyB0byBpbnN0YW5jZSBsZXZlbCBlbmNvZGluZykuXG4gICAgICovXG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmdWYWwgPSB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnID8gZW5jb2RpbmcgOiB0aGlzLl9lbmNvZGluZztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgZW5jb2RpbmcuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZ1ZhbCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmLnRvU3RyaW5nKGVuY29kaW5nVmFsLCAwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGluc2VydGluZyBhbmQgd3JpdGluZyBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHsgU3RyaW5nIH0gVGhlIFN0cmluZyB2YWx1ZSB0byBpbnNlcnQuXG4gICAgICogQHBhcmFtIGlzSW5zZXJ0IHsgQm9vbGVhbiB9IFRydWUgaWYgaW5zZXJ0aW5nIGEgc3RyaW5nLCBmYWxzZSBpZiB3cml0aW5nLlxuICAgICAqIEBwYXJhbSBhcmcyIHsgTnVtYmVyIHwgU3RyaW5nIH0gVGhlIG9mZnNldCB0byBpbnNlcnQgdGhlIHN0cmluZyBhdCwgb3IgdGhlIEJ1ZmZlckVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgeyBTdHJpbmcgfSBUaGUgQnVmZmVyRW5jb2RpbmcgdG8gdXNlIGZvciB3cml0aW5nIHN0cmluZ3MgKGRlZmF1bHRzIHRvIGluc3RhbmNlIGVuY29kaW5nKS5cbiAgICAgKi9cbiAgICBfaGFuZGxlU3RyaW5nKHZhbHVlLCBpc0luc2VydCwgYXJnMywgZW5jb2RpbmcpIHtcbiAgICAgICAgbGV0IG9mZnNldFZhbCA9IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICBsZXQgZW5jb2RpbmdWYWwgPSB0aGlzLl9lbmNvZGluZztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG9mZnNldFxuICAgICAgICBpZiAodHlwZW9mIGFyZzMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvZmZzZXRWYWwgPSBhcmczO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGVuY29kaW5nXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrRW5jb2RpbmcoYXJnMyk7XG4gICAgICAgICAgICBlbmNvZGluZ1ZhbCA9IGFyZzM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVuY29kaW5nICh0aGlyZCBwYXJhbSlcbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgICAgICAgICBlbmNvZGluZ1ZhbCA9IGVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBieXRlbGVuZ3RoIG9mIHN0cmluZy5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZ1ZhbCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBlbm91Z2ggaW50ZXJuYWwgQnVmZmVyIGNhcGFjaXR5LlxuICAgICAgICBpZiAoaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlSW5zZXJ0YWJsZShieXRlTGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKGJ5dGVMZW5ndGgsIG9mZnNldFZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgdmFsdWVcbiAgICAgICAgdGhpcy5fYnVmZi53cml0ZSh2YWx1ZSwgb2Zmc2V0VmFsLCBieXRlTGVuZ3RoLCBlbmNvZGluZ1ZhbCk7XG4gICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBCdWZmZXIgd3JpdGUgb2Zmc2V0O1xuICAgICAgICBpZiAoaXNJbnNlcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmczID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5fd3JpdGVPZmZzZXQsIG9mZnNldFZhbCArIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gb2Zmc2V0IHdhcyBnaXZlbiwgd2Ugd3JvdGUgdG8gdGhlIGVuZCBvZiB0aGUgU21hcnRCdWZmZXIgc28gaW5jcmVtZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgd3JpdGluZyBvciBpbnNlcnQgb2YgYSBCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgeyBCdWZmZXIgfSBUaGUgQnVmZmVyIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBCdWZmZXIgdG8uXG4gICAgICovXG4gICAgX2hhbmRsZUJ1ZmZlcih2YWx1ZSwgaXNJbnNlcnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBvZmZzZXRWYWwgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS5cbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUodmFsdWUubGVuZ3RoLCBvZmZzZXRWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKHZhbHVlLmxlbmd0aCwgb2Zmc2V0VmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBidWZmZXIgdmFsdWVcbiAgICAgICAgdmFsdWUuY29weSh0aGlzLl9idWZmLCBvZmZzZXRWYWwpO1xuICAgICAgICAvLyBJbmNyZW1lbnQgaW50ZXJuYWwgQnVmZmVyIHdyaXRlIG9mZnNldDtcbiAgICAgICAgaWYgKGlzSW5zZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBhbiBvZmZzZXQgd2FzIGdpdmVuLCBjaGVjayB0byBzZWUgaWYgd2Ugd3JvdGUgYmV5b25kIHRoZSBjdXJyZW50IHdyaXRlT2Zmc2V0LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLl93cml0ZU9mZnNldCwgb2Zmc2V0VmFsICsgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIG9mZnNldCB3YXMgZ2l2ZW4sIHdlIHdyb3RlIHRvIHRoZSBlbmQgb2YgdGhlIFNtYXJ0QnVmZmVyIHNvIGluY3JlbWVudCB3cml0ZU9mZnNldC5cbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byByZWFkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHJlYWQuXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSByZWFkLlxuICAgICAqL1xuICAgIGVuc3VyZVJlYWRhYmxlKGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIE9mZnNldCB2YWx1ZSBkZWZhdWx0cyB0byBtYW5hZ2VkIHJlYWQgb2Zmc2V0LlxuICAgICAgICBsZXQgb2Zmc2V0VmFsID0gdGhpcy5fcmVhZE9mZnNldDtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBwcm92aWRlZCwgdXNlIGl0LlxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgdmFsaWQgbnVtYmVyaWMgdmFsdWU7XG4gICAgICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIE92ZXJpZGUgd2l0aCBjdXN0b20gb2Zmc2V0LlxuICAgICAgICAgICAgb2Zmc2V0VmFsID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBvZmZzZXQgaXMgYmVsb3cgemVybywgb3IgdGhlIG9mZnNldCtsZW5ndGggb2Zmc2V0IGlzIGJleW9uZCB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBtYW5hZ2VkIGRhdGEuXG4gICAgICAgIGlmIChvZmZzZXRWYWwgPCAwIHx8IG9mZnNldFZhbCArIGxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byBpbnNlcnQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhTGVuZ3RoIHsgTnVtYmVyIH0gVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIHdyaXR0ZW4uXG4gICAgICogQHBhcmFtIG9mZnNldCB7IE51bWJlciB9IFRoZSBvZmZzZXQgb2YgdGhlIGRhdGEgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBlbnN1cmVJbnNlcnRhYmxlKGRhdGFMZW5ndGgsIG9mZnNldCkge1xuICAgICAgICAvLyBDaGVja3MgZm9yIHZhbGlkIG51bWJlcmljIHZhbHVlO1xuICAgICAgICB1dGlsc18xLmNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuXG4gICAgICAgIHRoaXMuX2Vuc3VyZUNhcGFjaXR5KHRoaXMubGVuZ3RoICsgZGF0YUxlbmd0aCk7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgcHJvdmlkZWQgYW5kIGl0cyBub3QgdGhlIHZlcnkgZW5kIG9mIHRoZSBidWZmZXIsIGNvcHkgZGF0YSBpbnRvIGFwcHJvcHJpYXRlIGxvY2F0aW9uIGluIHJlZ2FyZHMgdG8gdGhlIG9mZnNldC5cbiAgICAgICAgaWYgKG9mZnNldCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmLmNvcHkodGhpcy5fYnVmZiwgb2Zmc2V0ICsgZGF0YUxlbmd0aCwgb2Zmc2V0LCB0aGlzLl9idWZmLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRqdXN0IHRyYWNrZWQgc21hcnQgYnVmZmVyIGxlbmd0aFxuICAgICAgICBpZiAob2Zmc2V0ICsgZGF0YUxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9mZnNldCArIGRhdGFMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgaW50ZXJuYWwgQnVmZmVyIGlzIGxhcmdlIGVub3VnaCB0byB3cml0ZSBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFMZW5ndGggeyBOdW1iZXIgfSBUaGUgbGVuZ3RoIG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHsgTnVtYmVyIH0gVGhlIG9mZnNldCBvZiB0aGUgZGF0YSB0byBiZSB3cml0dGVuIChkZWZhdWx0cyB0byB3cml0ZU9mZnNldCkuXG4gICAgICovXG4gICAgX2Vuc3VyZVdyaXRlYWJsZShkYXRhTGVuZ3RoLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIGVub3VnaCBjYXBhY2l0eSB0byB3cml0ZSBkYXRhLlxuICAgICAgICB0aGlzLl9lbnN1cmVDYXBhY2l0eShvZmZzZXRWYWwgKyBkYXRhTGVuZ3RoKTtcbiAgICAgICAgLy8gQWRqdXN0IFNtYXJ0QnVmZmVyIGxlbmd0aCAoaWYgb2Zmc2V0ICsgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIG1hbmFnZWQgbGVuZ3RoLCBhZGp1c3QgbGVuZ3RoKVxuICAgICAgICBpZiAob2Zmc2V0VmFsICsgZGF0YUxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG9mZnNldFZhbCArIGRhdGFMZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBpbnRlcm5hbCBCdWZmZXIgaXMgbGFyZ2UgZW5vdWdoIHRvIHdyaXRlIGF0IGxlYXN0IHRoZSBnaXZlbiBhbW91bnQgb2YgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtaW5MZW5ndGggeyBOdW1iZXIgfSBUaGUgbWluaW11bSBsZW5ndGggb2YgdGhlIGRhdGEgbmVlZHMgdG8gYmUgd3JpdHRlbi5cbiAgICAgKi9cbiAgICBfZW5zdXJlQ2FwYWNpdHkobWluTGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG9sZExlbmd0aCA9IHRoaXMuX2J1ZmYubGVuZ3RoO1xuICAgICAgICBpZiAobWluTGVuZ3RoID4gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX2J1ZmY7XG4gICAgICAgICAgICBsZXQgbmV3TGVuZ3RoID0gKG9sZExlbmd0aCAqIDMpIC8gMiArIDE7XG4gICAgICAgICAgICBpZiAobmV3TGVuZ3RoIDwgbWluTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gbWluTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYnVmZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuZXdMZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMuX2J1ZmYsIDAsIDAsIG9sZExlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudW1lcmljIG51bWJlciB2YWx1ZSB1c2luZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZXBhcmFtIFQgeyBudW1iZXIgfCBiaWdpbnQgfSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gYmUgcmVhZFxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmMgeyBGdW5jdGlvbihvZmZzZXQ6IG51bWJlcikgPT4gbnVtYmVyIH0gVGhlIGZ1bmN0aW9uIHRvIHJlYWQgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyByZWFkLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSBUaGUgb2Zmc2V0IHRvIHJlYWQgZnJvbSAob3B0aW9uYWwpLiBXaGVuIHRoaXMgaXMgbm90IHByb3ZpZGVkLCB0aGUgbWFuYWdlZCByZWFkT2Zmc2V0IGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsgVCB9IHRoZSBudW1iZXIgdmFsdWVcbiAgICAgKi9cbiAgICBfcmVhZE51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVSZWFkYWJsZShieXRlU2l6ZSwgb2Zmc2V0KTtcbiAgICAgICAgLy8gQ2FsbCBCdWZmZXIucmVhZFhYWFgoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgLy8gQWRqdXN0IGludGVybmFsIHJlYWQgb2Zmc2V0IGlmIGFuIG9wdGlvbmFsIHJlYWQgb2Zmc2V0IHdhcyBub3QgcHJvdmlkZWQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fcmVhZE9mZnNldCArPSBieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBudW1lcmljIG51bWJlciB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gVCB7IG51bWJlciB8IGJpZ2ludCB9IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuYyB7IEZ1bmN0aW9uKG9mZnNldDogVCwgb2Zmc2V0PykgPT4gbnVtYmVyfSBUaGUgZnVuY3Rpb24gdG8gd3JpdGUgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFQgfSBUaGUgbnVtYmVyIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSB0aGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBudW1iZXIgYXQgKFJFUVVJUkVEKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNtYXJ0QnVmZmVyIHRoaXMgYnVmZmVyXG4gICAgICovXG4gICAgX2luc2VydE51bWJlclZhbHVlKGZ1bmMsIGJ5dGVTaXplLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnZhbGlkIG9mZnNldCB2YWx1ZXMuXG4gICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgZW5vdWdoIGludGVybmFsIEJ1ZmZlciBjYXBhY2l0eS4gKHJhdyBvZmZzZXQgaXMgcGFzc2VkKVxuICAgICAgICB0aGlzLmVuc3VyZUluc2VydGFibGUoYnl0ZVNpemUsIG9mZnNldCk7XG4gICAgICAgIC8vIENhbGwgYnVmZmVyLndyaXRlWFhYWCgpO1xuICAgICAgICBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdmFsdWUsIG9mZnNldCk7XG4gICAgICAgIC8vIEFkanVzdHMgaW50ZXJuYWxseSBtYW5hZ2VkIHdyaXRlIG9mZnNldC5cbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgKz0gYnl0ZVNpemU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudW1lcmljIG51bWJlciB2YWx1ZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEB0eXBlcGFyYW0gVCB7IG51bWJlciB8IGJpZ2ludCB9IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBiZSB3cml0dGVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuYyB7IEZ1bmN0aW9uKG9mZnNldDogVCwgb2Zmc2V0PykgPT4gbnVtYmVyfSBUaGUgZnVuY3Rpb24gdG8gd3JpdGUgZGF0YSBvbiB0aGUgaW50ZXJuYWwgQnVmZmVyIHdpdGguXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIHsgTnVtYmVyIH0gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7IFQgfSBUaGUgbnVtYmVyIHZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgeyBOdW1iZXIgfSB0aGUgb2Zmc2V0IHRvIHdyaXRlIHRoZSBudW1iZXIgYXQgKFJFUVVJUkVEKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFNtYXJ0QnVmZmVyIHRoaXMgYnVmZmVyXG4gICAgICovXG4gICAgX3dyaXRlTnVtYmVyVmFsdWUoZnVuYywgYnl0ZVNpemUsIHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gSWYgYW4gb2Zmc2V0IHdhcyBwcm92aWRlZCwgdmFsaWRhdGUgaXQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgd3JpdGluZyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgbWFuYWdlZCBkYXRhLlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbHNfMS5FUlJPUlMuSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzXzEuY2hlY2tPZmZzZXRWYWx1ZShvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgdG8gd3JpdGVPZmZzZXQgaWYgbm8gb2Zmc2V0IHZhbHVlIHdhcyBnaXZlbi5cbiAgICAgICAgY29uc3Qgb2Zmc2V0VmFsID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldDtcbiAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGVub3VnaCBpbnRlcm5hbCBCdWZmZXIgY2FwYWNpdHkuIChyYXcgb2Zmc2V0IGlzIHBhc3NlZClcbiAgICAgICAgdGhpcy5fZW5zdXJlV3JpdGVhYmxlKGJ5dGVTaXplLCBvZmZzZXRWYWwpO1xuICAgICAgICBmdW5jLmNhbGwodGhpcy5fYnVmZiwgdmFsdWUsIG9mZnNldFZhbCk7XG4gICAgICAgIC8vIElmIGFuIG9mZnNldCB3YXMgZ2l2ZW4sIGNoZWNrIHRvIHNlZSBpZiB3ZSB3cm90ZSBiZXlvbmQgdGhlIGN1cnJlbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLl93cml0ZU9mZnNldCwgb2Zmc2V0VmFsICsgYnl0ZVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gbnVtZXJpYyBvZmZzZXQgd2FzIGdpdmVuLCB3ZSB3cm90ZSB0byB0aGUgZW5kIG9mIHRoZSBTbWFydEJ1ZmZlciBzbyBpbmNyZW1lbnQgd3JpdGVPZmZzZXQuXG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0QnVmZmVyID0gU21hcnRCdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbWFydGJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dGlsc18xIiwicmVxdWlyZSIsIkRFRkFVTFRfU01BUlRCVUZGRVJfU0laRSIsIkRFRkFVTFRfU01BUlRCVUZGRVJfRU5DT0RJTkciLCJTbWFydEJ1ZmZlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImxlbmd0aCIsIl9lbmNvZGluZyIsIl93cml0ZU9mZnNldCIsIl9yZWFkT2Zmc2V0IiwiaXNTbWFydEJ1ZmZlck9wdGlvbnMiLCJlbmNvZGluZyIsImNoZWNrRW5jb2RpbmciLCJzaXplIiwiaXNGaW5pdGVJbnRlZ2VyIiwiX2J1ZmYiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsIkVycm9yIiwiRVJST1JTIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9TSVpFIiwiYnVmZiIsImlzQnVmZmVyIiwiSU5WQUxJRF9TTUFSVEJVRkZFUl9CVUZGRVIiLCJJTlZBTElEX1NNQVJUQlVGRkVSX09CSkVDVCIsImZyb21TaXplIiwiZnJvbUJ1ZmZlciIsImZyb21PcHRpb25zIiwiY2FzdE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJyZWFkSW50OCIsIm9mZnNldCIsIl9yZWFkTnVtYmVyVmFsdWUiLCJwcm90b3R5cGUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQxNkxFIiwicmVhZEludDMyQkUiLCJyZWFkSW50MzJMRSIsInJlYWRCaWdJbnQ2NEJFIiwiYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayIsInJlYWRCaWdJbnQ2NExFIiwid3JpdGVJbnQ4IiwiX3dyaXRlTnVtYmVyVmFsdWUiLCJpbnNlcnRJbnQ4IiwiX2luc2VydE51bWJlclZhbHVlIiwid3JpdGVJbnQxNkJFIiwiaW5zZXJ0SW50MTZCRSIsIndyaXRlSW50MTZMRSIsImluc2VydEludDE2TEUiLCJ3cml0ZUludDMyQkUiLCJpbnNlcnRJbnQzMkJFIiwid3JpdGVJbnQzMkxFIiwiaW5zZXJ0SW50MzJMRSIsIndyaXRlQmlnSW50NjRCRSIsImluc2VydEJpZ0ludDY0QkUiLCJ3cml0ZUJpZ0ludDY0TEUiLCJpbnNlcnRCaWdJbnQ2NExFIiwicmVhZFVJbnQ4IiwicmVhZFVJbnQxNkJFIiwicmVhZFVJbnQxNkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZFVJbnQzMkxFIiwicmVhZEJpZ1VJbnQ2NEJFIiwicmVhZEJpZ1VJbnQ2NExFIiwid3JpdGVVSW50OCIsImluc2VydFVJbnQ4Iiwid3JpdGVVSW50MTZCRSIsImluc2VydFVJbnQxNkJFIiwid3JpdGVVSW50MTZMRSIsImluc2VydFVJbnQxNkxFIiwid3JpdGVVSW50MzJCRSIsImluc2VydFVJbnQzMkJFIiwid3JpdGVVSW50MzJMRSIsImluc2VydFVJbnQzMkxFIiwid3JpdGVCaWdVSW50NjRCRSIsImluc2VydEJpZ1VJbnQ2NEJFIiwid3JpdGVCaWdVSW50NjRMRSIsImluc2VydEJpZ1VJbnQ2NExFIiwicmVhZEZsb2F0QkUiLCJyZWFkRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsImluc2VydEZsb2F0QkUiLCJ3cml0ZUZsb2F0TEUiLCJpbnNlcnRGbG9hdExFIiwicmVhZERvdWJsZUJFIiwicmVhZERvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsImluc2VydERvdWJsZUJFIiwid3JpdGVEb3VibGVMRSIsImluc2VydERvdWJsZUxFIiwicmVhZFN0cmluZyIsImFyZzEiLCJsZW5ndGhWYWwiLCJjaGVja0xlbmd0aFZhbHVlIiwiTWF0aCIsIm1pbiIsInNsaWNlIiwidG9TdHJpbmciLCJpbnNlcnRTdHJpbmciLCJjaGVja09mZnNldFZhbHVlIiwiX2hhbmRsZVN0cmluZyIsIndyaXRlU3RyaW5nIiwiYXJnMiIsInJlYWRTdHJpbmdOVCIsIm51bGxQb3MiLCJpIiwiaW5zZXJ0U3RyaW5nTlQiLCJ3cml0ZVN0cmluZ05UIiwid3JpdGVPZmZzZXQiLCJyZWFkQnVmZmVyIiwiZW5kUG9pbnQiLCJpbnNlcnRCdWZmZXIiLCJfaGFuZGxlQnVmZmVyIiwid3JpdGVCdWZmZXIiLCJyZWFkQnVmZmVyTlQiLCJpbnNlcnRCdWZmZXJOVCIsIndyaXRlQnVmZmVyTlQiLCJjbGVhciIsInJlbWFpbmluZyIsInJlYWRPZmZzZXQiLCJjaGVja1RhcmdldE9mZnNldCIsImludGVybmFsQnVmZmVyIiwidG9CdWZmZXIiLCJlbmNvZGluZ1ZhbCIsImRlc3Ryb3kiLCJpc0luc2VydCIsImFyZzMiLCJvZmZzZXRWYWwiLCJieXRlTGVuZ3RoIiwiZW5zdXJlSW5zZXJ0YWJsZSIsIl9lbnN1cmVXcml0ZWFibGUiLCJ3cml0ZSIsIm1heCIsImNvcHkiLCJlbnN1cmVSZWFkYWJsZSIsIklOVkFMSURfUkVBRF9CRVlPTkRfQk9VTkRTIiwiZGF0YUxlbmd0aCIsIl9lbnN1cmVDYXBhY2l0eSIsIm1pbkxlbmd0aCIsIm9sZExlbmd0aCIsImRhdGEiLCJuZXdMZW5ndGgiLCJmdW5jIiwiYnl0ZVNpemUiLCJjYWxsIiwiSU5WQUxJRF9XUklURV9CRVlPTkRfQk9VTkRTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/smart-buffer/build/smartbuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/smart-buffer/build/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/smart-buffer/build/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\n/**\n * Error strings\n */ const ERRORS = {\n    INVALID_ENCODING: \"Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.\",\n    INVALID_SMARTBUFFER_SIZE: \"Invalid size provided. Size must be a valid integer greater than zero.\",\n    INVALID_SMARTBUFFER_BUFFER: \"Invalid Buffer provided in SmartBufferOptions.\",\n    INVALID_SMARTBUFFER_OBJECT: \"Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.\",\n    INVALID_OFFSET: \"An invalid offset value was provided.\",\n    INVALID_OFFSET_NON_NUMBER: \"An invalid offset value was provided. A numeric value is required.\",\n    INVALID_LENGTH: \"An invalid length value was provided.\",\n    INVALID_LENGTH_NON_NUMBER: \"An invalid length value was provived. A numeric value is required.\",\n    INVALID_TARGET_OFFSET: \"Target offset is beyond the bounds of the internal SmartBuffer data.\",\n    INVALID_TARGET_LENGTH: \"Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.\",\n    INVALID_READ_BEYOND_BOUNDS: \"Attempted to read beyond the bounds of the managed data.\",\n    INVALID_WRITE_BEYOND_BOUNDS: \"Attempted to write beyond the bounds of the managed data.\"\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */ function checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */ function isFiniteInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */ function checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === \"number\") {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    } else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */ function checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */ function checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */ function checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */ function bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === \"undefined\") {\n        throw new Error(\"Platform does not support JS BigInt type.\");\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === \"undefined\") {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc21hcnQtYnVmZmVyL2J1aWxkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDOztDQUVDLEdBQ0QsTUFBTUMsU0FBUztJQUNYQyxrQkFBa0I7SUFDbEJDLDBCQUEwQjtJQUMxQkMsNEJBQTRCO0lBQzVCQyw0QkFBNEI7SUFDNUJDLGdCQUFnQjtJQUNoQkMsMkJBQTJCO0lBQzNCQyxnQkFBZ0I7SUFDaEJDLDJCQUEyQjtJQUMzQkMsdUJBQXVCO0lBQ3ZCQyx1QkFBdUI7SUFDdkJDLDRCQUE0QjtJQUM1QkMsNkJBQTZCO0FBQ2pDO0FBQ0FoQixjQUFjLEdBQUdJO0FBQ2pCOzs7O0NBSUMsR0FDRCxTQUFTYSxjQUFjQyxRQUFRO0lBQzNCLElBQUksQ0FBQ2hCLFNBQVNpQixNQUFNLENBQUNDLFVBQVUsQ0FBQ0YsV0FBVztRQUN2QyxNQUFNLElBQUlHLE1BQU1qQixPQUFPQyxnQkFBZ0I7SUFDM0M7QUFDSjtBQUNBTCxxQkFBcUIsR0FBR2lCO0FBQ3hCOzs7O0NBSUMsR0FDRCxTQUFTSyxnQkFBZ0JyQixLQUFLO0lBQzFCLE9BQU8sT0FBT0EsVUFBVSxZQUFZc0IsU0FBU3RCLFVBQVV1QixVQUFVdkI7QUFDckU7QUFDQUQsdUJBQXVCLEdBQUdzQjtBQUMxQjs7Ozs7Q0FLQyxHQUNELFNBQVNHLHlCQUF5QnhCLEtBQUssRUFBRXlCLE1BQU07SUFDM0MsSUFBSSxPQUFPekIsVUFBVSxVQUFVO1FBQzNCLG9DQUFvQztRQUNwQyxJQUFJLENBQUNxQixnQkFBZ0JyQixVQUFVQSxRQUFRLEdBQUc7WUFDdEMsTUFBTSxJQUFJb0IsTUFBTUssU0FBU3RCLE9BQU9LLGNBQWMsR0FBR0wsT0FBT08sY0FBYztRQUMxRTtJQUNKLE9BQ0s7UUFDRCxNQUFNLElBQUlVLE1BQU1LLFNBQVN0QixPQUFPTSx5QkFBeUIsR0FBR04sT0FBT1EseUJBQXlCO0lBQ2hHO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU2UsaUJBQWlCQyxNQUFNO0lBQzVCSCx5QkFBeUJHLFFBQVE7QUFDckM7QUFDQTVCLHdCQUF3QixHQUFHMkI7QUFDM0I7Ozs7Q0FJQyxHQUNELFNBQVNFLGlCQUFpQkgsTUFBTTtJQUM1QkQseUJBQXlCQyxRQUFRO0FBQ3JDO0FBQ0ExQix3QkFBd0IsR0FBRzZCO0FBQzNCOzs7OztDQUtDLEdBQ0QsU0FBU0Msa0JBQWtCSixNQUFNLEVBQUVLLElBQUk7SUFDbkMsSUFBSUwsU0FBUyxLQUFLQSxTQUFTSyxLQUFLSCxNQUFNLEVBQUU7UUFDcEMsTUFBTSxJQUFJUCxNQUFNakIsT0FBT1MscUJBQXFCO0lBQ2hEO0FBQ0o7QUFDQWIseUJBQXlCLEdBQUc4QjtBQUM1Qjs7O0NBR0MsR0FDRCxTQUFTTixVQUFVdkIsS0FBSztJQUNwQixPQUFPLE9BQU9BLFVBQVUsWUFBWXNCLFNBQVN0QixVQUFVK0IsS0FBS0MsS0FBSyxDQUFDaEMsV0FBV0E7QUFDakY7QUFDQTs7Q0FFQyxHQUNELFNBQVNpQywwQkFBMEJDLFlBQVk7SUFDM0MsSUFBSSxPQUFPQyxXQUFXLGFBQWE7UUFDL0IsTUFBTSxJQUFJZixNQUFNO0lBQ3BCO0lBQ0EsSUFBSSxPQUFPbkIsU0FBU2lCLE1BQU0sQ0FBQ2tCLFNBQVMsQ0FBQ0YsYUFBYSxLQUFLLGFBQWE7UUFDaEUsTUFBTSxJQUFJZCxNQUFNLENBQUMsMkNBQTJDLEVBQUVjLGFBQWEsQ0FBQyxDQUFDO0lBQ2pGO0FBQ0o7QUFDQW5DLGlDQUFpQyxHQUFHa0MsMkJBQ3BDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NtYXJ0LWJ1ZmZlci9idWlsZC91dGlscy5qcz9iYzU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuLyoqXG4gKiBFcnJvciBzdHJpbmdzXG4gKi9cbmNvbnN0IEVSUk9SUyA9IHtcbiAgICBJTlZBTElEX0VOQ09ESU5HOiAnSW52YWxpZCBlbmNvZGluZyBwcm92aWRlZC4gUGxlYXNlIHNwZWNpZnkgYSB2YWxpZCBlbmNvZGluZyB0aGUgaW50ZXJuYWwgTm9kZS5qcyBCdWZmZXIgc3VwcG9ydHMuJyxcbiAgICBJTlZBTElEX1NNQVJUQlVGRkVSX1NJWkU6ICdJbnZhbGlkIHNpemUgcHJvdmlkZWQuIFNpemUgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgZ3JlYXRlciB0aGFuIHplcm8uJyxcbiAgICBJTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUjogJ0ludmFsaWQgQnVmZmVyIHByb3ZpZGVkIGluIFNtYXJ0QnVmZmVyT3B0aW9ucy4nLFxuICAgIElOVkFMSURfU01BUlRCVUZGRVJfT0JKRUNUOiAnSW52YWxpZCBTbWFydEJ1ZmZlck9wdGlvbnMgb2JqZWN0IHN1cHBsaWVkIHRvIFNtYXJ0QnVmZmVyIGNvbnN0cnVjdG9yIG9yIGZhY3RvcnkgbWV0aG9kcy4nLFxuICAgIElOVkFMSURfT0ZGU0VUOiAnQW4gaW52YWxpZCBvZmZzZXQgdmFsdWUgd2FzIHByb3ZpZGVkLicsXG4gICAgSU5WQUxJRF9PRkZTRVRfTk9OX05VTUJFUjogJ0FuIGludmFsaWQgb2Zmc2V0IHZhbHVlIHdhcyBwcm92aWRlZC4gQSBudW1lcmljIHZhbHVlIGlzIHJlcXVpcmVkLicsXG4gICAgSU5WQUxJRF9MRU5HVEg6ICdBbiBpbnZhbGlkIGxlbmd0aCB2YWx1ZSB3YXMgcHJvdmlkZWQuJyxcbiAgICBJTlZBTElEX0xFTkdUSF9OT05fTlVNQkVSOiAnQW4gaW52YWxpZCBsZW5ndGggdmFsdWUgd2FzIHByb3ZpdmVkLiBBIG51bWVyaWMgdmFsdWUgaXMgcmVxdWlyZWQuJyxcbiAgICBJTlZBTElEX1RBUkdFVF9PRkZTRVQ6ICdUYXJnZXQgb2Zmc2V0IGlzIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBpbnRlcm5hbCBTbWFydEJ1ZmZlciBkYXRhLicsXG4gICAgSU5WQUxJRF9UQVJHRVRfTEVOR1RIOiAnU3BlY2lmaWVkIGxlbmd0aCB2YWx1ZSBtb3ZlcyBjdXJzb3IgYmV5b25nIHRoZSBib3VuZHMgb2YgdGhlIGludGVybmFsIFNtYXJ0QnVmZmVyIGRhdGEuJyxcbiAgICBJTlZBTElEX1JFQURfQkVZT05EX0JPVU5EUzogJ0F0dGVtcHRlZCB0byByZWFkIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBtYW5hZ2VkIGRhdGEuJyxcbiAgICBJTlZBTElEX1dSSVRFX0JFWU9ORF9CT1VORFM6ICdBdHRlbXB0ZWQgdG8gd3JpdGUgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIG1hbmFnZWQgZGF0YS4nXG59O1xuZXhwb3J0cy5FUlJPUlMgPSBFUlJPUlM7XG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGVuY29kaW5nIGlzIGEgdmFsaWQgQnVmZmVyIGVuY29kaW5nLiAoVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBjaGVjayBmYWlscylcbiAqXG4gKiBAcGFyYW0geyBTdHJpbmcgfSBlbmNvZGluZyBUaGUgZW5jb2Rpbmcgc3RyaW5nIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBjaGVja0VuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5JTlZBTElEX0VOQ09ESU5HKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRW5jb2RpbmcgPSBjaGVja0VuY29kaW5nO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBudW1iZXIgaXMgYSBmaW5pdGUgaW50ZWdlci4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gdmFsdWUgVGhlIG51bWJlciB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNGaW5pdGVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIGlzSW50ZWdlcih2YWx1ZSk7XG59XG5leHBvcnRzLmlzRmluaXRlSW50ZWdlciA9IGlzRmluaXRlSW50ZWdlcjtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9mZnNldC9sZW5ndGggdmFsdWUgaXMgdmFsaWQuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gb2Zmc2V0IFRydWUgaWYgY2hlY2tpbmcgYW4gb2Zmc2V0LCBmYWxzZSBpZiBjaGVja2luZyBhIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXRPckxlbmd0aFZhbHVlKHZhbHVlLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBDaGVjayBmb3Igbm9uIGZpbml0ZS9ub24gaW50ZWdlcnNcbiAgICAgICAgaWYgKCFpc0Zpbml0ZUludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9mZnNldCA/IEVSUk9SUy5JTlZBTElEX09GRlNFVCA6IEVSUk9SUy5JTlZBTElEX0xFTkdUSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihvZmZzZXQgPyBFUlJPUlMuSU5WQUxJRF9PRkZTRVRfTk9OX05VTUJFUiA6IEVSUk9SUy5JTlZBTElEX0xFTkdUSF9OT05fTlVNQkVSKTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIGxlbmd0aCB2YWx1ZSBpcyB2YWxpZC4gKFRocm93cyBhbiBleGNlcHRpb24gaWYgY2hlY2sgZmFpbHMpXG4gKlxuICogQHBhcmFtIHsgTnVtYmVyIH0gbGVuZ3RoIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gY2hlY2tMZW5ndGhWYWx1ZShsZW5ndGgpIHtcbiAgICBjaGVja09mZnNldE9yTGVuZ3RoVmFsdWUobGVuZ3RoLCBmYWxzZSk7XG59XG5leHBvcnRzLmNoZWNrTGVuZ3RoVmFsdWUgPSBjaGVja0xlbmd0aFZhbHVlO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBvZmZzZXQgdmFsdWUgaXMgdmFsaWQuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IG9mZnNldCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0VmFsdWUob2Zmc2V0KSB7XG4gICAgY2hlY2tPZmZzZXRPckxlbmd0aFZhbHVlKG9mZnNldCwgdHJ1ZSk7XG59XG5leHBvcnRzLmNoZWNrT2Zmc2V0VmFsdWUgPSBjaGVja09mZnNldFZhbHVlO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB0YXJnZXQgb2Zmc2V0IHZhbHVlIGlzIG91dCBvZiBib3VuZHMuIChUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIGNoZWNrIGZhaWxzKVxuICpcbiAqIEBwYXJhbSB7IE51bWJlciB9IG9mZnNldCBUaGUgb2Zmc2V0IHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHsgU21hcnRCdWZmZXIgfSBidWZmIFRoZSBTbWFydEJ1ZmZlciBpbnN0YW5jZSB0byBjaGVjayBhZ2FpbnN0LlxuICovXG5mdW5jdGlvbiBjaGVja1RhcmdldE9mZnNldChvZmZzZXQsIGJ1ZmYpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBidWZmLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLklOVkFMSURfVEFSR0VUX09GRlNFVCk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1RhcmdldE9mZnNldCA9IGNoZWNrVGFyZ2V0T2Zmc2V0O1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBudW1iZXIgaXMgYSBpbnRlZ2VyLlxuICogQHBhcmFtIHZhbHVlIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59XG4vKipcbiAqIFRocm93cyBpZiBOb2RlLmpzIHZlcnNpb24gaXMgdG9vIGxvdyB0byBzdXBwb3J0IGJpZ2ludFxuICovXG5mdW5jdGlvbiBiaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrKGJ1ZmZlck1ldGhvZCkge1xuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgSlMgQmlnSW50IHR5cGUuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYnVmZmVyXzEuQnVmZmVyLnByb3RvdHlwZVtidWZmZXJNZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQnVmZmVyLnByb3RvdHlwZS4ke2J1ZmZlck1ldGhvZH0uYCk7XG4gICAgfVxufVxuZXhwb3J0cy5iaWdJbnRBbmRCdWZmZXJJbnQ2NENoZWNrID0gYmlnSW50QW5kQnVmZmVySW50NjRDaGVjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImJ1ZmZlcl8xIiwicmVxdWlyZSIsIkVSUk9SUyIsIklOVkFMSURfRU5DT0RJTkciLCJJTlZBTElEX1NNQVJUQlVGRkVSX1NJWkUiLCJJTlZBTElEX1NNQVJUQlVGRkVSX0JVRkZFUiIsIklOVkFMSURfU01BUlRCVUZGRVJfT0JKRUNUIiwiSU5WQUxJRF9PRkZTRVQiLCJJTlZBTElEX09GRlNFVF9OT05fTlVNQkVSIiwiSU5WQUxJRF9MRU5HVEgiLCJJTlZBTElEX0xFTkdUSF9OT05fTlVNQkVSIiwiSU5WQUxJRF9UQVJHRVRfT0ZGU0VUIiwiSU5WQUxJRF9UQVJHRVRfTEVOR1RIIiwiSU5WQUxJRF9SRUFEX0JFWU9ORF9CT1VORFMiLCJJTlZBTElEX1dSSVRFX0JFWU9ORF9CT1VORFMiLCJjaGVja0VuY29kaW5nIiwiZW5jb2RpbmciLCJCdWZmZXIiLCJpc0VuY29kaW5nIiwiRXJyb3IiLCJpc0Zpbml0ZUludGVnZXIiLCJpc0Zpbml0ZSIsImlzSW50ZWdlciIsImNoZWNrT2Zmc2V0T3JMZW5ndGhWYWx1ZSIsIm9mZnNldCIsImNoZWNrTGVuZ3RoVmFsdWUiLCJsZW5ndGgiLCJjaGVja09mZnNldFZhbHVlIiwiY2hlY2tUYXJnZXRPZmZzZXQiLCJidWZmIiwiTWF0aCIsImZsb29yIiwiYmlnSW50QW5kQnVmZmVySW50NjRDaGVjayIsImJ1ZmZlck1ldGhvZCIsIkJpZ0ludCIsInByb3RvdHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/smart-buffer/build/utils.js\n");

/***/ })

};
;