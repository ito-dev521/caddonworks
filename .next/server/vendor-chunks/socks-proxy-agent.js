"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socks-proxy-agent";
exports.ids = ["vendor-chunks/socks-proxy-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/socks-proxy-agent/dist/agent.js":
/*!******************************************************!*\
  !*** ./node_modules/socks-proxy-agent/dist/agent.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst dns_1 = __importDefault(__webpack_require__(/*! dns */ \"dns\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst url_1 = __importDefault(__webpack_require__(/*! url */ \"url\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/agent-base/dist/src/index.js\");\nconst socks_1 = __webpack_require__(/*! socks */ \"(rsc)/./node_modules/socks/build/index.js\");\nconst debug = debug_1.default(\"socks-proxy-agent\");\nfunction dnsLookup(host) {\n    return new Promise((resolve, reject)=>{\n        dns_1.default.lookup(host, (err, res)=>{\n            if (err) {\n                reject(err);\n            } else {\n                resolve(res);\n            }\n        });\n    });\n}\nfunction parseSocksProxy(opts) {\n    let port = 0;\n    let lookup = false;\n    let type = 5;\n    // Prefer `hostname` over `host`, because of `url.parse()`\n    const host = opts.hostname || opts.host;\n    if (!host) {\n        throw new TypeError('No \"host\"');\n    }\n    if (typeof opts.port === \"number\") {\n        port = opts.port;\n    } else if (typeof opts.port === \"string\") {\n        port = parseInt(opts.port, 10);\n    }\n    // From RFC 1928, Section 3: https://tools.ietf.org/html/rfc1928#section-3\n    // \"The SOCKS service is conventionally located on TCP port 1080\"\n    if (!port) {\n        port = 1080;\n    }\n    // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n    // Defaults to 5.\n    if (opts.protocol) {\n        switch(opts.protocol.replace(\":\", \"\")){\n            case \"socks4\":\n                lookup = true;\n            // pass through\n            case \"socks4a\":\n                type = 4;\n                break;\n            case \"socks5\":\n                lookup = true;\n            // pass through\n            case \"socks\":\n            case \"socks5h\":\n                type = 5;\n                break;\n            default:\n                throw new TypeError(`A \"socks\" protocol must be specified! Got: ${opts.protocol}`);\n        }\n    }\n    if (typeof opts.type !== \"undefined\") {\n        if (opts.type === 4 || opts.type === 5) {\n            type = opts.type;\n        } else {\n            throw new TypeError(`\"type\" must be 4 or 5, got: ${opts.type}`);\n        }\n    }\n    const proxy = {\n        host,\n        port,\n        type\n    };\n    let userId = opts.userId || opts.username;\n    let password = opts.password;\n    if (opts.auth) {\n        const auth = opts.auth.split(\":\");\n        userId = auth[0];\n        password = auth[1];\n    }\n    if (userId) {\n        Object.defineProperty(proxy, \"userId\", {\n            value: userId,\n            enumerable: false\n        });\n    }\n    if (password) {\n        Object.defineProperty(proxy, \"password\", {\n            value: password,\n            enumerable: false\n        });\n    }\n    return {\n        lookup,\n        proxy\n    };\n}\n/**\n * The `SocksProxyAgent`.\n *\n * @api public\n */ class SocksProxyAgent extends agent_base_1.Agent {\n    constructor(_opts){\n        let opts;\n        if (typeof _opts === \"string\") {\n            opts = url_1.default.parse(_opts);\n        } else {\n            opts = _opts;\n        }\n        if (!opts) {\n            throw new TypeError(\"a SOCKS proxy server `host` and `port` must be specified!\");\n        }\n        super(opts);\n        const parsedProxy = parseSocksProxy(opts);\n        this.lookup = parsedProxy.lookup;\n        this.proxy = parsedProxy.proxy;\n    }\n    /**\n     * Initiates a SOCKS connection to the specified SOCKS proxy server,\n     * which in turn connects to the specified remote host and port.\n     *\n     * @api protected\n     */ callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { lookup, proxy } = this;\n            let { host, port, timeout } = opts;\n            if (!host) {\n                throw new Error(\"No `host` defined!\");\n            }\n            if (lookup) {\n                // Client-side DNS resolution for \"4\" and \"5\" socks proxy versions.\n                host = yield dnsLookup(host);\n            }\n            const socksOpts = {\n                proxy,\n                destination: {\n                    host,\n                    port\n                },\n                command: \"connect\",\n                timeout\n            };\n            debug(\"Creating socks proxy connection: %o\", socksOpts);\n            const { socket } = yield socks_1.SocksClient.createConnection(socksOpts);\n            debug(\"Successfully created socks proxy connection\");\n            if (opts.secureEndpoint) {\n                // The proxy is connecting to a TLS server, so upgrade\n                // this socket connection to a TLS connection.\n                debug(\"Upgrading socket connection to TLS\");\n                const servername = opts.servername || host;\n                return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, \"host\", \"hostname\", \"path\", \"port\")), {\n                    socket,\n                    servername\n                }));\n            }\n            return socket;\n        });\n    }\n}\nexports[\"default\"] = SocksProxyAgent;\nfunction omit(obj, ...keys) {\n    const ret = {};\n    let key;\n    for(key in obj){\n        if (!keys.includes(key)) {\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n} //# sourceMappingURL=agent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVksSUFBSyxJQUFJLElBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENB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OURqQyxNQUFNO1lBQ04sSUFBSVEsS0FBSytCLGNBQWMsRUFBRTtnQkFDckIsc0RBQXNEO2dCQUN0RCw4Q0FBOEM7Z0JBQzlDdkMsTUFBTTtnQkFDTixNQUFNd0MsYUFBYWhDLEtBQUtnQyxVQUFVLElBQUlyQztnQkFDdEMsT0FBT1IsTUFBTU0sT0FBTyxDQUFDd0MsT0FBTyxDQUFDbkQsT0FBT29ELE1BQU0sQ0FBQ3BELE9BQU9vRCxNQUFNLENBQUMsQ0FBQyxHQUFHQyxLQUFLbkMsTUFBTSxRQUFRLFlBQVksUUFBUSxVQUFVO29CQUFFNEI7b0JBQzVHSTtnQkFBVztZQUNuQjtZQUNBLE9BQU9KO1FBQ1g7SUFDSjtBQUNKO0FBQ0E1QyxrQkFBZSxHQUFHK0I7QUFDbEIsU0FBU29CLEtBQUtDLEdBQUcsRUFBRSxHQUFHQyxJQUFJO0lBQ3RCLE1BQU1DLE1BQU0sQ0FBQztJQUNiLElBQUlDO0lBQ0osSUFBS0EsT0FBT0gsSUFBSztRQUNiLElBQUksQ0FBQ0MsS0FBS0csUUFBUSxDQUFDRCxNQUFNO1lBQ3JCRCxHQUFHLENBQUNDLElBQUksR0FBR0gsR0FBRyxDQUFDRyxJQUFJO1FBQ3ZCO0lBQ0o7SUFDQSxPQUFPRDtBQUNYLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc29ja3MtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcz9hYmUwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBkbnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG5zXCIpKTtcbmNvbnN0IHRsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3QgdXJsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInVybFwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBhZ2VudF9iYXNlXzEgPSByZXF1aXJlKFwiYWdlbnQtYmFzZVwiKTtcbmNvbnN0IHNvY2tzXzEgPSByZXF1aXJlKFwic29ja3NcIik7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnc29ja3MtcHJveHktYWdlbnQnKTtcbmZ1bmN0aW9uIGRuc0xvb2t1cChob3N0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgZG5zXzEuZGVmYXVsdC5sb29rdXAoaG9zdCwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VTb2Nrc1Byb3h5KG9wdHMpIHtcbiAgICBsZXQgcG9ydCA9IDA7XG4gICAgbGV0IGxvb2t1cCA9IGZhbHNlO1xuICAgIGxldCB0eXBlID0gNTtcbiAgICAvLyBQcmVmZXIgYGhvc3RuYW1lYCBvdmVyIGBob3N0YCwgYmVjYXVzZSBvZiBgdXJsLnBhcnNlKClgXG4gICAgY29uc3QgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0O1xuICAgIGlmICghaG9zdCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBcImhvc3RcIicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcG9ydCA9IG9wdHMucG9ydDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9wdHMucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcG9ydCA9IHBhcnNlSW50KG9wdHMucG9ydCwgMTApO1xuICAgIH1cbiAgICAvLyBGcm9tIFJGQyAxOTI4LCBTZWN0aW9uIDM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxOTI4I3NlY3Rpb24tM1xuICAgIC8vIFwiVGhlIFNPQ0tTIHNlcnZpY2UgaXMgY29udmVudGlvbmFsbHkgbG9jYXRlZCBvbiBUQ1AgcG9ydCAxMDgwXCJcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgcG9ydCA9IDEwODA7XG4gICAgfVxuICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugd2FudCBzb2NrcyB2NCBvciB2NSwgYmFzZWQgb24gdGhlIFwicHJvdG9jb2xcIiB1c2VkLlxuICAgIC8vIERlZmF1bHRzIHRvIDUuXG4gICAgaWYgKG9wdHMucHJvdG9jb2wpIHtcbiAgICAgICAgc3dpdGNoIChvcHRzLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJykpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzNCc6XG4gICAgICAgICAgICAgICAgbG9va3VwID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc29ja3M0YSc6XG4gICAgICAgICAgICAgICAgdHlwZSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb2NrczUnOlxuICAgICAgICAgICAgICAgIGxvb2t1cCA9IHRydWU7XG4gICAgICAgICAgICAvLyBwYXNzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzJzogLy8gbm8gdmVyc2lvbiBzcGVjaWZpZWQsIGRlZmF1bHQgdG8gNWhcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzNWgnOlxuICAgICAgICAgICAgICAgIHR5cGUgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIFwic29ja3NcIiBwcm90b2NvbCBtdXN0IGJlIHNwZWNpZmllZCEgR290OiAke29wdHMucHJvdG9jb2x9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChvcHRzLnR5cGUgPT09IDQgfHwgb3B0cy50eXBlID09PSA1KSB7XG4gICAgICAgICAgICB0eXBlID0gb3B0cy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJ0eXBlXCIgbXVzdCBiZSA0IG9yIDUsIGdvdDogJHtvcHRzLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJveHkgPSB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHR5cGVcbiAgICB9O1xuICAgIGxldCB1c2VySWQgPSBvcHRzLnVzZXJJZCB8fCBvcHRzLnVzZXJuYW1lO1xuICAgIGxldCBwYXNzd29yZCA9IG9wdHMucGFzc3dvcmQ7XG4gICAgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgICBjb25zdCBhdXRoID0gb3B0cy5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVzZXJJZCA9IGF1dGhbMF07XG4gICAgICAgIHBhc3N3b3JkID0gYXV0aFsxXTtcbiAgICB9XG4gICAgaWYgKHVzZXJJZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICd1c2VySWQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogdXNlcklkLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXNzd29yZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksICdwYXNzd29yZCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXNzd29yZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBsb29rdXAsIHByb3h5IH07XG59XG4vKipcbiAqIFRoZSBgU29ja3NQcm94eUFnZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5jbGFzcyBTb2Nrc1Byb3h5QWdlbnQgZXh0ZW5kcyBhZ2VudF9iYXNlXzEuQWdlbnQge1xuICAgIGNvbnN0cnVjdG9yKF9vcHRzKSB7XG4gICAgICAgIGxldCBvcHRzO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0cyA9IHVybF8xLmRlZmF1bHQucGFyc2UoX29wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IF9vcHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBTT0NLUyBwcm94eSBzZXJ2ZXIgYGhvc3RgIGFuZCBgcG9ydGAgbXVzdCBiZSBzcGVjaWZpZWQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFByb3h5ID0gcGFyc2VTb2Nrc1Byb3h5KG9wdHMpO1xuICAgICAgICB0aGlzLmxvb2t1cCA9IHBhcnNlZFByb3h5Lmxvb2t1cDtcbiAgICAgICAgdGhpcy5wcm94eSA9IHBhcnNlZFByb3h5LnByb3h5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZXMgYSBTT0NLUyBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgU09DS1MgcHJveHkgc2VydmVyLFxuICAgICAqIHdoaWNoIGluIHR1cm4gY29ubmVjdHMgdG8gdGhlIHNwZWNpZmllZCByZW1vdGUgaG9zdCBhbmQgcG9ydC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsbGJhY2socmVxLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGxvb2t1cCwgcHJveHkgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBob3N0LCBwb3J0LCB0aW1lb3V0IH0gPSBvcHRzO1xuICAgICAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBgaG9zdGAgZGVmaW5lZCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgICAgICAvLyBDbGllbnQtc2lkZSBETlMgcmVzb2x1dGlvbiBmb3IgXCI0XCIgYW5kIFwiNVwiIHNvY2tzIHByb3h5IHZlcnNpb25zLlxuICAgICAgICAgICAgICAgIGhvc3QgPSB5aWVsZCBkbnNMb29rdXAoaG9zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb2Nrc09wdHMgPSB7XG4gICAgICAgICAgICAgICAgcHJveHksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHsgaG9zdCwgcG9ydCB9LFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0JyxcbiAgICAgICAgICAgICAgICB0aW1lb3V0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVidWcoJ0NyZWF0aW5nIHNvY2tzIHByb3h5IGNvbm5lY3Rpb246ICVvJywgc29ja3NPcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc29ja2V0IH0gPSB5aWVsZCBzb2Nrc18xLlNvY2tzQ2xpZW50LmNyZWF0ZUNvbm5lY3Rpb24oc29ja3NPcHRzKTtcbiAgICAgICAgICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgY3JlYXRlZCBzb2NrcyBwcm94eSBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICBpZiAob3B0cy5zZWN1cmVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc29ja2V0IGNvbm5lY3Rpb24gdG8gYSBUTFMgY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAgICBkZWJ1ZygnVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWUgfHwgaG9zdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGxzXzEuZGVmYXVsdC5jb25uZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb21pdChvcHRzLCAnaG9zdCcsICdob3N0bmFtZScsICdwYXRoJywgJ3BvcnQnKSksIHsgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNvY2tzUHJveHlBZ2VudDtcbmZ1bmN0aW9uIG9taXQob2JqLCAuLi5rZXlzKSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGtleTtcbiAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiZG5zXzEiLCJyZXF1aXJlIiwidGxzXzEiLCJ1cmxfMSIsImRlYnVnXzEiLCJhZ2VudF9iYXNlXzEiLCJzb2Nrc18xIiwiZGVidWciLCJkZWZhdWx0IiwiZG5zTG9va3VwIiwiaG9zdCIsImxvb2t1cCIsImVyciIsInJlcyIsInBhcnNlU29ja3NQcm94eSIsIm9wdHMiLCJwb3J0IiwidHlwZSIsImhvc3RuYW1lIiwiVHlwZUVycm9yIiwicGFyc2VJbnQiLCJwcm90b2NvbCIsInJlcGxhY2UiLCJwcm94eSIsInVzZXJJZCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJhdXRoIiwic3BsaXQiLCJlbnVtZXJhYmxlIiwiU29ja3NQcm94eUFnZW50IiwiQWdlbnQiLCJjb25zdHJ1Y3RvciIsIl9vcHRzIiwicGFyc2UiLCJwYXJzZWRQcm94eSIsImNhbGxiYWNrIiwicmVxIiwidGltZW91dCIsIkVycm9yIiwic29ja3NPcHRzIiwiZGVzdGluYXRpb24iLCJjb21tYW5kIiwic29ja2V0IiwiU29ja3NDbGllbnQiLCJjcmVhdGVDb25uZWN0aW9uIiwic2VjdXJlRW5kcG9pbnQiLCJzZXJ2ZXJuYW1lIiwiY29ubmVjdCIsImFzc2lnbiIsIm9taXQiLCJvYmoiLCJrZXlzIiwicmV0Iiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks-proxy-agent/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socks-proxy-agent/dist/index.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/socks-proxy-agent/dist/agent.js\"));\nfunction createSocksProxyAgent(opts) {\n    return new agent_1.default(opts);\n}\n(function(createSocksProxyAgent) {\n    createSocksProxyAgent.SocksProxyAgent = agent_1.default;\n    createSocksProxyAgent.prototype = agent_1.default.prototype;\n})(createSocksProxyAgent || (createSocksProxyAgent = {}));\nmodule.exports = createSocksProxyAgent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MtcHJveHktYWdlbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQSxNQUFNRSxVQUFVSCxnQkFBZ0JJLG1CQUFPQSxDQUFDLHFFQUFTO0FBQ2pELFNBQVNDLHNCQUFzQkMsSUFBSTtJQUMvQixPQUFPLElBQUlILFFBQVFJLE9BQU8sQ0FBQ0Q7QUFDL0I7QUFDQyxVQUFVRCxxQkFBcUI7SUFDNUJBLHNCQUFzQkcsZUFBZSxHQUFHTCxRQUFRSSxPQUFPO0lBQ3ZERixzQkFBc0JJLFNBQVMsR0FBR04sUUFBUUksT0FBTyxDQUFDRSxTQUFTO0FBQy9ELEdBQUdKLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDdERLLE9BQU9DLE9BQU8sR0FBR04sdUJBQ2pCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tzLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/ZDU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGFnZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYWdlbnRcIikpO1xuZnVuY3Rpb24gY3JlYXRlU29ja3NQcm94eUFnZW50KG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGFnZW50XzEuZGVmYXVsdChvcHRzKTtcbn1cbihmdW5jdGlvbiAoY3JlYXRlU29ja3NQcm94eUFnZW50KSB7XG4gICAgY3JlYXRlU29ja3NQcm94eUFnZW50LlNvY2tzUHJveHlBZ2VudCA9IGFnZW50XzEuZGVmYXVsdDtcbiAgICBjcmVhdGVTb2Nrc1Byb3h5QWdlbnQucHJvdG90eXBlID0gYWdlbnRfMS5kZWZhdWx0LnByb3RvdHlwZTtcbn0pKGNyZWF0ZVNvY2tzUHJveHlBZ2VudCB8fCAoY3JlYXRlU29ja3NQcm94eUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU29ja3NQcm94eUFnZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJhZ2VudF8xIiwicmVxdWlyZSIsImNyZWF0ZVNvY2tzUHJveHlBZ2VudCIsIm9wdHMiLCJkZWZhdWx0IiwiU29ja3NQcm94eUFnZW50IiwicHJvdG90eXBlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks-proxy-agent/dist/index.js\n");

/***/ })

};
;