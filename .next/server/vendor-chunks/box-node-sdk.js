"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/box-node-sdk";
exports.ids = ["vendor-chunks/box-node-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/box-node-sdk/lib/api-request-manager.js":
/*!**************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/api-request-manager.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview A library for making requests to the Box API.\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar APIRequest = __webpack_require__(/*! ./api-request */ \"(rsc)/./node_modules/box-node-sdk/lib/api-request.js\"), errors = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * A library for communicating with the Box API.\n *\n * @param {Config} config SDK configuration object instance.\n * @param {EventEmitter} eventBus The event bus for SDK events\n * @constructor\n */ function APIRequestManager(config, eventBus) {\n    this.config = config;\n    this.eventBus = eventBus;\n}\n/**\n * Make a request to the API, and get the response via callback.\n *\n * @param {Object} options The request options\n * @returns {Promise<Response>} A promise resolving to the response object\n */ APIRequestManager.prototype.makeRequest = function(options) {\n    // Add default APIRequestManager options to each request\n    var requestConfig = this.config.extend({\n        request: options\n    });\n    // Make the request\n    var apiRequest = new APIRequest(requestConfig, this.eventBus);\n    return Promise.fromCallback((callback)=>apiRequest.execute(callback)).catch((err)=>errors.unwrapAndThrow(err));\n};\n/**\n * Make a request to the API, and return a read stream for the response.\n *\n * @param {Object} options The request options\n * @returns {Stream.Readable} The response stream\n */ APIRequestManager.prototype.makeStreamingRequest = function(options) {\n    // Add default APIRequestManager options to each request\n    var requestConfig = this.config.extend({\n        request: options\n    });\n    // Make the request\n    var apiRequest = new APIRequest(requestConfig, this.eventBus);\n    apiRequest.execute();\n    return apiRequest.getResponseStream();\n};\n/**\n * @module box-node-sdk/lib/api-request-manager\n * @see {@Link APIRequestManager}\n */ module.exports = APIRequestManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9hcGktcmVxdWVzdC1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxpRkFBaUY7QUFDakYsZUFBZTtBQUNmLGlGQUFpRjtBQUNqRixJQUFJQSxhQUFhQyxtQkFBT0EsQ0FBQyw4RUFDeEJDLFNBQVNELG1CQUFPQSxDQUFDLDhFQUNqQkUsVUFBVUYsbUJBQU9BLENBQUM7QUFFbkIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFFakYsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7OztDQU1DLEdBQ0QsU0FBU0csa0JBQWtCQyxNQUFNLEVBQUVDLFFBQVE7SUFFMUMsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO0lBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO0FBQ2pCO0FBRUE7Ozs7O0NBS0MsR0FDREYsa0JBQWtCRyxTQUFTLENBQUNDLFdBQVcsR0FBRyxTQUFTQyxPQUFPO0lBQ3pELHdEQUF3RDtJQUN4RCxJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDTCxNQUFNLENBQUNNLE1BQU0sQ0FBQztRQUN0Q0MsU0FBU0g7SUFDVjtJQUVBLG1CQUFtQjtJQUNuQixJQUFJSSxhQUFhLElBQUliLFdBQVdVLGVBQWUsSUFBSSxDQUFDSixRQUFRO0lBQzVELE9BQU9ILFFBQVFXLFlBQVksQ0FBQ0MsQ0FBQUEsV0FBWUYsV0FBV0csT0FBTyxDQUFDRCxXQUN6REUsS0FBSyxDQUFDQyxDQUFBQSxNQUFPaEIsT0FBT2lCLGNBQWMsQ0FBQ0Q7QUFDdEM7QUFFQTs7Ozs7Q0FLQyxHQUNEZCxrQkFBa0JHLFNBQVMsQ0FBQ2Esb0JBQW9CLEdBQUcsU0FBU1gsT0FBTztJQUNsRSx3REFBd0Q7SUFDeEQsSUFBSUMsZ0JBQWdCLElBQUksQ0FBQ0wsTUFBTSxDQUFDTSxNQUFNLENBQUM7UUFDdENDLFNBQVNIO0lBQ1Y7SUFFQSxtQkFBbUI7SUFDbkIsSUFBSUksYUFBYSxJQUFJYixXQUFXVSxlQUFlLElBQUksQ0FBQ0osUUFBUTtJQUM1RE8sV0FBV0csT0FBTztJQUNsQixPQUFPSCxXQUFXUSxpQkFBaUI7QUFDcEM7QUFFQTs7O0NBR0MsR0FDREMsT0FBT0MsT0FBTyxHQUFHbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL2FwaS1yZXF1ZXN0LW1hbmFnZXIuanM/ZTAyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBsaWJyYXJ5IGZvciBtYWtpbmcgcmVxdWVzdHMgdG8gdGhlIEJveCBBUEkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQVBJUmVxdWVzdCA9IHJlcXVpcmUoJy4vYXBpLXJlcXVlc3QnKSxcblx0ZXJyb3JzID0gcmVxdWlyZSgnLi91dGlsL2Vycm9ycycpLFxuXHRQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEEgbGlicmFyeSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSBCb3ggQVBJLlxuICpcbiAqIEBwYXJhbSB7Q29uZmlnfSBjb25maWcgU0RLIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGluc3RhbmNlLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGV2ZW50QnVzIFRoZSBldmVudCBidXMgZm9yIFNESyBldmVudHNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBUElSZXF1ZXN0TWFuYWdlcihjb25maWcsIGV2ZW50QnVzKSB7XG5cblx0dGhpcy5jb25maWcgPSBjb25maWc7XG5cdHRoaXMuZXZlbnRCdXMgPSBldmVudEJ1cztcbn1cblxuLyoqXG4gKiBNYWtlIGEgcmVxdWVzdCB0byB0aGUgQVBJLCBhbmQgZ2V0IHRoZSByZXNwb25zZSB2aWEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIHJlcXVlc3Qgb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXNwb25zZSBvYmplY3RcbiAqL1xuQVBJUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvLyBBZGQgZGVmYXVsdCBBUElSZXF1ZXN0TWFuYWdlciBvcHRpb25zIHRvIGVhY2ggcmVxdWVzdFxuXHR2YXIgcmVxdWVzdENvbmZpZyA9IHRoaXMuY29uZmlnLmV4dGVuZCh7XG5cdFx0cmVxdWVzdDogb3B0aW9uc1xuXHR9KTtcblxuXHQvLyBNYWtlIHRoZSByZXF1ZXN0XG5cdHZhciBhcGlSZXF1ZXN0ID0gbmV3IEFQSVJlcXVlc3QocmVxdWVzdENvbmZpZywgdGhpcy5ldmVudEJ1cyk7XG5cdHJldHVybiBQcm9taXNlLmZyb21DYWxsYmFjayhjYWxsYmFjayA9PiBhcGlSZXF1ZXN0LmV4ZWN1dGUoY2FsbGJhY2spKVxuXHRcdC5jYXRjaChlcnIgPT4gZXJyb3JzLnVud3JhcEFuZFRocm93KGVycikpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcmVxdWVzdCB0byB0aGUgQVBJLCBhbmQgcmV0dXJuIGEgcmVhZCBzdHJlYW0gZm9yIHRoZSByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgcmVxdWVzdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7U3RyZWFtLlJlYWRhYmxlfSBUaGUgcmVzcG9uc2Ugc3RyZWFtXG4gKi9cbkFQSVJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5tYWtlU3RyZWFtaW5nUmVxdWVzdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0Ly8gQWRkIGRlZmF1bHQgQVBJUmVxdWVzdE1hbmFnZXIgb3B0aW9ucyB0byBlYWNoIHJlcXVlc3Rcblx0dmFyIHJlcXVlc3RDb25maWcgPSB0aGlzLmNvbmZpZy5leHRlbmQoe1xuXHRcdHJlcXVlc3Q6IG9wdGlvbnNcblx0fSk7XG5cblx0Ly8gTWFrZSB0aGUgcmVxdWVzdFxuXHR2YXIgYXBpUmVxdWVzdCA9IG5ldyBBUElSZXF1ZXN0KHJlcXVlc3RDb25maWcsIHRoaXMuZXZlbnRCdXMpO1xuXHRhcGlSZXF1ZXN0LmV4ZWN1dGUoKTtcblx0cmV0dXJuIGFwaVJlcXVlc3QuZ2V0UmVzcG9uc2VTdHJlYW0oKTtcbn07XG5cbi8qKlxuICogQG1vZHVsZSBib3gtbm9kZS1zZGsvbGliL2FwaS1yZXF1ZXN0LW1hbmFnZXJcbiAqIEBzZWUge0BMaW5rIEFQSVJlcXVlc3RNYW5hZ2VyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEFQSVJlcXVlc3RNYW5hZ2VyO1xuIl0sIm5hbWVzIjpbIkFQSVJlcXVlc3QiLCJyZXF1aXJlIiwiZXJyb3JzIiwiUHJvbWlzZSIsIkFQSVJlcXVlc3RNYW5hZ2VyIiwiY29uZmlnIiwiZXZlbnRCdXMiLCJwcm90b3R5cGUiLCJtYWtlUmVxdWVzdCIsIm9wdGlvbnMiLCJyZXF1ZXN0Q29uZmlnIiwiZXh0ZW5kIiwicmVxdWVzdCIsImFwaVJlcXVlc3QiLCJmcm9tQ2FsbGJhY2siLCJjYWxsYmFjayIsImV4ZWN1dGUiLCJjYXRjaCIsImVyciIsInVud3JhcEFuZFRocm93IiwibWFrZVN0cmVhbWluZ1JlcXVlc3QiLCJnZXRSZXNwb25zZVN0cmVhbSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/api-request-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/api-request.js":
/*!******************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/api-request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview A Box API Request\n */ // @NOTE(fschott) 08/05/2014: THIS FILE SHOULD NOT BE ACCESSED DIRECTLY OUTSIDE OF API-REQUEST-MANAGER\n// This module is used by APIRequestManager to make requests. If you'd like to make requests to the\n// Box API, consider using APIRequestManager instead. {@Link APIRequestManager}\n\n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar assert = __webpack_require__(/*! assert */ \"assert\"), request = __webpack_require__(/*! request */ \"(rsc)/./node_modules/request/index.js\"), EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter), Config = __webpack_require__(/*! ./util/config */ \"(rsc)/./node_modules/box-node-sdk/lib/util/config.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\"), getRetryTimeout = __webpack_require__(/*! ./util/exponential-backoff */ \"(rsc)/./node_modules/box-node-sdk/lib/util/exponential-backoff.js\");\n// ------------------------------------------------------------------------------\n// Typedefs and Callbacks\n// ------------------------------------------------------------------------------\n/**\n * The API response object includes information about the request made and its response. The information attached is a subset\n * of the information returned by the request module, which is too large and complex to be safely handled (contains circular\n * references, errors on serialization, etc.)\n * @NOTE(fschott) 08-19-2014: We cannot return the request/response objects directly because they contain loads of extra\n *  information, unnecessary bloat, circular dependencies, and cause an infinite loop when stringifying.\n *\n * @typedef {Object} APIRequest~ResponseObject\n * @property {APIRequest~RequestObject} request Information about the request that generated this response\n * @property {int} statusCode The response HTTP status code\n * @property {Object} headers A collection of response headers\n * @property {Object|Buffer|string} [body] The response body. Encoded to JSON by default, but can be a buffer\n *  (if encoding fails or if json encoding is disabled) or a string (if string encoding is enabled). Will be undefined\n *  if no response body is sent.\n */ /**\n * The API request object includes information about the request made. The information attached is a subset of the information\n * of a request module instance, which is too large and complex to be safely handled (contains circular references, errors on\n * serialization, etc.).\n * @NOTE(fschott) 08-19-2014: We cannot return the request/response objects directly because they contain loads of extra\n *  information, unnecessary bloat, circular dependencies, and cause an infinite loop when stringifying.\n *\n * @typedef {Object} APIRequest~RequestObject\n * @property {Object} uri Information about the request, including host, path, and the full 'href' url\n * @property {string} method The request method (GET, POST, etc.)\n * @property {Object} headers A collection of headers sent with the request\n */ /**\n * The error returned by APIRequest callbacks, which includes any relevent, available information about the request\n * and response. Note that these properties do not exist on stream errors, only errors retuned to the callback.\n *\n * @typedef {Error} APIRequest~Error\n * @property {APIRequest~RequestObject} request Information about the request that generated this error\n * @property {APIRequest~ResponseObject} [response] Information about the response related to this error, if available\n * @property {int} [statusCode] The response HTTP status code\n * @property {boolean} [maxRetriesExceeded] True iff the max number of retries were exceeded. Otherwise, undefined.\n */ /**\n * Callback invoked when an APIRequest request is complete and finalized. On success,\n * propagates the relevent response information. An err will indicate an unresolvable issue\n * with the request (permanent failure or temp error response from the server, retried too many times).\n *\n * @callback APIRequest~Callback\n * @param {?APIRequest~Error} err If Error object, API request did not get back the data it was supposed to. This\n *  could be either because of a temporary error, or a more serious error connecting to the API.\n * @param {APIRequest~ResponseObject} response The response returned by an APIRequestManager request\n */ // ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// Message to replace removed headers with in the request\nvar REMOVED_HEADER_MESSAGE = \"[REMOVED BY SDK]\";\n// Range of SERVER ERROR http status codes\nvar HTTP_STATUS_CODE_SERVER_ERROR_BLOCK_RANGE = [\n    500,\n    599\n];\n// Timer used to track elapsed time beginning from executing an async request to emitting the response.\nvar asyncRequestTimer;\n// A map of HTTP status codes and whether or not they can be retried\nvar retryableStatusCodes = {};\nretryableStatusCodes[httpStatusCodes.REQUEST_TIMEOUT] = true;\nretryableStatusCodes[httpStatusCodes.TOO_MANY_REQUESTS] = true;\n/**\n * Returns true if the response info indicates a temporary/transient error.\n *\n * @param {?APIRequest~ResponseObject} response The response info from an API request,\n * or undefined if the API request did not return any response info.\n * @returns {boolean} True if the API call error is temporary (and hence can\n * be retried). False otherwise.\n * @private\n */ function isTemporaryError(response) {\n    var statusCode = response.statusCode;\n    // An API error is a temporary/transient if it returns a 5xx HTTP Status, with the exception of the 507 status.\n    // The API returns a 507 error when the user has run out of account space, in which case, it should be treated\n    // as a permanent, non-retryable error.\n    if (statusCode !== httpStatusCodes.INSUFFICIENT_STORAGE && statusCode >= HTTP_STATUS_CODE_SERVER_ERROR_BLOCK_RANGE[0] && statusCode <= HTTP_STATUS_CODE_SERVER_ERROR_BLOCK_RANGE[1]) {\n        return true;\n    }\n    // An API error is a temporary/transient error if it returns a HTTP Status that indicates it is a temporary,\n    if (retryableStatusCodes[statusCode]) {\n        return true;\n    }\n    return false;\n}\n/**\n * Determine whether a given request can be retried, based on its options\n * @param {Object} options The request options\n * @returns {boolean} Whether or not the request is retryable\n * @private\n */ function isRequestRetryable(options) {\n    return !options.formData;\n}\n/**\n * Clean sensitive headers from the request object. This prevents this data from\n * propagating out to the SDK and getting unintentionally logged via the error or\n * response objects. Note that this function modifies the given object and returns\n * nothing.\n *\n * @param {APIRequest~RequestObject} requestObj Any request object\n * @returns {void}\n * @private\n */ function cleanSensitiveHeaders(requestObj) {\n    if (requestObj.headers) {\n        if (requestObj.headers.BoxApi) {\n            requestObj.headers.BoxApi = REMOVED_HEADER_MESSAGE;\n        }\n        if (requestObj.headers.Authorization) {\n            requestObj.headers.Authorization = REMOVED_HEADER_MESSAGE;\n        }\n    }\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * APIRequest helps to prepare and execute requests to the Box API. It supports\n * retries, multipart uploads, and more.\n *\n\n * @param {Config} config Request-specific Config object\n * @param {EventEmitter} eventBus Event bus for the SDK instance\n * @constructor\n */ function APIRequest(config, eventBus) {\n    assert(config instanceof Config, \"Config must be passed to APIRequest constructor\");\n    assert(eventBus instanceof EventEmitter, \"Valid event bus must be passed to APIRequest constructor\");\n    this.config = config;\n    this.eventBus = eventBus;\n    this.isRetryable = isRequestRetryable(config.request);\n}\n/**\n * Executes the request with the given options. If a callback is provided, we'll\n * handle the response via callbacks. Otherwise, the response will be streamed to\n * via the stream property. You can access this stream with the getResponseStream()\n * method.\n *\n * @param {APIRequest~Callback} [callback] Callback for handling the response\n * @returns {void}\n */ APIRequest.prototype.execute = function(callback) {\n    this._callback = callback || this._callback;\n    // Initiate an async- or stream-based request, based on the presence of the callback.\n    if (this._callback) {\n        // Start the request timer immediately before executing the async request\n        if (!asyncRequestTimer) {\n            asyncRequestTimer = process.hrtime();\n        }\n        this.request = request(this.config.request, this._handleResponse.bind(this));\n    } else {\n        this.request = request(this.config.request);\n        this.stream = this.request;\n        this.stream.on(\"error\", (err)=>this.eventBus.emit(\"response\", err));\n        this.stream.on(\"response\", (response)=>this.eventBus.emit(\"response\", null, response));\n    }\n};\n/**\n * Return the response read stream for a request. This will be undefined until\n * a stream-based request has been started.\n *\n * @returns {?ReadableStream} The response stream\n */ APIRequest.prototype.getResponseStream = function() {\n    return this.stream;\n};\n/**\n * Handle the request response in the callback case.\n *\n * @param {?Error} err An error, if one occurred\n * @param {Object} [response] The full response object, returned by the request module.\n *  Contains information about the request & response, including the response body itself.\n * @returns {void}\n * @private\n */ APIRequest.prototype._handleResponse = function(err, response) {\n    // Clean sensitive headers here to prevent the user from accidentily using/logging them in prod\n    cleanSensitiveHeaders(this.request);\n    // If the API connected successfully but responded with a temporary error (like a 5xx code,\n    // a rate limited response, etc.) then this is considered an error as well.\n    if (!err && isTemporaryError(response)) {\n        var errorMessage = `${response.statusCode} - ${httpStatusCodes[response.statusCode]}`;\n        err = new Error(errorMessage);\n    }\n    if (err) {\n        // Attach request & response information to the error object\n        err.request = this.request;\n        if (response) {\n            err.response = response;\n            err.statusCode = response.statusCode;\n        }\n        // Have the SDK emit the error response\n        this.eventBus.emit(\"response\", err);\n        var isJWT = false;\n        if (this.config.request.hasOwnProperty(\"form\") && this.config.request.form.hasOwnProperty(\"grant_type\") && this.config.request.form.grant_type === \"urn:ietf:params:oauth:grant-type:jwt-bearer\") {\n            isJWT = true;\n        }\n        // If our APIRequest instance is retryable, attempt a retry. Otherwise, finish and propagate the error. Doesn't retry when the request is for JWT authentication, since that is handled in retryJWTGrant.\n        if (this.isRetryable && !isJWT) {\n            this._retry(err);\n        } else {\n            this._finish(err);\n        }\n        return;\n    }\n    // If the request was successful, emit & propagate the response!\n    this.eventBus.emit(\"response\", null, response);\n    this._finish(null, response);\n};\n/**\n * Attempt a retry. If the request hasn't exceeded it's maximum number of retries,\n * re-execute the request (after the retry interval). Otherwise, propagate a new error.\n *\n * @param {?Error} err An error, if one occurred\n * @returns {void}\n * @private\n */ APIRequest.prototype._retry = function(err) {\n    this.numRetries = this.numRetries || 0;\n    if (this.numRetries < this.config.numMaxRetries) {\n        var retryTimeout;\n        this.numRetries += 1;\n        // If the retry strategy is defined, then use it to determine the time (in ms) until the next retry or to\n        // propagate an error to the user.\n        if (this.config.retryStrategy) {\n            // Get the total elapsed time so far since the request was executed\n            var totalElapsedTime = process.hrtime(asyncRequestTimer);\n            var totalElapsedTimeMS = totalElapsedTime[0] * 1000 + totalElapsedTime[1] / 1000000;\n            var retryOptions = {\n                error: err,\n                numRetryAttempts: this.numRetries,\n                numMaxRetries: this.config.numMaxRetries,\n                retryIntervalMS: this.config.retryIntervalMS,\n                totalElapsedTimeMS\n            };\n            retryTimeout = this.config.retryStrategy(retryOptions);\n            // If the retry strategy doesn't return a number/time in ms, then propagate the response error to the user.\n            // However, if the retry strategy returns its own error, this will be propagated to the user instead.\n            if (typeof retryTimeout !== \"number\") {\n                if (retryTimeout instanceof Error) {\n                    err = retryTimeout;\n                }\n                this._finish(err);\n                return;\n            }\n        } else if (err.hasOwnProperty(\"response\") && err.response.hasOwnProperty(\"headers\") && err.response.headers.hasOwnProperty(\"retry-after\")) {\n            retryTimeout = err.response.headers[\"retry-after\"] * 1000;\n        } else {\n            retryTimeout = getRetryTimeout(this.numRetries, this.config.retryIntervalMS);\n        }\n        setTimeout(this.execute.bind(this), retryTimeout);\n    } else {\n        err.maxRetriesExceeded = true;\n        this._finish(err);\n    }\n};\n/**\n * Propagate the response to the provided callback.\n *\n * @param {?Error} err An error, if one occurred\n * @param {APIRequest~ResponseObject} response Information about the request & response\n * @returns {void}\n * @private\n */ APIRequest.prototype._finish = function(err, response) {\n    var callback = this._callback;\n    process.nextTick(()=>{\n        if (err) {\n            callback(err);\n            return;\n        }\n        callback(null, response);\n    });\n};\n/**\n * @module box-node-sdk/lib/api-request\n * @see {@Link APIRequest}\n */ module.exports = APIRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9hcGktcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVELHNHQUFzRztBQUN0RyxtR0FBbUc7QUFDbkcsK0VBQStFO0FBRS9FO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUMseUJBQ3BCQyxVQUFVRCxtQkFBT0EsQ0FBQyx5REFDbEJFLGVBQWVGLDBEQUE4QixFQUM3Q0csU0FBU0gsbUJBQU9BLENBQUMsOEVBQ2pCSSxrQkFBa0JKLG1CQUFPQSxDQUFDLHFFQUMxQkssa0JBQWtCTCxtQkFBT0EsQ0FBQztBQUUzQixpRkFBaUY7QUFDakYseUJBQXlCO0FBQ3pCLGlGQUFpRjtBQUVqRjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUVEOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBR0QsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFFakYseURBQXlEO0FBQ3pELElBQUlNLHlCQUF5QjtBQUU3QiwwQ0FBMEM7QUFDMUMsSUFBSUMsNENBQTRDO0lBQy9DO0lBQ0E7Q0FDQTtBQUVELHVHQUF1RztBQUN2RyxJQUFJQztBQUVKLG9FQUFvRTtBQUNwRSxJQUFJQyx1QkFBdUIsQ0FBQztBQUM1QkEsb0JBQW9CLENBQUNMLGdCQUFnQk0sZUFBZSxDQUFDLEdBQUc7QUFDeERELG9CQUFvQixDQUFDTCxnQkFBZ0JPLGlCQUFpQixDQUFDLEdBQUc7QUFFMUQ7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTQyxpQkFBaUJDLFFBQVE7SUFDakMsSUFBSUMsYUFBYUQsU0FBU0MsVUFBVTtJQUVwQywrR0FBK0c7SUFDL0csOEdBQThHO0lBQzlHLHVDQUF1QztJQUN2QyxJQUFJQSxlQUFlVixnQkFBZ0JXLG9CQUFvQixJQUNuREQsY0FBY1AseUNBQXlDLENBQUMsRUFBRSxJQUMxRE8sY0FBY1AseUNBQXlDLENBQUMsRUFBRSxFQUFFO1FBQy9ELE9BQU87SUFDUjtJQUVBLDRHQUE0RztJQUM1RyxJQUFJRSxvQkFBb0IsQ0FBQ0ssV0FBVyxFQUFFO1FBQ3JDLE9BQU87SUFDUjtJQUVBLE9BQU87QUFDUjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU0UsbUJBQW1CQyxPQUFPO0lBQ2xDLE9BQU8sQ0FBQ0EsUUFBUUMsUUFBUTtBQUN6QjtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNDLHNCQUFzQkMsVUFBVTtJQUN4QyxJQUFJQSxXQUFXQyxPQUFPLEVBQUU7UUFDdkIsSUFBSUQsV0FBV0MsT0FBTyxDQUFDQyxNQUFNLEVBQUU7WUFDOUJGLFdBQVdDLE9BQU8sQ0FBQ0MsTUFBTSxHQUFHaEI7UUFDN0I7UUFDQSxJQUFJYyxXQUFXQyxPQUFPLENBQUNFLGFBQWEsRUFBRTtZQUNyQ0gsV0FBV0MsT0FBTyxDQUFDRSxhQUFhLEdBQUdqQjtRQUNwQztJQUNEO0FBQ0Q7QUFFQSxpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNrQixXQUFXQyxNQUFNLEVBQUVDLFFBQVE7SUFDbkMzQixPQUFPMEIsa0JBQWtCdEIsUUFBUTtJQUNqQ0osT0FBTzJCLG9CQUFvQnhCLGNBQWM7SUFDekMsSUFBSSxDQUFDdUIsTUFBTSxHQUFHQTtJQUNkLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNoQixJQUFJLENBQUNDLFdBQVcsR0FBR1gsbUJBQW1CUyxPQUFPeEIsT0FBTztBQUNyRDtBQUVBOzs7Ozs7OztDQVFDLEdBQ0R1QixXQUFXSSxTQUFTLENBQUNDLE9BQU8sR0FBRyxTQUFTQyxRQUFRO0lBQy9DLElBQUksQ0FBQ0MsU0FBUyxHQUFHRCxZQUFZLElBQUksQ0FBQ0MsU0FBUztJQUUzQyxxRkFBcUY7SUFDckYsSUFBSSxJQUFJLENBQUNBLFNBQVMsRUFBRTtRQUNuQix5RUFBeUU7UUFDekUsSUFBSSxDQUFDdkIsbUJBQW1CO1lBQ3ZCQSxvQkFBb0J3QixRQUFRQyxNQUFNO1FBQ25DO1FBQ0EsSUFBSSxDQUFDaEMsT0FBTyxHQUFHQSxRQUFRLElBQUksQ0FBQ3dCLE1BQU0sQ0FBQ3hCLE9BQU8sRUFBRSxJQUFJLENBQUNpQyxlQUFlLENBQUNDLElBQUksQ0FBQyxJQUFJO0lBQzNFLE9BQU87UUFDTixJQUFJLENBQUNsQyxPQUFPLEdBQUdBLFFBQVEsSUFBSSxDQUFDd0IsTUFBTSxDQUFDeEIsT0FBTztRQUMxQyxJQUFJLENBQUNtQyxNQUFNLEdBQUcsSUFBSSxDQUFDbkMsT0FBTztRQUMxQixJQUFJLENBQUNtQyxNQUFNLENBQUNDLEVBQUUsQ0FBQyxTQUFTQyxDQUFBQSxNQUFPLElBQUksQ0FBQ1osUUFBUSxDQUFDYSxJQUFJLENBQUMsWUFBWUQ7UUFDOUQsSUFBSSxDQUFDRixNQUFNLENBQUNDLEVBQUUsQ0FBQyxZQUFZeEIsQ0FBQUEsV0FBWSxJQUFJLENBQUNhLFFBQVEsQ0FBQ2EsSUFBSSxDQUFDLFlBQVksTUFBTTFCO0lBQzdFO0FBRUQ7QUFFQTs7Ozs7Q0FLQyxHQUNEVyxXQUFXSSxTQUFTLENBQUNZLGlCQUFpQixHQUFHO0lBQ3hDLE9BQU8sSUFBSSxDQUFDSixNQUFNO0FBQ25CO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRFosV0FBV0ksU0FBUyxDQUFDTSxlQUFlLEdBQUcsU0FBU0ksR0FBRyxFQUFFekIsUUFBUTtJQUM1RCwrRkFBK0Y7SUFDL0ZNLHNCQUFzQixJQUFJLENBQUNsQixPQUFPO0lBRWxDLDJGQUEyRjtJQUMzRiwyRUFBMkU7SUFDM0UsSUFBSSxDQUFDcUMsT0FBTzFCLGlCQUFpQkMsV0FBVztRQUN2QyxJQUFJNEIsZUFBZSxDQUFDLEVBQUU1QixTQUFTQyxVQUFVLENBQUMsR0FBRyxFQUFFVixlQUFlLENBQUNTLFNBQVNDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDckZ3QixNQUFNLElBQUlJLE1BQU1EO0lBQ2pCO0lBRUEsSUFBSUgsS0FBSztRQUVSLDREQUE0RDtRQUM1REEsSUFBSXJDLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDMUIsSUFBSVksVUFBVTtZQUNieUIsSUFBSXpCLFFBQVEsR0FBR0E7WUFDZnlCLElBQUl4QixVQUFVLEdBQUdELFNBQVNDLFVBQVU7UUFDckM7UUFFQSx1Q0FBdUM7UUFDdkMsSUFBSSxDQUFDWSxRQUFRLENBQUNhLElBQUksQ0FBQyxZQUFZRDtRQUUvQixJQUFJSyxRQUFRO1FBQ1osSUFBSSxJQUFJLENBQUNsQixNQUFNLENBQUN4QixPQUFPLENBQUMyQyxjQUFjLENBQUMsV0FBVyxJQUFJLENBQUNuQixNQUFNLENBQUN4QixPQUFPLENBQUM0QyxJQUFJLENBQUNELGNBQWMsQ0FBQyxpQkFBaUIsSUFBSSxDQUFDbkIsTUFBTSxDQUFDeEIsT0FBTyxDQUFDNEMsSUFBSSxDQUFDQyxVQUFVLEtBQUssK0NBQStDO1lBQ2pNSCxRQUFRO1FBQ1Q7UUFDQSx5TUFBeU07UUFDek0sSUFBSSxJQUFJLENBQUNoQixXQUFXLElBQUksQ0FBQ2dCLE9BQU87WUFDL0IsSUFBSSxDQUFDSSxNQUFNLENBQUNUO1FBQ2IsT0FBTztZQUNOLElBQUksQ0FBQ1UsT0FBTyxDQUFDVjtRQUNkO1FBRUE7SUFDRDtJQUVBLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNaLFFBQVEsQ0FBQ2EsSUFBSSxDQUFDLFlBQVksTUFBTTFCO0lBQ3JDLElBQUksQ0FBQ21DLE9BQU8sQ0FBQyxNQUFNbkM7QUFDcEI7QUFFQTs7Ozs7OztDQU9DLEdBQ0RXLFdBQVdJLFNBQVMsQ0FBQ21CLE1BQU0sR0FBRyxTQUFTVCxHQUFHO0lBQ3pDLElBQUksQ0FBQ1csVUFBVSxHQUFHLElBQUksQ0FBQ0EsVUFBVSxJQUFJO0lBRXJDLElBQUksSUFBSSxDQUFDQSxVQUFVLEdBQUcsSUFBSSxDQUFDeEIsTUFBTSxDQUFDeUIsYUFBYSxFQUFFO1FBQ2hELElBQUlDO1FBQ0osSUFBSSxDQUFDRixVQUFVLElBQUk7UUFDbkIseUdBQXlHO1FBQ3pHLGtDQUFrQztRQUNsQyxJQUFJLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQzJCLGFBQWEsRUFBRTtZQUM5QixtRUFBbUU7WUFDbkUsSUFBSUMsbUJBQW1CckIsUUFBUUMsTUFBTSxDQUFDekI7WUFDdEMsSUFBSThDLHFCQUFxQixnQkFBaUIsQ0FBQyxFQUFFLEdBQUcsT0FBU0QsZ0JBQWdCLENBQUMsRUFBRSxHQUFHO1lBQy9FLElBQUlFLGVBQWU7Z0JBQ2xCQyxPQUFPbEI7Z0JBQ1BtQixrQkFBa0IsSUFBSSxDQUFDUixVQUFVO2dCQUNqQ0MsZUFBZSxJQUFJLENBQUN6QixNQUFNLENBQUN5QixhQUFhO2dCQUN4Q1EsaUJBQWlCLElBQUksQ0FBQ2pDLE1BQU0sQ0FBQ2lDLGVBQWU7Z0JBQzVDSjtZQUNEO1lBRUFILGVBQWUsSUFBSSxDQUFDMUIsTUFBTSxDQUFDMkIsYUFBYSxDQUFDRztZQUV6QywyR0FBMkc7WUFDM0cscUdBQXFHO1lBQ3JHLElBQUksT0FBT0osaUJBQWlCLFVBQVU7Z0JBQ3JDLElBQUlBLHdCQUF3QlQsT0FBTztvQkFDbENKLE1BQU1hO2dCQUNQO2dCQUNBLElBQUksQ0FBQ0gsT0FBTyxDQUFDVjtnQkFDYjtZQUNEO1FBQ0QsT0FBTyxJQUFJQSxJQUFJTSxjQUFjLENBQUMsZUFBZU4sSUFBSXpCLFFBQVEsQ0FBQytCLGNBQWMsQ0FBQyxjQUFjTixJQUFJekIsUUFBUSxDQUFDUSxPQUFPLENBQUN1QixjQUFjLENBQUMsZ0JBQWdCO1lBQzFJTyxlQUFlYixJQUFJekIsUUFBUSxDQUFDUSxPQUFPLENBQUMsY0FBYyxHQUFHO1FBQ3RELE9BQU87WUFDTjhCLGVBQWU5QyxnQkFBZ0IsSUFBSSxDQUFDNEMsVUFBVSxFQUFFLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ2lDLGVBQWU7UUFDNUU7UUFDQUMsV0FBVyxJQUFJLENBQUM5QixPQUFPLENBQUNNLElBQUksQ0FBQyxJQUFJLEdBQUdnQjtJQUNyQyxPQUFPO1FBQ05iLElBQUlzQixrQkFBa0IsR0FBRztRQUN6QixJQUFJLENBQUNaLE9BQU8sQ0FBQ1Y7SUFDZDtBQUNEO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEZCxXQUFXSSxTQUFTLENBQUNvQixPQUFPLEdBQUcsU0FBU1YsR0FBRyxFQUFFekIsUUFBUTtJQUNwRCxJQUFJaUIsV0FBVyxJQUFJLENBQUNDLFNBQVM7SUFDN0JDLFFBQVE2QixRQUFRLENBQUM7UUFDaEIsSUFBSXZCLEtBQUs7WUFDUlIsU0FBU1E7WUFDVDtRQUNEO1FBRUFSLFNBQVMsTUFBTWpCO0lBQ2hCO0FBQ0Q7QUFHQTs7O0NBR0MsR0FDRGlELE9BQU9DLE9BQU8sR0FBR3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9hcGktcmVxdWVzdC5qcz9jMjBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBBIEJveCBBUEkgUmVxdWVzdFxuICovXG5cbi8vIEBOT1RFKGZzY2hvdHQpIDA4LzA1LzIwMTQ6IFRISVMgRklMRSBTSE9VTEQgTk9UIEJFIEFDQ0VTU0VEIERJUkVDVExZIE9VVFNJREUgT0YgQVBJLVJFUVVFU1QtTUFOQUdFUlxuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCBieSBBUElSZXF1ZXN0TWFuYWdlciB0byBtYWtlIHJlcXVlc3RzLiBJZiB5b3UnZCBsaWtlIHRvIG1ha2UgcmVxdWVzdHMgdG8gdGhlXG4vLyBCb3ggQVBJLCBjb25zaWRlciB1c2luZyBBUElSZXF1ZXN0TWFuYWdlciBpbnN0ZWFkLiB7QExpbmsgQVBJUmVxdWVzdE1hbmFnZXJ9XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpLFxuXHRyZXF1ZXN0ID0gcmVxdWlyZSgncmVxdWVzdCcpLFxuXHRFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG5cdENvbmZpZyA9IHJlcXVpcmUoJy4vdXRpbC9jb25maWcnKSxcblx0aHR0cFN0YXR1c0NvZGVzID0gcmVxdWlyZSgnaHR0cC1zdGF0dXMnKSxcblx0Z2V0UmV0cnlUaW1lb3V0ID0gcmVxdWlyZSgnLi91dGlsL2V4cG9uZW50aWFsLWJhY2tvZmYnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlZGVmcyBhbmQgQ2FsbGJhY2tzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUaGUgQVBJIHJlc3BvbnNlIG9iamVjdCBpbmNsdWRlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdCBtYWRlIGFuZCBpdHMgcmVzcG9uc2UuIFRoZSBpbmZvcm1hdGlvbiBhdHRhY2hlZCBpcyBhIHN1YnNldFxuICogb2YgdGhlIGluZm9ybWF0aW9uIHJldHVybmVkIGJ5IHRoZSByZXF1ZXN0IG1vZHVsZSwgd2hpY2ggaXMgdG9vIGxhcmdlIGFuZCBjb21wbGV4IHRvIGJlIHNhZmVseSBoYW5kbGVkIChjb250YWlucyBjaXJjdWxhclxuICogcmVmZXJlbmNlcywgZXJyb3JzIG9uIHNlcmlhbGl6YXRpb24sIGV0Yy4pXG4gKiBATk9URShmc2Nob3R0KSAwOC0xOS0yMDE0OiBXZSBjYW5ub3QgcmV0dXJuIHRoZSByZXF1ZXN0L3Jlc3BvbnNlIG9iamVjdHMgZGlyZWN0bHkgYmVjYXVzZSB0aGV5IGNvbnRhaW4gbG9hZHMgb2YgZXh0cmFcbiAqICBpbmZvcm1hdGlvbiwgdW5uZWNlc3NhcnkgYmxvYXQsIGNpcmN1bGFyIGRlcGVuZGVuY2llcywgYW5kIGNhdXNlIGFuIGluZmluaXRlIGxvb3Agd2hlbiBzdHJpbmdpZnlpbmcuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQVBJUmVxdWVzdH5SZXNwb25zZU9iamVjdFxuICogQHByb3BlcnR5IHtBUElSZXF1ZXN0flJlcXVlc3RPYmplY3R9IHJlcXVlc3QgSW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3QgdGhhdCBnZW5lcmF0ZWQgdGhpcyByZXNwb25zZVxuICogQHByb3BlcnR5IHtpbnR9IHN0YXR1c0NvZGUgVGhlIHJlc3BvbnNlIEhUVFAgc3RhdHVzIGNvZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBoZWFkZXJzIEEgY29sbGVjdGlvbiBvZiByZXNwb25zZSBoZWFkZXJzXG4gKiBAcHJvcGVydHkge09iamVjdHxCdWZmZXJ8c3RyaW5nfSBbYm9keV0gVGhlIHJlc3BvbnNlIGJvZHkuIEVuY29kZWQgdG8gSlNPTiBieSBkZWZhdWx0LCBidXQgY2FuIGJlIGEgYnVmZmVyXG4gKiAgKGlmIGVuY29kaW5nIGZhaWxzIG9yIGlmIGpzb24gZW5jb2RpbmcgaXMgZGlzYWJsZWQpIG9yIGEgc3RyaW5nIChpZiBzdHJpbmcgZW5jb2RpbmcgaXMgZW5hYmxlZCkuIFdpbGwgYmUgdW5kZWZpbmVkXG4gKiAgaWYgbm8gcmVzcG9uc2UgYm9keSBpcyBzZW50LlxuICovXG5cbi8qKlxuICogVGhlIEFQSSByZXF1ZXN0IG9iamVjdCBpbmNsdWRlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVxdWVzdCBtYWRlLiBUaGUgaW5mb3JtYXRpb24gYXR0YWNoZWQgaXMgYSBzdWJzZXQgb2YgdGhlIGluZm9ybWF0aW9uXG4gKiBvZiBhIHJlcXVlc3QgbW9kdWxlIGluc3RhbmNlLCB3aGljaCBpcyB0b28gbGFyZ2UgYW5kIGNvbXBsZXggdG8gYmUgc2FmZWx5IGhhbmRsZWQgKGNvbnRhaW5zIGNpcmN1bGFyIHJlZmVyZW5jZXMsIGVycm9ycyBvblxuICogc2VyaWFsaXphdGlvbiwgZXRjLikuXG4gKiBATk9URShmc2Nob3R0KSAwOC0xOS0yMDE0OiBXZSBjYW5ub3QgcmV0dXJuIHRoZSByZXF1ZXN0L3Jlc3BvbnNlIG9iamVjdHMgZGlyZWN0bHkgYmVjYXVzZSB0aGV5IGNvbnRhaW4gbG9hZHMgb2YgZXh0cmFcbiAqICBpbmZvcm1hdGlvbiwgdW5uZWNlc3NhcnkgYmxvYXQsIGNpcmN1bGFyIGRlcGVuZGVuY2llcywgYW5kIGNhdXNlIGFuIGluZmluaXRlIGxvb3Agd2hlbiBzdHJpbmdpZnlpbmcuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQVBJUmVxdWVzdH5SZXF1ZXN0T2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gdXJpIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0LCBpbmNsdWRpbmcgaG9zdCwgcGF0aCwgYW5kIHRoZSBmdWxsICdocmVmJyB1cmxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXRob2QgVGhlIHJlcXVlc3QgbWV0aG9kIChHRVQsIFBPU1QsIGV0Yy4pXG4gKiBAcHJvcGVydHkge09iamVjdH0gaGVhZGVycyBBIGNvbGxlY3Rpb24gb2YgaGVhZGVycyBzZW50IHdpdGggdGhlIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIFRoZSBlcnJvciByZXR1cm5lZCBieSBBUElSZXF1ZXN0IGNhbGxiYWNrcywgd2hpY2ggaW5jbHVkZXMgYW55IHJlbGV2ZW50LCBhdmFpbGFibGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3RcbiAqIGFuZCByZXNwb25zZS4gTm90ZSB0aGF0IHRoZXNlIHByb3BlcnRpZXMgZG8gbm90IGV4aXN0IG9uIHN0cmVhbSBlcnJvcnMsIG9ubHkgZXJyb3JzIHJldHVuZWQgdG8gdGhlIGNhbGxiYWNrLlxuICpcbiAqIEB0eXBlZGVmIHtFcnJvcn0gQVBJUmVxdWVzdH5FcnJvclxuICogQHByb3BlcnR5IHtBUElSZXF1ZXN0flJlcXVlc3RPYmplY3R9IHJlcXVlc3QgSW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3QgdGhhdCBnZW5lcmF0ZWQgdGhpcyBlcnJvclxuICogQHByb3BlcnR5IHtBUElSZXF1ZXN0flJlc3BvbnNlT2JqZWN0fSBbcmVzcG9uc2VdIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZXNwb25zZSByZWxhdGVkIHRvIHRoaXMgZXJyb3IsIGlmIGF2YWlsYWJsZVxuICogQHByb3BlcnR5IHtpbnR9IFtzdGF0dXNDb2RlXSBUaGUgcmVzcG9uc2UgSFRUUCBzdGF0dXMgY29kZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbbWF4UmV0cmllc0V4Y2VlZGVkXSBUcnVlIGlmZiB0aGUgbWF4IG51bWJlciBvZiByZXRyaWVzIHdlcmUgZXhjZWVkZWQuIE90aGVyd2lzZSwgdW5kZWZpbmVkLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgaW52b2tlZCB3aGVuIGFuIEFQSVJlcXVlc3QgcmVxdWVzdCBpcyBjb21wbGV0ZSBhbmQgZmluYWxpemVkLiBPbiBzdWNjZXNzLFxuICogcHJvcGFnYXRlcyB0aGUgcmVsZXZlbnQgcmVzcG9uc2UgaW5mb3JtYXRpb24uIEFuIGVyciB3aWxsIGluZGljYXRlIGFuIHVucmVzb2x2YWJsZSBpc3N1ZVxuICogd2l0aCB0aGUgcmVxdWVzdCAocGVybWFuZW50IGZhaWx1cmUgb3IgdGVtcCBlcnJvciByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIsIHJldHJpZWQgdG9vIG1hbnkgdGltZXMpLlxuICpcbiAqIEBjYWxsYmFjayBBUElSZXF1ZXN0fkNhbGxiYWNrXG4gKiBAcGFyYW0gez9BUElSZXF1ZXN0fkVycm9yfSBlcnIgSWYgRXJyb3Igb2JqZWN0LCBBUEkgcmVxdWVzdCBkaWQgbm90IGdldCBiYWNrIHRoZSBkYXRhIGl0IHdhcyBzdXBwb3NlZCB0by4gVGhpc1xuICogIGNvdWxkIGJlIGVpdGhlciBiZWNhdXNlIG9mIGEgdGVtcG9yYXJ5IGVycm9yLCBvciBhIG1vcmUgc2VyaW91cyBlcnJvciBjb25uZWN0aW5nIHRvIHRoZSBBUEkuXG4gKiBAcGFyYW0ge0FQSVJlcXVlc3R+UmVzcG9uc2VPYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZSByZXR1cm5lZCBieSBhbiBBUElSZXF1ZXN0TWFuYWdlciByZXF1ZXN0XG4gKi9cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBNZXNzYWdlIHRvIHJlcGxhY2UgcmVtb3ZlZCBoZWFkZXJzIHdpdGggaW4gdGhlIHJlcXVlc3RcbnZhciBSRU1PVkVEX0hFQURFUl9NRVNTQUdFID0gJ1tSRU1PVkVEIEJZIFNES10nO1xuXG4vLyBSYW5nZSBvZiBTRVJWRVIgRVJST1IgaHR0cCBzdGF0dXMgY29kZXNcbnZhciBIVFRQX1NUQVRVU19DT0RFX1NFUlZFUl9FUlJPUl9CTE9DS19SQU5HRSA9IFtcblx0NTAwLFxuXHQ1OTlcbl07XG5cbi8vIFRpbWVyIHVzZWQgdG8gdHJhY2sgZWxhcHNlZCB0aW1lIGJlZ2lubmluZyBmcm9tIGV4ZWN1dGluZyBhbiBhc3luYyByZXF1ZXN0IHRvIGVtaXR0aW5nIHRoZSByZXNwb25zZS5cbnZhciBhc3luY1JlcXVlc3RUaW1lcjtcblxuLy8gQSBtYXAgb2YgSFRUUCBzdGF0dXMgY29kZXMgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkgY2FuIGJlIHJldHJpZWRcbnZhciByZXRyeWFibGVTdGF0dXNDb2RlcyA9IHt9O1xucmV0cnlhYmxlU3RhdHVzQ29kZXNbaHR0cFN0YXR1c0NvZGVzLlJFUVVFU1RfVElNRU9VVF0gPSB0cnVlO1xucmV0cnlhYmxlU3RhdHVzQ29kZXNbaHR0cFN0YXR1c0NvZGVzLlRPT19NQU5ZX1JFUVVFU1RTXSA9IHRydWU7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSByZXNwb25zZSBpbmZvIGluZGljYXRlcyBhIHRlbXBvcmFyeS90cmFuc2llbnQgZXJyb3IuXG4gKlxuICogQHBhcmFtIHs/QVBJUmVxdWVzdH5SZXNwb25zZU9iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlIGluZm8gZnJvbSBhbiBBUEkgcmVxdWVzdCxcbiAqIG9yIHVuZGVmaW5lZCBpZiB0aGUgQVBJIHJlcXVlc3QgZGlkIG5vdCByZXR1cm4gYW55IHJlc3BvbnNlIGluZm8uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgQVBJIGNhbGwgZXJyb3IgaXMgdGVtcG9yYXJ5IChhbmQgaGVuY2UgY2FuXG4gKiBiZSByZXRyaWVkKS4gRmFsc2Ugb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNUZW1wb3JhcnlFcnJvcihyZXNwb25zZSkge1xuXHR2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG5cblx0Ly8gQW4gQVBJIGVycm9yIGlzIGEgdGVtcG9yYXJ5L3RyYW5zaWVudCBpZiBpdCByZXR1cm5zIGEgNXh4IEhUVFAgU3RhdHVzLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIDUwNyBzdGF0dXMuXG5cdC8vIFRoZSBBUEkgcmV0dXJucyBhIDUwNyBlcnJvciB3aGVuIHRoZSB1c2VyIGhhcyBydW4gb3V0IG9mIGFjY291bnQgc3BhY2UsIGluIHdoaWNoIGNhc2UsIGl0IHNob3VsZCBiZSB0cmVhdGVkXG5cdC8vIGFzIGEgcGVybWFuZW50LCBub24tcmV0cnlhYmxlIGVycm9yLlxuXHRpZiAoc3RhdHVzQ29kZSAhPT0gaHR0cFN0YXR1c0NvZGVzLklOU1VGRklDSUVOVF9TVE9SQUdFXG5cdFx0JiYgc3RhdHVzQ29kZSA+PSBIVFRQX1NUQVRVU19DT0RFX1NFUlZFUl9FUlJPUl9CTE9DS19SQU5HRVswXVxuXHRcdCYmIHN0YXR1c0NvZGUgPD0gSFRUUF9TVEFUVVNfQ09ERV9TRVJWRVJfRVJST1JfQkxPQ0tfUkFOR0VbMV0pIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEFuIEFQSSBlcnJvciBpcyBhIHRlbXBvcmFyeS90cmFuc2llbnQgZXJyb3IgaWYgaXQgcmV0dXJucyBhIEhUVFAgU3RhdHVzIHRoYXQgaW5kaWNhdGVzIGl0IGlzIGEgdGVtcG9yYXJ5LFxuXHRpZiAocmV0cnlhYmxlU3RhdHVzQ29kZXNbc3RhdHVzQ29kZV0pIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHJlcXVlc3QgY2FuIGJlIHJldHJpZWQsIGJhc2VkIG9uIGl0cyBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgcmVxdWVzdCBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHJlcXVlc3QgaXMgcmV0cnlhYmxlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1JlcXVlc3RSZXRyeWFibGUob3B0aW9ucykge1xuXHRyZXR1cm4gIW9wdGlvbnMuZm9ybURhdGE7XG59XG5cbi8qKlxuICogQ2xlYW4gc2Vuc2l0aXZlIGhlYWRlcnMgZnJvbSB0aGUgcmVxdWVzdCBvYmplY3QuIFRoaXMgcHJldmVudHMgdGhpcyBkYXRhIGZyb21cbiAqIHByb3BhZ2F0aW5nIG91dCB0byB0aGUgU0RLIGFuZCBnZXR0aW5nIHVuaW50ZW50aW9uYWxseSBsb2dnZWQgdmlhIHRoZSBlcnJvciBvclxuICogcmVzcG9uc2Ugb2JqZWN0cy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIGdpdmVuIG9iamVjdCBhbmQgcmV0dXJuc1xuICogbm90aGluZy5cbiAqXG4gKiBAcGFyYW0ge0FQSVJlcXVlc3R+UmVxdWVzdE9iamVjdH0gcmVxdWVzdE9iaiBBbnkgcmVxdWVzdCBvYmplY3RcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYW5TZW5zaXRpdmVIZWFkZXJzKHJlcXVlc3RPYmopIHtcblx0aWYgKHJlcXVlc3RPYmouaGVhZGVycykge1xuXHRcdGlmIChyZXF1ZXN0T2JqLmhlYWRlcnMuQm94QXBpKSB7XG5cdFx0XHRyZXF1ZXN0T2JqLmhlYWRlcnMuQm94QXBpID0gUkVNT1ZFRF9IRUFERVJfTUVTU0FHRTtcblx0XHR9XG5cdFx0aWYgKHJlcXVlc3RPYmouaGVhZGVycy5BdXRob3JpemF0aW9uKSB7XG5cdFx0XHRyZXF1ZXN0T2JqLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFJFTU9WRURfSEVBREVSX01FU1NBR0U7XG5cdFx0fVxuXHR9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBUElSZXF1ZXN0IGhlbHBzIHRvIHByZXBhcmUgYW5kIGV4ZWN1dGUgcmVxdWVzdHMgdG8gdGhlIEJveCBBUEkuIEl0IHN1cHBvcnRzXG4gKiByZXRyaWVzLCBtdWx0aXBhcnQgdXBsb2FkcywgYW5kIG1vcmUuXG4gKlxuXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFJlcXVlc3Qtc3BlY2lmaWMgQ29uZmlnIG9iamVjdFxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGV2ZW50QnVzIEV2ZW50IGJ1cyBmb3IgdGhlIFNESyBpbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFQSVJlcXVlc3QoY29uZmlnLCBldmVudEJ1cykge1xuXHRhc3NlcnQoY29uZmlnIGluc3RhbmNlb2YgQ29uZmlnLCAnQ29uZmlnIG11c3QgYmUgcGFzc2VkIHRvIEFQSVJlcXVlc3QgY29uc3RydWN0b3InKTtcblx0YXNzZXJ0KGV2ZW50QnVzIGluc3RhbmNlb2YgRXZlbnRFbWl0dGVyLCAnVmFsaWQgZXZlbnQgYnVzIG11c3QgYmUgcGFzc2VkIHRvIEFQSVJlcXVlc3QgY29uc3RydWN0b3InKTtcblx0dGhpcy5jb25maWcgPSBjb25maWc7XG5cdHRoaXMuZXZlbnRCdXMgPSBldmVudEJ1cztcblx0dGhpcy5pc1JldHJ5YWJsZSA9IGlzUmVxdWVzdFJldHJ5YWJsZShjb25maWcucmVxdWVzdCk7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy4gSWYgYSBjYWxsYmFjayBpcyBwcm92aWRlZCwgd2UnbGxcbiAqIGhhbmRsZSB0aGUgcmVzcG9uc2UgdmlhIGNhbGxiYWNrcy4gT3RoZXJ3aXNlLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZSBzdHJlYW1lZCB0b1xuICogdmlhIHRoZSBzdHJlYW0gcHJvcGVydHkuIFlvdSBjYW4gYWNjZXNzIHRoaXMgc3RyZWFtIHdpdGggdGhlIGdldFJlc3BvbnNlU3RyZWFtKClcbiAqIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge0FQSVJlcXVlc3R+Q2FsbGJhY2t9IFtjYWxsYmFja10gQ2FsbGJhY2sgZm9yIGhhbmRsaW5nIHRoZSByZXNwb25zZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkFQSVJlcXVlc3QucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHR0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrIHx8IHRoaXMuX2NhbGxiYWNrO1xuXG5cdC8vIEluaXRpYXRlIGFuIGFzeW5jLSBvciBzdHJlYW0tYmFzZWQgcmVxdWVzdCwgYmFzZWQgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBjYWxsYmFjay5cblx0aWYgKHRoaXMuX2NhbGxiYWNrKSB7XG5cdFx0Ly8gU3RhcnQgdGhlIHJlcXVlc3QgdGltZXIgaW1tZWRpYXRlbHkgYmVmb3JlIGV4ZWN1dGluZyB0aGUgYXN5bmMgcmVxdWVzdFxuXHRcdGlmICghYXN5bmNSZXF1ZXN0VGltZXIpIHtcblx0XHRcdGFzeW5jUmVxdWVzdFRpbWVyID0gcHJvY2Vzcy5ocnRpbWUoKTtcblx0XHR9XG5cdFx0dGhpcy5yZXF1ZXN0ID0gcmVxdWVzdCh0aGlzLmNvbmZpZy5yZXF1ZXN0LCB0aGlzLl9oYW5kbGVSZXNwb25zZS5iaW5kKHRoaXMpKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KHRoaXMuY29uZmlnLnJlcXVlc3QpO1xuXHRcdHRoaXMuc3RyZWFtID0gdGhpcy5yZXF1ZXN0O1xuXHRcdHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiB0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc3BvbnNlJywgZXJyKSk7XG5cdFx0dGhpcy5zdHJlYW0ub24oJ3Jlc3BvbnNlJywgcmVzcG9uc2UgPT4gdGhpcy5ldmVudEJ1cy5lbWl0KCdyZXNwb25zZScsIG51bGwsIHJlc3BvbnNlKSk7XG5cdH1cblxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHJlc3BvbnNlIHJlYWQgc3RyZWFtIGZvciBhIHJlcXVlc3QuIFRoaXMgd2lsbCBiZSB1bmRlZmluZWQgdW50aWxcbiAqIGEgc3RyZWFtLWJhc2VkIHJlcXVlc3QgaGFzIGJlZW4gc3RhcnRlZC5cbiAqXG4gKiBAcmV0dXJucyB7P1JlYWRhYmxlU3RyZWFtfSBUaGUgcmVzcG9uc2Ugc3RyZWFtXG4gKi9cbkFQSVJlcXVlc3QucHJvdG90eXBlLmdldFJlc3BvbnNlU3RyZWFtID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnN0cmVhbTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSByZXF1ZXN0IHJlc3BvbnNlIGluIHRoZSBjYWxsYmFjayBjYXNlLlxuICpcbiAqIEBwYXJhbSB7P0Vycm9yfSBlcnIgQW4gZXJyb3IsIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIGZ1bGwgcmVzcG9uc2Ugb2JqZWN0LCByZXR1cm5lZCBieSB0aGUgcmVxdWVzdCBtb2R1bGUuXG4gKiAgQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlcXVlc3QgJiByZXNwb25zZSwgaW5jbHVkaW5nIHRoZSByZXNwb25zZSBib2R5IGl0c2VsZi5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuQVBJUmVxdWVzdC5wcm90b3R5cGUuX2hhbmRsZVJlc3BvbnNlID0gZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuXHQvLyBDbGVhbiBzZW5zaXRpdmUgaGVhZGVycyBoZXJlIHRvIHByZXZlbnQgdGhlIHVzZXIgZnJvbSBhY2NpZGVudGlseSB1c2luZy9sb2dnaW5nIHRoZW0gaW4gcHJvZFxuXHRjbGVhblNlbnNpdGl2ZUhlYWRlcnModGhpcy5yZXF1ZXN0KTtcblxuXHQvLyBJZiB0aGUgQVBJIGNvbm5lY3RlZCBzdWNjZXNzZnVsbHkgYnV0IHJlc3BvbmRlZCB3aXRoIGEgdGVtcG9yYXJ5IGVycm9yIChsaWtlIGEgNXh4IGNvZGUsXG5cdC8vIGEgcmF0ZSBsaW1pdGVkIHJlc3BvbnNlLCBldGMuKSB0aGVuIHRoaXMgaXMgY29uc2lkZXJlZCBhbiBlcnJvciBhcyB3ZWxsLlxuXHRpZiAoIWVyciAmJiBpc1RlbXBvcmFyeUVycm9yKHJlc3BvbnNlKSkge1xuXHRcdHZhciBlcnJvck1lc3NhZ2UgPSBgJHtyZXNwb25zZS5zdGF0dXNDb2RlfSAtICR7aHR0cFN0YXR1c0NvZGVzW3Jlc3BvbnNlLnN0YXR1c0NvZGVdfWA7XG5cdFx0ZXJyID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdH1cblxuXHRpZiAoZXJyKSB7XG5cblx0XHQvLyBBdHRhY2ggcmVxdWVzdCAmIHJlc3BvbnNlIGluZm9ybWF0aW9uIHRvIHRoZSBlcnJvciBvYmplY3Rcblx0XHRlcnIucmVxdWVzdCA9IHRoaXMucmVxdWVzdDtcblx0XHRpZiAocmVzcG9uc2UpIHtcblx0XHRcdGVyci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHRcdFx0ZXJyLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEhhdmUgdGhlIFNESyBlbWl0IHRoZSBlcnJvciByZXNwb25zZVxuXHRcdHRoaXMuZXZlbnRCdXMuZW1pdCgncmVzcG9uc2UnLCBlcnIpO1xuXG5cdFx0dmFyIGlzSldUID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuY29uZmlnLnJlcXVlc3QuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKSAmJiB0aGlzLmNvbmZpZy5yZXF1ZXN0LmZvcm0uaGFzT3duUHJvcGVydHkoJ2dyYW50X3R5cGUnKSAmJiB0aGlzLmNvbmZpZy5yZXF1ZXN0LmZvcm0uZ3JhbnRfdHlwZSA9PT0gJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmp3dC1iZWFyZXInKSB7XG5cdFx0XHRpc0pXVCA9IHRydWU7XG5cdFx0fVxuXHRcdC8vIElmIG91ciBBUElSZXF1ZXN0IGluc3RhbmNlIGlzIHJldHJ5YWJsZSwgYXR0ZW1wdCBhIHJldHJ5LiBPdGhlcndpc2UsIGZpbmlzaCBhbmQgcHJvcGFnYXRlIHRoZSBlcnJvci4gRG9lc24ndCByZXRyeSB3aGVuIHRoZSByZXF1ZXN0IGlzIGZvciBKV1QgYXV0aGVudGljYXRpb24sIHNpbmNlIHRoYXQgaXMgaGFuZGxlZCBpbiByZXRyeUpXVEdyYW50LlxuXHRcdGlmICh0aGlzLmlzUmV0cnlhYmxlICYmICFpc0pXVCkge1xuXHRcdFx0dGhpcy5fcmV0cnkoZXJyKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZmluaXNoKGVycik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gSWYgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwsIGVtaXQgJiBwcm9wYWdhdGUgdGhlIHJlc3BvbnNlIVxuXHR0aGlzLmV2ZW50QnVzLmVtaXQoJ3Jlc3BvbnNlJywgbnVsbCwgcmVzcG9uc2UpO1xuXHR0aGlzLl9maW5pc2gobnVsbCwgcmVzcG9uc2UpO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmV0cnkuIElmIHRoZSByZXF1ZXN0IGhhc24ndCBleGNlZWRlZCBpdCdzIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMsXG4gKiByZS1leGVjdXRlIHRoZSByZXF1ZXN0IChhZnRlciB0aGUgcmV0cnkgaW50ZXJ2YWwpLiBPdGhlcndpc2UsIHByb3BhZ2F0ZSBhIG5ldyBlcnJvci5cbiAqXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIEFuIGVycm9yLCBpZiBvbmUgb2NjdXJyZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuQVBJUmVxdWVzdC5wcm90b3R5cGUuX3JldHJ5ID0gZnVuY3Rpb24oZXJyKSB7XG5cdHRoaXMubnVtUmV0cmllcyA9IHRoaXMubnVtUmV0cmllcyB8fCAwO1xuXG5cdGlmICh0aGlzLm51bVJldHJpZXMgPCB0aGlzLmNvbmZpZy5udW1NYXhSZXRyaWVzKSB7XG5cdFx0dmFyIHJldHJ5VGltZW91dDtcblx0XHR0aGlzLm51bVJldHJpZXMgKz0gMTtcblx0XHQvLyBJZiB0aGUgcmV0cnkgc3RyYXRlZ3kgaXMgZGVmaW5lZCwgdGhlbiB1c2UgaXQgdG8gZGV0ZXJtaW5lIHRoZSB0aW1lIChpbiBtcykgdW50aWwgdGhlIG5leHQgcmV0cnkgb3IgdG9cblx0XHQvLyBwcm9wYWdhdGUgYW4gZXJyb3IgdG8gdGhlIHVzZXIuXG5cdFx0aWYgKHRoaXMuY29uZmlnLnJldHJ5U3RyYXRlZ3kpIHtcblx0XHRcdC8vIEdldCB0aGUgdG90YWwgZWxhcHNlZCB0aW1lIHNvIGZhciBzaW5jZSB0aGUgcmVxdWVzdCB3YXMgZXhlY3V0ZWRcblx0XHRcdHZhciB0b3RhbEVsYXBzZWRUaW1lID0gcHJvY2Vzcy5ocnRpbWUoYXN5bmNSZXF1ZXN0VGltZXIpO1xuXHRcdFx0dmFyIHRvdGFsRWxhcHNlZFRpbWVNUyA9ICh0b3RhbEVsYXBzZWRUaW1lWzBdICogMTAwMCkgKyAodG90YWxFbGFwc2VkVGltZVsxXSAvIDEwMDAwMDApO1xuXHRcdFx0dmFyIHJldHJ5T3B0aW9ucyA9IHtcblx0XHRcdFx0ZXJyb3I6IGVycixcblx0XHRcdFx0bnVtUmV0cnlBdHRlbXB0czogdGhpcy5udW1SZXRyaWVzLFxuXHRcdFx0XHRudW1NYXhSZXRyaWVzOiB0aGlzLmNvbmZpZy5udW1NYXhSZXRyaWVzLFxuXHRcdFx0XHRyZXRyeUludGVydmFsTVM6IHRoaXMuY29uZmlnLnJldHJ5SW50ZXJ2YWxNUyxcblx0XHRcdFx0dG90YWxFbGFwc2VkVGltZU1TXG5cdFx0XHR9O1xuXG5cdFx0XHRyZXRyeVRpbWVvdXQgPSB0aGlzLmNvbmZpZy5yZXRyeVN0cmF0ZWd5KHJldHJ5T3B0aW9ucyk7XG5cblx0XHRcdC8vIElmIHRoZSByZXRyeSBzdHJhdGVneSBkb2Vzbid0IHJldHVybiBhIG51bWJlci90aW1lIGluIG1zLCB0aGVuIHByb3BhZ2F0ZSB0aGUgcmVzcG9uc2UgZXJyb3IgdG8gdGhlIHVzZXIuXG5cdFx0XHQvLyBIb3dldmVyLCBpZiB0aGUgcmV0cnkgc3RyYXRlZ3kgcmV0dXJucyBpdHMgb3duIGVycm9yLCB0aGlzIHdpbGwgYmUgcHJvcGFnYXRlZCB0byB0aGUgdXNlciBpbnN0ZWFkLlxuXHRcdFx0aWYgKHR5cGVvZiByZXRyeVRpbWVvdXQgIT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGlmIChyZXRyeVRpbWVvdXQgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRcdGVyciA9IHJldHJ5VGltZW91dDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9maW5pc2goZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZXJyLmhhc093blByb3BlcnR5KCdyZXNwb25zZScpICYmIGVyci5yZXNwb25zZS5oYXNPd25Qcm9wZXJ0eSgnaGVhZGVycycpICYmIGVyci5yZXNwb25zZS5oZWFkZXJzLmhhc093blByb3BlcnR5KCdyZXRyeS1hZnRlcicpKSB7XG5cdFx0XHRyZXRyeVRpbWVvdXQgPSBlcnIucmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSAqIDEwMDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHJ5VGltZW91dCA9IGdldFJldHJ5VGltZW91dCh0aGlzLm51bVJldHJpZXMsIHRoaXMuY29uZmlnLnJldHJ5SW50ZXJ2YWxNUyk7XG5cdFx0fVxuXHRcdHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIHJldHJ5VGltZW91dCk7XG5cdH0gZWxzZSB7XG5cdFx0ZXJyLm1heFJldHJpZXNFeGNlZWRlZCA9IHRydWU7XG5cdFx0dGhpcy5fZmluaXNoKGVycik7XG5cdH1cbn07XG5cbi8qKlxuICogUHJvcGFnYXRlIHRoZSByZXNwb25zZSB0byB0aGUgcHJvdmlkZWQgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHs/RXJyb3J9IGVyciBBbiBlcnJvciwgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge0FQSVJlcXVlc3R+UmVzcG9uc2VPYmplY3R9IHJlc3BvbnNlIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZXF1ZXN0ICYgcmVzcG9uc2VcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuQVBJUmVxdWVzdC5wcm90b3R5cGUuX2ZpbmlzaCA9IGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcblx0dmFyIGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2s7XG5cdHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXHRcdGlmIChlcnIpIHtcblx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuXHR9KTtcbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvYXBpLXJlcXVlc3RcbiAqIEBzZWUge0BMaW5rIEFQSVJlcXVlc3R9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQVBJUmVxdWVzdDtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwicmVxdWVzdCIsIkV2ZW50RW1pdHRlciIsIkNvbmZpZyIsImh0dHBTdGF0dXNDb2RlcyIsImdldFJldHJ5VGltZW91dCIsIlJFTU9WRURfSEVBREVSX01FU1NBR0UiLCJIVFRQX1NUQVRVU19DT0RFX1NFUlZFUl9FUlJPUl9CTE9DS19SQU5HRSIsImFzeW5jUmVxdWVzdFRpbWVyIiwicmV0cnlhYmxlU3RhdHVzQ29kZXMiLCJSRVFVRVNUX1RJTUVPVVQiLCJUT09fTUFOWV9SRVFVRVNUUyIsImlzVGVtcG9yYXJ5RXJyb3IiLCJyZXNwb25zZSIsInN0YXR1c0NvZGUiLCJJTlNVRkZJQ0lFTlRfU1RPUkFHRSIsImlzUmVxdWVzdFJldHJ5YWJsZSIsIm9wdGlvbnMiLCJmb3JtRGF0YSIsImNsZWFuU2Vuc2l0aXZlSGVhZGVycyIsInJlcXVlc3RPYmoiLCJoZWFkZXJzIiwiQm94QXBpIiwiQXV0aG9yaXphdGlvbiIsIkFQSVJlcXVlc3QiLCJjb25maWciLCJldmVudEJ1cyIsImlzUmV0cnlhYmxlIiwicHJvdG90eXBlIiwiZXhlY3V0ZSIsImNhbGxiYWNrIiwiX2NhbGxiYWNrIiwicHJvY2VzcyIsImhydGltZSIsIl9oYW5kbGVSZXNwb25zZSIsImJpbmQiLCJzdHJlYW0iLCJvbiIsImVyciIsImVtaXQiLCJnZXRSZXNwb25zZVN0cmVhbSIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwiaXNKV1QiLCJoYXNPd25Qcm9wZXJ0eSIsImZvcm0iLCJncmFudF90eXBlIiwiX3JldHJ5IiwiX2ZpbmlzaCIsIm51bVJldHJpZXMiLCJudW1NYXhSZXRyaWVzIiwicmV0cnlUaW1lb3V0IiwicmV0cnlTdHJhdGVneSIsInRvdGFsRWxhcHNlZFRpbWUiLCJ0b3RhbEVsYXBzZWRUaW1lTVMiLCJyZXRyeU9wdGlvbnMiLCJlcnJvciIsIm51bVJldHJ5QXR0ZW1wdHMiLCJyZXRyeUludGVydmFsTVMiLCJzZXRUaW1lb3V0IiwibWF4UmV0cmllc0V4Y2VlZGVkIiwibmV4dFRpY2siLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/api-request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/box-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/box-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Box API Client\n */ \n// ------------------------------------------------------------------------------\n// Typedefs and Callbacks\n// ------------------------------------------------------------------------------\n/**\n * A collaboration role constant\n * @typedef {string} CollaborationRole\n */ /**\n* A Box file or folder type constant\n* @typedef {string} ItemType\n*/ /**\n * An access level constant. Used for setting and updating shared links, folder upload, etc.\n * @typedef {?Object} AccessLevel\n */ // ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar util = __webpack_require__(/*! util */ \"util\"), qs = __webpack_require__(/*! querystring */ \"querystring\"), errors = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\"), isIP = (__webpack_require__(/*! net */ \"net\").isIP), merge = __webpack_require__(/*! merge-options */ \"(rsc)/./node_modules/merge-options/index.js\"), PagingIterator = __webpack_require__(/*! ./util/paging-iterator */ \"(rsc)/./node_modules/box-node-sdk/lib/util/paging-iterator.js\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), pkg = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/box-node-sdk/package.json\");\n// API Resource Managers\nvar Users = __webpack_require__(/*! ./managers/users */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/users.js\"), Files = __webpack_require__(/*! ./managers/files */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/files.js\"), Folders = __webpack_require__(/*! ./managers/folders */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/folders.js\"), Collaborations = __webpack_require__(/*! ./managers/collaborations */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/collaborations.js\"), Groups = __webpack_require__(/*! ./managers/groups */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/groups.js\"), Comments = __webpack_require__(/*! ./managers/comments */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/comments.js\"), SharedItems = __webpack_require__(/*! ./managers/shared-items */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/shared-items.js\"), Metadata = __webpack_require__(/*! ./managers/metadata */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/metadata.js\"), Collections = __webpack_require__(/*! ./managers/collections */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/collections.js\"), Events = __webpack_require__(/*! ./managers/events */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/events.js\"), Search = __webpack_require__(/*! ./managers/search */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/search.js\"), Tasks = __webpack_require__(/*! ./managers/tasks */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/tasks.js\"), Trash = __webpack_require__(/*! ./managers/trash */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/trash.js\"), Enterprise = __webpack_require__(/*! ./managers/enterprise */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/enterprise.js\"), LegalHoldPolicies = __webpack_require__(/*! ./managers/legal-hold-policies */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/legal-hold-policies.js\"), WebLinks = __webpack_require__(/*! ./managers/web-links */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/web-links.js\"), RetentionPolicies = __webpack_require__(/*! ./managers/retention-policies */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/retention-policies.js\"), DevicePins = __webpack_require__(/*! ./managers/device-pins */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/device-pins.js\"), Webhooks = __webpack_require__(/*! ./managers/webhooks */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/webhooks.js\"), RecentItems = __webpack_require__(/*! ./managers/recent-items */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/recent-items.js\"), CollaborationWhitelist = __webpack_require__(/*! ./managers/collaboration-whitelist */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/collaboration-whitelist.js\"), TermsOfService = __webpack_require__(/*! ./managers/terms-of-service */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/terms-of-service.js\"), StoragePolicies = __webpack_require__(/*! ./managers/storage-policies */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/storage-policies.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// The Authorization header label\nvar HEADER_AUTHORIZATION = \"Authorization\", // Prefix our token with this string in the Authorization header\nHEADER_AUTHORIZATION_PREFIX = \"Bearer \", // The 'BoxApi' header label\nHEADER_BOXAPI = \"BoxApi\", // The XFF header label - Used to give the API better information for uploads, rate-limiting, etc.\nHEADER_XFF = \"X-Forwarded-For\", // As-User header\nHEADER_AS_USER = \"As-User\", // Range of SUCCESS http status codes\nHTTP_STATUS_CODE_SUCCESS_BLOCK_RANGE = [\n    200,\n    299\n];\n/**\n * Build the 'Authorization' Header for the API\n *\n * @param {string} accessToken An OAuth Access Token\n * @returns {string} A properly formatted 'Authorization' header\n * @private\n */ function buildAuthorizationHeader(accessToken) {\n    return HEADER_AUTHORIZATION_PREFIX + accessToken;\n}\n/**\n * Returns true iff the response is a 401 UNAUTHORIZED that is caused by an expired access token.\n * @param {APIRequest~ResponseObject} response - The response returned by an APIRequestManager request\n * @returns {boolean} - true iff the response is a 401 UNAUTHORIZED caused by an expired access token\n * @private\n */ function isUnauthorizedDueToExpiredAccessToken(response) {\n    // There are three cases to consider:\n    // 1) The response body is a Buffer. This indicates that the request was malformed (i.e. malformed url) so return false.\n    // 2) The status code is UNAUTHORIZED and the response body is an empty object or null. This indicates that the access tokens are expired, so return true.\n    // 3) The status code is UNAUTHORIZED and the response body is a non-empty object. This indicates that the 401 was returned for some reason other\n    //    than expired tokens, so return false.\n    if (Buffer.isBuffer(response.body)) {\n        return false;\n    }\n    var isResponseStatusCodeUnauthorized = response.statusCode === httpStatusCodes.UNAUTHORIZED, isResponseBodyEmpty = !response.body || Object.getOwnPropertyNames(response.body).length === 0;\n    return isResponseStatusCodeUnauthorized && isResponseBodyEmpty;\n}\n/**\n * Returns a full URL. If the url argument begins with http:// or https://, then url is simply returned.\n * Otherwise, the defaultBasePath is prepended to url and returned.\n *\n * @param {string} defaultBasePath The default root URL that will be prepended if `url` is a partial url\n * @param {string} url A full or partial URL that will be used to construct the final URL\n * @returns {string} The final URL\n * @private\n */ function getFullURL(defaultBasePath, url) {\n    if (/^https?:\\/\\//.test(url)) {\n        return url;\n    }\n    return defaultBasePath + url;\n}\n/**\n * Create a valid request object for the Batch API from a standard request\n * params object\n * @param {Object} params The request params\n * @returns {Object} The batch API request object\n * @private\n */ function formatRequestForBatch(params) {\n    var relativePath = params.url.replace(/^http.*?\\/\\d\\.\\d\\//, \"/\");\n    return {\n        method: params.method,\n        relative_url: relativePath + (params.qs ? `?${qs.stringify(params.qs)}` : \"\"),\n        body: params.body,\n        headers: params.headers\n    };\n}\n/**\n * Format a Batch API response object into a standard request response\n * for use in response handling\n * @param {Object} response The batch API response object\n * @returns {Object} The standard response object\n * @private\n */ function formatResponseForBatch(response) {\n    return {\n        statusCode: response.status,\n        headers: response.headers,\n        body: response.response\n    };\n}\n/**\n * Construct the X-Box-UA header to send analytics identifiers\n * @param {Object} [client] Analytics client information\n * @returns {string} The header value\n */ function constructBoxUAHeader(client) {\n    var analyticsIdentifiers = {\n        agent: `box-node-sdk/${pkg.version}`,\n        env: `Node/${process.version.replace(\"v\", \"\")}`\n    };\n    if (client) {\n        analyticsIdentifiers.client = `${client.name}/${client.version}`;\n    }\n    return Object.keys(analyticsIdentifiers).map((k)=>`${k}=${analyticsIdentifiers[k]}`).join(\"; \");\n}\n/**\n * The BoxClient can make API calls on behalf of a valid API Session. It is responsible\n * for formatting the requests and handling the response. Its goal is to deliver\n * sensible results to the user.\n *\n * @param {APISession} apiSession An initialized API Session, used to get/revoke tokens and handle\n * unauthorized responses from the API.\n * @param {Config} config The SDK configuration options\n * @param {APIRequestManager} requestManager The API Request Manager\n * @constructor\n */ function BoxClient(apiSession, config, requestManager) {\n    // the API Session used by the client for authentication\n    this._session = apiSession;\n    // Attach a request manager instance for making requests\n    this._requestManager = requestManager;\n    // An object of custom headers to apply to every request. Modified via BoxClient.setCustomHeader().\n    this._customHeaders = {};\n    // Attach the configured properties\n    this._baseURL = util.format(\"%s/%s\", config.apiRootURL, config.apiVersion);\n    this._uploadBaseURL = util.format(\"%s/%s\", config.uploadAPIRootURL, config.apiVersion);\n    this._uploadRequestTimeoutMS = config.uploadRequestTimeoutMS;\n    this._useIterators = config.iterators;\n    this._analyticsClient = config.analyticsClient;\n    // Attach API Resource Managers\n    this.users = new Users(this);\n    this.files = new Files(this);\n    this.folders = new Folders(this);\n    this.comments = new Comments(this);\n    this.collaborations = new Collaborations(this);\n    this.groups = new Groups(this);\n    this.sharedItems = new SharedItems(this);\n    this.metadata = new Metadata(this);\n    this.collections = new Collections(this);\n    this.events = new Events(this);\n    this.search = new Search(this);\n    this.tasks = new Tasks(this);\n    this.trash = new Trash(this);\n    this.enterprise = new Enterprise(this);\n    this.legalHoldPolicies = new LegalHoldPolicies(this);\n    this.weblinks = new WebLinks(this);\n    this.retentionPolicies = new RetentionPolicies(this);\n    this.devicePins = new DevicePins(this);\n    this.webhooks = new Webhooks(this);\n    this.recentItems = new RecentItems(this);\n    this.collaborationWhitelist = new CollaborationWhitelist(this);\n    this.termsOfService = new TermsOfService(this);\n    this.storagePolicies = new StoragePolicies(this);\n    // Array of requests when in batch mode, null otherwise\n    this._batch = null;\n}\n/**\n * Returns an object containing the given headers as well as other headers (like the authorization header and\n * custom headers) that should be included in a request.\n * @param {?Object} callerHeaders - headers that the caller wishes to include in the request. This method will not\n * override these headers with its own. Thus, if all the headers that this method was planning to add are already\n * specified here, this method will return an object with exactly the same headers.\n * @param {string} accessToken - the access token that will be used to make the request\n * @returns {Object} - a new object with the headers needed for the request\n * @private\n */ BoxClient.prototype._createHeadersForRequest = function(callerHeaders, accessToken) {\n    var headers = {};\n    // 'Authorization' - contains your valid access token for authorization\n    headers[HEADER_AUTHORIZATION] = buildAuthorizationHeader(accessToken);\n    // We copy our own custom headers (XFF, BoxApi, etc.) before copying over the caller-specified headers so that\n    // the caller-specified headers will take precedence.\n    Object.assign(headers, this._customHeaders, callerHeaders);\n    // Add analytics headers last so they cannot be overwritten\n    Object.assign(headers, {\n        \"X-Box-UA\": constructBoxUAHeader(this._analyticsClient)\n    });\n    return headers;\n};\n/**\n * Makes an API request to the Box API on behalf of the client. Before executing\n * the request, it first ensures the user has usable tokens. Will be called again\n * if the request returns a temporary error. Will propogate error if request returns\n * a permanent error, or if usable tokens are not available.\n *\n * @param {Object} params - Request lib params to configure the request\n * @param {APIRequest~Callback} [callback] - passed response data\n * @returns {Promise} Promise resolving to the response\n * @private\n */ BoxClient.prototype._makeRequest = function(params, callback) {\n    var promise;\n    if (this._batch) {\n        // eslint-disable-next-line promise/avoid-new\n        promise = new Promise((resolve, reject)=>{\n            this._batch.push({\n                params,\n                resolve,\n                reject\n            });\n        });\n    } else {\n        // Check that tokens are fresh, update if tokens are expired or soon-to-be expired\n        promise = this._session.getAccessToken(this._tokenOptions).then((accessToken)=>{\n            params.headers = this._createHeadersForRequest(params.headers, accessToken);\n            if (params.streaming) {\n                // streaming is specific to the SDK, so delete it from params before continuing\n                delete params.streaming;\n                var responseStream = this._requestManager.makeStreamingRequest(params);\n                // Listen to 'response' event, so we can cleanup the token store in case when the request is unauthorized\n                // due to expired access token\n                responseStream.on(\"response\", (response)=>{\n                    if (isUnauthorizedDueToExpiredAccessToken(response)) {\n                        var expiredTokensError = errors.buildAuthError(response);\n                        // Give the session a chance to handle the error (ex: a persistent session will clear the token store)\n                        if (this._session.handleExpiredTokensError) {\n                            this._session.handleExpiredTokensError(expiredTokensError);\n                        }\n                    }\n                });\n                return responseStream;\n            }\n            // Make the request to Box, and perform standard response handling\n            return this._requestManager.makeRequest(params);\n        });\n    }\n    return promise.then((response)=>{\n        if (!response.statusCode) {\n            // Response is not yet complete, and is just a stream that will return the response later\n            // Just return the stream, since it doesn't need further response handling\n            return response;\n        }\n        if (isUnauthorizedDueToExpiredAccessToken(response)) {\n            var expiredTokensError = errors.buildAuthError(response);\n            // Give the session a chance to handle the error (ex: a persistent session will clear the token store)\n            if (this._session.handleExpiredTokensError) {\n                return this._session.handleExpiredTokensError(expiredTokensError);\n            }\n            throw expiredTokensError;\n        }\n        return response;\n    }).asCallback(callback);\n};\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Enum of valid collaboration roles\n *\n * @readonly\n * @enum {CollaborationRole}\n */ BoxClient.prototype.collaborationRoles = {\n    EDITOR: \"editor\",\n    VIEWER: \"viewer\",\n    PREVIEWER: \"previewer\",\n    UPLOADER: \"uploader\",\n    PREVIEWER_UPLOADER: \"previewer uploader\",\n    VIEWER_UPLOADER: \"viewer uploader\",\n    CO_OWNER: \"co-owner\",\n    OWNER: \"owner\"\n};\n/**\n * Enum of Box item types\n *\n * @readonly\n * @enum {ItemType}\n */ BoxClient.prototype.itemTypes = {\n    FILE: \"file\",\n    FOLDER: \"folder\"\n};\n/**\n * Enum of valid values for setting different access levels. To be used when\n * creating and editting shared links, upload emails, etc.\n *\n * @readonly\n * @type {AccessLevel}\n */ BoxClient.prototype.accessLevels = {\n    OPEN: {\n        access: \"open\"\n    },\n    COLLABORATORS: {\n        access: \"collaborators\"\n    },\n    COMPANY: {\n        access: \"company\"\n    },\n    DEFAULT: {},\n    DISABLED: null\n};\n/** @const {string} */ BoxClient.prototype.CURRENT_USER_ID = Users.prototype.CURRENT_USER_ID;\n/**\n * Set a custom header. A custom header is applied to every request for the life of the client. To\n * remove a header, set it's value to null.\n *\n * @param {string} header The name of the custom header to set.\n * @param {*} value The value of the custom header. Set to null to remove the given header.\n * @returns {void}\n */ BoxClient.prototype.setCustomHeader = function(header, value) {\n    if (value) {\n        this._customHeaders[header] = value;\n    } else {\n        delete this._customHeaders[header];\n    }\n};\n/**\n * Sets the list of requesting IP addresses for the X-Forwarded-For header. Used to give the API\n * better information for uploads, rate-limiting, etc.\n *\n * @param {string[]} ips - Array of IP Addresses\n * @returns {void}\n */ BoxClient.prototype.setIPs = function(ips) {\n    var validIPs = ips.filter((ipString)=>isIP(ipString)).join(\", \");\n    this.setCustomHeader(HEADER_XFF, validIPs);\n    this._tokenOptions = {\n        ip: validIPs\n    };\n};\n/**\n * Sets the shared item context on the API Session. Overwrites any current context.\n *\n * @param {string} url The shared link url\n * @param {?string} password The shared link password, null if no password exists.\n * @returns {void}\n */ BoxClient.prototype.setSharedContext = function(url, password) {\n    var sharedContextAuthHeader = this.buildSharedItemAuthHeader(url, password);\n    this.setCustomHeader(HEADER_BOXAPI, sharedContextAuthHeader);\n};\n/**\n * Removes any current shared item context from API Session.\n *\n * @returns {void}\n */ BoxClient.prototype.revokeSharedContext = function() {\n    this.setCustomHeader(HEADER_BOXAPI, null);\n};\n/**\n * Set up the As-User context, which is used by enterprise admins to\n * impersonate their managed users and perform actions on their behalf.\n *\n * @param {string} userID - The ID of the user to impersonate\n * @returns {void}\n */ BoxClient.prototype.asUser = function(userID) {\n    this.setCustomHeader(HEADER_AS_USER, userID);\n};\n/**\n * Revoke the As-User context and return to making calls on behalf of the user\n * who owns the client's access token.\n *\n * @returns {void}\n */ BoxClient.prototype.asSelf = function() {\n    this.setCustomHeader(HEADER_AS_USER, null);\n};\n/**\n * Revokes the client's access tokens. The client will no longer be tied to a user\n * and will be unable to make calls to the API, rendering it effectively useless.\n *\n * @param {Function} [callback] Called after revoking, with an error if one existed\n * @returns {Promise} A promise resolving when the client's access token is revoked\n */ BoxClient.prototype.revokeTokens = function(callback) {\n    return this._session.revokeTokens(this._tokenOptions).asCallback(callback);\n};\n/**\n * Exchange the client access token for one with lower scope\n * @param {string|string[]} scopes The scope(s) requested for the new token\n * @param {string} [resource] The absolute URL of an API resource to scope the new token to\n * @param {Object} [options] - Optional parameters\n * @param {ActorParams} [options.actor] - Optional actor parameters for creating annotator tokens with Token Auth client\n * @param {SharedLinkParams} [options.sharedLink] - Optional shared link parameters for creating tokens using shared links\n * @param {Function} [callback] Called with the new token\n * @returns {Promise<TokenInfo>} A promise resolving to the exchanged token info\n */ BoxClient.prototype.exchangeToken = function(scopes, resource, options, callback) {\n    // Shuffle optional parameters\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var opts = Object.assign({\n        tokenRequestOptions: this._tokenOptions || null\n    }, options);\n    return this._session.exchangeToken(scopes, resource, opts).asCallback(callback);\n};\n/**\n * Makes GET request to Box API V2 endpoint\n *\n * @param {string} path - path to a certain API endpoint (ex: /file)\n * @param {?Object} params - object containing parameters for the request, such as query strings and headers\n * @param {APIRequest~Callback} callback - passed final API response or err if request failed\n * @returns {void}\n */ BoxClient.prototype.get = function(path, params, callback) {\n    var newParams = merge({}, params || {});\n    newParams.method = \"GET\";\n    newParams.url = getFullURL(this._baseURL, path);\n    return this._makeRequest(newParams, callback);\n};\n/**\n * Makes POST request to Box API V2 endpoint\n *\n * @param {string} path - path to a certain API endpoint (ex: /file)\n * @param {?Object} params - object containing parameters for the request, such as query strings and headers\n * @param {APIRequest~Callback} callback - passed final API response or err if request failed\n * @returns {void}\n */ BoxClient.prototype.post = function(path, params, callback) {\n    var newParams = merge({}, params || {});\n    newParams.method = \"POST\";\n    newParams.url = getFullURL(this._baseURL, path);\n    return this._makeRequest(newParams, callback);\n};\n/**\n * Makes PUT request to Box API V2 endpoint\n *\n * @param {string} path - path to a certain API endpoint (ex: /file)\n * @param {?Object} params - object containing parameters for the request, such as query strings and headers\n * @param {APIRequest~Callback} callback - passed final API response or err if request failed\n * @returns {void}\n */ BoxClient.prototype.put = function(path, params, callback) {\n    var newParams = merge({}, params || {});\n    newParams.method = \"PUT\";\n    newParams.url = getFullURL(this._baseURL, path);\n    return this._makeRequest(newParams, callback);\n};\n/**\n * Makes DELETE request to Box API V2 endpoint\n *\n * @param {string} path - path to a certain API endpoint (ex: /file)\n * @param {?Object} params - object containing parameters for the request, such as query strings and headers\n * @param {APIRequest~Callback} callback - passed final API response or err if request failed\n * @returns {void}\n */ BoxClient.prototype.del = function(path, params, callback) {\n    var newParams = merge({}, params || {});\n    newParams.method = \"DELETE\";\n    newParams.url = getFullURL(this._baseURL, path);\n    return this._makeRequest(newParams, callback);\n};\n/**\n * Makes an OPTIONS call to a Box API V2 endpoint\n *\n * @param {string} path - Path to an API endpoint (e.g. /files/content)\n * @param {?Object} params - An optional object containing request parameters\n * @param {APIRequest~Callback} callback - Called with API call results, or err if call failed\n * @returns {void}\n */ BoxClient.prototype.options = function(path, params, callback) {\n    var newParams = merge({}, params || {});\n    newParams.method = \"OPTIONS\";\n    newParams.url = getFullURL(this._baseURL, path);\n    return this._makeRequest(newParams, callback);\n};\n/**\n * Makes a POST call to a Box API V2 upload endpoint\n * @param {string} path - path to an upload API endpoint\n * @param {?Object} params - an optional object containing request parameters\n * @param {?Object} formData - multipart form data to include in the upload request {@see https://github.com/mikeal/request#multipartform-data-multipart-form-uploads}\n * @param {APIRequest~Callback} callback - called with API call results, or an error if the call failed\n * @returns {void}\n */ BoxClient.prototype.upload = function(path, params, formData, callback) {\n    var defaults = {\n        method: \"POST\"\n    };\n    var newParams = merge(defaults, params || {});\n    newParams.url = getFullURL(this._uploadBaseURL, path);\n    newParams.formData = formData;\n    newParams.timeout = this._uploadRequestTimeoutMS;\n    return this._makeRequest(newParams, callback);\n};\n/**\n * Puts the client into batch mode, which will queue calls instead of\n * immediately making the API request.\n *\n * DEPRECATED: Batch API is not supported and should not be used; make calls in parallel instead.\n *\n * @returns {BoxClient} Current client object\n */ BoxClient.prototype.batch = util.deprecate(function() {\n    /* eslint-disable no-invalid-this */ this._batch = [];\n    return this;\n/* eslint-enable no-invalid-this */ }, \"Batch API is not supported and should not be used; make calls in parallel instead.\");\n/**\n * Executes a batch of requests.\n *\n * DEPRECATED: Batch API is not supported and should not be used; make calls in parallel instead.\n *\n * @returns {Promise<Object>} Promise resolving to the collection of batch responses\n */ BoxClient.prototype.batchExec = util.deprecate(function(callback) {\n    /* eslint-disable no-invalid-this */ if (!this._batch) {\n        return Promise.reject(new Error(\"Must start a batch before executing\")).asCallback(callback);\n    }\n    var params = {\n        body: {\n            requests: this._batch.map((batchReq)=>formatRequestForBatch(batchReq.params))\n        }\n    };\n    var batch = this._batch;\n    this._batch = null;\n    return this.post(\"/batch\", params).then((res)=>{\n        var responses = res.body.responses;\n        responses.map((x)=>formatResponseForBatch(x)).forEach((response, index)=>{\n            batch[index].resolve(response);\n        });\n        return res.body;\n    }).catch((err)=>{\n        batch.forEach((req)=>req.reject(err));\n        throw err;\n    }).asCallback(callback);\n/* eslint-enable no-invalid-this */ }, \"Batch API is not supported and should not be used; make calls in parallel instead.\");\n/**\n * Build the 'BoxApi' Header used for authenticating access to a shared item\n *\n * @param {string} url The shared link url\n * @param {string} [password] The shared link password\n * @returns {string} A properly formatted 'BoxApi' header\n */ BoxClient.prototype.buildSharedItemAuthHeader = function(url, password) {\n    var encodedURL = encodeURIComponent(url), encodedPassword = encodeURIComponent(password);\n    if (password) {\n        return util.format(\"shared_link=%s&shared_link_password=%s\", encodedURL, encodedPassword);\n    }\n    return util.format(\"shared_link=%s\", encodedURL);\n};\n/**\n * Return a callback that properly handles a successful response code by passing the response\n * body to the original callback. Any request error or unsuccessful response codes are propagated\n * back to the callback as errors. This is the standard behavior of most endpoints.\n *\n * @param {Function} callback The original callback given by the consumer\n * @returns {?APIRequest~Callback} A new callback that processes the response before passing it to the callback.\n */ BoxClient.prototype.defaultResponseHandler = function(callback) {\n    var self = this;\n    if (!callback) {\n        return null;\n    }\n    return function(err, response) {\n        // Error with Request\n        if (err) {\n            callback(err);\n            return;\n        }\n        // Successful Response\n        if (response.statusCode >= HTTP_STATUS_CODE_SUCCESS_BLOCK_RANGE[0] && response.statusCode <= HTTP_STATUS_CODE_SUCCESS_BLOCK_RANGE[1]) {\n            if (self._useIterators && PagingIterator.isIterable(response)) {\n                callback(null, new PagingIterator(response, self));\n                return;\n            }\n            callback(null, response.body);\n            return;\n        }\n        // Unexpected Response\n        callback(errors.buildUnexpectedResponseError(response));\n    };\n};\n/**\n * Wrap a client method with the default handler for both callback and promise styles\n * @param {Function} method The client method (e.g. client.get)\n * @returns {Function}  The wrapped method\n */ BoxClient.prototype.wrapWithDefaultHandler = function(method) {\n    var self = this;\n    return function wrappedClientMethod() {\n        // Check if the last argument is a callback\n        var lastArg = arguments[arguments.length - 1], callback;\n        if (typeof lastArg === \"function\") {\n            callback = self.defaultResponseHandler(lastArg);\n            arguments[arguments.length - 1] = callback;\n        }\n        var ret = method.apply(self, arguments);\n        if (ret instanceof Promise) {\n            ret = ret.then((response)=>{\n                if (response.statusCode >= HTTP_STATUS_CODE_SUCCESS_BLOCK_RANGE[0] && response.statusCode <= HTTP_STATUS_CODE_SUCCESS_BLOCK_RANGE[1]) {\n                    if (self._useIterators && PagingIterator.isIterable(response)) {\n                        return new PagingIterator(response, self);\n                    }\n                    return response.body;\n                }\n                throw errors.buildUnexpectedResponseError(response);\n            });\n        }\n        if (callback) {\n            // If the callback will handle any errors, don't worry about the promise\n            ret.suppressUnhandledRejections();\n        }\n        return ret;\n    };\n};\n/**\n * Add a SDK plugin. Warning: This will modify the box-client interface and can override existing properties.\n * @param {string} name Plugin name. Will be accessible via client.<plugin-name>\n * @param {Function} plugin The SDK plugin to add\n * @param {Object} [options] Plugin-specific options\n * @returns {void}\n * @throws Will throw an error if plugin name matches an existing method on box-client\n */ BoxClient.prototype.plug = function(name, plugin, options) {\n    options = options || {};\n    if (name in this && typeof this[name] === \"function\") {\n        throw new Error(\"You cannot define a plugin that overrides an existing method on the client\");\n    }\n    // Create plugin and export plugin onto client.\n    this[name] = plugin(this, options);\n};\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * @module box-node-sdk/lib/box-client\n * @see {@Link BoxClient}\n */ module.exports = BoxClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9ib3gtY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFHQSxpRkFBaUY7QUFDakYseUJBQXlCO0FBQ3pCLGlGQUFpRjtBQUVqRjs7O0NBR0MsR0FFRDs7O0FBR0EsR0FFQTs7O0NBR0MsR0FFRCxpRkFBaUY7QUFDakYsZUFBZTtBQUNmLGlGQUFpRjtBQUNqRixJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQyxxQkFDbEJDLEtBQUtELG1CQUFPQSxDQUFDLG1DQUNiRSxTQUFTRixtQkFBT0EsQ0FBQyw4RUFDakJHLGtCQUFrQkgsbUJBQU9BLENBQUMscUVBQzFCSSxPQUFPSiw0Q0FBbUIsRUFDMUJLLFFBQVFMLG1CQUFPQSxDQUFDLHFFQUNoQk0saUJBQWlCTixtQkFBT0EsQ0FBQyxnR0FDekJPLFVBQVVQLG1CQUFPQSxDQUFDLHlFQUNsQlEsTUFBTVIsbUJBQU9BLENBQUM7QUFFZix3QkFBd0I7QUFDeEIsSUFBSVMsUUFBUVQsbUJBQU9BLENBQUMsb0ZBQ25CVSxRQUFRVixtQkFBT0EsQ0FBQyxvRkFDaEJXLFVBQVVYLG1CQUFPQSxDQUFDLHdGQUNsQlksaUJBQWlCWixtQkFBT0EsQ0FBQyxzR0FDekJhLFNBQVNiLG1CQUFPQSxDQUFDLHNGQUNqQmMsV0FBV2QsbUJBQU9BLENBQUMsMEZBQ25CZSxjQUFjZixtQkFBT0EsQ0FBQyxrR0FDdEJnQixXQUFXaEIsbUJBQU9BLENBQUMsMEZBQ25CaUIsY0FBY2pCLG1CQUFPQSxDQUFDLGdHQUN0QmtCLFNBQVNsQixtQkFBT0EsQ0FBQyxzRkFDakJtQixTQUFTbkIsbUJBQU9BLENBQUMsc0ZBQ2pCb0IsUUFBUXBCLG1CQUFPQSxDQUFDLG9GQUNoQnFCLFFBQVFyQixtQkFBT0EsQ0FBQyxvRkFDaEJzQixhQUFhdEIsbUJBQU9BLENBQUMsOEZBQ3JCdUIsb0JBQW9CdkIsbUJBQU9BLENBQUMsZ0hBQzVCd0IsV0FBV3hCLG1CQUFPQSxDQUFD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TzlLLFNBQVNHLElBQUk7Z0JBQ3JCO2dCQUVBLE1BQU0xQyxPQUFPdU4sNEJBQTRCLENBQUNoTDtZQUMzQztRQUNEO1FBRUEsSUFBSXFGLFVBQVU7WUFDYix3RUFBd0U7WUFDeEVnRyxJQUFJRSwyQkFBMkI7UUFDaEM7UUFFQSxPQUFPRjtJQUNSO0FBQ0Q7QUFFQTs7Ozs7OztDQU9DLEdBQ0RoSixVQUFVMkMsU0FBUyxDQUFDd0csSUFBSSxHQUFHLFNBQVN4SixJQUFJLEVBQUV5SixNQUFNLEVBQUUxQyxPQUFPO0lBQ3hEQSxVQUFVQSxXQUFXLENBQUM7SUFFdEIsSUFBSSxRQUFTLElBQUksSUFBTSxPQUFPLElBQUksQ0FBQy9HLEtBQUssS0FBSyxZQUFhO1FBQ3pELE1BQU0sSUFBSStILE1BQU07SUFDakI7SUFFQSwrQ0FBK0M7SUFDL0MsSUFBSSxDQUFDL0gsS0FBSyxHQUFHeUosT0FBTyxJQUFJLEVBQUUxQztBQUMzQjtBQUdBLGlGQUFpRjtBQUNqRixTQUFTO0FBQ1QsaUZBQWlGO0FBRWpGOzs7Q0FHQyxHQUNEMkMsT0FBT0MsT0FBTyxHQUFHdEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL2JveC1jbGllbnQuanM/ZDA1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQm94IEFQSSBDbGllbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlZGVmcyBhbmQgQ2FsbGJhY2tzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIGNvbGxhYm9yYXRpb24gcm9sZSBjb25zdGFudFxuICogQHR5cGVkZWYge3N0cmluZ30gQ29sbGFib3JhdGlvblJvbGVcbiAqL1xuXG4vKipcbiogQSBCb3ggZmlsZSBvciBmb2xkZXIgdHlwZSBjb25zdGFudFxuKiBAdHlwZWRlZiB7c3RyaW5nfSBJdGVtVHlwZVxuKi9cblxuLyoqXG4gKiBBbiBhY2Nlc3MgbGV2ZWwgY29uc3RhbnQuIFVzZWQgZm9yIHNldHRpbmcgYW5kIHVwZGF0aW5nIHNoYXJlZCBsaW5rcywgZm9sZGVyIHVwbG9hZCwgZXRjLlxuICogQHR5cGVkZWYgez9PYmplY3R9IEFjY2Vzc0xldmVsXG4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKSxcblx0ZXJyb3JzID0gcmVxdWlyZSgnLi91dGlsL2Vycm9ycycpLFxuXHRodHRwU3RhdHVzQ29kZXMgPSByZXF1aXJlKCdodHRwLXN0YXR1cycpLFxuXHRpc0lQID0gcmVxdWlyZSgnbmV0JykuaXNJUCxcblx0bWVyZ2UgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJyksXG5cdFBhZ2luZ0l0ZXJhdG9yID0gcmVxdWlyZSgnLi91dGlsL3BhZ2luZy1pdGVyYXRvcicpLFxuXHRQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKSxcblx0cGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbi8vIEFQSSBSZXNvdXJjZSBNYW5hZ2Vyc1xudmFyIFVzZXJzID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy91c2VycycpLFxuXHRGaWxlcyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvZmlsZXMnKSxcblx0Rm9sZGVycyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvZm9sZGVycycpLFxuXHRDb2xsYWJvcmF0aW9ucyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvY29sbGFib3JhdGlvbnMnKSxcblx0R3JvdXBzID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9ncm91cHMnKSxcblx0Q29tbWVudHMgPSByZXF1aXJlKCcuL21hbmFnZXJzL2NvbW1lbnRzJyksXG5cdFNoYXJlZEl0ZW1zID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9zaGFyZWQtaXRlbXMnKSxcblx0TWV0YWRhdGEgPSByZXF1aXJlKCcuL21hbmFnZXJzL21ldGFkYXRhJyksXG5cdENvbGxlY3Rpb25zID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy9jb2xsZWN0aW9ucycpLFxuXHRFdmVudHMgPSByZXF1aXJlKCcuL21hbmFnZXJzL2V2ZW50cycpLFxuXHRTZWFyY2ggPSByZXF1aXJlKCcuL21hbmFnZXJzL3NlYXJjaCcpLFxuXHRUYXNrcyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvdGFza3MnKSxcblx0VHJhc2ggPSByZXF1aXJlKCcuL21hbmFnZXJzL3RyYXNoJyksXG5cdEVudGVycHJpc2UgPSByZXF1aXJlKCcuL21hbmFnZXJzL2VudGVycHJpc2UnKSxcblx0TGVnYWxIb2xkUG9saWNpZXMgPSByZXF1aXJlKCcuL21hbmFnZXJzL2xlZ2FsLWhvbGQtcG9saWNpZXMnKSxcblx0V2ViTGlua3MgPSByZXF1aXJlKCcuL21hbmFnZXJzL3dlYi1saW5rcycpLFxuXHRSZXRlbnRpb25Qb2xpY2llcyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvcmV0ZW50aW9uLXBvbGljaWVzJyksXG5cdERldmljZVBpbnMgPSByZXF1aXJlKCcuL21hbmFnZXJzL2RldmljZS1waW5zJyksXG5cdFdlYmhvb2tzID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy93ZWJob29rcycpLFxuXHRSZWNlbnRJdGVtcyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvcmVjZW50LWl0ZW1zJyksXG5cdENvbGxhYm9yYXRpb25XaGl0ZWxpc3QgPSByZXF1aXJlKCcuL21hbmFnZXJzL2NvbGxhYm9yYXRpb24td2hpdGVsaXN0JyksXG5cdFRlcm1zT2ZTZXJ2aWNlID0gcmVxdWlyZSgnLi9tYW5hZ2Vycy90ZXJtcy1vZi1zZXJ2aWNlJyksXG5cdFN0b3JhZ2VQb2xpY2llcyA9IHJlcXVpcmUoJy4vbWFuYWdlcnMvc3RvcmFnZS1wb2xpY2llcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8vIFRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBsYWJlbFxudmFyIEhFQURFUl9BVVRIT1JJWkFUSU9OID0gJ0F1dGhvcml6YXRpb24nLFxuXHQvLyBQcmVmaXggb3VyIHRva2VuIHdpdGggdGhpcyBzdHJpbmcgaW4gdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyXG5cdEhFQURFUl9BVVRIT1JJWkFUSU9OX1BSRUZJWCA9ICdCZWFyZXIgJyxcblx0Ly8gVGhlICdCb3hBcGknIGhlYWRlciBsYWJlbFxuXHRIRUFERVJfQk9YQVBJID0gJ0JveEFwaScsXG5cdC8vIFRoZSBYRkYgaGVhZGVyIGxhYmVsIC0gVXNlZCB0byBnaXZlIHRoZSBBUEkgYmV0dGVyIGluZm9ybWF0aW9uIGZvciB1cGxvYWRzLCByYXRlLWxpbWl0aW5nLCBldGMuXG5cdEhFQURFUl9YRkYgPSAnWC1Gb3J3YXJkZWQtRm9yJyxcblx0Ly8gQXMtVXNlciBoZWFkZXJcblx0SEVBREVSX0FTX1VTRVIgPSAnQXMtVXNlcicsXG5cdC8vIFJhbmdlIG9mIFNVQ0NFU1MgaHR0cCBzdGF0dXMgY29kZXNcblx0SFRUUF9TVEFUVVNfQ09ERV9TVUNDRVNTX0JMT0NLX1JBTkdFID0gW1xuXHRcdDIwMCxcblx0XHQyOTlcblx0XTtcblxuLyoqXG4gKiBCdWlsZCB0aGUgJ0F1dGhvcml6YXRpb24nIEhlYWRlciBmb3IgdGhlIEFQSVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBbiBPQXV0aCBBY2Nlc3MgVG9rZW5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgcHJvcGVybHkgZm9ybWF0dGVkICdBdXRob3JpemF0aW9uJyBoZWFkZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQXV0aG9yaXphdGlvbkhlYWRlcihhY2Nlc3NUb2tlbikge1xuXHRyZXR1cm4gSEVBREVSX0FVVEhPUklaQVRJT05fUFJFRklYICsgYWNjZXNzVG9rZW47XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmZiB0aGUgcmVzcG9uc2UgaXMgYSA0MDEgVU5BVVRIT1JJWkVEIHRoYXQgaXMgY2F1c2VkIGJ5IGFuIGV4cGlyZWQgYWNjZXNzIHRva2VuLlxuICogQHBhcmFtIHtBUElSZXF1ZXN0flJlc3BvbnNlT2JqZWN0fSByZXNwb25zZSAtIFRoZSByZXNwb25zZSByZXR1cm5lZCBieSBhbiBBUElSZXF1ZXN0TWFuYWdlciByZXF1ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlIGlmZiB0aGUgcmVzcG9uc2UgaXMgYSA0MDEgVU5BVVRIT1JJWkVEIGNhdXNlZCBieSBhbiBleHBpcmVkIGFjY2VzcyB0b2tlblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNVbmF1dGhvcml6ZWREdWVUb0V4cGlyZWRBY2Nlc3NUb2tlbihyZXNwb25zZSkge1xuXHQvLyBUaGVyZSBhcmUgdGhyZWUgY2FzZXMgdG8gY29uc2lkZXI6XG5cdC8vIDEpIFRoZSByZXNwb25zZSBib2R5IGlzIGEgQnVmZmVyLiBUaGlzIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IHdhcyBtYWxmb3JtZWQgKGkuZS4gbWFsZm9ybWVkIHVybCkgc28gcmV0dXJuIGZhbHNlLlxuXHQvLyAyKSBUaGUgc3RhdHVzIGNvZGUgaXMgVU5BVVRIT1JJWkVEIGFuZCB0aGUgcmVzcG9uc2UgYm9keSBpcyBhbiBlbXB0eSBvYmplY3Qgb3IgbnVsbC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgYWNjZXNzIHRva2VucyBhcmUgZXhwaXJlZCwgc28gcmV0dXJuIHRydWUuXG5cdC8vIDMpIFRoZSBzdGF0dXMgY29kZSBpcyBVTkFVVEhPUklaRUQgYW5kIHRoZSByZXNwb25zZSBib2R5IGlzIGEgbm9uLWVtcHR5IG9iamVjdC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgNDAxIHdhcyByZXR1cm5lZCBmb3Igc29tZSByZWFzb24gb3RoZXJcblx0Ly8gICAgdGhhbiBleHBpcmVkIHRva2Vucywgc28gcmV0dXJuIGZhbHNlLlxuXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIocmVzcG9uc2UuYm9keSkpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgaXNSZXNwb25zZVN0YXR1c0NvZGVVbmF1dGhvcml6ZWQgPSByZXNwb25zZS5zdGF0dXNDb2RlID09PSBodHRwU3RhdHVzQ29kZXMuVU5BVVRIT1JJWkVELFxuXHRcdGlzUmVzcG9uc2VCb2R5RW1wdHkgPSAhcmVzcG9uc2UuYm9keSB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyZXNwb25zZS5ib2R5KS5sZW5ndGggPT09IDA7XG5cdHJldHVybiBpc1Jlc3BvbnNlU3RhdHVzQ29kZVVuYXV0aG9yaXplZCAmJiBpc1Jlc3BvbnNlQm9keUVtcHR5O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdWxsIFVSTC4gSWYgdGhlIHVybCBhcmd1bWVudCBiZWdpbnMgd2l0aCBodHRwOi8vIG9yIGh0dHBzOi8vLCB0aGVuIHVybCBpcyBzaW1wbHkgcmV0dXJuZWQuXG4gKiBPdGhlcndpc2UsIHRoZSBkZWZhdWx0QmFzZVBhdGggaXMgcHJlcGVuZGVkIHRvIHVybCBhbmQgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRCYXNlUGF0aCBUaGUgZGVmYXVsdCByb290IFVSTCB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIGlmIGB1cmxgIGlzIGEgcGFydGlhbCB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgQSBmdWxsIG9yIHBhcnRpYWwgVVJMIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgZmluYWwgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZmluYWwgVVJMXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRGdWxsVVJMKGRlZmF1bHRCYXNlUGF0aCwgdXJsKSB7XG5cdGlmICgvXmh0dHBzPzpcXC9cXC8vLnRlc3QodXJsKSkge1xuXHRcdHJldHVybiB1cmw7XG5cdH1cblx0cmV0dXJuIGRlZmF1bHRCYXNlUGF0aCArIHVybDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB2YWxpZCByZXF1ZXN0IG9iamVjdCBmb3IgdGhlIEJhdGNoIEFQSSBmcm9tIGEgc3RhbmRhcmQgcmVxdWVzdFxuICogcGFyYW1zIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGUgcmVxdWVzdCBwYXJhbXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBiYXRjaCBBUEkgcmVxdWVzdCBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFJlcXVlc3RGb3JCYXRjaChwYXJhbXMpIHtcblxuXHR2YXIgcmVsYXRpdmVQYXRoID0gcGFyYW1zLnVybC5yZXBsYWNlKC9eaHR0cC4qP1xcL1xcZFxcLlxcZFxcLy8sICcvJyk7XG5cblx0cmV0dXJuIHtcblx0XHRtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG5cdFx0cmVsYXRpdmVfdXJsOiByZWxhdGl2ZVBhdGggKyAocGFyYW1zLnFzID8gYD8ke3FzLnN0cmluZ2lmeShwYXJhbXMucXMpfWAgOiAnJyksXG5cdFx0Ym9keTogcGFyYW1zLmJvZHksXG5cdFx0aGVhZGVyczogcGFyYW1zLmhlYWRlcnNcblx0fTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBCYXRjaCBBUEkgcmVzcG9uc2Ugb2JqZWN0IGludG8gYSBzdGFuZGFyZCByZXF1ZXN0IHJlc3BvbnNlXG4gKiBmb3IgdXNlIGluIHJlc3BvbnNlIGhhbmRsaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgVGhlIGJhdGNoIEFQSSByZXNwb25zZSBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzdGFuZGFyZCByZXNwb25zZSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFJlc3BvbnNlRm9yQmF0Y2gocmVzcG9uc2UpIHtcblxuXHRyZXR1cm4ge1xuXHRcdHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcblx0XHRoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuXHRcdGJvZHk6IHJlc3BvbnNlLnJlc3BvbnNlXG5cdH07XG59XG5cbi8qKlxuICogQ29uc3RydWN0IHRoZSBYLUJveC1VQSBoZWFkZXIgdG8gc2VuZCBhbmFseXRpY3MgaWRlbnRpZmllcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2xpZW50XSBBbmFseXRpY3MgY2xpZW50IGluZm9ybWF0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaGVhZGVyIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdEJveFVBSGVhZGVyKGNsaWVudCkge1xuXG5cdHZhciBhbmFseXRpY3NJZGVudGlmaWVycyA9IHtcblx0XHRhZ2VudDogYGJveC1ub2RlLXNkay8ke3BrZy52ZXJzaW9ufWAsXG5cdFx0ZW52OiBgTm9kZS8ke3Byb2Nlc3MudmVyc2lvbi5yZXBsYWNlKCd2JywgJycpfWBcblx0fTtcblxuXHRpZiAoY2xpZW50KSB7XG5cdFx0YW5hbHl0aWNzSWRlbnRpZmllcnMuY2xpZW50ID0gYCR7Y2xpZW50Lm5hbWV9LyR7Y2xpZW50LnZlcnNpb259YDtcblx0fVxuXG5cdHJldHVybiBPYmplY3Qua2V5cyhhbmFseXRpY3NJZGVudGlmaWVycykubWFwKGsgPT4gYCR7a309JHthbmFseXRpY3NJZGVudGlmaWVyc1trXX1gKVxuXHRcdC5qb2luKCc7ICcpO1xufVxuXG4vKipcbiAqIFRoZSBCb3hDbGllbnQgY2FuIG1ha2UgQVBJIGNhbGxzIG9uIGJlaGFsZiBvZiBhIHZhbGlkIEFQSSBTZXNzaW9uLiBJdCBpcyByZXNwb25zaWJsZVxuICogZm9yIGZvcm1hdHRpbmcgdGhlIHJlcXVlc3RzIGFuZCBoYW5kbGluZyB0aGUgcmVzcG9uc2UuIEl0cyBnb2FsIGlzIHRvIGRlbGl2ZXJcbiAqIHNlbnNpYmxlIHJlc3VsdHMgdG8gdGhlIHVzZXIuXG4gKlxuICogQHBhcmFtIHtBUElTZXNzaW9ufSBhcGlTZXNzaW9uIEFuIGluaXRpYWxpemVkIEFQSSBTZXNzaW9uLCB1c2VkIHRvIGdldC9yZXZva2UgdG9rZW5zIGFuZCBoYW5kbGVcbiAqIHVuYXV0aG9yaXplZCByZXNwb25zZXMgZnJvbSB0aGUgQVBJLlxuICogQHBhcmFtIHtDb25maWd9IGNvbmZpZyBUaGUgU0RLIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogQHBhcmFtIHtBUElSZXF1ZXN0TWFuYWdlcn0gcmVxdWVzdE1hbmFnZXIgVGhlIEFQSSBSZXF1ZXN0IE1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCb3hDbGllbnQoYXBpU2Vzc2lvbiwgY29uZmlnLCByZXF1ZXN0TWFuYWdlcikge1xuXHQvLyB0aGUgQVBJIFNlc3Npb24gdXNlZCBieSB0aGUgY2xpZW50IGZvciBhdXRoZW50aWNhdGlvblxuXHR0aGlzLl9zZXNzaW9uID0gYXBpU2Vzc2lvbjtcblxuXHQvLyBBdHRhY2ggYSByZXF1ZXN0IG1hbmFnZXIgaW5zdGFuY2UgZm9yIG1ha2luZyByZXF1ZXN0c1xuXHR0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuXG5cdC8vIEFuIG9iamVjdCBvZiBjdXN0b20gaGVhZGVycyB0byBhcHBseSB0byBldmVyeSByZXF1ZXN0LiBNb2RpZmllZCB2aWEgQm94Q2xpZW50LnNldEN1c3RvbUhlYWRlcigpLlxuXHR0aGlzLl9jdXN0b21IZWFkZXJzID0ge307XG5cdC8vIEF0dGFjaCB0aGUgY29uZmlndXJlZCBwcm9wZXJ0aWVzXG5cdHRoaXMuX2Jhc2VVUkwgPSB1dGlsLmZvcm1hdCgnJXMvJXMnLCBjb25maWcuYXBpUm9vdFVSTCwgY29uZmlnLmFwaVZlcnNpb24pO1xuXHR0aGlzLl91cGxvYWRCYXNlVVJMID0gdXRpbC5mb3JtYXQoJyVzLyVzJywgY29uZmlnLnVwbG9hZEFQSVJvb3RVUkwsIGNvbmZpZy5hcGlWZXJzaW9uKTtcblx0dGhpcy5fdXBsb2FkUmVxdWVzdFRpbWVvdXRNUyA9IGNvbmZpZy51cGxvYWRSZXF1ZXN0VGltZW91dE1TO1xuXHR0aGlzLl91c2VJdGVyYXRvcnMgPSBjb25maWcuaXRlcmF0b3JzO1xuXHR0aGlzLl9hbmFseXRpY3NDbGllbnQgPSBjb25maWcuYW5hbHl0aWNzQ2xpZW50O1xuXG5cdC8vIEF0dGFjaCBBUEkgUmVzb3VyY2UgTWFuYWdlcnNcblx0dGhpcy51c2VycyA9IG5ldyBVc2Vycyh0aGlzKTtcblx0dGhpcy5maWxlcyA9IG5ldyBGaWxlcyh0aGlzKTtcblx0dGhpcy5mb2xkZXJzID0gbmV3IEZvbGRlcnModGhpcyk7XG5cdHRoaXMuY29tbWVudHMgPSBuZXcgQ29tbWVudHModGhpcyk7XG5cdHRoaXMuY29sbGFib3JhdGlvbnMgPSBuZXcgQ29sbGFib3JhdGlvbnModGhpcyk7XG5cdHRoaXMuZ3JvdXBzID0gbmV3IEdyb3Vwcyh0aGlzKTtcblx0dGhpcy5zaGFyZWRJdGVtcyA9IG5ldyBTaGFyZWRJdGVtcyh0aGlzKTtcblx0dGhpcy5tZXRhZGF0YSA9IG5ldyBNZXRhZGF0YSh0aGlzKTtcblx0dGhpcy5jb2xsZWN0aW9ucyA9IG5ldyBDb2xsZWN0aW9ucyh0aGlzKTtcblx0dGhpcy5ldmVudHMgPSBuZXcgRXZlbnRzKHRoaXMpO1xuXHR0aGlzLnNlYXJjaCA9IG5ldyBTZWFyY2godGhpcyk7XG5cdHRoaXMudGFza3MgPSBuZXcgVGFza3ModGhpcyk7XG5cdHRoaXMudHJhc2ggPSBuZXcgVHJhc2godGhpcyk7XG5cdHRoaXMuZW50ZXJwcmlzZSA9IG5ldyBFbnRlcnByaXNlKHRoaXMpO1xuXHR0aGlzLmxlZ2FsSG9sZFBvbGljaWVzID0gbmV3IExlZ2FsSG9sZFBvbGljaWVzKHRoaXMpO1xuXHR0aGlzLndlYmxpbmtzID0gbmV3IFdlYkxpbmtzKHRoaXMpO1xuXHR0aGlzLnJldGVudGlvblBvbGljaWVzID0gbmV3IFJldGVudGlvblBvbGljaWVzKHRoaXMpO1xuXHR0aGlzLmRldmljZVBpbnMgPSBuZXcgRGV2aWNlUGlucyh0aGlzKTtcblx0dGhpcy53ZWJob29rcyA9IG5ldyBXZWJob29rcyh0aGlzKTtcblx0dGhpcy5yZWNlbnRJdGVtcyA9IG5ldyBSZWNlbnRJdGVtcyh0aGlzKTtcblx0dGhpcy5jb2xsYWJvcmF0aW9uV2hpdGVsaXN0ID0gbmV3IENvbGxhYm9yYXRpb25XaGl0ZWxpc3QodGhpcyk7XG5cdHRoaXMudGVybXNPZlNlcnZpY2UgPSBuZXcgVGVybXNPZlNlcnZpY2UodGhpcyk7XG5cdHRoaXMuc3RvcmFnZVBvbGljaWVzID0gbmV3IFN0b3JhZ2VQb2xpY2llcyh0aGlzKTtcblxuXHQvLyBBcnJheSBvZiByZXF1ZXN0cyB3aGVuIGluIGJhdGNoIG1vZGUsIG51bGwgb3RoZXJ3aXNlXG5cdHRoaXMuX2JhdGNoID0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBnaXZlbiBoZWFkZXJzIGFzIHdlbGwgYXMgb3RoZXIgaGVhZGVycyAobGlrZSB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXIgYW5kXG4gKiBjdXN0b20gaGVhZGVycykgdGhhdCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gYSByZXF1ZXN0LlxuICogQHBhcmFtIHs/T2JqZWN0fSBjYWxsZXJIZWFkZXJzIC0gaGVhZGVycyB0aGF0IHRoZSBjYWxsZXIgd2lzaGVzIHRvIGluY2x1ZGUgaW4gdGhlIHJlcXVlc3QuIFRoaXMgbWV0aG9kIHdpbGwgbm90XG4gKiBvdmVycmlkZSB0aGVzZSBoZWFkZXJzIHdpdGggaXRzIG93bi4gVGh1cywgaWYgYWxsIHRoZSBoZWFkZXJzIHRoYXQgdGhpcyBtZXRob2Qgd2FzIHBsYW5uaW5nIHRvIGFkZCBhcmUgYWxyZWFkeVxuICogc3BlY2lmaWVkIGhlcmUsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGV4YWN0bHkgdGhlIHNhbWUgaGVhZGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiAtIHRoZSBhY2Nlc3MgdG9rZW4gdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge09iamVjdH0gLSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgaGVhZGVycyBuZWVkZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLl9jcmVhdGVIZWFkZXJzRm9yUmVxdWVzdCA9IGZ1bmN0aW9uKGNhbGxlckhlYWRlcnMsIGFjY2Vzc1Rva2VuKSB7XG5cdHZhciBoZWFkZXJzID0ge307XG5cblx0Ly8gJ0F1dGhvcml6YXRpb24nIC0gY29udGFpbnMgeW91ciB2YWxpZCBhY2Nlc3MgdG9rZW4gZm9yIGF1dGhvcml6YXRpb25cblx0aGVhZGVyc1tIRUFERVJfQVVUSE9SSVpBVElPTl0gPSBidWlsZEF1dGhvcml6YXRpb25IZWFkZXIoYWNjZXNzVG9rZW4pO1xuXG5cdC8vIFdlIGNvcHkgb3VyIG93biBjdXN0b20gaGVhZGVycyAoWEZGLCBCb3hBcGksIGV0Yy4pIGJlZm9yZSBjb3B5aW5nIG92ZXIgdGhlIGNhbGxlci1zcGVjaWZpZWQgaGVhZGVycyBzbyB0aGF0XG5cdC8vIHRoZSBjYWxsZXItc3BlY2lmaWVkIGhlYWRlcnMgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG5cdE9iamVjdC5hc3NpZ24oaGVhZGVycywgdGhpcy5fY3VzdG9tSGVhZGVycywgY2FsbGVySGVhZGVycyk7XG5cblx0Ly8gQWRkIGFuYWx5dGljcyBoZWFkZXJzIGxhc3Qgc28gdGhleSBjYW5ub3QgYmUgb3ZlcndyaXR0ZW5cblx0T2JqZWN0LmFzc2lnbihoZWFkZXJzLCB7ICdYLUJveC1VQSc6IGNvbnN0cnVjdEJveFVBSGVhZGVyKHRoaXMuX2FuYWx5dGljc0NsaWVudCkgfSk7XG5cblx0cmV0dXJuIGhlYWRlcnM7XG59O1xuXG4vKipcbiAqIE1ha2VzIGFuIEFQSSByZXF1ZXN0IHRvIHRoZSBCb3ggQVBJIG9uIGJlaGFsZiBvZiB0aGUgY2xpZW50LiBCZWZvcmUgZXhlY3V0aW5nXG4gKiB0aGUgcmVxdWVzdCwgaXQgZmlyc3QgZW5zdXJlcyB0aGUgdXNlciBoYXMgdXNhYmxlIHRva2Vucy4gV2lsbCBiZSBjYWxsZWQgYWdhaW5cbiAqIGlmIHRoZSByZXF1ZXN0IHJldHVybnMgYSB0ZW1wb3JhcnkgZXJyb3IuIFdpbGwgcHJvcG9nYXRlIGVycm9yIGlmIHJlcXVlc3QgcmV0dXJuc1xuICogYSBwZXJtYW5lbnQgZXJyb3IsIG9yIGlmIHVzYWJsZSB0b2tlbnMgYXJlIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFJlcXVlc3QgbGliIHBhcmFtcyB0byBjb25maWd1cmUgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7QVBJUmVxdWVzdH5DYWxsYmFja30gW2NhbGxiYWNrXSAtIHBhc3NlZCByZXNwb25zZSBkYXRhXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3BvbnNlXG4gKiBAcHJpdmF0ZVxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLl9tYWtlUmVxdWVzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblxuXHR2YXIgcHJvbWlzZTtcblxuXHRpZiAodGhpcy5fYmF0Y2gpIHtcblxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcm9taXNlL2F2b2lkLW5ld1xuXHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHR0aGlzLl9iYXRjaC5wdXNoKHsgcGFyYW1zLCByZXNvbHZlLCByZWplY3QgfSk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBDaGVjayB0aGF0IHRva2VucyBhcmUgZnJlc2gsIHVwZGF0ZSBpZiB0b2tlbnMgYXJlIGV4cGlyZWQgb3Igc29vbi10by1iZSBleHBpcmVkXG5cdFx0cHJvbWlzZSA9IHRoaXMuX3Nlc3Npb24uZ2V0QWNjZXNzVG9rZW4odGhpcy5fdG9rZW5PcHRpb25zKVxuXHRcdFx0LnRoZW4oYWNjZXNzVG9rZW4gPT4ge1xuXG5cdFx0XHRcdHBhcmFtcy5oZWFkZXJzID0gdGhpcy5fY3JlYXRlSGVhZGVyc0ZvclJlcXVlc3QocGFyYW1zLmhlYWRlcnMsIGFjY2Vzc1Rva2VuKTtcblxuXHRcdFx0XHRpZiAocGFyYW1zLnN0cmVhbWluZykge1xuXHRcdFx0XHRcdC8vIHN0cmVhbWluZyBpcyBzcGVjaWZpYyB0byB0aGUgU0RLLCBzbyBkZWxldGUgaXQgZnJvbSBwYXJhbXMgYmVmb3JlIGNvbnRpbnVpbmdcblx0XHRcdFx0XHRkZWxldGUgcGFyYW1zLnN0cmVhbWluZztcblx0XHRcdFx0XHR2YXIgcmVzcG9uc2VTdHJlYW0gPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci5tYWtlU3RyZWFtaW5nUmVxdWVzdChwYXJhbXMpO1xuXHRcdFx0XHRcdC8vIExpc3RlbiB0byAncmVzcG9uc2UnIGV2ZW50LCBzbyB3ZSBjYW4gY2xlYW51cCB0aGUgdG9rZW4gc3RvcmUgaW4gY2FzZSB3aGVuIHRoZSByZXF1ZXN0IGlzIHVuYXV0aG9yaXplZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBleHBpcmVkIGFjY2VzcyB0b2tlblxuXHRcdFx0XHRcdHJlc3BvbnNlU3RyZWFtLm9uKCdyZXNwb25zZScsIHJlc3BvbnNlID0+IHtcblx0XHRcdFx0XHRcdGlmIChpc1VuYXV0aG9yaXplZER1ZVRvRXhwaXJlZEFjY2Vzc1Rva2VuKHJlc3BvbnNlKSkge1xuXG5cdFx0XHRcdFx0XHRcdHZhciBleHBpcmVkVG9rZW5zRXJyb3IgPSBlcnJvcnMuYnVpbGRBdXRoRXJyb3IocmVzcG9uc2UpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEdpdmUgdGhlIHNlc3Npb24gYSBjaGFuY2UgdG8gaGFuZGxlIHRoZSBlcnJvciAoZXg6IGEgcGVyc2lzdGVudCBzZXNzaW9uIHdpbGwgY2xlYXIgdGhlIHRva2VuIHN0b3JlKVxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5fc2Vzc2lvbi5oYW5kbGVFeHBpcmVkVG9rZW5zRXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXNzaW9uLmhhbmRsZUV4cGlyZWRUb2tlbnNFcnJvcihleHBpcmVkVG9rZW5zRXJyb3IpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZXR1cm4gcmVzcG9uc2VTdHJlYW07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNYWtlIHRoZSByZXF1ZXN0IHRvIEJveCwgYW5kIHBlcmZvcm0gc3RhbmRhcmQgcmVzcG9uc2UgaGFuZGxpbmdcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLm1ha2VSZXF1ZXN0KHBhcmFtcyk7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBwcm9taXNlXG5cdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRpZiAoIXJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcblx0XHRcdFx0Ly8gUmVzcG9uc2UgaXMgbm90IHlldCBjb21wbGV0ZSwgYW5kIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCB3aWxsIHJldHVybiB0aGUgcmVzcG9uc2UgbGF0ZXJcblx0XHRcdFx0Ly8gSnVzdCByZXR1cm4gdGhlIHN0cmVhbSwgc2luY2UgaXQgZG9lc24ndCBuZWVkIGZ1cnRoZXIgcmVzcG9uc2UgaGFuZGxpbmdcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNVbmF1dGhvcml6ZWREdWVUb0V4cGlyZWRBY2Nlc3NUb2tlbihyZXNwb25zZSkpIHtcblx0XHRcdFx0dmFyIGV4cGlyZWRUb2tlbnNFcnJvciA9IGVycm9ycy5idWlsZEF1dGhFcnJvcihyZXNwb25zZSk7XG5cblx0XHRcdFx0Ly8gR2l2ZSB0aGUgc2Vzc2lvbiBhIGNoYW5jZSB0byBoYW5kbGUgdGhlIGVycm9yIChleDogYSBwZXJzaXN0ZW50IHNlc3Npb24gd2lsbCBjbGVhciB0aGUgdG9rZW4gc3RvcmUpXG5cdFx0XHRcdGlmICh0aGlzLl9zZXNzaW9uLmhhbmRsZUV4cGlyZWRUb2tlbnNFcnJvcikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9zZXNzaW9uLmhhbmRsZUV4cGlyZWRUb2tlbnNFcnJvcihleHBpcmVkVG9rZW5zRXJyb3IpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgZXhwaXJlZFRva2Vuc0Vycm9yO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogRW51bSBvZiB2YWxpZCBjb2xsYWJvcmF0aW9uIHJvbGVzXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7Q29sbGFib3JhdGlvblJvbGV9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuY29sbGFib3JhdGlvblJvbGVzID0ge1xuXHRFRElUT1I6ICdlZGl0b3InLFxuXHRWSUVXRVI6ICd2aWV3ZXInLFxuXHRQUkVWSUVXRVI6ICdwcmV2aWV3ZXInLFxuXHRVUExPQURFUjogJ3VwbG9hZGVyJyxcblx0UFJFVklFV0VSX1VQTE9BREVSOiAncHJldmlld2VyIHVwbG9hZGVyJyxcblx0VklFV0VSX1VQTE9BREVSOiAndmlld2VyIHVwbG9hZGVyJyxcblx0Q09fT1dORVI6ICdjby1vd25lcicsXG5cdE9XTkVSOiAnb3duZXInXG59O1xuXG4vKipcbiAqIEVudW0gb2YgQm94IGl0ZW0gdHlwZXNcbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtJdGVtVHlwZX1cbiAqL1xuQm94Q2xpZW50LnByb3RvdHlwZS5pdGVtVHlwZXMgPSB7XG5cdEZJTEU6ICdmaWxlJyxcblx0Rk9MREVSOiAnZm9sZGVyJ1xufTtcblxuLyoqXG4gKiBFbnVtIG9mIHZhbGlkIHZhbHVlcyBmb3Igc2V0dGluZyBkaWZmZXJlbnQgYWNjZXNzIGxldmVscy4gVG8gYmUgdXNlZCB3aGVuXG4gKiBjcmVhdGluZyBhbmQgZWRpdHRpbmcgc2hhcmVkIGxpbmtzLCB1cGxvYWQgZW1haWxzLCBldGMuXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAdHlwZSB7QWNjZXNzTGV2ZWx9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuYWNjZXNzTGV2ZWxzID0ge1xuXHRPUEVOOiB7YWNjZXNzOiAnb3Blbid9LFxuXHRDT0xMQUJPUkFUT1JTOiB7YWNjZXNzOiAnY29sbGFib3JhdG9ycyd9LFxuXHRDT01QQU5ZOiB7YWNjZXNzOiAnY29tcGFueSd9LFxuXHRERUZBVUxUOiB7fSxcblx0RElTQUJMRUQ6IG51bGxcbn07XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbkJveENsaWVudC5wcm90b3R5cGUuQ1VSUkVOVF9VU0VSX0lEID0gVXNlcnMucHJvdG90eXBlLkNVUlJFTlRfVVNFUl9JRDtcblxuLyoqXG4gKiBTZXQgYSBjdXN0b20gaGVhZGVyLiBBIGN1c3RvbSBoZWFkZXIgaXMgYXBwbGllZCB0byBldmVyeSByZXF1ZXN0IGZvciB0aGUgbGlmZSBvZiB0aGUgY2xpZW50LiBUb1xuICogcmVtb3ZlIGEgaGVhZGVyLCBzZXQgaXQncyB2YWx1ZSB0byBudWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXIgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBoZWFkZXIgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGN1c3RvbSBoZWFkZXIuIFNldCB0byBudWxsIHRvIHJlbW92ZSB0aGUgZ2l2ZW4gaGVhZGVyLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuc2V0Q3VzdG9tSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyLCB2YWx1ZSkge1xuXHRpZiAodmFsdWUpIHtcblx0XHR0aGlzLl9jdXN0b21IZWFkZXJzW2hlYWRlcl0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRkZWxldGUgdGhpcy5fY3VzdG9tSGVhZGVyc1toZWFkZXJdO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3Qgb2YgcmVxdWVzdGluZyBJUCBhZGRyZXNzZXMgZm9yIHRoZSBYLUZvcndhcmRlZC1Gb3IgaGVhZGVyLiBVc2VkIHRvIGdpdmUgdGhlIEFQSVxuICogYmV0dGVyIGluZm9ybWF0aW9uIGZvciB1cGxvYWRzLCByYXRlLWxpbWl0aW5nLCBldGMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gaXBzIC0gQXJyYXkgb2YgSVAgQWRkcmVzc2VzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuQm94Q2xpZW50LnByb3RvdHlwZS5zZXRJUHMgPSBmdW5jdGlvbihpcHMpIHtcblx0dmFyIHZhbGlkSVBzID0gaXBzLmZpbHRlcihpcFN0cmluZyA9PiBpc0lQKGlwU3RyaW5nKSkuam9pbignLCAnKTtcblxuXHR0aGlzLnNldEN1c3RvbUhlYWRlcihIRUFERVJfWEZGLCB2YWxpZElQcyk7XG5cblx0dGhpcy5fdG9rZW5PcHRpb25zID0ge2lwOiB2YWxpZElQc307XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNoYXJlZCBpdGVtIGNvbnRleHQgb24gdGhlIEFQSSBTZXNzaW9uLiBPdmVyd3JpdGVzIGFueSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgc2hhcmVkIGxpbmsgdXJsXG4gKiBAcGFyYW0gez9zdHJpbmd9IHBhc3N3b3JkIFRoZSBzaGFyZWQgbGluayBwYXNzd29yZCwgbnVsbCBpZiBubyBwYXNzd29yZCBleGlzdHMuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuQm94Q2xpZW50LnByb3RvdHlwZS5zZXRTaGFyZWRDb250ZXh0ID0gZnVuY3Rpb24odXJsLCBwYXNzd29yZCkge1xuXHR2YXIgc2hhcmVkQ29udGV4dEF1dGhIZWFkZXIgPSB0aGlzLmJ1aWxkU2hhcmVkSXRlbUF1dGhIZWFkZXIodXJsLCBwYXNzd29yZCk7XG5cdHRoaXMuc2V0Q3VzdG9tSGVhZGVyKEhFQURFUl9CT1hBUEksIHNoYXJlZENvbnRleHRBdXRoSGVhZGVyKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbnkgY3VycmVudCBzaGFyZWQgaXRlbSBjb250ZXh0IGZyb20gQVBJIFNlc3Npb24uXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUucmV2b2tlU2hhcmVkQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLnNldEN1c3RvbUhlYWRlcihIRUFERVJfQk9YQVBJLCBudWxsKTtcbn07XG5cbi8qKlxuICogU2V0IHVwIHRoZSBBcy1Vc2VyIGNvbnRleHQsIHdoaWNoIGlzIHVzZWQgYnkgZW50ZXJwcmlzZSBhZG1pbnMgdG9cbiAqIGltcGVyc29uYXRlIHRoZWlyIG1hbmFnZWQgdXNlcnMgYW5kIHBlcmZvcm0gYWN0aW9ucyBvbiB0aGVpciBiZWhhbGYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byBpbXBlcnNvbmF0ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuYXNVc2VyID0gZnVuY3Rpb24odXNlcklEKSB7XG5cblx0dGhpcy5zZXRDdXN0b21IZWFkZXIoSEVBREVSX0FTX1VTRVIsIHVzZXJJRCk7XG59O1xuXG4vKipcbiAqIFJldm9rZSB0aGUgQXMtVXNlciBjb250ZXh0IGFuZCByZXR1cm4gdG8gbWFraW5nIGNhbGxzIG9uIGJlaGFsZiBvZiB0aGUgdXNlclxuICogd2hvIG93bnMgdGhlIGNsaWVudCdzIGFjY2VzcyB0b2tlbi5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuQm94Q2xpZW50LnByb3RvdHlwZS5hc1NlbGYgPSBmdW5jdGlvbigpIHtcblxuXHR0aGlzLnNldEN1c3RvbUhlYWRlcihIRUFERVJfQVNfVVNFUiwgbnVsbCk7XG59O1xuXG4vKipcbiAqIFJldm9rZXMgdGhlIGNsaWVudCdzIGFjY2VzcyB0b2tlbnMuIFRoZSBjbGllbnQgd2lsbCBubyBsb25nZXIgYmUgdGllZCB0byBhIHVzZXJcbiAqIGFuZCB3aWxsIGJlIHVuYWJsZSB0byBtYWtlIGNhbGxzIHRvIHRoZSBBUEksIHJlbmRlcmluZyBpdCBlZmZlY3RpdmVseSB1c2VsZXNzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGVkIGFmdGVyIHJldm9raW5nLCB3aXRoIGFuIGVycm9yIGlmIG9uZSBleGlzdGVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBjbGllbnQncyBhY2Nlc3MgdG9rZW4gaXMgcmV2b2tlZFxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLnJldm9rZVRva2VucyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cblx0cmV0dXJuIHRoaXMuX3Nlc3Npb24ucmV2b2tlVG9rZW5zKHRoaXMuX3Rva2VuT3B0aW9ucylcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEV4Y2hhbmdlIHRoZSBjbGllbnQgYWNjZXNzIHRva2VuIGZvciBvbmUgd2l0aCBsb3dlciBzY29wZVxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHNjb3BlcyBUaGUgc2NvcGUocykgcmVxdWVzdGVkIGZvciB0aGUgbmV3IHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Jlc291cmNlXSBUaGUgYWJzb2x1dGUgVVJMIG9mIGFuIEFQSSByZXNvdXJjZSB0byBzY29wZSB0aGUgbmV3IHRva2VuIHRvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtBY3RvclBhcmFtc30gW29wdGlvbnMuYWN0b3JdIC0gT3B0aW9uYWwgYWN0b3IgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYW5ub3RhdG9yIHRva2VucyB3aXRoIFRva2VuIEF1dGggY2xpZW50XG4gKiBAcGFyYW0ge1NoYXJlZExpbmtQYXJhbXN9IFtvcHRpb25zLnNoYXJlZExpbmtdIC0gT3B0aW9uYWwgc2hhcmVkIGxpbmsgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgdG9rZW5zIHVzaW5nIHNoYXJlZCBsaW5rc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBDYWxsZWQgd2l0aCB0aGUgbmV3IHRva2VuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkluZm8+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBleGNoYW5nZWQgdG9rZW4gaW5mb1xuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLmV4Y2hhbmdlVG9rZW4gPSBmdW5jdGlvbihzY29wZXMsIHJlc291cmNlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdC8vIFNodWZmbGUgb3B0aW9uYWwgcGFyYW1ldGVyc1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0dmFyIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdG9rZW5SZXF1ZXN0T3B0aW9uczogdGhpcy5fdG9rZW5PcHRpb25zIHx8IG51bGwgfSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIHRoaXMuX3Nlc3Npb24uZXhjaGFuZ2VUb2tlbihzY29wZXMsIHJlc291cmNlLCBvcHRzKVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogTWFrZXMgR0VUIHJlcXVlc3QgdG8gQm94IEFQSSBWMiBlbmRwb2ludFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gcGF0aCB0byBhIGNlcnRhaW4gQVBJIGVuZHBvaW50IChleDogL2ZpbGUpXG4gKiBAcGFyYW0gez9PYmplY3R9IHBhcmFtcyAtIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0LCBzdWNoIGFzIHF1ZXJ5IHN0cmluZ3MgYW5kIGhlYWRlcnNcbiAqIEBwYXJhbSB7QVBJUmVxdWVzdH5DYWxsYmFja30gY2FsbGJhY2sgLSBwYXNzZWQgZmluYWwgQVBJIHJlc3BvbnNlIG9yIGVyciBpZiByZXF1ZXN0IGZhaWxlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGF0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHR2YXIgbmV3UGFyYW1zID0gbWVyZ2Uoe30sIHBhcmFtcyB8fCB7fSk7XG5cdG5ld1BhcmFtcy5tZXRob2QgPSAnR0VUJztcblx0bmV3UGFyYW1zLnVybCA9IGdldEZ1bGxVUkwodGhpcy5fYmFzZVVSTCwgcGF0aCk7XG5cblx0cmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG5ld1BhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBNYWtlcyBQT1NUIHJlcXVlc3QgdG8gQm94IEFQSSBWMiBlbmRwb2ludFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gcGF0aCB0byBhIGNlcnRhaW4gQVBJIGVuZHBvaW50IChleDogL2ZpbGUpXG4gKiBAcGFyYW0gez9PYmplY3R9IHBhcmFtcyAtIG9iamVjdCBjb250YWluaW5nIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0LCBzdWNoIGFzIHF1ZXJ5IHN0cmluZ3MgYW5kIGhlYWRlcnNcbiAqIEBwYXJhbSB7QVBJUmVxdWVzdH5DYWxsYmFja30gY2FsbGJhY2sgLSBwYXNzZWQgZmluYWwgQVBJIHJlc3BvbnNlIG9yIGVyciBpZiByZXF1ZXN0IGZhaWxlZFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKHBhdGgsIHBhcmFtcywgY2FsbGJhY2spIHtcblx0dmFyIG5ld1BhcmFtcyA9IG1lcmdlKHt9LCBwYXJhbXMgfHwge30pO1xuXHRuZXdQYXJhbXMubWV0aG9kID0gJ1BPU1QnO1xuXHRuZXdQYXJhbXMudXJsID0gZ2V0RnVsbFVSTCh0aGlzLl9iYXNlVVJMLCBwYXRoKTtcblx0cmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG5ld1BhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBNYWtlcyBQVVQgcmVxdWVzdCB0byBCb3ggQVBJIFYyIGVuZHBvaW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBwYXRoIHRvIGEgY2VydGFpbiBBUEkgZW5kcG9pbnQgKGV4OiAvZmlsZSlcbiAqIEBwYXJhbSB7P09iamVjdH0gcGFyYW1zIC0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3QsIHN1Y2ggYXMgcXVlcnkgc3RyaW5ncyBhbmQgaGVhZGVyc1xuICogQHBhcmFtIHtBUElSZXF1ZXN0fkNhbGxiYWNrfSBjYWxsYmFjayAtIHBhc3NlZCBmaW5hbCBBUEkgcmVzcG9uc2Ugb3IgZXJyIGlmIHJlcXVlc3QgZmFpbGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuQm94Q2xpZW50LnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbihwYXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdHZhciBuZXdQYXJhbXMgPSBtZXJnZSh7fSwgcGFyYW1zIHx8IHt9KTtcblx0bmV3UGFyYW1zLm1ldGhvZCA9ICdQVVQnO1xuXHRuZXdQYXJhbXMudXJsID0gZ2V0RnVsbFVSTCh0aGlzLl9iYXNlVVJMLCBwYXRoKTtcblx0cmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG5ld1BhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBNYWtlcyBERUxFVEUgcmVxdWVzdCB0byBCb3ggQVBJIFYyIGVuZHBvaW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBwYXRoIHRvIGEgY2VydGFpbiBBUEkgZW5kcG9pbnQgKGV4OiAvZmlsZSlcbiAqIEBwYXJhbSB7P09iamVjdH0gcGFyYW1zIC0gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3QsIHN1Y2ggYXMgcXVlcnkgc3RyaW5ncyBhbmQgaGVhZGVyc1xuICogQHBhcmFtIHtBUElSZXF1ZXN0fkNhbGxiYWNrfSBjYWxsYmFjayAtIHBhc3NlZCBmaW5hbCBBUEkgcmVzcG9uc2Ugb3IgZXJyIGlmIHJlcXVlc3QgZmFpbGVkXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuQm94Q2xpZW50LnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihwYXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdHZhciBuZXdQYXJhbXMgPSBtZXJnZSh7fSwgcGFyYW1zIHx8IHt9KTtcblx0bmV3UGFyYW1zLm1ldGhvZCA9ICdERUxFVEUnO1xuXHRuZXdQYXJhbXMudXJsID0gZ2V0RnVsbFVSTCh0aGlzLl9iYXNlVVJMLCBwYXRoKTtcblx0cmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG5ld1BhcmFtcywgY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIE1ha2VzIGFuIE9QVElPTlMgY2FsbCB0byBhIEJveCBBUEkgVjIgZW5kcG9pbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIFBhdGggdG8gYW4gQVBJIGVuZHBvaW50IChlLmcuIC9maWxlcy9jb250ZW50KVxuICogQHBhcmFtIHs/T2JqZWN0fSBwYXJhbXMgLSBBbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyByZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QVBJUmVxdWVzdH5DYWxsYmFja30gY2FsbGJhY2sgLSBDYWxsZWQgd2l0aCBBUEkgY2FsbCByZXN1bHRzLCBvciBlcnIgaWYgY2FsbCBmYWlsZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLm9wdGlvbnMgPSBmdW5jdGlvbihwYXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdHZhciBuZXdQYXJhbXMgPSBtZXJnZSh7fSwgcGFyYW1zIHx8IHt9KTtcblx0bmV3UGFyYW1zLm1ldGhvZCA9ICdPUFRJT05TJztcblx0bmV3UGFyYW1zLnVybCA9IGdldEZ1bGxVUkwodGhpcy5fYmFzZVVSTCwgcGF0aCk7XG5cblx0cmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG5ld1BhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIFBPU1QgY2FsbCB0byBhIEJveCBBUEkgVjIgdXBsb2FkIGVuZHBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHBhdGggdG8gYW4gdXBsb2FkIEFQSSBlbmRwb2ludFxuICogQHBhcmFtIHs/T2JqZWN0fSBwYXJhbXMgLSBhbiBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyByZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7P09iamVjdH0gZm9ybURhdGEgLSBtdWx0aXBhcnQgZm9ybSBkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIHVwbG9hZCByZXF1ZXN0IHtAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWtlYWwvcmVxdWVzdCNtdWx0aXBhcnRmb3JtLWRhdGEtbXVsdGlwYXJ0LWZvcm0tdXBsb2Fkc31cbiAqIEBwYXJhbSB7QVBJUmVxdWVzdH5DYWxsYmFja30gY2FsbGJhY2sgLSBjYWxsZWQgd2l0aCBBUEkgY2FsbCByZXN1bHRzLCBvciBhbiBlcnJvciBpZiB0aGUgY2FsbCBmYWlsZWRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLnVwbG9hZCA9IGZ1bmN0aW9uKHBhdGgsIHBhcmFtcywgZm9ybURhdGEsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGRlZmF1bHRzID0ge1xuXHRcdG1ldGhvZDogJ1BPU1QnXG5cdH07XG5cdHZhciBuZXdQYXJhbXMgPSBtZXJnZShkZWZhdWx0cywgcGFyYW1zIHx8IHt9KTtcblx0bmV3UGFyYW1zLnVybCA9IGdldEZ1bGxVUkwodGhpcy5fdXBsb2FkQmFzZVVSTCwgcGF0aCk7XG5cdG5ld1BhcmFtcy5mb3JtRGF0YSA9IGZvcm1EYXRhO1xuXHRuZXdQYXJhbXMudGltZW91dCA9IHRoaXMuX3VwbG9hZFJlcXVlc3RUaW1lb3V0TVM7XG5cblx0cmV0dXJuIHRoaXMuX21ha2VSZXF1ZXN0KG5ld1BhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQdXRzIHRoZSBjbGllbnQgaW50byBiYXRjaCBtb2RlLCB3aGljaCB3aWxsIHF1ZXVlIGNhbGxzIGluc3RlYWQgb2ZcbiAqIGltbWVkaWF0ZWx5IG1ha2luZyB0aGUgQVBJIHJlcXVlc3QuXG4gKlxuICogREVQUkVDQVRFRDogQmF0Y2ggQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZDsgbWFrZSBjYWxscyBpbiBwYXJhbGxlbCBpbnN0ZWFkLlxuICpcbiAqIEByZXR1cm5zIHtCb3hDbGllbnR9IEN1cnJlbnQgY2xpZW50IG9iamVjdFxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLmJhdGNoID0gdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24oKSB7XG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXHR0aGlzLl9iYXRjaCA9IFtdO1xuXHRyZXR1cm4gdGhpcztcblx0LyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cbn0sICdCYXRjaCBBUEkgaXMgbm90IHN1cHBvcnRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkOyBtYWtlIGNhbGxzIGluIHBhcmFsbGVsIGluc3RlYWQuJyk7XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBiYXRjaCBvZiByZXF1ZXN0cy5cbiAqXG4gKiBERVBSRUNBVEVEOiBCYXRjaCBBUEkgaXMgbm90IHN1cHBvcnRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkOyBtYWtlIGNhbGxzIGluIHBhcmFsbGVsIGluc3RlYWQuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgYmF0Y2ggcmVzcG9uc2VzXG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuYmF0Y2hFeGVjID0gdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0LyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cdGlmICghdGhpcy5fYmF0Y2gpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNdXN0IHN0YXJ0IGEgYmF0Y2ggYmVmb3JlIGV4ZWN1dGluZycpKVxuXHRcdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuXHR9XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHRyZXF1ZXN0czogdGhpcy5fYmF0Y2gubWFwKGJhdGNoUmVxID0+IGZvcm1hdFJlcXVlc3RGb3JCYXRjaChiYXRjaFJlcS5wYXJhbXMpKVxuXHRcdH1cblx0fTtcblxuXHR2YXIgYmF0Y2ggPSB0aGlzLl9iYXRjaDtcblx0dGhpcy5fYmF0Y2ggPSBudWxsO1xuXHRyZXR1cm4gdGhpcy5wb3N0KCcvYmF0Y2gnLCBwYXJhbXMpXG5cdFx0LnRoZW4ocmVzID0+IHtcblxuXHRcdFx0dmFyIHJlc3BvbnNlcyA9IHJlcy5ib2R5LnJlc3BvbnNlcztcblxuXHRcdFx0cmVzcG9uc2VzLm1hcCh4ID0+IGZvcm1hdFJlc3BvbnNlRm9yQmF0Y2goeCkpLmZvckVhY2goKHJlc3BvbnNlLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRiYXRjaFtpbmRleF0ucmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHJlcy5ib2R5O1xuXHRcdH0pXG5cdFx0LmNhdGNoKGVyciA9PiB7XG5cdFx0XHRiYXRjaC5mb3JFYWNoKHJlcSA9PiByZXEucmVqZWN0KGVycikpO1xuXG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG5cdC8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG59LCAnQmF0Y2ggQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZDsgbWFrZSBjYWxscyBpbiBwYXJhbGxlbCBpbnN0ZWFkLicpO1xuXG4vKipcbiAqIEJ1aWxkIHRoZSAnQm94QXBpJyBIZWFkZXIgdXNlZCBmb3IgYXV0aGVudGljYXRpbmcgYWNjZXNzIHRvIGEgc2hhcmVkIGl0ZW1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBzaGFyZWQgbGluayB1cmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFzc3dvcmRdIFRoZSBzaGFyZWQgbGluayBwYXNzd29yZFxuICogQHJldHVybnMge3N0cmluZ30gQSBwcm9wZXJseSBmb3JtYXR0ZWQgJ0JveEFwaScgaGVhZGVyXG4gKi9cbkJveENsaWVudC5wcm90b3R5cGUuYnVpbGRTaGFyZWRJdGVtQXV0aEhlYWRlciA9IGZ1bmN0aW9uKHVybCwgcGFzc3dvcmQpIHtcblx0dmFyIGVuY29kZWRVUkwgPSBlbmNvZGVVUklDb21wb25lbnQodXJsKSxcblx0XHRlbmNvZGVkUGFzc3dvcmQgPSBlbmNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpO1xuXG5cdGlmIChwYXNzd29yZCkge1xuXHRcdHJldHVybiB1dGlsLmZvcm1hdCgnc2hhcmVkX2xpbms9JXMmc2hhcmVkX2xpbmtfcGFzc3dvcmQ9JXMnLCBlbmNvZGVkVVJMLCBlbmNvZGVkUGFzc3dvcmQpO1xuXHR9XG5cblx0cmV0dXJuIHV0aWwuZm9ybWF0KCdzaGFyZWRfbGluaz0lcycsIGVuY29kZWRVUkwpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBjYWxsYmFjayB0aGF0IHByb3Blcmx5IGhhbmRsZXMgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGNvZGUgYnkgcGFzc2luZyB0aGUgcmVzcG9uc2VcbiAqIGJvZHkgdG8gdGhlIG9yaWdpbmFsIGNhbGxiYWNrLiBBbnkgcmVxdWVzdCBlcnJvciBvciB1bnN1Y2Nlc3NmdWwgcmVzcG9uc2UgY29kZXMgYXJlIHByb3BhZ2F0ZWRcbiAqIGJhY2sgdG8gdGhlIGNhbGxiYWNrIGFzIGVycm9ycy4gVGhpcyBpcyB0aGUgc3RhbmRhcmQgYmVoYXZpb3Igb2YgbW9zdCBlbmRwb2ludHMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIG9yaWdpbmFsIGNhbGxiYWNrIGdpdmVuIGJ5IHRoZSBjb25zdW1lclxuICogQHJldHVybnMgez9BUElSZXF1ZXN0fkNhbGxiYWNrfSBBIG5ldyBjYWxsYmFjayB0aGF0IHByb2Nlc3NlcyB0aGUgcmVzcG9uc2UgYmVmb3JlIHBhc3NpbmcgaXQgdG8gdGhlIGNhbGxiYWNrLlxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLmRlZmF1bHRSZXNwb25zZUhhbmRsZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdGlmICghY2FsbGJhY2spIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cblx0cmV0dXJuIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcblx0XHQvLyBFcnJvciB3aXRoIFJlcXVlc3Rcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFN1Y2Nlc3NmdWwgUmVzcG9uc2Vcblx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSBIVFRQX1NUQVRVU19DT0RFX1NVQ0NFU1NfQkxPQ0tfUkFOR0VbMF1cblx0XHRcdCYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPD0gSFRUUF9TVEFUVVNfQ09ERV9TVUNDRVNTX0JMT0NLX1JBTkdFWzFdKSB7XG5cblx0XHRcdGlmIChzZWxmLl91c2VJdGVyYXRvcnMgJiYgUGFnaW5nSXRlcmF0b3IuaXNJdGVyYWJsZShyZXNwb25zZSkpIHtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgbmV3IFBhZ2luZ0l0ZXJhdG9yKHJlc3BvbnNlLCBzZWxmKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzcG9uc2UuYm9keSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIFVuZXhwZWN0ZWQgUmVzcG9uc2Vcblx0XHRjYWxsYmFjayhlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSkpO1xuXHR9O1xufTtcblxuLyoqXG4gKiBXcmFwIGEgY2xpZW50IG1ldGhvZCB3aXRoIHRoZSBkZWZhdWx0IGhhbmRsZXIgZm9yIGJvdGggY2FsbGJhY2sgYW5kIHByb21pc2Ugc3R5bGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgVGhlIGNsaWVudCBtZXRob2QgKGUuZy4gY2xpZW50LmdldClcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gIFRoZSB3cmFwcGVkIG1ldGhvZFxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLndyYXBXaXRoRGVmYXVsdEhhbmRsZXIgPSBmdW5jdGlvbihtZXRob2QpIHtcblxuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHJldHVybiBmdW5jdGlvbiB3cmFwcGVkQ2xpZW50TWV0aG9kKC8qIGFyZ3VtZW50cyAqLykge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIGxhc3QgYXJndW1lbnQgaXMgYSBjYWxsYmFja1xuXHRcdHZhciBsYXN0QXJnID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXSxcblx0XHRcdGNhbGxiYWNrO1xuXHRcdGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2FsbGJhY2sgPSBzZWxmLmRlZmF1bHRSZXNwb25zZUhhbmRsZXIobGFzdEFyZyk7XG5cdFx0XHRhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID0gY2FsbGJhY2s7XG5cdFx0fVxuXG5cdFx0dmFyIHJldCA9IG1ldGhvZC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXG5cdFx0aWYgKHJldCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblxuXHRcdFx0cmV0ID0gcmV0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID49IEhUVFBfU1RBVFVTX0NPREVfU1VDQ0VTU19CTE9DS19SQU5HRVswXVxuXHRcdFx0XHRcdFx0JiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA8PSBIVFRQX1NUQVRVU19DT0RFX1NVQ0NFU1NfQkxPQ0tfUkFOR0VbMV0pIHtcblxuXHRcdFx0XHRcdGlmIChzZWxmLl91c2VJdGVyYXRvcnMgJiYgUGFnaW5nSXRlcmF0b3IuaXNJdGVyYWJsZShyZXNwb25zZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgUGFnaW5nSXRlcmF0b3IocmVzcG9uc2UsIHNlbGYpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHQvLyBJZiB0aGUgY2FsbGJhY2sgd2lsbCBoYW5kbGUgYW55IGVycm9ycywgZG9uJ3Qgd29ycnkgYWJvdXQgdGhlIHByb21pc2Vcblx0XHRcdHJldC5zdXBwcmVzc1VuaGFuZGxlZFJlamVjdGlvbnMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufTtcblxuLyoqXG4gKiBBZGQgYSBTREsgcGx1Z2luLiBXYXJuaW5nOiBUaGlzIHdpbGwgbW9kaWZ5IHRoZSBib3gtY2xpZW50IGludGVyZmFjZSBhbmQgY2FuIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQbHVnaW4gbmFtZS4gV2lsbCBiZSBhY2Nlc3NpYmxlIHZpYSBjbGllbnQuPHBsdWdpbi1uYW1lPlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIFRoZSBTREsgcGx1Z2luIHRvIGFkZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBQbHVnaW4tc3BlY2lmaWMgb3B0aW9uc1xuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgcGx1Z2luIG5hbWUgbWF0Y2hlcyBhbiBleGlzdGluZyBtZXRob2Qgb24gYm94LWNsaWVudFxuICovXG5Cb3hDbGllbnQucHJvdG90eXBlLnBsdWcgPSBmdW5jdGlvbihuYW1lLCBwbHVnaW4sIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0aWYgKChuYW1lIGluIHRoaXMpICYmICh0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgZGVmaW5lIGEgcGx1Z2luIHRoYXQgb3ZlcnJpZGVzIGFuIGV4aXN0aW5nIG1ldGhvZCBvbiB0aGUgY2xpZW50Jyk7XG5cdH1cblxuXHQvLyBDcmVhdGUgcGx1Z2luIGFuZCBleHBvcnQgcGx1Z2luIG9udG8gY2xpZW50LlxuXHR0aGlzW25hbWVdID0gcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQG1vZHVsZSBib3gtbm9kZS1zZGsvbGliL2JveC1jbGllbnRcbiAqIEBzZWUge0BMaW5rIEJveENsaWVudH1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBCb3hDbGllbnQ7XG4iXSwibmFtZXMiOlsidXRpbCIsInJlcXVpcmUiLCJxcyIsImVycm9ycyIsImh0dHBTdGF0dXNDb2RlcyIsImlzSVAiLCJtZXJnZSIsIlBhZ2luZ0l0ZXJhdG9yIiwiUHJvbWlzZSIsInBrZyIsIlVzZXJzIiwiRmlsZXMiLCJGb2xkZXJzIiwiQ29sbGFib3JhdGlvbnMiLCJHcm91cHMiLCJDb21tZW50cyIsIlNoYXJlZEl0ZW1zIiwiTWV0YWRhdGEiLCJDb2xsZWN0aW9ucyIsIkV2ZW50cyIsIlNlYXJjaCIsIlRhc2tzIiwiVHJhc2giLCJFbnRlcnByaXNlIiwiTGVnYWxIb2xkUG9saWNpZXMiLCJXZWJMaW5rcyIsIlJldGVudGlvblBvbGljaWVzIiwiRGV2aWNlUGlucyIsIldlYmhvb2tzIiwiUmVjZW50SXRlbXMiLCJDb2xsYWJvcmF0aW9uV2hpdGVsaXN0IiwiVGVybXNPZlNlcnZpY2UiLCJTdG9yYWdlUG9saWNpZXMiLCJIRUFERVJfQVVUSE9SSVpBVElPTiIsIkhFQURFUl9BVVRIT1JJWkFUSU9OX1BSRUZJWCIsIkhFQURFUl9CT1hBUEkiLCJIRUFERVJfWEZGIiwiSEVBREVSX0FTX1VTRVIiLCJIVFRQX1NUQVRVU19DT0RFX1NVQ0NFU1NfQkxPQ0tfUkFOR0UiLCJidWlsZEF1dGhvcml6YXRpb25IZWFkZXIiLCJhY2Nlc3NUb2tlbiIsImlzVW5hdXRob3JpemVkRHVlVG9FeHBpcmVkQWNjZXNzVG9rZW4iLCJyZXNwb25zZSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiYm9keSIsImlzUmVzcG9uc2VTdGF0dXNDb2RlVW5hdXRob3JpemVkIiwic3RhdHVzQ29kZSIsIlVOQVVUSE9SSVpFRCIsImlzUmVzcG9uc2VCb2R5RW1wdHkiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibGVuZ3RoIiwiZ2V0RnVsbFVSTCIsImRlZmF1bHRCYXNlUGF0aCIsInVybCIsInRlc3QiLCJmb3JtYXRSZXF1ZXN0Rm9yQmF0Y2giLCJwYXJhbXMiLCJyZWxhdGl2ZVBhdGgiLCJyZXBsYWNlIiwibWV0aG9kIiwicmVsYXRpdmVfdXJsIiwic3RyaW5naWZ5IiwiaGVhZGVycyIsImZvcm1hdFJlc3BvbnNlRm9yQmF0Y2giLCJzdGF0dXMiLCJjb25zdHJ1Y3RCb3hVQUhlYWRlciIsImNsaWVudCIsImFuYWx5dGljc0lkZW50aWZpZXJzIiwiYWdlbnQiLCJ2ZXJzaW9uIiwiZW52IiwicHJvY2VzcyIsIm5hbWUiLCJrZXlzIiwibWFwIiwiayIsImpvaW4iLCJCb3hDbGllbnQiLCJhcGlTZXNzaW9uIiwiY29uZmlnIiwicmVxdWVzdE1hbmFnZXIiLCJfc2Vzc2lvbiIsIl9yZXF1ZXN0TWFuYWdlciIsIl9jdXN0b21IZWFkZXJzIiwiX2Jhc2VVUkwiLCJmb3JtYXQiLCJhcGlSb290VVJMIiwiYXBpVmVyc2lvbiIsIl91cGxvYWRCYXNlVVJMIiwidXBsb2FkQVBJUm9vdFVSTCIsIl91cGxvYWRSZXF1ZXN0VGltZW91dE1TIiwidXBsb2FkUmVxdWVzdFRpbWVvdXRNUyIsIl91c2VJdGVyYXRvcnMiLCJpdGVyYXRvcnMiLCJfYW5hbHl0aWNzQ2xpZW50IiwiYW5hbHl0aWNzQ2xpZW50IiwidXNlcnMiLCJmaWxlcyIsImZvbGRlcnMiLCJjb21tZW50cyIsImNvbGxhYm9yYXRpb25zIiwiZ3JvdXBzIiwic2hhcmVkSXRlbXMiLCJtZXRhZGF0YSIsImNvbGxlY3Rpb25zIiwiZXZlbnRzIiwic2VhcmNoIiwidGFza3MiLCJ0cmFzaCIsImVudGVycHJpc2UiLCJsZWdhbEhvbGRQb2xpY2llcyIsIndlYmxpbmtzIiwicmV0ZW50aW9uUG9saWNpZXMiLCJkZXZpY2VQaW5zIiwid2ViaG9va3MiLCJyZWNlbnRJdGVtcyIsImNvbGxhYm9yYXRpb25XaGl0ZWxpc3QiLCJ0ZXJtc09mU2VydmljZSIsInN0b3JhZ2VQb2xpY2llcyIsIl9iYXRjaCIsInByb3RvdHlwZSIsIl9jcmVhdGVIZWFkZXJzRm9yUmVxdWVzdCIsImNhbGxlckhlYWRlcnMiLCJhc3NpZ24iLCJfbWFrZVJlcXVlc3QiLCJjYWxsYmFjayIsInByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicHVzaCIsImdldEFjY2Vzc1Rva2VuIiwiX3Rva2VuT3B0aW9ucyIsInRoZW4iLCJzdHJlYW1pbmciLCJyZXNwb25zZVN0cmVhbSIsIm1ha2VTdHJlYW1pbmdSZXF1ZXN0Iiwib24iLCJleHBpcmVkVG9rZW5zRXJyb3IiLCJidWlsZEF1dGhFcnJvciIsImhhbmRsZUV4cGlyZWRUb2tlbnNFcnJvciIsIm1ha2VSZXF1ZXN0IiwiYXNDYWxsYmFjayIsImNvbGxhYm9yYXRpb25Sb2xlcyIsIkVESVRPUiIsIlZJRVdFUiIsIlBSRVZJRVdFUiIsIlVQTE9BREVSIiwiUFJFVklFV0VSX1VQTE9BREVSIiwiVklFV0VSX1VQTE9BREVSIiwiQ09fT1dORVIiLCJPV05FUiIsIml0ZW1UeXBlcyIsIkZJTEUiLCJGT0xERVIiLCJhY2Nlc3NMZXZlbHMiLCJPUEVOIiwiYWNjZXNzIiwiQ09MTEFCT1JBVE9SUyIsIkNPTVBBTlkiLCJERUZBVUxUIiwiRElTQUJMRUQiLCJDVVJSRU5UX1VTRVJfSUQiLCJzZXRDdXN0b21IZWFkZXIiLCJoZWFkZXIiLCJ2YWx1ZSIsInNldElQcyIsImlwcyIsInZhbGlkSVBzIiwiZmlsdGVyIiwiaXBTdHJpbmciLCJpcCIsInNldFNoYXJlZENvbnRleHQiLCJwYXNzd29yZCIsInNoYXJlZENvbnRleHRBdXRoSGVhZGVyIiwiYnVpbGRTaGFyZWRJdGVtQXV0aEhlYWRlciIsInJldm9rZVNoYXJlZENvbnRleHQiLCJhc1VzZXIiLCJ1c2VySUQiLCJhc1NlbGYiLCJyZXZva2VUb2tlbnMiLCJleGNoYW5nZVRva2VuIiwic2NvcGVzIiwicmVzb3VyY2UiLCJvcHRpb25zIiwib3B0cyIsInRva2VuUmVxdWVzdE9wdGlvbnMiLCJnZXQiLCJwYXRoIiwibmV3UGFyYW1zIiwicG9zdCIsInB1dCIsImRlbCIsInVwbG9hZCIsImZvcm1EYXRhIiwiZGVmYXVsdHMiLCJ0aW1lb3V0IiwiYmF0Y2giLCJkZXByZWNhdGUiLCJiYXRjaEV4ZWMiLCJFcnJvciIsInJlcXVlc3RzIiwiYmF0Y2hSZXEiLCJyZXMiLCJyZXNwb25zZXMiLCJ4IiwiZm9yRWFjaCIsImluZGV4IiwiY2F0Y2giLCJlcnIiLCJyZXEiLCJlbmNvZGVkVVJMIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlZFBhc3N3b3JkIiwiZGVmYXVsdFJlc3BvbnNlSGFuZGxlciIsInNlbGYiLCJpc0l0ZXJhYmxlIiwiYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJ3cmFwcGVkQ2xpZW50TWV0aG9kIiwibGFzdEFyZyIsImFyZ3VtZW50cyIsInJldCIsImFwcGx5Iiwic3VwcHJlc3NVbmhhbmRsZWRSZWplY3Rpb25zIiwicGx1ZyIsInBsdWdpbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/box-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/box-node-sdk.js":
/*!*******************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/box-node-sdk.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Box SDK for Node.js\n */ \n// ------------------------------------------------------------------------------\n// Typedefs and Callbacks\n// ------------------------------------------------------------------------------\n/**\n * Object representing interface functions for PersistentClient to interact with the consumer app's central storage layer.\n * @typedef {Object} TokenStore\n * @property {ReadTokenInfoFromStore} read - read TokenInfo from app central store.\n * @property {WriteTokenInfoToStore} write - write TokenInfo to the app's central store.\n * @property {ClearTokenInfoFromStore} clear - delete TokenInfo from the app's central store.\n */ /**\n * Acquires TokenInfo from the consumer app's central store.\n * @typedef {Function} ReadTokenInfoFromStore\n * @param {Function} callback - err if store read issue occurred, otherwise propagates a TokenInfo object\n */ /**\n * Writes TokenInfo to the consumer app's central store\n * @typedef {Function} WriteTokenInfoToStore\n * @param {TokenInfo} tokenInfo - the token info to be written\n * @param {Function} callback - err if store write issue occurred, otherwise propagates null err\n *  and null result to indicate success\n */ /**\n * Clears TokenInfo from the consumer app's central store\n * @typedef {Function} ClearTokenInfoFromStore\n * @param {Function} callback - err if store delete issue occurred, otherwise propagates null err\n *  and null result to indicate success\n */ // ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter), util = __webpack_require__(/*! util */ \"util\"), qs = __webpack_require__(/*! querystring */ \"querystring\"), Config = __webpack_require__(/*! ./util/config */ \"(rsc)/./node_modules/box-node-sdk/lib/util/config.js\"), APIRequestManager = __webpack_require__(/*! ./api-request-manager */ \"(rsc)/./node_modules/box-node-sdk/lib/api-request-manager.js\"), TokenManager = __webpack_require__(/*! ./token-manager */ \"(rsc)/./node_modules/box-node-sdk/lib/token-manager.js\"), BasicAPISession = __webpack_require__(/*! ./sessions/basic-session */ \"(rsc)/./node_modules/box-node-sdk/lib/sessions/basic-session.js\"), PersistentAPISession = __webpack_require__(/*! ./sessions/persistent-session */ \"(rsc)/./node_modules/box-node-sdk/lib/sessions/persistent-session.js\"), AnonymousAPISession = __webpack_require__(/*! ./sessions/anonymous-session */ \"(rsc)/./node_modules/box-node-sdk/lib/sessions/anonymous-session.js\"), AppAuthSession = __webpack_require__(/*! ./sessions/app-auth-session */ \"(rsc)/./node_modules/box-node-sdk/lib/sessions/app-auth-session.js\"), BoxClient = __webpack_require__(/*! ./box-client */ \"(rsc)/./node_modules/box-node-sdk/lib/box-client.js\"), Webhooks = __webpack_require__(/*! ./managers/webhooks */ \"(rsc)/./node_modules/box-node-sdk/lib/managers/webhooks.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * A backend NodeJS SDK to interact with the Box V2 API.\n * This is the single entry point for all SDK consumer interactions. This is the only file that a 3rd party app\n * should require. All other components are private and reached out to via this component.\n * 1. Provides getters to spawn client instances for users to interact with the Box API.\n * 2. Provides manual capability to acquire tokens via token grant endpoints.\n *    However, it is recommended to use clients to do this for you.\n * 3. Emits notification events about relevant request/response events. Useful for logging Box API interactions.\n *    Notification events: request retries, exceeding max retries, permanent failures.\n *\n * @param {UserConfigurationOptions} params User settings used to initialize and customize the SDK\n * @constructor\n */ function BoxSDKNode(params) {\n    EventEmitter.call(this);\n    var eventBus = new EventEmitter();\n    var self = this;\n    eventBus.on(\"response\", function() {\n        var args = [].slice.call(arguments);\n        args.unshift(\"response\");\n        self.emit.apply(self, args);\n    });\n    // Setup the configuration with the given params\n    this.config = new Config(params);\n    this._eventBus = eventBus;\n    this._setup();\n}\nutil.inherits(BoxSDKNode, EventEmitter);\n/**\n * Setup the SDK instance by instantiating necessary objects with current\n * configuration values.\n *\n * @param {EventEmitter} eventBus The event bus to use\n * @returns {void}\n * @private\n */ BoxSDKNode.prototype._setup = function() {\n    // Instantiate the request manager\n    this.requestManager = new APIRequestManager(this.config, this._eventBus);\n    // Initialize the rest of the SDK with the given configuration\n    this.tokenManager = new TokenManager(this.config, this.requestManager);\n    this.anonymousSession = new AnonymousAPISession(this.config, this.tokenManager);\n};\n/**\n * Expose the BoxClient property enumerations to the SDK as a whole. This allows\n * the consumer to access and use these values from anywhere in their application\n * (like a helper) by requiring the SDK, instead of needing to pass the client.\n */ BoxSDKNode.prototype.accessLevels = BoxClient.prototype.accessLevels;\nBoxSDKNode.accessLevels = BoxSDKNode.prototype.accessLevels;\nBoxSDKNode.prototype.collaborationRoles = BoxClient.prototype.collaborationRoles;\nBoxSDKNode.collaborationRoles = BoxSDKNode.prototype.collaborationRoles;\nBoxSDKNode.prototype.CURRENT_USER_ID = BoxClient.prototype.CURRENT_USER_ID;\nBoxSDKNode.CURRENT_USER_ID = BoxSDKNode.prototype.CURRENT_USER_ID;\n/**\n * Gets the BoxSDKNode instance by passing boxAppSettings json downloaded from the developer console.\n *\n * @param {Object} appConfig boxAppSettings object retrieved from Dev Console.\n * @returns {BoxSDKNode} an instance that has been preconfigured with the values from the Dev Console\n */ BoxSDKNode.getPreconfiguredInstance = function(appConfig) {\n    if (typeof appConfig.boxAppSettings !== \"object\") {\n        throw new TypeError(\"Configuration does not include boxAppSettings object.\");\n    }\n    var boxAppSettings = appConfig.boxAppSettings;\n    var webhooks = appConfig.webhooks;\n    if (typeof webhooks === \"object\") {\n        Webhooks.setSignatureKeys(webhooks.primaryKey, webhooks.secondaryKey);\n    }\n    var params = {};\n    if (typeof boxAppSettings.clientID === \"string\") {\n        params.clientID = boxAppSettings.clientID;\n    }\n    if (typeof boxAppSettings.clientSecret === \"string\") {\n        params.clientSecret = boxAppSettings.clientSecret;\n    }\n    // Only try to assign app auth settings if they are present\n    // Some configurations do not include them (but might include other info, e.g. webhooks)\n    if (typeof boxAppSettings.appAuth === \"object\" && boxAppSettings.appAuth.publicKeyID) {\n        var appAuth = {};\n        // Assign publicKeyID to keyID\n        appAuth.keyID = boxAppSettings.appAuth.publicKeyID;\n        appAuth.privateKey = boxAppSettings.appAuth.privateKey;\n        var passphrase = boxAppSettings.appAuth.passphrase;\n        if (typeof passphrase === \"string\") {\n            appAuth.passphrase = passphrase;\n        }\n        params.appAuth = appAuth;\n    }\n    if (typeof appConfig.enterpriseID === \"string\") {\n        params.enterpriseID = appConfig.enterpriseID;\n    }\n    return new BoxSDKNode(params);\n};\n/**\n * Updates the SDK configuration with new parameters.\n *\n * @param {UserConfigurationOptions} params User settings\n * @returns {void}\n */ BoxSDKNode.prototype.configure = function(params) {\n    this.config = this.config.extend(params);\n    this._setup();\n};\n/**\n * Returns a Box Client with a Basic API Session. The client is able to make requests on behalf of a user.\n * A basic session has no access to a user's refresh token. Because of this, once the session's tokens\n * expire the client cannot recover and a new session will need to be generated.\n *\n * @param {string} accessToken A user's Box API access token\n * @returns {BoxClient} Returns a new Box Client paired to a new BasicAPISession\n */ BoxSDKNode.prototype.getBasicClient = function(accessToken) {\n    var apiSession = new BasicAPISession(accessToken, this.tokenManager);\n    return new BoxClient(apiSession, this.config, this.requestManager);\n};\n/**\n * Returns a Box Client with a Basic API Session. The client is able to make requests on behalf of a user.\n * A basic session has no access to a user's refresh token. Because of this, once the session's tokens\n * expire the client cannot recover and a new session will need to be generated.\n *\n * @param {string} accessToken A user's Box API access token\n * @returns {BoxClient} Returns a new Box Client paired to a new BasicAPISession\n */ BoxSDKNode.getBasicClient = function(accessToken) {\n    return new BoxSDKNode({\n        clientID: \"\",\n        clientSecret: \"\"\n    }).getBasicClient(accessToken);\n};\n/**\n * Returns a Box Client with a persistent API session. A persistent API session helps manage the user's tokens,\n * and can refresh them automatically if the access token expires. If a central data-store is given, the session\n * can read & write tokens to it.\n *\n * @NOTE: If tokenInfo or tokenStore are formatted incorrectly, this method will throw an error. If you\n * haven't explicitly created either of these objects or are otherwise not completly confident in their validity,\n * you should wrap your call to getPersistentClient in a try-catch to handle any potential errors.\n *\n * @param {TokenInfo} tokenInfo A tokenInfo object to use for authentication\n * @param {TokenStore} [tokenStore] An optional token store for reading/writing tokens to session\n * @returns {BoxClient} Returns a new Box Client paired to a new PersistentAPISession\n */ BoxSDKNode.prototype.getPersistentClient = function(tokenInfo, tokenStore) {\n    var apiSession = new PersistentAPISession(tokenInfo, tokenStore, this.config, this.tokenManager);\n    return new BoxClient(apiSession, this.config, this.requestManager);\n};\n/**\n * Returns A Box Client with an Anonymous API Session. An Anonymous API Session has access to an anonymous\n * client-credentials token, which isn't tied to any specific user. Because of this, the client will only\n * have access to endpoints that allow client-credential tokens. All Anonymous API Sessions share the\n * same tokens, which allows them to refresh them efficiently and reduce load on both the application and\n * the API.\n *\n * @returns {BoxClient} Returns a new Box Client paired to a AnonymousAPISession\n */ BoxSDKNode.prototype.getAnonymousClient = function() {\n    return new BoxClient(this.anonymousSession, this.config, this.requestManager);\n};\n/**\n * Create a new client using App Auth for the given entity.  This allows either\n * managing App Users (as the enterprise) or performing operations as the App\n * Users themselves (as a user).\n *\n * @param {string} type The type of entity to operate as, \"enterprise\" or \"user\"\n * @param {string} id The Box ID of the entity to operate as\n * @param {TokenStore} [tokenStore] (Optional) the token store to use for caching tokens\n * @returns {BoxClient} A new client authorized as the app user or enterprise\n */ BoxSDKNode.prototype.getAppAuthClient = function(type, id, tokenStore) {\n    if (type === \"enterprise\" && !id) {\n        if (this.config.enterpriseID) {\n            id = this.config.enterpriseID;\n        } else {\n            throw new Error(\"Enterprise ID must be passed\");\n        }\n    }\n    var appAuthSession = new AppAuthSession(type, id, this.config, this.tokenManager, tokenStore);\n    return new BoxClient(appAuthSession, this.config, this.requestManager);\n};\n/**\n * Generate the URL for the authorize page to send users to for the first leg of\n * the OAuth2 flow.\n *\n * @param {Object} params The OAuth2 parameters\n * @returns {string} The authorize page URL\n */ BoxSDKNode.prototype.getAuthorizeURL = function(params) {\n    params.client_id = this.config.clientID;\n    return `${this.config.authorizeRootURL}/oauth2/authorize?${qs.stringify(params)}`;\n};\n/**\n * Acquires token info using an authorization code\n *\n * @param {string} authorizationCode - authorization code issued by Box\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant, null for default behavior\n * @param {Function} [callback] - passed a TokenInfo object if tokens were granted successfully\n * @returns {Promise<TokenInfo>} Promise resolving to the token info\n */ BoxSDKNode.prototype.getTokensAuthorizationCodeGrant = function(authorizationCode, options, callback) {\n    return this.tokenManager.getTokensAuthorizationCodeGrant(authorizationCode, options).asCallback(callback);\n};\n/**\n * Refreshes the access and refresh tokens for a given refresh token.\n *\n * @param {string} refreshToken - A valid OAuth refresh token\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant, null for default behavior\n * @param {Function} [callback] - passed a TokenInfo object if tokens were granted successfully\n * @returns {Promise<TokenInfo>} Promise resolving to the token info\n */ BoxSDKNode.prototype.getTokensRefreshGrant = function(refreshToken, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    return this.tokenManager.getTokensRefreshGrant(refreshToken, options).asCallback(callback);\n};\n/**\n * Gets tokens for enterprise administration of app users\n * @param {string} enterpriseID The ID of the enterprise to generate a token for\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant, null for default behavior\n * @param {Function} [callback] Passed the tokens if successful\n * @returns {Promise<TokenInfo>} Promise resolving to the token info\n */ BoxSDKNode.prototype.getEnterpriseAppAuthTokens = function(enterpriseID, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    if (!enterpriseID) {\n        if (this.config.enterpriseID) {\n            enterpriseID = this.config.enterpriseID;\n        } else {\n            throw new Error(\"Enterprise id must be passed\");\n        }\n    }\n    return this.tokenManager.getTokensJWTGrant(\"enterprise\", enterpriseID, options).asCallback(callback);\n};\n/**\n * Gets tokens for App Users via a JWT grant\n * @param {string} userID The ID of the App User to generate a token for\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant, null for default behavior\n * @param {Function} [callback] Passed the tokens if successful\n * @returns {Promise<TokentInfo>} Promise reolving to the token infp\n */ BoxSDKNode.prototype.getAppUserTokens = function(userID, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    return this.tokenManager.getTokensJWTGrant(\"user\", userID, options).asCallback(callback);\n};\n/**\n * Revokes a token pair associated with a given access or refresh token.\n *\n * @param {string} token - A valid access or refresh token to revoke\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant, null for default behavior\n * @param {Function} [callback] - If err, revoke failed. Otherwise, revoke succeeded.\n * @returns {Promise<TokenInfo>} Promise resolving to the token info\n */ BoxSDKNode.prototype.revokeTokens = function(token, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    return this.tokenManager.revokeTokens(token, options).asCallback(callback);\n};\n/**\n * Expose Webhooks.validateMessage() to the SDK as a whole. This allows\n * the consumer to call BoxSDK.validateWebhookMessage() by just requiring the SDK,\n * instead of needing to create a client (which is not needed to validate messages).\n */ BoxSDKNode.validateWebhookMessage = Webhooks.validateMessage;\n/** @module box-node-sdk/lib/box-node-sdk */ module.exports = BoxSDKNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9ib3gtbm9kZS1zZGsuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRix5QkFBeUI7QUFDekIsaUZBQWlGO0FBRWpGOzs7Ozs7Q0FNQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7O0NBTUMsR0FFRDs7Ozs7Q0FLQyxHQUVELGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBRWpGLElBQUlBLGVBQWVDLDBEQUE4QixFQUNoREMsT0FBT0QsbUJBQU9BLENBQUMscUJBQ2ZFLEtBQUtGLG1CQUFPQSxDQUFDLG1DQUNiRyxTQUFTSCxtQkFBT0EsQ0FBQyw4RUFDakJJLG9CQUFvQkosbUJBQU9BLENBQUMsOEZBQzVCSyxlQUFlTCxtQkFBT0EsQ0FBQyxrRkFDdkJNLGtCQUFrQk4sbUJBQU9BLENBQUMsb0dBQzFCTyx1QkFBdUJQLG1CQUFPQSxDQUFDLDhHQUMvQlEsc0JBQXNCUixtQkFBT0EsQ0FBQyw0R0FDOUJTLGlCQUFpQlQsbUJBQU9BLENBQUMsMEdBQ3pCVSxZQUFZVixtQkFBT0EsQ0FBQyw0RUFDcEJXLFdBQVdYLG1CQUFPQSxDQUFDO0FBRXBCLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBRWpGLGlGQUFpRjtBQUNqRixTQUFTO0FBQ1QsaUZBQWlGO0FBRWpGOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNELFNBQVNZLFdBQVdDLE1BQU07SUFDekJkLGFBQWFlLElBQUksQ0FBQyxJQUFJO0lBRXRCLElBQUlDLFdBQVcsSUFBSWhCO0lBRW5CLElBQUlpQixPQUFPLElBQUk7SUFDZkQsU0FBU0UsRUFBRSxDQUFDLFlBQVk7UUFDdkIsSUFBSUMsT0FBTyxFQUFFLENBQUNDLEtBQUssQ0FBQ0wsSUFBSSxDQUFDTTtRQUN6QkYsS0FBS0csT0FBTyxDQUFDO1FBQ2JMLEtBQUtNLElBQUksQ0FBQ0MsS0FBSyxDQUFDUCxNQUFNRTtJQUN2QjtJQUdBLGdEQUFn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YnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL2JveC1ub2RlLXNkay5qcz9hYjhjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBCb3ggU0RLIGZvciBOb2RlLmpzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzIGFuZCBDYWxsYmFja3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIE9iamVjdCByZXByZXNlbnRpbmcgaW50ZXJmYWNlIGZ1bmN0aW9ucyBmb3IgUGVyc2lzdGVudENsaWVudCB0byBpbnRlcmFjdCB3aXRoIHRoZSBjb25zdW1lciBhcHAncyBjZW50cmFsIHN0b3JhZ2UgbGF5ZXIuXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUb2tlblN0b3JlXG4gKiBAcHJvcGVydHkge1JlYWRUb2tlbkluZm9Gcm9tU3RvcmV9IHJlYWQgLSByZWFkIFRva2VuSW5mbyBmcm9tIGFwcCBjZW50cmFsIHN0b3JlLlxuICogQHByb3BlcnR5IHtXcml0ZVRva2VuSW5mb1RvU3RvcmV9IHdyaXRlIC0gd3JpdGUgVG9rZW5JbmZvIHRvIHRoZSBhcHAncyBjZW50cmFsIHN0b3JlLlxuICogQHByb3BlcnR5IHtDbGVhclRva2VuSW5mb0Zyb21TdG9yZX0gY2xlYXIgLSBkZWxldGUgVG9rZW5JbmZvIGZyb20gdGhlIGFwcCdzIGNlbnRyYWwgc3RvcmUuXG4gKi9cblxuLyoqXG4gKiBBY3F1aXJlcyBUb2tlbkluZm8gZnJvbSB0aGUgY29uc3VtZXIgYXBwJ3MgY2VudHJhbCBzdG9yZS5cbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gUmVhZFRva2VuSW5mb0Zyb21TdG9yZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBlcnIgaWYgc3RvcmUgcmVhZCBpc3N1ZSBvY2N1cnJlZCwgb3RoZXJ3aXNlIHByb3BhZ2F0ZXMgYSBUb2tlbkluZm8gb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBXcml0ZXMgVG9rZW5JbmZvIHRvIHRoZSBjb25zdW1lciBhcHAncyBjZW50cmFsIHN0b3JlXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IFdyaXRlVG9rZW5JbmZvVG9TdG9yZVxuICogQHBhcmFtIHtUb2tlbkluZm99IHRva2VuSW5mbyAtIHRoZSB0b2tlbiBpbmZvIHRvIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXJyIGlmIHN0b3JlIHdyaXRlIGlzc3VlIG9jY3VycmVkLCBvdGhlcndpc2UgcHJvcGFnYXRlcyBudWxsIGVyclxuICogIGFuZCBudWxsIHJlc3VsdCB0byBpbmRpY2F0ZSBzdWNjZXNzXG4gKi9cblxuLyoqXG4gKiBDbGVhcnMgVG9rZW5JbmZvIGZyb20gdGhlIGNvbnN1bWVyIGFwcCdzIGNlbnRyYWwgc3RvcmVcbiAqIEB0eXBlZGVmIHtGdW5jdGlvbn0gQ2xlYXJUb2tlbkluZm9Gcm9tU3RvcmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZXJyIGlmIHN0b3JlIGRlbGV0ZSBpc3N1ZSBvY2N1cnJlZCwgb3RoZXJ3aXNlIHByb3BhZ2F0ZXMgbnVsbCBlcnJcbiAqICBhbmQgbnVsbCByZXN1bHQgdG8gaW5kaWNhdGUgc3VjY2Vzc1xuICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcixcblx0dXRpbCA9IHJlcXVpcmUoJ3V0aWwnKSxcblx0cXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpLFxuXHRDb25maWcgPSByZXF1aXJlKCcuL3V0aWwvY29uZmlnJyksXG5cdEFQSVJlcXVlc3RNYW5hZ2VyID0gcmVxdWlyZSgnLi9hcGktcmVxdWVzdC1tYW5hZ2VyJyksXG5cdFRva2VuTWFuYWdlciA9IHJlcXVpcmUoJy4vdG9rZW4tbWFuYWdlcicpLFxuXHRCYXNpY0FQSVNlc3Npb24gPSByZXF1aXJlKCcuL3Nlc3Npb25zL2Jhc2ljLXNlc3Npb24nKSxcblx0UGVyc2lzdGVudEFQSVNlc3Npb24gPSByZXF1aXJlKCcuL3Nlc3Npb25zL3BlcnNpc3RlbnQtc2Vzc2lvbicpLFxuXHRBbm9ueW1vdXNBUElTZXNzaW9uID0gcmVxdWlyZSgnLi9zZXNzaW9ucy9hbm9ueW1vdXMtc2Vzc2lvbicpLFxuXHRBcHBBdXRoU2Vzc2lvbiA9IHJlcXVpcmUoJy4vc2Vzc2lvbnMvYXBwLWF1dGgtc2Vzc2lvbicpLFxuXHRCb3hDbGllbnQgPSByZXF1aXJlKCcuL2JveC1jbGllbnQnKSxcblx0V2ViaG9va3MgPSByZXF1aXJlKCcuL21hbmFnZXJzL3dlYmhvb2tzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIGJhY2tlbmQgTm9kZUpTIFNESyB0byBpbnRlcmFjdCB3aXRoIHRoZSBCb3ggVjIgQVBJLlxuICogVGhpcyBpcyB0aGUgc2luZ2xlIGVudHJ5IHBvaW50IGZvciBhbGwgU0RLIGNvbnN1bWVyIGludGVyYWN0aW9ucy4gVGhpcyBpcyB0aGUgb25seSBmaWxlIHRoYXQgYSAzcmQgcGFydHkgYXBwXG4gKiBzaG91bGQgcmVxdWlyZS4gQWxsIG90aGVyIGNvbXBvbmVudHMgYXJlIHByaXZhdGUgYW5kIHJlYWNoZWQgb3V0IHRvIHZpYSB0aGlzIGNvbXBvbmVudC5cbiAqIDEuIFByb3ZpZGVzIGdldHRlcnMgdG8gc3Bhd24gY2xpZW50IGluc3RhbmNlcyBmb3IgdXNlcnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQm94IEFQSS5cbiAqIDIuIFByb3ZpZGVzIG1hbnVhbCBjYXBhYmlsaXR5IHRvIGFjcXVpcmUgdG9rZW5zIHZpYSB0b2tlbiBncmFudCBlbmRwb2ludHMuXG4gKiAgICBIb3dldmVyLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgY2xpZW50cyB0byBkbyB0aGlzIGZvciB5b3UuXG4gKiAzLiBFbWl0cyBub3RpZmljYXRpb24gZXZlbnRzIGFib3V0IHJlbGV2YW50IHJlcXVlc3QvcmVzcG9uc2UgZXZlbnRzLiBVc2VmdWwgZm9yIGxvZ2dpbmcgQm94IEFQSSBpbnRlcmFjdGlvbnMuXG4gKiAgICBOb3RpZmljYXRpb24gZXZlbnRzOiByZXF1ZXN0IHJldHJpZXMsIGV4Y2VlZGluZyBtYXggcmV0cmllcywgcGVybWFuZW50IGZhaWx1cmVzLlxuICpcbiAqIEBwYXJhbSB7VXNlckNvbmZpZ3VyYXRpb25PcHRpb25zfSBwYXJhbXMgVXNlciBzZXR0aW5ncyB1c2VkIHRvIGluaXRpYWxpemUgYW5kIGN1c3RvbWl6ZSB0aGUgU0RLXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQm94U0RLTm9kZShwYXJhbXMpIHtcblx0RXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cblx0dmFyIGV2ZW50QnVzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdHZhciBzZWxmID0gdGhpcztcblx0ZXZlbnRCdXMub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0YXJncy51bnNoaWZ0KCdyZXNwb25zZScpO1xuXHRcdHNlbGYuZW1pdC5hcHBseShzZWxmLCBhcmdzKTtcblx0fSk7XG5cblxuXHQvLyBTZXR1cCB0aGUgY29uZmlndXJhdGlvbiB3aXRoIHRoZSBnaXZlbiBwYXJhbXNcblx0dGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHBhcmFtcyk7XG5cdHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG5cdHRoaXMuX3NldHVwKCk7XG59XG5cbnV0aWwuaW5oZXJpdHMoQm94U0RLTm9kZSwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBTZXR1cCB0aGUgU0RLIGluc3RhbmNlIGJ5IGluc3RhbnRpYXRpbmcgbmVjZXNzYXJ5IG9iamVjdHMgd2l0aCBjdXJyZW50XG4gKiBjb25maWd1cmF0aW9uIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZXZlbnRCdXMgVGhlIGV2ZW50IGJ1cyB0byB1c2VcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuQm94U0RLTm9kZS5wcm90b3R5cGUuX3NldHVwID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gSW5zdGFudGlhdGUgdGhlIHJlcXVlc3QgbWFuYWdlclxuXHR0aGlzLnJlcXVlc3RNYW5hZ2VyID0gbmV3IEFQSVJlcXVlc3RNYW5hZ2VyKHRoaXMuY29uZmlnLCB0aGlzLl9ldmVudEJ1cyk7XG5cblx0Ly8gSW5pdGlhbGl6ZSB0aGUgcmVzdCBvZiB0aGUgU0RLIHdpdGggdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb25cblx0dGhpcy50b2tlbk1hbmFnZXIgPSBuZXcgVG9rZW5NYW5hZ2VyKHRoaXMuY29uZmlnLCB0aGlzLnJlcXVlc3RNYW5hZ2VyKTtcblx0dGhpcy5hbm9ueW1vdXNTZXNzaW9uID0gbmV3IEFub255bW91c0FQSVNlc3Npb24odGhpcy5jb25maWcsIHRoaXMudG9rZW5NYW5hZ2VyKTtcbn07XG5cbi8qKlxuICogRXhwb3NlIHRoZSBCb3hDbGllbnQgcHJvcGVydHkgZW51bWVyYXRpb25zIHRvIHRoZSBTREsgYXMgYSB3aG9sZS4gVGhpcyBhbGxvd3NcbiAqIHRoZSBjb25zdW1lciB0byBhY2Nlc3MgYW5kIHVzZSB0aGVzZSB2YWx1ZXMgZnJvbSBhbnl3aGVyZSBpbiB0aGVpciBhcHBsaWNhdGlvblxuICogKGxpa2UgYSBoZWxwZXIpIGJ5IHJlcXVpcmluZyB0aGUgU0RLLCBpbnN0ZWFkIG9mIG5lZWRpbmcgdG8gcGFzcyB0aGUgY2xpZW50LlxuICovXG5Cb3hTREtOb2RlLnByb3RvdHlwZS5hY2Nlc3NMZXZlbHMgPSBCb3hDbGllbnQucHJvdG90eXBlLmFjY2Vzc0xldmVscztcbkJveFNES05vZGUuYWNjZXNzTGV2ZWxzID0gQm94U0RLTm9kZS5wcm90b3R5cGUuYWNjZXNzTGV2ZWxzO1xuQm94U0RLTm9kZS5wcm90b3R5cGUuY29sbGFib3JhdGlvblJvbGVzID0gQm94Q2xpZW50LnByb3RvdHlwZS5jb2xsYWJvcmF0aW9uUm9sZXM7XG5Cb3hTREtOb2RlLmNvbGxhYm9yYXRpb25Sb2xlcyA9IEJveFNES05vZGUucHJvdG90eXBlLmNvbGxhYm9yYXRpb25Sb2xlcztcbkJveFNES05vZGUucHJvdG90eXBlLkNVUlJFTlRfVVNFUl9JRCA9IEJveENsaWVudC5wcm90b3R5cGUuQ1VSUkVOVF9VU0VSX0lEO1xuQm94U0RLTm9kZS5DVVJSRU5UX1VTRVJfSUQgPSBCb3hTREtOb2RlLnByb3RvdHlwZS5DVVJSRU5UX1VTRVJfSUQ7XG5cbi8qKlxuICogR2V0cyB0aGUgQm94U0RLTm9kZSBpbnN0YW5jZSBieSBwYXNzaW5nIGJveEFwcFNldHRpbmdzIGpzb24gZG93bmxvYWRlZCBmcm9tIHRoZSBkZXZlbG9wZXIgY29uc29sZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXBwQ29uZmlnIGJveEFwcFNldHRpbmdzIG9iamVjdCByZXRyaWV2ZWQgZnJvbSBEZXYgQ29uc29sZS5cbiAqIEByZXR1cm5zIHtCb3hTREtOb2RlfSBhbiBpbnN0YW5jZSB0aGF0IGhhcyBiZWVuIHByZWNvbmZpZ3VyZWQgd2l0aCB0aGUgdmFsdWVzIGZyb20gdGhlIERldiBDb25zb2xlXG4gKi9cbkJveFNES05vZGUuZ2V0UHJlY29uZmlndXJlZEluc3RhbmNlID0gZnVuY3Rpb24oYXBwQ29uZmlnKSB7XG5cdGlmICh0eXBlb2YgYXBwQ29uZmlnLmJveEFwcFNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbmZpZ3VyYXRpb24gZG9lcyBub3QgaW5jbHVkZSBib3hBcHBTZXR0aW5ncyBvYmplY3QuJyk7XG5cdH1cblxuXHR2YXIgYm94QXBwU2V0dGluZ3MgPSBhcHBDb25maWcuYm94QXBwU2V0dGluZ3M7XG5cdHZhciB3ZWJob29rcyA9IGFwcENvbmZpZy53ZWJob29rcztcblx0aWYgKHR5cGVvZiB3ZWJob29rcyA9PT0gJ29iamVjdCcpIHtcblx0XHRXZWJob29rcy5zZXRTaWduYXR1cmVLZXlzKHdlYmhvb2tzLnByaW1hcnlLZXksIHdlYmhvb2tzLnNlY29uZGFyeUtleSk7XG5cdH1cblxuXHR2YXIgcGFyYW1zID0ge307XG5cdGlmICh0eXBlb2YgYm94QXBwU2V0dGluZ3MuY2xpZW50SUQgPT09ICdzdHJpbmcnKSB7XG5cdFx0cGFyYW1zLmNsaWVudElEID0gYm94QXBwU2V0dGluZ3MuY2xpZW50SUQ7XG5cdH1cblxuXHRpZiAodHlwZW9mIGJveEFwcFNldHRpbmdzLmNsaWVudFNlY3JldCA9PT0gJ3N0cmluZycpIHtcblx0XHRwYXJhbXMuY2xpZW50U2VjcmV0ID0gYm94QXBwU2V0dGluZ3MuY2xpZW50U2VjcmV0O1xuXHR9XG5cblx0Ly8gT25seSB0cnkgdG8gYXNzaWduIGFwcCBhdXRoIHNldHRpbmdzIGlmIHRoZXkgYXJlIHByZXNlbnRcblx0Ly8gU29tZSBjb25maWd1cmF0aW9ucyBkbyBub3QgaW5jbHVkZSB0aGVtIChidXQgbWlnaHQgaW5jbHVkZSBvdGhlciBpbmZvLCBlLmcuIHdlYmhvb2tzKVxuXHRpZiAodHlwZW9mIGJveEFwcFNldHRpbmdzLmFwcEF1dGggPT09ICdvYmplY3QnICYmIGJveEFwcFNldHRpbmdzLmFwcEF1dGgucHVibGljS2V5SUQpIHtcblxuXHRcdHZhciBhcHBBdXRoID0ge307XG5cdFx0Ly8gQXNzaWduIHB1YmxpY0tleUlEIHRvIGtleUlEXG5cdFx0YXBwQXV0aC5rZXlJRCA9IGJveEFwcFNldHRpbmdzLmFwcEF1dGgucHVibGljS2V5SUQ7XG5cblx0XHRhcHBBdXRoLnByaXZhdGVLZXkgPSBib3hBcHBTZXR0aW5ncy5hcHBBdXRoLnByaXZhdGVLZXk7XG5cblx0XHR2YXIgcGFzc3BocmFzZSA9IGJveEFwcFNldHRpbmdzLmFwcEF1dGgucGFzc3BocmFzZTtcblx0XHRpZiAodHlwZW9mIHBhc3NwaHJhc2UgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRhcHBBdXRoLnBhc3NwaHJhc2UgPSBwYXNzcGhyYXNlO1xuXHRcdH1cblx0XHRwYXJhbXMuYXBwQXV0aCA9IGFwcEF1dGg7XG5cdH1cblxuXHRpZiAodHlwZW9mIGFwcENvbmZpZy5lbnRlcnByaXNlSUQgPT09ICdzdHJpbmcnKSB7XG5cdFx0cGFyYW1zLmVudGVycHJpc2VJRCA9IGFwcENvbmZpZy5lbnRlcnByaXNlSUQ7XG5cdH1cblxuXHRyZXR1cm4gbmV3IEJveFNES05vZGUocGFyYW1zKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgU0RLIGNvbmZpZ3VyYXRpb24gd2l0aCBuZXcgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1VzZXJDb25maWd1cmF0aW9uT3B0aW9uc30gcGFyYW1zIFVzZXIgc2V0dGluZ3NcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5Cb3hTREtOb2RlLnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0dGhpcy5jb25maWcgPSB0aGlzLmNvbmZpZy5leHRlbmQocGFyYW1zKTtcblx0dGhpcy5fc2V0dXAoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIEJveCBDbGllbnQgd2l0aCBhIEJhc2ljIEFQSSBTZXNzaW9uLiBUaGUgY2xpZW50IGlzIGFibGUgdG8gbWFrZSByZXF1ZXN0cyBvbiBiZWhhbGYgb2YgYSB1c2VyLlxuICogQSBiYXNpYyBzZXNzaW9uIGhhcyBubyBhY2Nlc3MgdG8gYSB1c2VyJ3MgcmVmcmVzaCB0b2tlbi4gQmVjYXVzZSBvZiB0aGlzLCBvbmNlIHRoZSBzZXNzaW9uJ3MgdG9rZW5zXG4gKiBleHBpcmUgdGhlIGNsaWVudCBjYW5ub3QgcmVjb3ZlciBhbmQgYSBuZXcgc2Vzc2lvbiB3aWxsIG5lZWQgdG8gYmUgZ2VuZXJhdGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiBBIHVzZXIncyBCb3ggQVBJIGFjY2VzcyB0b2tlblxuICogQHJldHVybnMge0JveENsaWVudH0gUmV0dXJucyBhIG5ldyBCb3ggQ2xpZW50IHBhaXJlZCB0byBhIG5ldyBCYXNpY0FQSVNlc3Npb25cbiAqL1xuQm94U0RLTm9kZS5wcm90b3R5cGUuZ2V0QmFzaWNDbGllbnQgPSBmdW5jdGlvbihhY2Nlc3NUb2tlbikge1xuXHR2YXIgYXBpU2Vzc2lvbiA9IG5ldyBCYXNpY0FQSVNlc3Npb24oYWNjZXNzVG9rZW4sIHRoaXMudG9rZW5NYW5hZ2VyKTtcblx0cmV0dXJuIG5ldyBCb3hDbGllbnQoYXBpU2Vzc2lvbiwgdGhpcy5jb25maWcsIHRoaXMucmVxdWVzdE1hbmFnZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgQm94IENsaWVudCB3aXRoIGEgQmFzaWMgQVBJIFNlc3Npb24uIFRoZSBjbGllbnQgaXMgYWJsZSB0byBtYWtlIHJlcXVlc3RzIG9uIGJlaGFsZiBvZiBhIHVzZXIuXG4gKiBBIGJhc2ljIHNlc3Npb24gaGFzIG5vIGFjY2VzcyB0byBhIHVzZXIncyByZWZyZXNoIHRva2VuLiBCZWNhdXNlIG9mIHRoaXMsIG9uY2UgdGhlIHNlc3Npb24ncyB0b2tlbnNcbiAqIGV4cGlyZSB0aGUgY2xpZW50IGNhbm5vdCByZWNvdmVyIGFuZCBhIG5ldyBzZXNzaW9uIHdpbGwgbmVlZCB0byBiZSBnZW5lcmF0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIEEgdXNlcidzIEJveCBBUEkgYWNjZXNzIHRva2VuXG4gKiBAcmV0dXJucyB7Qm94Q2xpZW50fSBSZXR1cm5zIGEgbmV3IEJveCBDbGllbnQgcGFpcmVkIHRvIGEgbmV3IEJhc2ljQVBJU2Vzc2lvblxuICovXG5Cb3hTREtOb2RlLmdldEJhc2ljQ2xpZW50ID0gZnVuY3Rpb24oYWNjZXNzVG9rZW4pIHtcblx0cmV0dXJuIG5ldyBCb3hTREtOb2RlKHtcblx0XHRjbGllbnRJRDogJycsXG5cdFx0Y2xpZW50U2VjcmV0OiAnJ1xuXHR9KS5nZXRCYXNpY0NsaWVudChhY2Nlc3NUb2tlbik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBCb3ggQ2xpZW50IHdpdGggYSBwZXJzaXN0ZW50IEFQSSBzZXNzaW9uLiBBIHBlcnNpc3RlbnQgQVBJIHNlc3Npb24gaGVscHMgbWFuYWdlIHRoZSB1c2VyJ3MgdG9rZW5zLFxuICogYW5kIGNhbiByZWZyZXNoIHRoZW0gYXV0b21hdGljYWxseSBpZiB0aGUgYWNjZXNzIHRva2VuIGV4cGlyZXMuIElmIGEgY2VudHJhbCBkYXRhLXN0b3JlIGlzIGdpdmVuLCB0aGUgc2Vzc2lvblxuICogY2FuIHJlYWQgJiB3cml0ZSB0b2tlbnMgdG8gaXQuXG4gKlxuICogQE5PVEU6IElmIHRva2VuSW5mbyBvciB0b2tlblN0b3JlIGFyZSBmb3JtYXR0ZWQgaW5jb3JyZWN0bHksIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgYW4gZXJyb3IuIElmIHlvdVxuICogaGF2ZW4ndCBleHBsaWNpdGx5IGNyZWF0ZWQgZWl0aGVyIG9mIHRoZXNlIG9iamVjdHMgb3IgYXJlIG90aGVyd2lzZSBub3QgY29tcGxldGx5IGNvbmZpZGVudCBpbiB0aGVpciB2YWxpZGl0eSxcbiAqIHlvdSBzaG91bGQgd3JhcCB5b3VyIGNhbGwgdG8gZ2V0UGVyc2lzdGVudENsaWVudCBpbiBhIHRyeS1jYXRjaCB0byBoYW5kbGUgYW55IHBvdGVudGlhbCBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtUb2tlbkluZm99IHRva2VuSW5mbyBBIHRva2VuSW5mbyBvYmplY3QgdG8gdXNlIGZvciBhdXRoZW50aWNhdGlvblxuICogQHBhcmFtIHtUb2tlblN0b3JlfSBbdG9rZW5TdG9yZV0gQW4gb3B0aW9uYWwgdG9rZW4gc3RvcmUgZm9yIHJlYWRpbmcvd3JpdGluZyB0b2tlbnMgdG8gc2Vzc2lvblxuICogQHJldHVybnMge0JveENsaWVudH0gUmV0dXJucyBhIG5ldyBCb3ggQ2xpZW50IHBhaXJlZCB0byBhIG5ldyBQZXJzaXN0ZW50QVBJU2Vzc2lvblxuICovXG5Cb3hTREtOb2RlLnByb3RvdHlwZS5nZXRQZXJzaXN0ZW50Q2xpZW50ID0gZnVuY3Rpb24odG9rZW5JbmZvLCB0b2tlblN0b3JlKSB7XG5cdHZhciBhcGlTZXNzaW9uID0gbmV3IFBlcnNpc3RlbnRBUElTZXNzaW9uKHRva2VuSW5mbywgdG9rZW5TdG9yZSwgdGhpcy5jb25maWcsIHRoaXMudG9rZW5NYW5hZ2VyKTtcblx0cmV0dXJuIG5ldyBCb3hDbGllbnQoYXBpU2Vzc2lvbiwgdGhpcy5jb25maWcsIHRoaXMucmVxdWVzdE1hbmFnZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEEgQm94IENsaWVudCB3aXRoIGFuIEFub255bW91cyBBUEkgU2Vzc2lvbi4gQW4gQW5vbnltb3VzIEFQSSBTZXNzaW9uIGhhcyBhY2Nlc3MgdG8gYW4gYW5vbnltb3VzXG4gKiBjbGllbnQtY3JlZGVudGlhbHMgdG9rZW4sIHdoaWNoIGlzbid0IHRpZWQgdG8gYW55IHNwZWNpZmljIHVzZXIuIEJlY2F1c2Ugb2YgdGhpcywgdGhlIGNsaWVudCB3aWxsIG9ubHlcbiAqIGhhdmUgYWNjZXNzIHRvIGVuZHBvaW50cyB0aGF0IGFsbG93IGNsaWVudC1jcmVkZW50aWFsIHRva2Vucy4gQWxsIEFub255bW91cyBBUEkgU2Vzc2lvbnMgc2hhcmUgdGhlXG4gKiBzYW1lIHRva2Vucywgd2hpY2ggYWxsb3dzIHRoZW0gdG8gcmVmcmVzaCB0aGVtIGVmZmljaWVudGx5IGFuZCByZWR1Y2UgbG9hZCBvbiBib3RoIHRoZSBhcHBsaWNhdGlvbiBhbmRcbiAqIHRoZSBBUEkuXG4gKlxuICogQHJldHVybnMge0JveENsaWVudH0gUmV0dXJucyBhIG5ldyBCb3ggQ2xpZW50IHBhaXJlZCB0byBhIEFub255bW91c0FQSVNlc3Npb25cbiAqL1xuQm94U0RLTm9kZS5wcm90b3R5cGUuZ2V0QW5vbnltb3VzQ2xpZW50ID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBuZXcgQm94Q2xpZW50KHRoaXMuYW5vbnltb3VzU2Vzc2lvbiwgdGhpcy5jb25maWcsIHRoaXMucmVxdWVzdE1hbmFnZXIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2xpZW50IHVzaW5nIEFwcCBBdXRoIGZvciB0aGUgZ2l2ZW4gZW50aXR5LiAgVGhpcyBhbGxvd3MgZWl0aGVyXG4gKiBtYW5hZ2luZyBBcHAgVXNlcnMgKGFzIHRoZSBlbnRlcnByaXNlKSBvciBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgYXMgdGhlIEFwcFxuICogVXNlcnMgdGhlbXNlbHZlcyAoYXMgYSB1c2VyKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBlbnRpdHkgdG8gb3BlcmF0ZSBhcywgXCJlbnRlcnByaXNlXCIgb3IgXCJ1c2VyXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgQm94IElEIG9mIHRoZSBlbnRpdHkgdG8gb3BlcmF0ZSBhc1xuICogQHBhcmFtIHtUb2tlblN0b3JlfSBbdG9rZW5TdG9yZV0gKE9wdGlvbmFsKSB0aGUgdG9rZW4gc3RvcmUgdG8gdXNlIGZvciBjYWNoaW5nIHRva2Vuc1xuICogQHJldHVybnMge0JveENsaWVudH0gQSBuZXcgY2xpZW50IGF1dGhvcml6ZWQgYXMgdGhlIGFwcCB1c2VyIG9yIGVudGVycHJpc2VcbiAqL1xuQm94U0RLTm9kZS5wcm90b3R5cGUuZ2V0QXBwQXV0aENsaWVudCA9IGZ1bmN0aW9uKHR5cGUsIGlkLCB0b2tlblN0b3JlKSB7XG5cdGlmICh0eXBlID09PSAnZW50ZXJwcmlzZScgJiYgIWlkKSB7XG5cdFx0aWYgKHRoaXMuY29uZmlnLmVudGVycHJpc2VJRCkge1xuXHRcdFx0aWQgPSB0aGlzLmNvbmZpZy5lbnRlcnByaXNlSUQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRW50ZXJwcmlzZSBJRCBtdXN0IGJlIHBhc3NlZCcpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBhcHBBdXRoU2Vzc2lvbiA9IG5ldyBBcHBBdXRoU2Vzc2lvbih0eXBlLCBpZCwgdGhpcy5jb25maWcsIHRoaXMudG9rZW5NYW5hZ2VyLCB0b2tlblN0b3JlKTtcblx0cmV0dXJuIG5ldyBCb3hDbGllbnQoYXBwQXV0aFNlc3Npb24sIHRoaXMuY29uZmlnLCB0aGlzLnJlcXVlc3RNYW5hZ2VyKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIFVSTCBmb3IgdGhlIGF1dGhvcml6ZSBwYWdlIHRvIHNlbmQgdXNlcnMgdG8gZm9yIHRoZSBmaXJzdCBsZWcgb2ZcbiAqIHRoZSBPQXV0aDIgZmxvdy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBPQXV0aDIgcGFyYW1ldGVyc1xuICogQHJldHVybnMge3N0cmluZ30gVGhlIGF1dGhvcml6ZSBwYWdlIFVSTFxuICovXG5Cb3hTREtOb2RlLnByb3RvdHlwZS5nZXRBdXRob3JpemVVUkwgPSBmdW5jdGlvbihwYXJhbXMpIHtcblxuXHRwYXJhbXMuY2xpZW50X2lkID0gdGhpcy5jb25maWcuY2xpZW50SUQ7XG5cblx0cmV0dXJuIGAke3RoaXMuY29uZmlnLmF1dGhvcml6ZVJvb3RVUkx9L29hdXRoMi9hdXRob3JpemU/JHtxcy5zdHJpbmdpZnkocGFyYW1zKX1gO1xufTtcblxuLyoqXG4gKiBBY3F1aXJlcyB0b2tlbiBpbmZvIHVzaW5nIGFuIGF1dGhvcml6YXRpb24gY29kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdXRob3JpemF0aW9uQ29kZSAtIGF1dGhvcml6YXRpb24gY29kZSBpc3N1ZWQgYnkgQm94XG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXSAtIFNldHMgb3B0aW9uYWwgYmVoYXZpb3IgZm9yIHRoZSB0b2tlbiBncmFudCwgbnVsbCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHBhc3NlZCBhIFRva2VuSW5mbyBvYmplY3QgaWYgdG9rZW5zIHdlcmUgZ3JhbnRlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZvXG4gKi9cbkJveFNES05vZGUucHJvdG90eXBlLmdldFRva2Vuc0F1dGhvcml6YXRpb25Db2RlR3JhbnQgPSBmdW5jdGlvbihhdXRob3JpemF0aW9uQ29kZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0cmV0dXJuIHRoaXMudG9rZW5NYW5hZ2VyLmdldFRva2Vuc0F1dGhvcml6YXRpb25Db2RlR3JhbnQoYXV0aG9yaXphdGlvbkNvZGUsIG9wdGlvbnMpXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZWZyZXNoZXMgdGhlIGFjY2VzcyBhbmQgcmVmcmVzaCB0b2tlbnMgZm9yIGEgZ2l2ZW4gcmVmcmVzaCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmcmVzaFRva2VuIC0gQSB2YWxpZCBPQXV0aCByZWZyZXNoIHRva2VuXG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXSAtIFNldHMgb3B0aW9uYWwgYmVoYXZpb3IgZm9yIHRoZSB0b2tlbiBncmFudCwgbnVsbCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHBhc3NlZCBhIFRva2VuSW5mbyBvYmplY3QgaWYgdG9rZW5zIHdlcmUgZ3JhbnRlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZvXG4gKi9cbkJveFNES05vZGUucHJvdG90eXBlLmdldFRva2Vuc1JlZnJlc2hHcmFudCA9IGZ1bmN0aW9uKHJlZnJlc2hUb2tlbiwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSBudWxsO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMudG9rZW5NYW5hZ2VyLmdldFRva2Vuc1JlZnJlc2hHcmFudChyZWZyZXNoVG9rZW4sIG9wdGlvbnMpXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXRzIHRva2VucyBmb3IgZW50ZXJwcmlzZSBhZG1pbmlzdHJhdGlvbiBvZiBhcHAgdXNlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcnByaXNlSUQgVGhlIElEIG9mIHRoZSBlbnRlcnByaXNlIHRvIGdlbmVyYXRlIGEgdG9rZW4gZm9yXG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXSAtIFNldHMgb3B0aW9uYWwgYmVoYXZpb3IgZm9yIHRoZSB0b2tlbiBncmFudCwgbnVsbCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBQYXNzZWQgdGhlIHRva2VucyBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkluZm8+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgdG9rZW4gaW5mb1xuICovXG5Cb3hTREtOb2RlLnByb3RvdHlwZS5nZXRFbnRlcnByaXNlQXBwQXV0aFRva2VucyA9IGZ1bmN0aW9uKGVudGVycHJpc2VJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSBudWxsO1xuXHR9XG5cblx0aWYgKCFlbnRlcnByaXNlSUQpIHtcblx0XHRpZiAodGhpcy5jb25maWcuZW50ZXJwcmlzZUlEKSB7XG5cdFx0XHRlbnRlcnByaXNlSUQgPSB0aGlzLmNvbmZpZy5lbnRlcnByaXNlSUQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignRW50ZXJwcmlzZSBpZCBtdXN0IGJlIHBhc3NlZCcpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0aGlzLnRva2VuTWFuYWdlci5nZXRUb2tlbnNKV1RHcmFudCgnZW50ZXJwcmlzZScsIGVudGVycHJpc2VJRCwgb3B0aW9ucylcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldHMgdG9rZW5zIGZvciBBcHAgVXNlcnMgdmlhIGEgSldUIGdyYW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklEIFRoZSBJRCBvZiB0aGUgQXBwIFVzZXIgdG8gZ2VuZXJhdGUgYSB0b2tlbiBmb3JcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50LCBudWxsIGZvciBkZWZhdWx0IGJlaGF2aW9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgdG9rZW5zIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VudEluZm8+fSBQcm9taXNlIHJlb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZwXG4gKi9cbkJveFNES05vZGUucHJvdG90eXBlLmdldEFwcFVzZXJUb2tlbnMgPSBmdW5jdGlvbih1c2VySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0gbnVsbDtcblx0fVxuXG5cdHJldHVybiB0aGlzLnRva2VuTWFuYWdlci5nZXRUb2tlbnNKV1RHcmFudCgndXNlcicsIHVzZXJJRCwgb3B0aW9ucylcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldm9rZXMgYSB0b2tlbiBwYWlyIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGFjY2VzcyBvciByZWZyZXNoIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIEEgdmFsaWQgYWNjZXNzIG9yIHJlZnJlc2ggdG9rZW4gdG8gcmV2b2tlXG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXSAtIFNldHMgb3B0aW9uYWwgYmVoYXZpb3IgZm9yIHRoZSB0b2tlbiBncmFudCwgbnVsbCBmb3IgZGVmYXVsdCBiZWhhdmlvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIElmIGVyciwgcmV2b2tlIGZhaWxlZC4gT3RoZXJ3aXNlLCByZXZva2Ugc3VjY2VlZGVkLlxuICogQHJldHVybnMge1Byb21pc2U8VG9rZW5JbmZvPn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRva2VuIGluZm9cbiAqL1xuQm94U0RLTm9kZS5wcm90b3R5cGUucmV2b2tlVG9rZW5zID0gZnVuY3Rpb24odG9rZW4sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0gbnVsbDtcblx0fVxuXG5cdHJldHVybiB0aGlzLnRva2VuTWFuYWdlci5yZXZva2VUb2tlbnModG9rZW4sIG9wdGlvbnMpXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgV2ViaG9va3MudmFsaWRhdGVNZXNzYWdlKCkgdG8gdGhlIFNESyBhcyBhIHdob2xlLiBUaGlzIGFsbG93c1xuICogdGhlIGNvbnN1bWVyIHRvIGNhbGwgQm94U0RLLnZhbGlkYXRlV2ViaG9va01lc3NhZ2UoKSBieSBqdXN0IHJlcXVpcmluZyB0aGUgU0RLLFxuICogaW5zdGVhZCBvZiBuZWVkaW5nIHRvIGNyZWF0ZSBhIGNsaWVudCAod2hpY2ggaXMgbm90IG5lZWRlZCB0byB2YWxpZGF0ZSBtZXNzYWdlcykuXG4gKi9cbkJveFNES05vZGUudmFsaWRhdGVXZWJob29rTWVzc2FnZSA9IFdlYmhvb2tzLnZhbGlkYXRlTWVzc2FnZTtcblxuLyoqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9ib3gtbm9kZS1zZGsgKi9cbm1vZHVsZS5leHBvcnRzID0gQm94U0RLTm9kZTtcbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwidXRpbCIsInFzIiwiQ29uZmlnIiwiQVBJUmVxdWVzdE1hbmFnZXIiLCJUb2tlbk1hbmFnZXIiLCJCYXNpY0FQSVNlc3Npb24iLCJQZXJzaXN0ZW50QVBJU2Vzc2lvbiIsIkFub255bW91c0FQSVNlc3Npb24iLCJBcHBBdXRoU2Vzc2lvbiIsIkJveENsaWVudCIsIldlYmhvb2tzIiwiQm94U0RLTm9kZSIsInBhcmFtcyIsImNhbGwiLCJldmVudEJ1cyIsInNlbGYiLCJvbiIsImFyZ3MiLCJzbGljZSIsImFyZ3VtZW50cyIsInVuc2hpZnQiLCJlbWl0IiwiYXBwbHkiLCJjb25maWciLCJfZXZlbnRCdXMiLCJfc2V0dXAiLCJpbmhlcml0cyIsInByb3RvdHlwZSIsInJlcXVlc3RNYW5hZ2VyIiwidG9rZW5NYW5hZ2VyIiwiYW5vbnltb3VzU2Vzc2lvbiIsImFjY2Vzc0xldmVscyIsImNvbGxhYm9yYXRpb25Sb2xlcyIsIkNVUlJFTlRfVVNFUl9JRCIsImdldFByZWNvbmZpZ3VyZWRJbnN0YW5jZSIsImFwcENvbmZpZyIsImJveEFwcFNldHRpbmdzIiwiVHlwZUVycm9yIiwid2ViaG9va3MiLCJzZXRTaWduYXR1cmVLZXlzIiwicHJpbWFyeUtleSIsInNlY29uZGFyeUtleSIsImNsaWVudElEIiwiY2xpZW50U2VjcmV0IiwiYXBwQXV0aCIsInB1YmxpY0tleUlEIiwia2V5SUQiLCJwcml2YXRlS2V5IiwicGFzc3BocmFzZSIsImVudGVycHJpc2VJRCIsImNvbmZpZ3VyZSIsImV4dGVuZCIsImdldEJhc2ljQ2xpZW50IiwiYWNjZXNzVG9rZW4iLCJhcGlTZXNzaW9uIiwiZ2V0UGVyc2lzdGVudENsaWVudCIsInRva2VuSW5mbyIsInRva2VuU3RvcmUiLCJnZXRBbm9ueW1vdXNDbGllbnQiLCJnZXRBcHBBdXRoQ2xpZW50IiwidHlwZSIsImlkIiwiRXJyb3IiLCJhcHBBdXRoU2Vzc2lvbiIsImdldEF1dGhvcml6ZVVSTCIsImNsaWVudF9pZCIsImF1dGhvcml6ZVJvb3RVUkwiLCJzdHJpbmdpZnkiLCJnZXRUb2tlbnNBdXRob3JpemF0aW9uQ29kZUdyYW50IiwiYXV0aG9yaXphdGlvbkNvZGUiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhc0NhbGxiYWNrIiwiZ2V0VG9rZW5zUmVmcmVzaEdyYW50IiwicmVmcmVzaFRva2VuIiwiZ2V0RW50ZXJwcmlzZUFwcEF1dGhUb2tlbnMiLCJnZXRUb2tlbnNKV1RHcmFudCIsImdldEFwcFVzZXJUb2tlbnMiLCJ1c2VySUQiLCJyZXZva2VUb2tlbnMiLCJ0b2tlbiIsInZhbGlkYXRlV2ViaG9va01lc3NhZ2UiLCJ2YWxpZGF0ZU1lc3NhZ2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/box-node-sdk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/chunked-uploader.js":
/*!***********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/chunked-uploader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Upload manager for large file uploads\n */ \nconst Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Chunk uploaded event\n * @event Chunk#uploaded\n * @param {UploadPart} data The data of the uploaded chunk\n * @private\n */ /**\n * Chunk error event\n * @event Chunk#error\n * @param {Error} err The error that occurred\n * @private\n */ /**\n * Event for when the upload is successfully aborted\n * @event ChunkedUploader#aborted\n */ /**\n * Event for when the abort fails because the upload session is not destroyed.\n * In general, the abort can be retried, and no new chunks will be uploaded.\n * @event ChunkedUploader#abortFailed\n * @param {Error} err The error that occurred\n */ /**\n * Event for when a chunk fails to upload.  Note that the chunk will automatically\n * retry until it is successfully uploaded.\n * @event ChunkedUploader#chunkError\n * @param {Error} err The error that occurred during chunk upload\n */ /**\n * Event for when a chunk is successfully uploaded\n * @event ChunkedUploader#chunkUploaded\n * @param {UploadPart} data The data for the uploaded chunk\n */ /**\n * Event for when the entire upload is complete\n * @event ChunkedUploader#uploadComplete\n * @param {Object} file The file object for the newly-uploaded file\n */ /**\n * Event for when an upload fails\n * @event ChunkedUploader#error\n * @param {Error} err The error that occurred\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter), ReadableStream = (__webpack_require__(/*! stream */ \"stream\").Readable), crypto = __webpack_require__(/*! crypto */ \"crypto\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nconst DEFAULT_OPTIONS = Object.freeze({\n    parallelism: 4,\n    retryInterval: 1000\n});\n/**\n * Chunk of a file to be uploaded, which handles trying to upload itself until\n * it succeeds.\n * @private\n */ class Chunk extends EventEmitter {\n    /**\n\t * Create a Chunk, representing a part of a file being uploaded\n\t * @param {BoxClient} client The Box SDK client\n\t * @param {string} sessionID The ID of the upload session the chunk belongs to\n\t * @param {Buffer|string} chunk The chunk that was uploaded\n\t * @param {int} offset The byte offset within the file where this chunk begins\n\t * @param {int} totalSize The total size of the file this chunk belongs to\n\t * @param {Object} options The options from the ChunkedUploader\n\t * @param {int} options.retryInterval The number of ms to wait before retrying a chunk upload\n\t */ constructor(client, sessionID, chunk, offset, totalSize, options){\n        super();\n        this.client = client;\n        this.sessionID = sessionID;\n        this.chunk = chunk;\n        this.length = chunk.length;\n        this.offset = offset;\n        this.totalSize = totalSize;\n        this.options = options;\n        this.data = null;\n        this.retry = null;\n        this.canceled = false;\n    }\n    /**\n\t * Get the final object representation of this chunk for the API\n\t * @returns {UploadPart} The chunk object\n\t */ getData() {\n        return this.data.part;\n    }\n    /**\n\t * Upload a chunk to the API\n\t * @returns {void}\n\t * @emits Chunk#uploaded\n\t * @emits Chunk#error\n\t */ upload() {\n        this.client.files.uploadPart(this.sessionID, this.chunk, this.offset, this.totalSize, (err, data)=>{\n            if (this.canceled) {\n                this.chunk = null;\n                return;\n            }\n            if (err) {\n                // handle the error or retry\n                if (err.statusCode) {\n                    // an API error, probably not retryable!\n                    this.emit(\"error\", err);\n                } else {\n                    // maybe a network error, retry\n                    this.retry = setTimeout(()=>this.upload(), this.options.retryInterval);\n                }\n                return;\n            }\n            // Record the chunk data for commit, and try to free up the chunk buffer\n            this.data = data;\n            this.chunk = null;\n            this.emit(\"uploaded\", data);\n        });\n    }\n    /**\n\t * Cancel trying to upload a chunk, preventing it from retrying and clearing\n\t * the associated buffer\n\t * @returns {void}\n\t */ cancel() {\n        clearTimeout(this.retry);\n        this.chunk = null;\n        this.canceled = true;\n    }\n}\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/** Manager for uploading a file in chunks */ class ChunkedUploader extends EventEmitter {\n    /**\n\t * Create an upload manager\n\t * @param {BoxClient} client The client to use to upload the file\n\t * @param {Object} uploadSessionInfo The upload session info to use for chunked upload\n\t * @param {ReadableStream|Buffer|string} file The file to upload\n\t * @param {int} size The size of the file to be uploaded\n\t * @param {Object} [options] Optional parameters\n\t * @param {int} [options.retryInterval=1000] The number of ms to wait before retrying operations\n\t * @param {int} [options.parallelism=4] The number of concurrent chunks to upload\n\t * @param {Object} [options.fileAttributes] Attributes to set on the file during commit\n\t */ constructor(client, uploadSessionInfo, file, size, options){\n        super();\n        this._client = client;\n        this._sessionID = uploadSessionInfo.id;\n        this._partSize = uploadSessionInfo.part_size;\n        this._uploadSessionInfo = uploadSessionInfo;\n        if (file instanceof ReadableStream) {\n            // Pause the stream so we can read specific chunks from it\n            this._stream = file.pause();\n            this._streamBuffer = [];\n        } else if (file instanceof Buffer || typeof file === \"string\") {\n            this._file = file;\n        } else {\n            throw new TypeError(\"file must be a Stream, Buffer, or string!\");\n        }\n        this._size = size;\n        this._options = Object.assign({}, DEFAULT_OPTIONS, options);\n        this._isStarted = false;\n        this._numChunksInFlight = 0;\n        this._chunks = [];\n        this._position = 0;\n        this._fileHash = crypto.createHash(\"sha1\");\n    }\n    /**\n\t * Start an upload\n\t * @returns {Promise<Object>} A promise resolving to the uploaded file\n\t */ start() {\n        if (this._isStarted) {\n            return this._promise;\n        }\n        // Create the initial chunks\n        for(let i = 0; i < this._options.parallelism; i++){\n            this._getNextChunk((chunk)=>chunk ? this._uploadChunk(chunk) : this._commit());\n        }\n        this._isStarted = true;\n        /* eslint-disable promise/avoid-new */ this._promise = new Promise((resolve, reject)=>{\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        /* eslint-enable promise/avoid-new */ return this._promise;\n    }\n    /**\n\t * Abort a running upload, which cancels all currently uploading chunks,\n\t * attempts to free up held memory, and aborts the upload session.  This\n\t * cannot be undone or resumed.\n\t * @returns {Promise} A promise resolving when the upload is aborted\n\t * @emits ChunkedUploader#aborted\n\t * @emits ChunkedUploader#abortFailed\n\t */ abort() {\n        this._chunks.forEach((chunk)=>chunk.removeAllListeners().cancel());\n        this._chunks = [];\n        this._file = null;\n        this._stream = null;\n        return this._client.files.abortUploadSession(this._sessionID)/* eslint-disable promise/always-return */ .then(()=>{\n            this.emit(\"aborted\");\n        })/* eslint-enable promise/always-return */ .catch((err)=>{\n            this.emit(\"abortFailed\", err);\n            throw err;\n        });\n    }\n    /**\n\t * Get the next chunk of the file to be uploaded\n\t * @param {Function} callback Called with the next chunk of the file to be uploaded\n\t * @returns {void}\n\t * @private\n\t */ _getNextChunk(callback) {\n        if (this._position >= this._size) {\n            callback(null);\n            return;\n        }\n        let buf;\n        if (this._file) {\n            // Buffer/string case, just get the slice we need\n            buf = this._file.slice(this._position, this._position + this._partSize);\n        } else if (this._streamBuffer.length > 0) {\n            buf = this._streamBuffer.shift();\n        } else {\n            // Stream case, need to read\n            buf = this._stream.read(this._partSize);\n            if (!buf) {\n                // stream needs to read more, retry later\n                setImmediate(()=>this._getNextChunk(callback));\n                return;\n            } else if (buf.length > this._partSize) {\n                // stream is done reading and had extra data, buffer the remainder of the file\n                for(let i = 0; i < buf.length; i += this._partSize){\n                    this._streamBuffer.push(buf.slice(i, i + this._partSize));\n                }\n                buf = this._streamBuffer.shift();\n            }\n        }\n        this._fileHash.update(buf);\n        let chunk = new Chunk(this._client, this._sessionID, buf, this._position, this._size, this._options);\n        this._position += buf.length;\n        callback(chunk);\n    }\n    /**\n\t * Upload a chunk\n\t * @param {Chunk} chunk The chunk to upload\n\t * @returns {void}\n\t * @emits ChunkedUploader#chunkError\n\t * @emits ChunkedUploader#chunkUploaded\n\t */ _uploadChunk(chunk) {\n        this._numChunksInFlight += 1;\n        chunk.on(\"error\", (err)=>this.emit(\"chunkError\", err));\n        chunk.on(\"uploaded\", (data)=>{\n            this._numChunksInFlight -= 1;\n            this.emit(\"chunkUploaded\", data);\n            this._getNextChunk((nextChunk)=>nextChunk ? this._uploadChunk(nextChunk) : this._commit());\n        });\n        chunk.upload();\n        this._chunks.push(chunk);\n    }\n    /**\n\t * Commit the upload, finalizing it\n\t * @returns {void}\n\t * @emits ChunkedUploader#uploadComplete\n\t * @emits ChunkedUploader#error\n\t */ _commit() {\n        if (!this._isStarted || this._numChunksInFlight > 0) {\n            return;\n        }\n        let hash = this._fileHash.digest(\"base64\");\n        this._isStarted = false;\n        let options = Object.assign({\n            parts: this._chunks.map((c)=>c.getData())\n        }, this._options.fileAttributes);\n        this._client.files.commitUploadSession(this._sessionID, hash, options, (err, file)=>{\n            // It's not clear what the SDK can do here, so we just return the error and session info\n            // so users can retry if they wish\n            if (err) {\n                this.emit(\"error\", {\n                    uploadSession: this._uploadSessionInfo,\n                    error: err\n                });\n                this._reject(err);\n                return;\n            }\n            this.emit(\"uploadComplete\", file);\n            this._resolve(file);\n        });\n    }\n}\nmodule.exports = ChunkedUploader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9jaHVua2VkLXVwbG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV4QixnRkFBZ0Y7QUFDaEYsV0FBVztBQUNYLGdGQUFnRjtBQUVoRjs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBRUQ7OztDQUdDLEdBRUQ7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7O0NBSUMsR0FFRDs7OztDQUlDLEdBRUQ7Ozs7Q0FJQyxHQUVELGdGQUFnRjtBQUNoRixlQUFlO0FBQ2YsZ0ZBQWdGO0FBRWhGLE1BQU1DLGVBQWVELDBEQUE4QixFQUNsREUsaUJBQWlCRixzREFBMEIsRUFDM0NJLFNBQVNKLG1CQUFPQSxDQUFDO0FBRWxCLGdGQUFnRjtBQUNoRixVQUFVO0FBQ1YsZ0ZBQWdGO0FBRWhGLE1BQU1LLGtCQUFrQkMsT0FBT0MsTUFBTSxDQUFDO0lBQ3JDQyxhQUFhO0lBQ2JDLGVBQWU7QUFDaEI7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsY0FBY1Q7SUFFbkI7Ozs7Ozs7OztFQVNDLEdBQ0RVLFlBQVlDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxPQUFPLENBQUU7UUFFakUsS0FBSztRQUVMLElBQUksQ0FBQ0wsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNJLE1BQU0sR0FBR0osTUFBTUksTUFBTTtRQUMxQixJQUFJLENBQUNILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0MsUUFB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Q1I7Z0JBQ0EsSUFBSSxDQUFDd0MsT0FBTyxDQUFDeEM7Z0JBQ2I7WUFDRDtZQUVBLElBQUksQ0FBQ0UsSUFBSSxDQUFDLGtCQUFrQk07WUFDNUIsSUFBSSxDQUFDK0IsUUFBUSxDQUFDL0I7UUFDZjtJQUNEO0FBRUQ7QUFFQTBELE9BQU9DLE9BQU8sR0FBRzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9jaHVua2VkLXVwbG9hZGVyLmpzPzNjNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVwbG9hZCBtYW5hZ2VyIGZvciBsYXJnZSBmaWxlIHVwbG9hZHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZWRlZnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQ2h1bmsgdXBsb2FkZWQgZXZlbnRcbiAqIEBldmVudCBDaHVuayN1cGxvYWRlZFxuICogQHBhcmFtIHtVcGxvYWRQYXJ0fSBkYXRhIFRoZSBkYXRhIG9mIHRoZSB1cGxvYWRlZCBjaHVua1xuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIENodW5rIGVycm9yIGV2ZW50XG4gKiBAZXZlbnQgQ2h1bmsjZXJyb3JcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdGhhdCBvY2N1cnJlZFxuICogQHByaXZhdGVcbiAqL1xuXG4vKipcbiAqIEV2ZW50IGZvciB3aGVuIHRoZSB1cGxvYWQgaXMgc3VjY2Vzc2Z1bGx5IGFib3J0ZWRcbiAqIEBldmVudCBDaHVua2VkVXBsb2FkZXIjYWJvcnRlZFxuICovXG5cbi8qKlxuICogRXZlbnQgZm9yIHdoZW4gdGhlIGFib3J0IGZhaWxzIGJlY2F1c2UgdGhlIHVwbG9hZCBzZXNzaW9uIGlzIG5vdCBkZXN0cm95ZWQuXG4gKiBJbiBnZW5lcmFsLCB0aGUgYWJvcnQgY2FuIGJlIHJldHJpZWQsIGFuZCBubyBuZXcgY2h1bmtzIHdpbGwgYmUgdXBsb2FkZWQuXG4gKiBAZXZlbnQgQ2h1bmtlZFVwbG9hZGVyI2Fib3J0RmFpbGVkXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRoYXQgb2NjdXJyZWRcbiAqL1xuXG4vKipcbiAqIEV2ZW50IGZvciB3aGVuIGEgY2h1bmsgZmFpbHMgdG8gdXBsb2FkLiAgTm90ZSB0aGF0IHRoZSBjaHVuayB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIHJldHJ5IHVudGlsIGl0IGlzIHN1Y2Nlc3NmdWxseSB1cGxvYWRlZC5cbiAqIEBldmVudCBDaHVua2VkVXBsb2FkZXIjY2h1bmtFcnJvclxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkIGR1cmluZyBjaHVuayB1cGxvYWRcbiAqL1xuXG4vKipcbiAqIEV2ZW50IGZvciB3aGVuIGEgY2h1bmsgaXMgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkXG4gKiBAZXZlbnQgQ2h1bmtlZFVwbG9hZGVyI2NodW5rVXBsb2FkZWRcbiAqIEBwYXJhbSB7VXBsb2FkUGFydH0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHVwbG9hZGVkIGNodW5rXG4gKi9cblxuLyoqXG4gKiBFdmVudCBmb3Igd2hlbiB0aGUgZW50aXJlIHVwbG9hZCBpcyBjb21wbGV0ZVxuICogQGV2ZW50IENodW5rZWRVcGxvYWRlciN1cGxvYWRDb21wbGV0ZVxuICogQHBhcmFtIHtPYmplY3R9IGZpbGUgVGhlIGZpbGUgb2JqZWN0IGZvciB0aGUgbmV3bHktdXBsb2FkZWQgZmlsZVxuICovXG5cbi8qKlxuICogRXZlbnQgZm9yIHdoZW4gYW4gdXBsb2FkIGZhaWxzXG4gKiBAZXZlbnQgQ2h1bmtlZFVwbG9hZGVyI2Vycm9yXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yIHRoYXQgb2NjdXJyZWRcbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXIsXG5cdFJlYWRhYmxlU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGUsXG5cdGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9PUFRJT05TID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBhcmFsbGVsaXNtOiA0LFxuXHRyZXRyeUludGVydmFsOiAxMDAwXG59KTtcblxuLyoqXG4gKiBDaHVuayBvZiBhIGZpbGUgdG8gYmUgdXBsb2FkZWQsIHdoaWNoIGhhbmRsZXMgdHJ5aW5nIHRvIHVwbG9hZCBpdHNlbGYgdW50aWxcbiAqIGl0IHN1Y2NlZWRzLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2h1bmsgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBDaHVuaywgcmVwcmVzZW50aW5nIGEgcGFydCBvZiBhIGZpbGUgYmVpbmcgdXBsb2FkZWRcblx0ICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCBUaGUgQm94IFNESyBjbGllbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JRCBUaGUgSUQgb2YgdGhlIHVwbG9hZCBzZXNzaW9uIHRoZSBjaHVuayBiZWxvbmdzIHRvXG5cdCAqIEBwYXJhbSB7QnVmZmVyfHN0cmluZ30gY2h1bmsgVGhlIGNodW5rIHRoYXQgd2FzIHVwbG9hZGVkXG5cdCAqIEBwYXJhbSB7aW50fSBvZmZzZXQgVGhlIGJ5dGUgb2Zmc2V0IHdpdGhpbiB0aGUgZmlsZSB3aGVyZSB0aGlzIGNodW5rIGJlZ2luc1xuXHQgKiBAcGFyYW0ge2ludH0gdG90YWxTaXplIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBmaWxlIHRoaXMgY2h1bmsgYmVsb25ncyB0b1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmcm9tIHRoZSBDaHVua2VkVXBsb2FkZXJcblx0ICogQHBhcmFtIHtpbnR9IG9wdGlvbnMucmV0cnlJbnRlcnZhbCBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIGEgY2h1bmsgdXBsb2FkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihjbGllbnQsIHNlc3Npb25JRCwgY2h1bmssIG9mZnNldCwgdG90YWxTaXplLCBvcHRpb25zKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG5cdFx0dGhpcy5zZXNzaW9uSUQgPSBzZXNzaW9uSUQ7XG5cdFx0dGhpcy5jaHVuayA9IGNodW5rO1xuXHRcdHRoaXMubGVuZ3RoID0gY2h1bmsubGVuZ3RoO1xuXHRcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdHRoaXMudG90YWxTaXplID0gdG90YWxTaXplO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5kYXRhID0gbnVsbDtcblx0XHR0aGlzLnJldHJ5ID0gbnVsbDtcblx0XHR0aGlzLmNhbmNlbGVkID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBmaW5hbCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjaHVuayBmb3IgdGhlIEFQSVxuXHQgKiBAcmV0dXJucyB7VXBsb2FkUGFydH0gVGhlIGNodW5rIG9iamVjdFxuXHQgKi9cblx0Z2V0RGF0YSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmRhdGEucGFydDtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGxvYWQgYSBjaHVuayB0byB0aGUgQVBJXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKiBAZW1pdHMgQ2h1bmsjdXBsb2FkZWRcblx0ICogQGVtaXRzIENodW5rI2Vycm9yXG5cdCAqL1xuXHR1cGxvYWQoKSB7XG5cblx0XHR0aGlzLmNsaWVudC5maWxlcy51cGxvYWRQYXJ0KHRoaXMuc2Vzc2lvbklELCB0aGlzLmNodW5rLCB0aGlzLm9mZnNldCwgdGhpcy50b3RhbFNpemUsIChlcnIsIGRhdGEpID0+IHtcblxuXHRcdFx0aWYgKHRoaXMuY2FuY2VsZWQpIHtcblx0XHRcdFx0dGhpcy5jaHVuayA9IG51bGw7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHQvLyBoYW5kbGUgdGhlIGVycm9yIG9yIHJldHJ5XG5cdFx0XHRcdGlmIChlcnIuc3RhdHVzQ29kZSkge1xuXHRcdFx0XHRcdC8vIGFuIEFQSSBlcnJvciwgcHJvYmFibHkgbm90IHJldHJ5YWJsZSFcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBtYXliZSBhIG5ldHdvcmsgZXJyb3IsIHJldHJ5XG5cdFx0XHRcdFx0dGhpcy5yZXRyeSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGxvYWQoKSwgdGhpcy5vcHRpb25zLnJldHJ5SW50ZXJ2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjb3JkIHRoZSBjaHVuayBkYXRhIGZvciBjb21taXQsIGFuZCB0cnkgdG8gZnJlZSB1cCB0aGUgY2h1bmsgYnVmZmVyXG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdFx0dGhpcy5jaHVuayA9IG51bGw7XG5cdFx0XHR0aGlzLmVtaXQoJ3VwbG9hZGVkJywgZGF0YSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ2FuY2VsIHRyeWluZyB0byB1cGxvYWQgYSBjaHVuaywgcHJldmVudGluZyBpdCBmcm9tIHJldHJ5aW5nIGFuZCBjbGVhcmluZ1xuXHQgKiB0aGUgYXNzb2NpYXRlZCBidWZmZXJcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRjYW5jZWwoKSB7XG5cblx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXRyeSk7XG5cdFx0dGhpcy5jaHVuayA9IG51bGw7XG5cdFx0dGhpcy5jYW5jZWxlZCA9IHRydWU7XG5cdH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqIE1hbmFnZXIgZm9yIHVwbG9hZGluZyBhIGZpbGUgaW4gY2h1bmtzICovXG5jbGFzcyBDaHVua2VkVXBsb2FkZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gdXBsb2FkIG1hbmFnZXJcblx0ICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCBUaGUgY2xpZW50IHRvIHVzZSB0byB1cGxvYWQgdGhlIGZpbGVcblx0ICogQHBhcmFtIHtPYmplY3R9IHVwbG9hZFNlc3Npb25JbmZvIFRoZSB1cGxvYWQgc2Vzc2lvbiBpbmZvIHRvIHVzZSBmb3IgY2h1bmtlZCB1cGxvYWRcblx0ICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbXxCdWZmZXJ8c3RyaW5nfSBmaWxlIFRoZSBmaWxlIHRvIHVwbG9hZFxuXHQgKiBAcGFyYW0ge2ludH0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcblx0ICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnJldHJ5SW50ZXJ2YWw9MTAwMF0gVGhlIG51bWJlciBvZiBtcyB0byB3YWl0IGJlZm9yZSByZXRyeWluZyBvcGVyYXRpb25zXG5cdCAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5wYXJhbGxlbGlzbT00XSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgY2h1bmtzIHRvIHVwbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmlsZUF0dHJpYnV0ZXNdIEF0dHJpYnV0ZXMgdG8gc2V0IG9uIHRoZSBmaWxlIGR1cmluZyBjb21taXRcblx0ICovXG5cdGNvbnN0cnVjdG9yKGNsaWVudCwgdXBsb2FkU2Vzc2lvbkluZm8sIGZpbGUsIHNpemUsIG9wdGlvbnMpIHtcblxuXHRcdHN1cGVyKCk7XG5cblx0XHR0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG5cdFx0dGhpcy5fc2Vzc2lvbklEID0gdXBsb2FkU2Vzc2lvbkluZm8uaWQ7XG5cdFx0dGhpcy5fcGFydFNpemUgPSB1cGxvYWRTZXNzaW9uSW5mby5wYXJ0X3NpemU7XG5cdFx0dGhpcy5fdXBsb2FkU2Vzc2lvbkluZm8gPSB1cGxvYWRTZXNzaW9uSW5mbztcblxuXHRcdGlmIChmaWxlIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcblx0XHRcdC8vIFBhdXNlIHRoZSBzdHJlYW0gc28gd2UgY2FuIHJlYWQgc3BlY2lmaWMgY2h1bmtzIGZyb20gaXRcblx0XHRcdHRoaXMuX3N0cmVhbSA9IGZpbGUucGF1c2UoKTtcblx0XHRcdHRoaXMuX3N0cmVhbUJ1ZmZlciA9IFtdO1xuXHRcdH0gZWxzZSBpZiAoZmlsZSBpbnN0YW5jZW9mIEJ1ZmZlciB8fCB0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRoaXMuX2ZpbGUgPSBmaWxlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIG11c3QgYmUgYSBTdHJlYW0sIEJ1ZmZlciwgb3Igc3RyaW5nIScpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NpemUgPSBzaXplO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5faXNTdGFydGVkID0gZmFsc2U7XG5cdFx0dGhpcy5fbnVtQ2h1bmtzSW5GbGlnaHQgPSAwO1xuXHRcdHRoaXMuX2NodW5rcyA9IFtdO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gMDtcblx0XHR0aGlzLl9maWxlSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGExJyk7XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnQgYW4gdXBsb2FkXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwbG9hZGVkIGZpbGVcblx0ICovXG5cdHN0YXJ0KCkge1xuXG5cdFx0aWYgKHRoaXMuX2lzU3RhcnRlZCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3Byb21pc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBpbml0aWFsIGNodW5rc1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb3B0aW9ucy5wYXJhbGxlbGlzbTsgaSsrKSB7XG5cdFx0XHR0aGlzLl9nZXROZXh0Q2h1bmsoY2h1bmsgPT4gKGNodW5rID8gdGhpcy5fdXBsb2FkQ2h1bmsoY2h1bmspIDogdGhpcy5fY29tbWl0KCkpKTtcblx0XHR9XG5cdFx0dGhpcy5faXNTdGFydGVkID0gdHJ1ZTtcblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIHByb21pc2UvYXZvaWQtbmV3ICovXG5cdFx0dGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0dGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuXHRcdH0pO1xuXHRcdC8qIGVzbGludC1lbmFibGUgcHJvbWlzZS9hdm9pZC1uZXcgKi9cblxuXHRcdHJldHVybiB0aGlzLl9wcm9taXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFib3J0IGEgcnVubmluZyB1cGxvYWQsIHdoaWNoIGNhbmNlbHMgYWxsIGN1cnJlbnRseSB1cGxvYWRpbmcgY2h1bmtzLFxuXHQgKiBhdHRlbXB0cyB0byBmcmVlIHVwIGhlbGQgbWVtb3J5LCBhbmQgYWJvcnRzIHRoZSB1cGxvYWQgc2Vzc2lvbi4gIFRoaXNcblx0ICogY2Fubm90IGJlIHVuZG9uZSBvciByZXN1bWVkLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSB1cGxvYWQgaXMgYWJvcnRlZFxuXHQgKiBAZW1pdHMgQ2h1bmtlZFVwbG9hZGVyI2Fib3J0ZWRcblx0ICogQGVtaXRzIENodW5rZWRVcGxvYWRlciNhYm9ydEZhaWxlZFxuXHQgKi9cblx0YWJvcnQoKSB7XG5cblx0XHR0aGlzLl9jaHVua3MuZm9yRWFjaChjaHVuayA9PiBjaHVuay5yZW1vdmVBbGxMaXN0ZW5lcnMoKS5jYW5jZWwoKSk7XG5cdFx0dGhpcy5fY2h1bmtzID0gW107XG5cdFx0dGhpcy5fZmlsZSA9IG51bGw7XG5cdFx0dGhpcy5fc3RyZWFtID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLl9jbGllbnQuZmlsZXMuYWJvcnRVcGxvYWRTZXNzaW9uKHRoaXMuX3Nlc3Npb25JRClcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIHByb21pc2UvYWx3YXlzLXJldHVybiAqL1xuXHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHR0aGlzLmVtaXQoJ2Fib3J0ZWQnKTtcblx0XHRcdH0pXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIHByb21pc2UvYWx3YXlzLXJldHVybiAqL1xuXHRcdFx0LmNhdGNoKGVyciA9PiB7XG5cdFx0XHRcdHRoaXMuZW1pdCgnYWJvcnRGYWlsZWQnLCBlcnIpO1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIG5leHQgY2h1bmsgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdpdGggdGhlIG5leHQgY2h1bmsgb2YgdGhlIGZpbGUgdG8gYmUgdXBsb2FkZWRcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0TmV4dENodW5rKGNhbGxiYWNrKSB7XG5cblx0XHRpZiAodGhpcy5fcG9zaXRpb24gPj0gdGhpcy5fc2l6ZSkge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IGJ1ZjtcblxuXHRcdGlmICh0aGlzLl9maWxlKSB7XG5cblx0XHRcdC8vIEJ1ZmZlci9zdHJpbmcgY2FzZSwganVzdCBnZXQgdGhlIHNsaWNlIHdlIG5lZWRcblx0XHRcdGJ1ZiA9IHRoaXMuX2ZpbGUuc2xpY2UodGhpcy5fcG9zaXRpb24sIHRoaXMuX3Bvc2l0aW9uICsgdGhpcy5fcGFydFNpemUpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fc3RyZWFtQnVmZmVyLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0YnVmID0gdGhpcy5fc3RyZWFtQnVmZmVyLnNoaWZ0KCk7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gU3RyZWFtIGNhc2UsIG5lZWQgdG8gcmVhZFxuXHRcdFx0YnVmID0gdGhpcy5fc3RyZWFtLnJlYWQodGhpcy5fcGFydFNpemUpO1xuXG5cdFx0XHRpZiAoIWJ1Zikge1xuXHRcdFx0XHQvLyBzdHJlYW0gbmVlZHMgdG8gcmVhZCBtb3JlLCByZXRyeSBsYXRlclxuXHRcdFx0XHRzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZ2V0TmV4dENodW5rKGNhbGxiYWNrKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoYnVmLmxlbmd0aCA+IHRoaXMuX3BhcnRTaXplKSB7XG5cblx0XHRcdFx0Ly8gc3RyZWFtIGlzIGRvbmUgcmVhZGluZyBhbmQgaGFkIGV4dHJhIGRhdGEsIGJ1ZmZlciB0aGUgcmVtYWluZGVyIG9mIHRoZSBmaWxlXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSB0aGlzLl9wYXJ0U2l6ZSkge1xuXG5cdFx0XHRcdFx0dGhpcy5fc3RyZWFtQnVmZmVyLnB1c2goYnVmLnNsaWNlKGksIGkgKyB0aGlzLl9wYXJ0U2l6ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJ1ZiA9IHRoaXMuX3N0cmVhbUJ1ZmZlci5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2ZpbGVIYXNoLnVwZGF0ZShidWYpO1xuXHRcdGxldCBjaHVuayA9IG5ldyBDaHVuayh0aGlzLl9jbGllbnQsIHRoaXMuX3Nlc3Npb25JRCwgYnVmLCB0aGlzLl9wb3NpdGlvbiwgdGhpcy5fc2l6ZSwgdGhpcy5fb3B0aW9ucyk7XG5cdFx0dGhpcy5fcG9zaXRpb24gKz0gYnVmLmxlbmd0aDtcblx0XHRjYWxsYmFjayhjaHVuayk7XG5cdH1cblxuXHQvKipcblx0ICogVXBsb2FkIGEgY2h1bmtcblx0ICogQHBhcmFtIHtDaHVua30gY2h1bmsgVGhlIGNodW5rIHRvIHVwbG9hZFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQGVtaXRzIENodW5rZWRVcGxvYWRlciNjaHVua0Vycm9yXG5cdCAqIEBlbWl0cyBDaHVua2VkVXBsb2FkZXIjY2h1bmtVcGxvYWRlZFxuXHQgKi9cblx0X3VwbG9hZENodW5rKGNodW5rKSB7XG5cblx0XHR0aGlzLl9udW1DaHVua3NJbkZsaWdodCArPSAxO1xuXG5cdFx0Y2h1bmsub24oJ2Vycm9yJywgZXJyID0+IHRoaXMuZW1pdCgnY2h1bmtFcnJvcicsIGVycikpO1xuXHRcdGNodW5rLm9uKCd1cGxvYWRlZCcsIGRhdGEgPT4ge1xuXG5cdFx0XHR0aGlzLl9udW1DaHVua3NJbkZsaWdodCAtPSAxO1xuXG5cdFx0XHR0aGlzLmVtaXQoJ2NodW5rVXBsb2FkZWQnLCBkYXRhKTtcblx0XHRcdHRoaXMuX2dldE5leHRDaHVuayhuZXh0Q2h1bmsgPT4gKG5leHRDaHVuayA/IHRoaXMuX3VwbG9hZENodW5rKG5leHRDaHVuaykgOiB0aGlzLl9jb21taXQoKSkpO1xuXHRcdH0pO1xuXHRcdGNodW5rLnVwbG9hZCgpO1xuXHRcdHRoaXMuX2NodW5rcy5wdXNoKGNodW5rKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb21taXQgdGhlIHVwbG9hZCwgZmluYWxpemluZyBpdFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQGVtaXRzIENodW5rZWRVcGxvYWRlciN1cGxvYWRDb21wbGV0ZVxuXHQgKiBAZW1pdHMgQ2h1bmtlZFVwbG9hZGVyI2Vycm9yXG5cdCAqL1xuXHRfY29tbWl0KCkge1xuXG5cdFx0aWYgKCF0aGlzLl9pc1N0YXJ0ZWQgfHwgdGhpcy5fbnVtQ2h1bmtzSW5GbGlnaHQgPiAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IGhhc2ggPSB0aGlzLl9maWxlSGFzaC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXHRcdHRoaXMuX2lzU3RhcnRlZCA9IGZhbHNlO1xuXHRcdGxldCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0XHRwYXJ0czogdGhpcy5fY2h1bmtzLm1hcChjID0+IGMuZ2V0RGF0YSgpKVxuXHRcdH0sIHRoaXMuX29wdGlvbnMuZmlsZUF0dHJpYnV0ZXMpO1xuXHRcdHRoaXMuX2NsaWVudC5maWxlcy5jb21taXRVcGxvYWRTZXNzaW9uKHRoaXMuX3Nlc3Npb25JRCwgaGFzaCwgb3B0aW9ucywgKGVyciwgZmlsZSkgPT4ge1xuXG5cdFx0XHQvLyBJdCdzIG5vdCBjbGVhciB3aGF0IHRoZSBTREsgY2FuIGRvIGhlcmUsIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBlcnJvciBhbmQgc2Vzc2lvbiBpbmZvXG5cdFx0XHQvLyBzbyB1c2VycyBjYW4gcmV0cnkgaWYgdGhleSB3aXNoXG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdHRoaXMuZW1pdCgnZXJyb3InLCB7XG5cdFx0XHRcdFx0dXBsb2FkU2Vzc2lvbjogdGhpcy5fdXBsb2FkU2Vzc2lvbkluZm8sXG5cdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGhpcy5fcmVqZWN0KGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbWl0KCd1cGxvYWRDb21wbGV0ZScsIGZpbGUpO1xuXHRcdFx0dGhpcy5fcmVzb2x2ZShmaWxlKTtcblx0XHR9KTtcblx0fVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2h1bmtlZFVwbG9hZGVyO1xuIl0sIm5hbWVzIjpbIlByb21pc2UiLCJyZXF1aXJlIiwiRXZlbnRFbWl0dGVyIiwiUmVhZGFibGVTdHJlYW0iLCJSZWFkYWJsZSIsImNyeXB0byIsIkRFRkFVTFRfT1BUSU9OUyIsIk9iamVjdCIsImZyZWV6ZSIsInBhcmFsbGVsaXNtIiwicmV0cnlJbnRlcnZhbCIsIkNodW5rIiwiY29uc3RydWN0b3IiLCJjbGllbnQiLCJzZXNzaW9uSUQiLCJjaHVuayIsIm9mZnNldCIsInRvdGFsU2l6ZSIsIm9wdGlvbnMiLCJsZW5ndGgiLCJkYXRhIiwicmV0cnkiLCJjYW5jZWxlZCIsImdldERhdGEiLCJwYXJ0IiwidXBsb2FkIiwiZmlsZXMiLCJ1cGxvYWRQYXJ0IiwiZXJyIiwic3RhdHVzQ29kZSIsImVtaXQiLCJzZXRUaW1lb3V0IiwiY2FuY2VsIiwiY2xlYXJUaW1lb3V0IiwiQ2h1bmtlZFVwbG9hZGVyIiwidXBsb2FkU2Vzc2lvbkluZm8iLCJmaWxlIiwic2l6ZSIsIl9jbGllbnQiLCJfc2Vzc2lvbklEIiwiaWQiLCJfcGFydFNpemUiLCJwYXJ0X3NpemUiLCJfdXBsb2FkU2Vzc2lvbkluZm8iLCJfc3RyZWFtIiwicGF1c2UiLCJfc3RyZWFtQnVmZmVyIiwiQnVmZmVyIiwiX2ZpbGUiLCJUeXBlRXJyb3IiLCJfc2l6ZSIsIl9vcHRpb25zIiwiYXNzaWduIiwiX2lzU3RhcnRlZCIsIl9udW1DaHVua3NJbkZsaWdodCIsIl9jaHVua3MiLCJfcG9zaXRpb24iLCJfZmlsZUhhc2giLCJjcmVhdGVIYXNoIiwic3RhcnQiLCJfcHJvbWlzZSIsImkiLCJfZ2V0TmV4dENodW5rIiwiX3VwbG9hZENodW5rIiwiX2NvbW1pdCIsInJlc29sdmUiLCJyZWplY3QiLCJfcmVzb2x2ZSIsIl9yZWplY3QiLCJhYm9ydCIsImZvckVhY2giLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJhYm9ydFVwbG9hZFNlc3Npb24iLCJ0aGVuIiwiY2F0Y2giLCJjYWxsYmFjayIsImJ1ZiIsInNsaWNlIiwic2hpZnQiLCJyZWFkIiwic2V0SW1tZWRpYXRlIiwicHVzaCIsInVwZGF0ZSIsIm9uIiwibmV4dENodW5rIiwiaGFzaCIsImRpZ2VzdCIsInBhcnRzIiwibWFwIiwiYyIsImZpbGVBdHRyaWJ1dGVzIiwiY29tbWl0VXBsb2FkU2Vzc2lvbiIsInVwbG9hZFNlc3Npb24iLCJlcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/chunked-uploader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/enterprise-event-stream.js":
/*!******************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/enterprise-event-stream.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Enterprise event stream backed by the enterprise events API\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable), util = __webpack_require__(/*! util */ \"util\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nconst DEFAULT_OPTIONS = Object.freeze({\n    pollingInterval: 60,\n    chunkSize: 500\n}); // ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Stream of Box enterprise events.\n *\n * By default, the stream starts from the current time.\n * Pass 'startDate' to start from a specific time.\n * Pass 'streamPosition' to start from a previous stream position, or '0' for all available past events (~1 year).\n * Once the stream catches up to the current time, it will begin polling every 'pollingInterval' seconds.\n * If 'pollingInterval' = 0, then the stream will end when it catches up to the current time (no polling).\n *\n * @param {BoxClient} client - The client to use to get events\n * @param {Object} [options] - Options\n * @param {string} [options.streamPosition] - The stream position to start from (pass '0' for all past events)\n * @param {string} [options.startDate] - The date to start from\n * @param {string} [options.endDate] - The date to end at\n * @param {EventType[]} [options.eventTypeFilter] - Array of event types to return\n * @param {int} [options.pollingInterval=60] - Polling interval (in seconds).  Pass 0 for no polling.\n * @param {int} [options.chunkSize=500] - Number of events to fetch per call (max = 500)\n * @constructor\n * @extends Readable\n */ function EnterpriseEventStream(client, options) {\n    Readable.call(this, {\n        objectMode: true\n    });\n    /**\n\t * @var {BoxClient} - The client for making API calls\n\t * @private\n\t */ this._client = client;\n    /**\n\t * @var {Object} - Options\n\t * @private\n\t */ this._options = Object.assign({}, DEFAULT_OPTIONS, options);\n    // Handle the case where the caller passes streamPosition = 0 instead of streamPosition = '0'.\n    if (!this._options.startDate && !this._options.streamPosition && this._options.streamPosition !== 0) {\n        // If neither startDate nor streamPosition is specified, start from the current time.\n        this._options.startDate = new Date().toISOString().replace(/\\.000Z$/, \"-00:00\");\n    }\n    /**\n\t * @var {?string} - The current stream position\n\t * @private\n\t */ this._streamPosition = this._options.streamPosition;\n}\nutil.inherits(EnterpriseEventStream, Readable);\n/**\n * @returns {?string} - Returns null if no events have been fetched from Box yet.\n */ EnterpriseEventStream.prototype.getStreamPosition = function() {\n    return this._streamPosition;\n};\n/**\n * Get the stream state.\n *\n * @returns {Object} - The stream state\n */ EnterpriseEventStream.prototype.getStreamState = function() {\n    // We need to return both streamPosition and startDate, since streamPosition will be null until\n    // the first set of events is returned from Box.\n    return {\n        streamPosition: this._streamPosition,\n        startDate: this._options.startDate,\n        endDate: this._options.endDate,\n        eventTypeFilter: this._options.eventTypeFilter\n    };\n};\n/**\n * Set the stream state.\n *\n * @param {Object} state - The stream state\n * @returns {void}\n */ EnterpriseEventStream.prototype.setStreamState = function(state) {\n    // We need to set both streamPosition and startDate, since streamPosition will be null until\n    // the first set of events is returned from Box.\n    this._streamPosition = state.streamPosition;\n    this._options.startDate = state.startDate;\n    this._options.endDate = state.endDate;\n    this._options.eventTypeFilter = state.eventTypeFilter;\n};\n/**\n * Fetch the next chunk of events\n *\n * If there are no events, poll until events are available.\n * If an error occurs, emit the error but continuing polling as usual.\n * @param {Function} callback - Passed the array of events\n * @returns {void}\n * @private\n */ EnterpriseEventStream.prototype.fetchEvents = function(callback) {\n    const self = this, params = {\n        stream_type: \"admin_logs\"\n    };\n    // Use the current stream position.\n    // Handle the case where the caller passes streamPosition === 0 instead of streamPosition === '0'.\n    if (this._streamPosition || this._streamPosition === 0) {\n        params.stream_position = this._streamPosition;\n    }\n    if (this._options.startDate) {\n        params.created_after = this._options.startDate;\n    }\n    if (this._options.endDate) {\n        params.created_before = this._options.endDate;\n    }\n    if (this._options.eventTypeFilter) {\n        params.event_type = this._options.eventTypeFilter.join(\",\");\n    }\n    if (this._options.chunkSize) {\n        params.limit = this._options.chunkSize;\n    }\n    this._client.events.get(params, (err, result)=>{\n        if (err) {\n            self.emit(\"error\", err);\n        // If there was a \"permanent\" error, we would call the callback with it here.\n        // But it's not clear which errors are truly permanent?\n        // If Box is down or returning errors for an extended period, we still want to resume when it recovers.\n        // So, continue polling at the regular frequency.\n        // Don't use a shorter retry interval (to avoid DDOSing Box).\n        }\n        if (err || !result || !result.entries || result.entries.length === 0) {\n            if (!self._options.pollingInterval) {\n                // If polling is disabled, end the stream.\n                callback();\n                return;\n            }\n            // There were no events returned (or an error occurred), so schedule another poll.\n            const delay = self._options.pollingInterval * 1000;\n            // Stream readers can use this to flush buffered events to a downstream system.\n            self.emit(\"wait\", delay);\n            setTimeout(()=>{\n                self.fetchEvents(callback);\n            }, delay);\n            return;\n        }\n        // Only update the stream position if there were events returned.\n        // The API currently returns next_stream_position = 0 if there are no events (may be a bug?).\n        // But we don't want to start over at the beginning in that case, so ignore it.\n        self._streamPosition = result.next_stream_position;\n        // Notify the reader of the new stream position.\n        // Stream readers can respond to the 'newStreamState' event to persist the stream state.\n        self.emit(\"newStreamState\", self.getStreamState());\n        callback(null, result.entries);\n    });\n};\n/**\n * Implementation of the stream-internal read function.\tThis is called\n * by the stream whenever it needs more data, and will not be called again\n * until data is pushed into the stream.\n * @returns {void}\n * @private\n */ EnterpriseEventStream.prototype._read = function() {\n    // Fetch the next chunk of events.\n    const self = this;\n    // This will poll forever until events are available.\n    this.fetchEvents((err, events)=>{\n        if (err || !events || events.length === 0) {\n            // Close the stream if there was a \"permanent\" failure or we reached the end of the events.\n            self.push(null);\n            return;\n        }\n        // Pause the stream to avoid race conditions while pushing in the new events.\n        // Without this, _read() would be called again from inside each push(),\n        // resulting in multiple parallel calls to fetchEvents().\n        // See https://github.com/nodejs/node/issues/3203\n        const wasPaused = self.isPaused();\n        self.pause();\n        // Push all of the events into the stream.\n        events.forEach((event)=>{\n            self.push(event);\n        });\n        if (!wasPaused) {\n            // This will deliver the events and trigger the next call to _read() once they have been consumed.\n            self.resume();\n        }\n    });\n};\nmodule.exports = EnterpriseEventStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9lbnRlcnByaXNlLWV2ZW50LXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFFakYsTUFBTUEsV0FBV0Msc0RBQTBCLEVBQzFDQyxPQUFPRCxtQkFBT0EsQ0FBQztBQUVoQixpRkFBaUY7QUFDakYsVUFBVTtBQUNWLGlGQUFpRjtBQUVqRixNQUFNRSxrQkFBa0JDLE9BQU9DLE1BQU0sQ0FBQztJQUNyQ0MsaUJBQWlCO0lBQ2pCQyxXQUFXO0FBRVosSUFBRyxpRkFBaUY7QUFDcEYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELFNBQVNDLHNCQUFzQkMsTUFBTSxFQUFFQyxPQUFPO0lBRTdDVixTQUFTVyxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ25CQyxZQUFZO0lBQ2I7SUFFQTs7O0VBR0MsR0FDRCxJQUFJLENBQUNDLE9BQU8sR0FBR0o7SUFFZjs7O0VBR0MsR0FDRCxJQUFJLENBQUNLLFFBQVEsR0FBR1YsT0FBT1csTUFBTSxDQUFDLENBQUMsR0FBR1osaUJBQWlCTztJQUVuRCw4RkFBOEY7SUFDOUYsSUFBSSxDQUFDLElBQUksQ0FBQ0ksUUFBUSxDQUFDRSxTQUFTLElBQUksQ0FBQyxJQUFJLENBQUNGLFFBQVEsQ0FBQ0csY0FBYyxJQUFJLElBQUksQ0FBQ0gsUUFBUSxDQUFDRyxjQUFjLEtBQUssR0FBRztRQUNwRyxxRkFBcUY7UUFDckYsSUFBSSxDQUFDSCxRQUFRLENBQUNFLFNBQVMsR0FBRyxJQUFJRSxPQUFPQyxXQUFXLEdBQzlDQyxPQUFPLENBQUMsV0FBVztJQUN0QjtJQUVBOzs7RUFHQyxHQUNELElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ1AsUUFBUSxDQUFDRyxjQUFjO0FBQ3BEO0FBRUFmLEtBQUtvQixRQUFRLENBQUNkLHVCQUF1QlI7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N0YsK0VBQStFO1FBQy9FaEIsS0FBS1gsZUFBZSxHQUFHdUIsT0FBT00sb0JBQW9CO1FBRWxELGdEQUFnRDtRQUNoRCx3RkFBd0Y7UUFDeEZsQixLQUFLYSxJQUFJLENBQUMsa0JBQWtCYixLQUFLUCxjQUFjO1FBRS9DTSxTQUFTLE1BQU1hLE9BQU9FLE9BQU87SUFDOUI7QUFDRDtBQUVBOzs7Ozs7Q0FNQyxHQUNEdEMsc0JBQXNCZSxTQUFTLENBQUM0QixLQUFLLEdBQUc7SUFDdkMsa0NBQWtDO0lBQ2xDLE1BQU1uQixPQUFPLElBQUk7SUFFakIscURBQXFEO0lBQ3JELElBQUksQ0FBQ0YsV0FBVyxDQUFDLENBQUNhLEtBQUtGO1FBQ3RCLElBQUlFLE9BQU8sQ0FBQ0YsVUFBVUEsT0FBT00sTUFBTSxLQUFLLEdBQUc7WUFDMUMsMkZBQTJGO1lBQzNGZixLQUFLb0IsSUFBSSxDQUFDO1lBQ1Y7UUFDRDtRQUVBLDZFQUE2RTtRQUM3RSx1RUFBdUU7UUFDdkUseURBQXlEO1FBQ3pELGlEQUFpRDtRQUNqRCxNQUFNQyxZQUFZckIsS0FBS3NCLFFBQVE7UUFDL0J0QixLQUFLdUIsS0FBSztRQUVWLDBDQUEwQztRQUMxQ2QsT0FBT2UsT0FBTyxDQUFDQyxDQUFBQTtZQUNkekIsS0FBS29CLElBQUksQ0FBQ0s7UUFDWDtRQUVBLElBQUksQ0FBQ0osV0FBVztZQUNmLGtHQUFrRztZQUNsR3JCLEtBQUswQixNQUFNO1FBQ1o7SUFDRDtBQUNEO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9lbnRlcnByaXNlLWV2ZW50LXN0cmVhbS5qcz8yYzQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBFbnRlcnByaXNlIGV2ZW50IHN0cmVhbSBiYWNrZWQgYnkgdGhlIGVudGVycHJpc2UgZXZlbnRzIEFQSVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlLFxuXHR1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSBPYmplY3QuZnJlZXplKHtcblx0cG9sbGluZ0ludGVydmFsOiA2MCxcdC8vIHNlY29uZHNcblx0Y2h1bmtTaXplOiA1MDBcblxufSk7Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFN0cmVhbSBvZiBCb3ggZW50ZXJwcmlzZSBldmVudHMuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIHN0cmVhbSBzdGFydHMgZnJvbSB0aGUgY3VycmVudCB0aW1lLlxuICogUGFzcyAnc3RhcnREYXRlJyB0byBzdGFydCBmcm9tIGEgc3BlY2lmaWMgdGltZS5cbiAqIFBhc3MgJ3N0cmVhbVBvc2l0aW9uJyB0byBzdGFydCBmcm9tIGEgcHJldmlvdXMgc3RyZWFtIHBvc2l0aW9uLCBvciAnMCcgZm9yIGFsbCBhdmFpbGFibGUgcGFzdCBldmVudHMgKH4xIHllYXIpLlxuICogT25jZSB0aGUgc3RyZWFtIGNhdGNoZXMgdXAgdG8gdGhlIGN1cnJlbnQgdGltZSwgaXQgd2lsbCBiZWdpbiBwb2xsaW5nIGV2ZXJ5ICdwb2xsaW5nSW50ZXJ2YWwnIHNlY29uZHMuXG4gKiBJZiAncG9sbGluZ0ludGVydmFsJyA9IDAsIHRoZW4gdGhlIHN0cmVhbSB3aWxsIGVuZCB3aGVuIGl0IGNhdGNoZXMgdXAgdG8gdGhlIGN1cnJlbnQgdGltZSAobm8gcG9sbGluZykuXG4gKlxuICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCAtIFRoZSBjbGllbnQgdG8gdXNlIHRvIGdldCBldmVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3RyZWFtUG9zaXRpb25dIC0gVGhlIHN0cmVhbSBwb3NpdGlvbiB0byBzdGFydCBmcm9tIChwYXNzICcwJyBmb3IgYWxsIHBhc3QgZXZlbnRzKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0YXJ0RGF0ZV0gLSBUaGUgZGF0ZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kRGF0ZV0gLSBUaGUgZGF0ZSB0byBlbmQgYXRcbiAqIEBwYXJhbSB7RXZlbnRUeXBlW119IFtvcHRpb25zLmV2ZW50VHlwZUZpbHRlcl0gLSBBcnJheSBvZiBldmVudCB0eXBlcyB0byByZXR1cm5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw9NjBdIC0gUG9sbGluZyBpbnRlcnZhbCAoaW4gc2Vjb25kcykuICBQYXNzIDAgZm9yIG5vIHBvbGxpbmcuXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMuY2h1bmtTaXplPTUwMF0gLSBOdW1iZXIgb2YgZXZlbnRzIHRvIGZldGNoIHBlciBjYWxsIChtYXggPSA1MDApXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlYWRhYmxlXG4gKi9cbmZ1bmN0aW9uIEVudGVycHJpc2VFdmVudFN0cmVhbShjbGllbnQsIG9wdGlvbnMpIHtcblxuXHRSZWFkYWJsZS5jYWxsKHRoaXMsIHtcblx0XHRvYmplY3RNb2RlOiB0cnVlXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBAdmFyIHtCb3hDbGllbnR9IC0gVGhlIGNsaWVudCBmb3IgbWFraW5nIEFQSSBjYWxsc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGhpcy5fY2xpZW50ID0gY2xpZW50O1xuXG5cdC8qKlxuXHQgKiBAdmFyIHtPYmplY3R9IC0gT3B0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG5cblx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjYWxsZXIgcGFzc2VzIHN0cmVhbVBvc2l0aW9uID0gMCBpbnN0ZWFkIG9mIHN0cmVhbVBvc2l0aW9uID0gJzAnLlxuXHRpZiAoIXRoaXMuX29wdGlvbnMuc3RhcnREYXRlICYmICF0aGlzLl9vcHRpb25zLnN0cmVhbVBvc2l0aW9uICYmIHRoaXMuX29wdGlvbnMuc3RyZWFtUG9zaXRpb24gIT09IDApIHtcblx0XHQvLyBJZiBuZWl0aGVyIHN0YXJ0RGF0ZSBub3Igc3RyZWFtUG9zaXRpb24gaXMgc3BlY2lmaWVkLCBzdGFydCBmcm9tIHRoZSBjdXJyZW50IHRpbWUuXG5cdFx0dGhpcy5fb3B0aW9ucy5zdGFydERhdGUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcblx0XHRcdC5yZXBsYWNlKC9cXC4wMDBaJC8sICctMDA6MDAnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAdmFyIHs/c3RyaW5nfSAtIFRoZSBjdXJyZW50IHN0cmVhbSBwb3NpdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGhpcy5fc3RyZWFtUG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnN0cmVhbVBvc2l0aW9uO1xufVxuXG51dGlsLmluaGVyaXRzKEVudGVycHJpc2VFdmVudFN0cmVhbSwgUmVhZGFibGUpO1xuXG4vKipcbiAqIEByZXR1cm5zIHs/c3RyaW5nfSAtIFJldHVybnMgbnVsbCBpZiBubyBldmVudHMgaGF2ZSBiZWVuIGZldGNoZWQgZnJvbSBCb3ggeWV0LlxuICovXG5FbnRlcnByaXNlRXZlbnRTdHJlYW0ucHJvdG90eXBlLmdldFN0cmVhbVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLl9zdHJlYW1Qb3NpdGlvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHJlYW0gc3RhdGUuXG4gKlxuICogQHJldHVybnMge09iamVjdH0gLSBUaGUgc3RyZWFtIHN0YXRlXG4gKi9cbkVudGVycHJpc2VFdmVudFN0cmVhbS5wcm90b3R5cGUuZ2V0U3RyZWFtU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0Ly8gV2UgbmVlZCB0byByZXR1cm4gYm90aCBzdHJlYW1Qb3NpdGlvbiBhbmQgc3RhcnREYXRlLCBzaW5jZSBzdHJlYW1Qb3NpdGlvbiB3aWxsIGJlIG51bGwgdW50aWxcblx0Ly8gdGhlIGZpcnN0IHNldCBvZiBldmVudHMgaXMgcmV0dXJuZWQgZnJvbSBCb3guXG5cdHJldHVybiB7XG5cdFx0c3RyZWFtUG9zaXRpb246IHRoaXMuX3N0cmVhbVBvc2l0aW9uLFxuXHRcdHN0YXJ0RGF0ZTogdGhpcy5fb3B0aW9ucy5zdGFydERhdGUsXG5cdFx0ZW5kRGF0ZTogdGhpcy5fb3B0aW9ucy5lbmREYXRlLFxuXHRcdGV2ZW50VHlwZUZpbHRlcjogdGhpcy5fb3B0aW9ucy5ldmVudFR5cGVGaWx0ZXJcblx0fTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzdHJlYW0gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIC0gVGhlIHN0cmVhbSBzdGF0ZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbkVudGVycHJpc2VFdmVudFN0cmVhbS5wcm90b3R5cGUuc2V0U3RyZWFtU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHQvLyBXZSBuZWVkIHRvIHNldCBib3RoIHN0cmVhbVBvc2l0aW9uIGFuZCBzdGFydERhdGUsIHNpbmNlIHN0cmVhbVBvc2l0aW9uIHdpbGwgYmUgbnVsbCB1bnRpbFxuXHQvLyB0aGUgZmlyc3Qgc2V0IG9mIGV2ZW50cyBpcyByZXR1cm5lZCBmcm9tIEJveC5cblx0dGhpcy5fc3RyZWFtUG9zaXRpb24gPSBzdGF0ZS5zdHJlYW1Qb3NpdGlvbjtcblx0dGhpcy5fb3B0aW9ucy5zdGFydERhdGUgPSBzdGF0ZS5zdGFydERhdGU7XG5cdHRoaXMuX29wdGlvbnMuZW5kRGF0ZSA9IHN0YXRlLmVuZERhdGU7XG5cdHRoaXMuX29wdGlvbnMuZXZlbnRUeXBlRmlsdGVyID0gc3RhdGUuZXZlbnRUeXBlRmlsdGVyO1xufTtcblxuLyoqXG4gKiBGZXRjaCB0aGUgbmV4dCBjaHVuayBvZiBldmVudHNcbiAqXG4gKiBJZiB0aGVyZSBhcmUgbm8gZXZlbnRzLCBwb2xsIHVudGlsIGV2ZW50cyBhcmUgYXZhaWxhYmxlLlxuICogSWYgYW4gZXJyb3Igb2NjdXJzLCBlbWl0IHRoZSBlcnJvciBidXQgY29udGludWluZyBwb2xsaW5nIGFzIHVzdWFsLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBQYXNzZWQgdGhlIGFycmF5IG9mIGV2ZW50c1xuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5FbnRlcnByaXNlRXZlbnRTdHJlYW0ucHJvdG90eXBlLmZldGNoRXZlbnRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0Y29uc3Qgc2VsZiA9IHRoaXMsXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0c3RyZWFtX3R5cGU6ICdhZG1pbl9sb2dzJ1xuXHRcdH07XG5cblx0Ly8gVXNlIHRoZSBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbi5cblx0Ly8gSGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjYWxsZXIgcGFzc2VzIHN0cmVhbVBvc2l0aW9uID09PSAwIGluc3RlYWQgb2Ygc3RyZWFtUG9zaXRpb24gPT09ICcwJy5cblx0aWYgKHRoaXMuX3N0cmVhbVBvc2l0aW9uIHx8IHRoaXMuX3N0cmVhbVBvc2l0aW9uID09PSAwKSB7XG5cdFx0cGFyYW1zLnN0cmVhbV9wb3NpdGlvbiA9IHRoaXMuX3N0cmVhbVBvc2l0aW9uO1xuXHR9XG5cblx0aWYgKHRoaXMuX29wdGlvbnMuc3RhcnREYXRlKSB7XG5cdFx0cGFyYW1zLmNyZWF0ZWRfYWZ0ZXIgPSB0aGlzLl9vcHRpb25zLnN0YXJ0RGF0ZTtcblx0fVxuXG5cdGlmICh0aGlzLl9vcHRpb25zLmVuZERhdGUpIHtcblx0XHRwYXJhbXMuY3JlYXRlZF9iZWZvcmUgPSB0aGlzLl9vcHRpb25zLmVuZERhdGU7XG5cdH1cblxuXHRpZiAodGhpcy5fb3B0aW9ucy5ldmVudFR5cGVGaWx0ZXIpIHtcblx0XHRwYXJhbXMuZXZlbnRfdHlwZSA9IHRoaXMuX29wdGlvbnMuZXZlbnRUeXBlRmlsdGVyLmpvaW4oJywnKTtcblx0fVxuXG5cdGlmICh0aGlzLl9vcHRpb25zLmNodW5rU2l6ZSkge1xuXHRcdHBhcmFtcy5saW1pdCA9IHRoaXMuX29wdGlvbnMuY2h1bmtTaXplO1xuXHR9XG5cblx0dGhpcy5fY2xpZW50LmV2ZW50cy5nZXQocGFyYW1zLCAoZXJyLCByZXN1bHQpID0+IHtcblx0XHRpZiAoZXJyKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0XHRcdC8vIElmIHRoZXJlIHdhcyBhIFwicGVybWFuZW50XCIgZXJyb3IsIHdlIHdvdWxkIGNhbGwgdGhlIGNhbGxiYWNrIHdpdGggaXQgaGVyZS5cblx0XHRcdC8vIEJ1dCBpdCdzIG5vdCBjbGVhciB3aGljaCBlcnJvcnMgYXJlIHRydWx5IHBlcm1hbmVudD9cblx0XHRcdC8vIElmIEJveCBpcyBkb3duIG9yIHJldHVybmluZyBlcnJvcnMgZm9yIGFuIGV4dGVuZGVkIHBlcmlvZCwgd2Ugc3RpbGwgd2FudCB0byByZXN1bWUgd2hlbiBpdCByZWNvdmVycy5cblx0XHRcdC8vIFNvLCBjb250aW51ZSBwb2xsaW5nIGF0IHRoZSByZWd1bGFyIGZyZXF1ZW5jeS5cblx0XHRcdC8vIERvbid0IHVzZSBhIHNob3J0ZXIgcmV0cnkgaW50ZXJ2YWwgKHRvIGF2b2lkIERET1NpbmcgQm94KS5cblx0XHR9XG5cblx0XHRpZiAoZXJyIHx8ICFyZXN1bHQgfHwgIXJlc3VsdC5lbnRyaWVzIHx8IHJlc3VsdC5lbnRyaWVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0aWYgKCFzZWxmLl9vcHRpb25zLnBvbGxpbmdJbnRlcnZhbCkge1xuXHRcdFx0XHQvLyBJZiBwb2xsaW5nIGlzIGRpc2FibGVkLCBlbmQgdGhlIHN0cmVhbS5cblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGVyZSB3ZXJlIG5vIGV2ZW50cyByZXR1cm5lZCAob3IgYW4gZXJyb3Igb2NjdXJyZWQpLCBzbyBzY2hlZHVsZSBhbm90aGVyIHBvbGwuXG5cdFx0XHRjb25zdCBkZWxheSA9IHNlbGYuX29wdGlvbnMucG9sbGluZ0ludGVydmFsICogMTAwMDtcblxuXHRcdFx0Ly8gU3RyZWFtIHJlYWRlcnMgY2FuIHVzZSB0aGlzIHRvIGZsdXNoIGJ1ZmZlcmVkIGV2ZW50cyB0byBhIGRvd25zdHJlYW0gc3lzdGVtLlxuXHRcdFx0c2VsZi5lbWl0KCd3YWl0JywgZGVsYXkpO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0c2VsZi5mZXRjaEV2ZW50cyhjYWxsYmFjayk7XG5cdFx0XHR9LCBkZWxheSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25seSB1cGRhdGUgdGhlIHN0cmVhbSBwb3NpdGlvbiBpZiB0aGVyZSB3ZXJlIGV2ZW50cyByZXR1cm5lZC5cblx0XHQvLyBUaGUgQVBJIGN1cnJlbnRseSByZXR1cm5zIG5leHRfc3RyZWFtX3Bvc2l0aW9uID0gMCBpZiB0aGVyZSBhcmUgbm8gZXZlbnRzIChtYXkgYmUgYSBidWc/KS5cblx0XHQvLyBCdXQgd2UgZG9uJ3Qgd2FudCB0byBzdGFydCBvdmVyIGF0IHRoZSBiZWdpbm5pbmcgaW4gdGhhdCBjYXNlLCBzbyBpZ25vcmUgaXQuXG5cdFx0c2VsZi5fc3RyZWFtUG9zaXRpb24gPSByZXN1bHQubmV4dF9zdHJlYW1fcG9zaXRpb247XG5cblx0XHQvLyBOb3RpZnkgdGhlIHJlYWRlciBvZiB0aGUgbmV3IHN0cmVhbSBwb3NpdGlvbi5cblx0XHQvLyBTdHJlYW0gcmVhZGVycyBjYW4gcmVzcG9uZCB0byB0aGUgJ25ld1N0cmVhbVN0YXRlJyBldmVudCB0byBwZXJzaXN0IHRoZSBzdHJlYW0gc3RhdGUuXG5cdFx0c2VsZi5lbWl0KCduZXdTdHJlYW1TdGF0ZScsIHNlbGYuZ2V0U3RyZWFtU3RhdGUoKSk7XG5cblx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQuZW50cmllcyk7XG5cdH0pO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RyZWFtLWludGVybmFsIHJlYWQgZnVuY3Rpb24uXHRUaGlzIGlzIGNhbGxlZFxuICogYnkgdGhlIHN0cmVhbSB3aGVuZXZlciBpdCBuZWVkcyBtb3JlIGRhdGEsIGFuZCB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW5cbiAqIHVudGlsIGRhdGEgaXMgcHVzaGVkIGludG8gdGhlIHN0cmVhbS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHByaXZhdGVcbiAqL1xuRW50ZXJwcmlzZUV2ZW50U3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBGZXRjaCB0aGUgbmV4dCBjaHVuayBvZiBldmVudHMuXG5cdGNvbnN0IHNlbGYgPSB0aGlzO1xuXG5cdC8vIFRoaXMgd2lsbCBwb2xsIGZvcmV2ZXIgdW50aWwgZXZlbnRzIGFyZSBhdmFpbGFibGUuXG5cdHRoaXMuZmV0Y2hFdmVudHMoKGVyciwgZXZlbnRzKSA9PiB7XG5cdFx0aWYgKGVyciB8fCAhZXZlbnRzIHx8IGV2ZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdC8vIENsb3NlIHRoZSBzdHJlYW0gaWYgdGhlcmUgd2FzIGEgXCJwZXJtYW5lbnRcIiBmYWlsdXJlIG9yIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZXZlbnRzLlxuXHRcdFx0c2VsZi5wdXNoKG51bGwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFBhdXNlIHRoZSBzdHJlYW0gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdoaWxlIHB1c2hpbmcgaW4gdGhlIG5ldyBldmVudHMuXG5cdFx0Ly8gV2l0aG91dCB0aGlzLCBfcmVhZCgpIHdvdWxkIGJlIGNhbGxlZCBhZ2FpbiBmcm9tIGluc2lkZSBlYWNoIHB1c2goKSxcblx0XHQvLyByZXN1bHRpbmcgaW4gbXVsdGlwbGUgcGFyYWxsZWwgY2FsbHMgdG8gZmV0Y2hFdmVudHMoKS5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjAzXG5cdFx0Y29uc3Qgd2FzUGF1c2VkID0gc2VsZi5pc1BhdXNlZCgpO1xuXHRcdHNlbGYucGF1c2UoKTtcblxuXHRcdC8vIFB1c2ggYWxsIG9mIHRoZSBldmVudHMgaW50byB0aGUgc3RyZWFtLlxuXHRcdGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcblx0XHRcdHNlbGYucHVzaChldmVudCk7XG5cdFx0fSk7XG5cblx0XHRpZiAoIXdhc1BhdXNlZCkge1xuXHRcdFx0Ly8gVGhpcyB3aWxsIGRlbGl2ZXIgdGhlIGV2ZW50cyBhbmQgdHJpZ2dlciB0aGUgbmV4dCBjYWxsIHRvIF9yZWFkKCkgb25jZSB0aGV5IGhhdmUgYmVlbiBjb25zdW1lZC5cblx0XHRcdHNlbGYucmVzdW1lKCk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJwcmlzZUV2ZW50U3RyZWFtO1xuIl0sIm5hbWVzIjpbIlJlYWRhYmxlIiwicmVxdWlyZSIsInV0aWwiLCJERUZBVUxUX09QVElPTlMiLCJPYmplY3QiLCJmcmVlemUiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjaHVua1NpemUiLCJFbnRlcnByaXNlRXZlbnRTdHJlYW0iLCJjbGllbnQiLCJvcHRpb25zIiwiY2FsbCIsIm9iamVjdE1vZGUiLCJfY2xpZW50IiwiX29wdGlvbnMiLCJhc3NpZ24iLCJzdGFydERhdGUiLCJzdHJlYW1Qb3NpdGlvbiIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJfc3RyZWFtUG9zaXRpb24iLCJpbmhlcml0cyIsInByb3RvdHlwZSIsImdldFN0cmVhbVBvc2l0aW9uIiwiZ2V0U3RyZWFtU3RhdGUiLCJlbmREYXRlIiwiZXZlbnRUeXBlRmlsdGVyIiwic2V0U3RyZWFtU3RhdGUiLCJzdGF0ZSIsImZldGNoRXZlbnRzIiwiY2FsbGJhY2siLCJzZWxmIiwicGFyYW1zIiwic3RyZWFtX3R5cGUiLCJzdHJlYW1fcG9zaXRpb24iLCJjcmVhdGVkX2FmdGVyIiwiY3JlYXRlZF9iZWZvcmUiLCJldmVudF90eXBlIiwiam9pbiIsImxpbWl0IiwiZXZlbnRzIiwiZ2V0IiwiZXJyIiwicmVzdWx0IiwiZW1pdCIsImVudHJpZXMiLCJsZW5ndGgiLCJkZWxheSIsInNldFRpbWVvdXQiLCJuZXh0X3N0cmVhbV9wb3NpdGlvbiIsIl9yZWFkIiwicHVzaCIsIndhc1BhdXNlZCIsImlzUGF1c2VkIiwicGF1c2UiLCJmb3JFYWNoIiwiZXZlbnQiLCJyZXN1bWUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/enterprise-event-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/event-stream.js":
/*!*******************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/event-stream.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Event stream backed by the events API\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar Readable = (__webpack_require__(/*! stream */ \"stream\").Readable), qs = __webpack_require__(/*! querystring */ \"querystring\"), util = __webpack_require__(/*! util */ \"util\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nconst DEFAULT_OPTIONS = Object.freeze({\n    deduplicationFilterSize: 5000,\n    retryDelay: 1000,\n    fetchInterval: 1000\n});\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Stream of Box events from a given client and point in time.\n * @param {BoxClient} client The client to use to get events\n * @param {string} streamPosition The point in time to start at\n * @param {Object} [options] Optional parameters\n * @param {int} [options.retryDelay=1000] Number of ms to wait before retrying after an error\n * @param {int} [options.deduplicationFilterSize=5000] Number of IDs to track for deduplication\n * @param {int} [options.fetchInterval=1000] Minimunm number of ms between calls for more events\n * @constructor\n * @extends Readable\n */ function EventStream(client, streamPosition, options) {\n    Readable.call(this, {\n        objectMode: true\n    });\n    /**\n\t * @var {BoxClient} The client for making API calls\n\t * @private\n\t */ this._client = client;\n    /**\n\t * @var {string} The latest stream position\n\t * @private\n\t */ this._streamPosition = streamPosition;\n    /**\n\t * @var {?Object} The information for how to long poll\n\t * @private\n\t */ this._longPollInfo = null;\n    /**\n\t * @var {int} The number of long poll requests we've made against one URL so far\n\t * @private\n\t */ this._longPollRetries = 0;\n    /**\n\t * @var {Object.<string, boolean>} Hash of event IDs we've already pushed\n\t * @private\n\t */ this._dedupHash = {};\n    /**\n\t * Rate limiting promise to ensure that events are not fetched too often,\n\t * initially resolved to allow an immediate API call.\n\t * @var {Promise}\n\t * @private\n\t */ this._rateLimiter = Promise.resolve();\n    this._options = Object.assign({}, DEFAULT_OPTIONS, options);\n}\nutil.inherits(EventStream, Readable);\n/**\n * Retrieve the url and params for long polling for new updates\n * @returns {Promise} Promise for testing purposes\n * @private\n */ EventStream.prototype.getLongPollInfo = function() {\n    if (this.destroyed) {\n        return Promise.resolve(false);\n    }\n    return this._client.events.getLongPollInfo().then((longPollInfo)=>{\n        // On getting new long poll info, reset everything\n        this._longPollInfo = longPollInfo;\n        this._longPollRetries = 0;\n        return this.doLongPoll();\n    }).catch((err)=>{\n        this.emit(\"error\", err);\n        // Only retry on resolvable errors\n        if (!err.authExpired) {\n            this.retryPollInfo();\n        }\n    });\n};\n/**\n * Long poll for notification of new events.\tWe do this rather than\n * polling for the events directly in order to minimize the number of API\n * calls necessary.\n * @returns {Promise} Promise for testing pruposes\n * @private\n */ EventStream.prototype.doLongPoll = function() {\n    if (this.destroyed) {\n        return Promise.resolve(false);\n    }\n    // If we're over the max number of retries, reset\n    if (this._longPollRetries > this._longPollInfo.max_retries) {\n        return this.getLongPollInfo();\n    }\n    var url = this._longPollInfo.url, qsDelim = url.indexOf(\"?\"), query = {};\n    // Break out the query params, otherwise the request URL gets messed up\n    if (qsDelim > 0) {\n        query = qs.parse(url.substr(qsDelim + 1));\n        url = url.substr(0, qsDelim);\n    }\n    query.stream_position = this._streamPosition;\n    var options = {\n        qs: query,\n        timeout: this._longPollInfo.retry_timeout * 1000\n    };\n    this._longPollRetries += 1;\n    return this._client.wrapWithDefaultHandler(this._client.get)(url, options).then((data)=>{\n        if (this.destroyed) {\n            return false;\n        }\n        if (data.message === \"reconnect\") {\n            return this.getLongPollInfo();\n        }\n        // We don't expect any messages other than reconnect and new_change, so if\n        // we get one just retry the long poll\n        if (data.message !== \"new_change\") {\n            return this.doLongPoll();\n        }\n        return this.fetchEvents();\n    }).catch(()=>{\n        this.retryPollInfo();\n    });\n};\n/**\n * Retries long-polling after a delay.\n * Does not attempt if stream is already destroyed.\n * @returns {void}\n * @private\n */ EventStream.prototype.retryPollInfo = function() {\n    if (!this.destroyed) {\n        this._retryTimer = setTimeout(()=>this.getLongPollInfo(), this._options.retryDelay);\n    }\n};\n/**\n * Fetch the latest group of events and push them into the stream\n * @returns {Promise} Promise for testing purposes\n * @private\n */ EventStream.prototype.fetchEvents = function() {\n    if (this.destroyed) {\n        return Promise.resolve(false);\n    }\n    var eventParams = {\n        stream_position: this._streamPosition,\n        limit: 500\n    };\n    // Get new events after the rate limiter expires\n    return this._rateLimiter.then(()=>this._client.events.get(eventParams).then((events)=>{\n            // Reset the rate limiter\n            this._rateLimiter = Promise.delay(this._options.fetchInterval);\n            // If the response wasn't what we expected, re-poll\n            if (!events.entries || !events.next_stream_position) {\n                return this.doLongPoll();\n            }\n            this._streamPosition = events.next_stream_position;\n            // De-duplicate the fetched events, since the API often returns\n            // the same events at multiple subsequent stream positions\n            var newEvents = events.entries.filter((event)=>!this._dedupHash[event.event_id]);\n            // If there aren't any non-duplicate events, go back to polling\n            if (newEvents.length === 0) {\n                return this.doLongPoll();\n            }\n            // Pause the stream to avoid race conditions while pushing in the new events.\n            // Without this, _read() would be called again from inside each push(),\n            // resulting in multiple parallel calls to fetchEvents().\n            // See https://github.com/nodejs/node/issues/3203\n            var wasPaused = this.isPaused();\n            this.pause();\n            // Push new events into the stream\n            newEvents.forEach((event)=>{\n                this._dedupHash[event.event_id] = true;\n                this.push(event);\n            });\n            if (!wasPaused) {\n                // This will deliver the events and trigger the next call to _read() once they have been consumed.\n                this.resume();\n            }\n            // Once the deduplication filter gets too big, clean it up\n            if (Object.keys(this._dedupHash).length >= this._options.deduplicationFilterSize) {\n                this.cleanupDedupFilter(events.entries);\n            }\n            return true;\n        }).catch((err)=>{\n            this.emit(\"error\", err);\n            this.retryPollInfo();\n        }));\n};\n/**\n * Clean up the deduplication filter, to prevent it from growing\n * too big and eating up memory.\tWe look at the latest set of events\n * returned and assume that any IDs not in that set don't need to be\n * tracked for deduplication any more.\n * @param {Object[]} latestEvents The latest events from the API\n * @returns {void}\n * @private\n */ EventStream.prototype.cleanupDedupFilter = function(latestEvents) {\n    var dedupIDs = Object.keys(this._dedupHash);\n    dedupIDs.forEach((eventID)=>{\n        var isEventCleared = !latestEvents.find((e)=>e.event_id === eventID);\n        if (isEventCleared) {\n            delete this._dedupHash[eventID];\n        }\n    });\n};\n/**\n * Implementation of the stream-internal read function.\tThis is called\n * by the stream whenever it needs more data, and will not be called again\n * until data is pushed into the stream.\n * @returns {void}\n * @private\n */ EventStream.prototype._read = function() {\n    // Start the process of getting new events\n    this.getLongPollInfo();\n};\n/**\n * Implementation of stream-internal `_destroy` function (v8.0.0 and later).\n * Called by stream consumers to effectively stop polling via the public\n * `destroy()`.\n * @returns {void}\n * @private\n */ EventStream.prototype._destroy = function() {\n    clearTimeout(this._retryTimer);\n    delete this._retryTimer;\n};\n// backwards-compat for Node.js pre-v8.0.0\n/* istanbul ignore if */ if (typeof Readable.prototype.destroy !== \"function\") {\n    /**\n\t * Destroys the stream.  Rough polyfill for `Readable#destroy`.\n\t * @returns {void}\n\t * @public\n\t */ EventStream.prototype.destroy = function() {\n        if (!this.destroyed) {\n            process.nextTick(()=>{\n                this.emit(\"close\");\n            });\n            this.destroyed = true;\n            this._destroy();\n        }\n    };\n}\nmodule.exports = EventStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9ldmVudC1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBRWpGLElBQUlBLFdBQVdDLHNEQUEwQixFQUN4Q0MsS0FBS0QsbUJBQU9BLENBQUMsbUNBQ2JFLE9BQU9GLG1CQUFPQSxDQUFDLHFCQUNmRyxVQUFVSCxtQkFBT0EsQ0FBQztBQUVuQixpRkFBaUY7QUFDakYsVUFBVTtBQUNWLGlGQUFpRjtBQUVqRixNQUFNSSxrQkFBa0JDLE9BQU9DLE1BQU0sQ0FBQztJQUNyQ0MseUJBQXlCO0lBQ3pCQyxZQUFZO0lBQ1pDLGVBQWU7QUFDaEI7QUFFQSxpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0MsWUFBWUMsTUFBTSxFQUFFQyxjQUFjLEVBQUVDLE9BQU87SUFFbkRkLFNBQVNlLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDbkJDLFlBQVk7SUFDYjtJQUVBOzs7RUFHQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHTDtJQUVmOzs7RUFHQyxHQUNELElBQUksQ0FBQ00sZUFBZSxHQUFHTDtJQUV2Qjs7O0VBR0MsR0FDRCxJQUFJLENBQUNNLGFBQWEsR0FBRztJQUVyQjs7O0VBR0MsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHO0lBRXhCOzs7RUFHQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7SUFFbkI7Ozs7O0VBS0MsR0FDRCxJQUFJLENBQUNDLFlBQVksR0FBR2xCLFFBQVFtQixPQUFPO0lBRW5DLElBQUksQ0FBQ0MsUUFBUSxHQUFHbEIsT0FBT21CLE1BQU0sQ0FBQyxDQUFDLEdBQUdwQixpQkFBaUJTO0FBQ3BEO0FBRUFYLEtBQUt1QixRQUFRLENBQUNmLGFBQWFYO0FBRTNCOzs7O0NBSUMsR0FDRFcsWUFBWWdCLFNBQVMsQ0FBQ0Ms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QixJQUFJLENBQUNqRCxJQUFJLENBQUM7WUFDWDtZQUNBLElBQUksQ0FBQ1AsU0FBUyxHQUFHO1lBQ2pCLElBQUksQ0FBQ29ELFFBQVE7UUFDZDtJQUNEO0FBQ0Q7QUFFQUssT0FBT0MsT0FBTyxHQUFHNUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL2V2ZW50LXN0cmVhbS5qcz84NGU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBFdmVudCBzdHJlYW0gYmFja2VkIGJ5IHRoZSBldmVudHMgQVBJXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlLFxuXHRxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyksXG5cdHV0aWwgPSByZXF1aXJlKCd1dGlsJyksXG5cdFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVkdXBsaWNhdGlvbkZpbHRlclNpemU6IDUwMDAsXG5cdHJldHJ5RGVsYXk6IDEwMDAsXG5cdGZldGNoSW50ZXJ2YWw6IDEwMDBcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU3RyZWFtIG9mIEJveCBldmVudHMgZnJvbSBhIGdpdmVuIGNsaWVudCBhbmQgcG9pbnQgaW4gdGltZS5cbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgVGhlIGNsaWVudCB0byB1c2UgdG8gZ2V0IGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHN0cmVhbVBvc2l0aW9uIFRoZSBwb2ludCBpbiB0aW1lIHRvIHN0YXJ0IGF0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5yZXRyeURlbGF5PTEwMDBdIE51bWJlciBvZiBtcyB0byB3YWl0IGJlZm9yZSByZXRyeWluZyBhZnRlciBhbiBlcnJvclxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmRlZHVwbGljYXRpb25GaWx0ZXJTaXplPTUwMDBdIE51bWJlciBvZiBJRHMgdG8gdHJhY2sgZm9yIGRlZHVwbGljYXRpb25cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5mZXRjaEludGVydmFsPTEwMDBdIE1pbmltdW5tIG51bWJlciBvZiBtcyBiZXR3ZWVuIGNhbGxzIGZvciBtb3JlIGV2ZW50c1xuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWFkYWJsZVxuICovXG5mdW5jdGlvbiBFdmVudFN0cmVhbShjbGllbnQsIHN0cmVhbVBvc2l0aW9uLCBvcHRpb25zKSB7XG5cblx0UmVhZGFibGUuY2FsbCh0aGlzLCB7XG5cdFx0b2JqZWN0TW9kZTogdHJ1ZVxuXHR9KTtcblxuXHQvKipcblx0ICogQHZhciB7Qm94Q2xpZW50fSBUaGUgY2xpZW50IGZvciBtYWtpbmcgQVBJIGNhbGxzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aGlzLl9jbGllbnQgPSBjbGllbnQ7XG5cblx0LyoqXG5cdCAqIEB2YXIge3N0cmluZ30gVGhlIGxhdGVzdCBzdHJlYW0gcG9zaXRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRoaXMuX3N0cmVhbVBvc2l0aW9uID0gc3RyZWFtUG9zaXRpb247XG5cblx0LyoqXG5cdCAqIEB2YXIgez9PYmplY3R9IFRoZSBpbmZvcm1hdGlvbiBmb3IgaG93IHRvIGxvbmcgcG9sbFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0dGhpcy5fbG9uZ1BvbGxJbmZvID0gbnVsbDtcblxuXHQvKipcblx0ICogQHZhciB7aW50fSBUaGUgbnVtYmVyIG9mIGxvbmcgcG9sbCByZXF1ZXN0cyB3ZSd2ZSBtYWRlIGFnYWluc3Qgb25lIFVSTCBzbyBmYXJcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRoaXMuX2xvbmdQb2xsUmV0cmllcyA9IDA7XG5cblx0LyoqXG5cdCAqIEB2YXIge09iamVjdC48c3RyaW5nLCBib29sZWFuPn0gSGFzaCBvZiBldmVudCBJRHMgd2UndmUgYWxyZWFkeSBwdXNoZWRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHRoaXMuX2RlZHVwSGFzaCA9IHt9O1xuXG5cdC8qKlxuXHQgKiBSYXRlIGxpbWl0aW5nIHByb21pc2UgdG8gZW5zdXJlIHRoYXQgZXZlbnRzIGFyZSBub3QgZmV0Y2hlZCB0b28gb2Z0ZW4sXG5cdCAqIGluaXRpYWxseSByZXNvbHZlZCB0byBhbGxvdyBhbiBpbW1lZGlhdGUgQVBJIGNhbGwuXG5cdCAqIEB2YXIge1Byb21pc2V9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHR0aGlzLl9yYXRlTGltaXRlciA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG5cdHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xufVxuXG51dGlsLmluaGVyaXRzKEV2ZW50U3RyZWFtLCBSZWFkYWJsZSk7XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHVybCBhbmQgcGFyYW1zIGZvciBsb25nIHBvbGxpbmcgZm9yIG5ldyB1cGRhdGVzXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICogQHByaXZhdGVcbiAqL1xuRXZlbnRTdHJlYW0ucHJvdG90eXBlLmdldExvbmdQb2xsSW5mbyA9IGZ1bmN0aW9uKCkge1xuXHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblx0fVxuXG5cdHJldHVybiB0aGlzLl9jbGllbnQuZXZlbnRzLmdldExvbmdQb2xsSW5mbygpXG5cdFx0LnRoZW4obG9uZ1BvbGxJbmZvID0+IHtcblxuXHRcdFx0Ly8gT24gZ2V0dGluZyBuZXcgbG9uZyBwb2xsIGluZm8sIHJlc2V0IGV2ZXJ5dGhpbmdcblx0XHRcdHRoaXMuX2xvbmdQb2xsSW5mbyA9IGxvbmdQb2xsSW5mbztcblx0XHRcdHRoaXMuX2xvbmdQb2xsUmV0cmllcyA9IDA7XG5cblx0XHRcdHJldHVybiB0aGlzLmRvTG9uZ1BvbGwoKTtcblx0XHR9KVxuXHRcdC5jYXRjaChlcnIgPT4ge1xuXHRcdFx0dGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cblx0XHRcdC8vIE9ubHkgcmV0cnkgb24gcmVzb2x2YWJsZSBlcnJvcnNcblx0XHRcdGlmICghZXJyLmF1dGhFeHBpcmVkKSB7XG5cdFx0XHRcdHRoaXMucmV0cnlQb2xsSW5mbygpO1xuXHRcdFx0fVxuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBMb25nIHBvbGwgZm9yIG5vdGlmaWNhdGlvbiBvZiBuZXcgZXZlbnRzLlx0V2UgZG8gdGhpcyByYXRoZXIgdGhhblxuICogcG9sbGluZyBmb3IgdGhlIGV2ZW50cyBkaXJlY3RseSBpbiBvcmRlciB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIEFQSVxuICogY2FsbHMgbmVjZXNzYXJ5LlxuICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgZm9yIHRlc3RpbmcgcHJ1cG9zZXNcbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50U3RyZWFtLnByb3RvdHlwZS5kb0xvbmdQb2xsID0gZnVuY3Rpb24oKSB7XG5cdGlmICh0aGlzLmRlc3Ryb3llZCkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHR9XG5cblx0Ly8gSWYgd2UncmUgb3ZlciB0aGUgbWF4IG51bWJlciBvZiByZXRyaWVzLCByZXNldFxuXHRpZiAodGhpcy5fbG9uZ1BvbGxSZXRyaWVzID4gdGhpcy5fbG9uZ1BvbGxJbmZvLm1heF9yZXRyaWVzKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TG9uZ1BvbGxJbmZvKCk7XG5cdH1cblxuXHR2YXIgdXJsID0gdGhpcy5fbG9uZ1BvbGxJbmZvLnVybCxcblx0XHRxc0RlbGltID0gdXJsLmluZGV4T2YoJz8nKSxcblx0XHRxdWVyeSA9IHt9O1xuXG5cdC8vIEJyZWFrIG91dCB0aGUgcXVlcnkgcGFyYW1zLCBvdGhlcndpc2UgdGhlIHJlcXVlc3QgVVJMIGdldHMgbWVzc2VkIHVwXG5cdGlmIChxc0RlbGltID4gMCkge1xuXHRcdHF1ZXJ5ID0gcXMucGFyc2UodXJsLnN1YnN0cihxc0RlbGltICsgMSkpO1xuXHRcdHVybCA9IHVybC5zdWJzdHIoMCwgcXNEZWxpbSk7XG5cdH1cblxuXHRxdWVyeS5zdHJlYW1fcG9zaXRpb24gPSB0aGlzLl9zdHJlYW1Qb3NpdGlvbjtcblxuXHR2YXIgb3B0aW9ucyA9IHtcblx0XHRxczogcXVlcnksXG5cdFx0dGltZW91dDogdGhpcy5fbG9uZ1BvbGxJbmZvLnJldHJ5X3RpbWVvdXQgKiAxMDAwXG5cdH07XG5cblx0dGhpcy5fbG9uZ1BvbGxSZXRyaWVzICs9IDE7XG5cdHJldHVybiB0aGlzLl9jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLl9jbGllbnQuZ2V0KSh1cmwsIG9wdGlvbnMpXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG5cdFx0XHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5tZXNzYWdlID09PSAncmVjb25uZWN0Jykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRMb25nUG9sbEluZm8oKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBtZXNzYWdlcyBvdGhlciB0aGFuIHJlY29ubmVjdCBhbmQgbmV3X2NoYW5nZSwgc28gaWZcblx0XHRcdC8vIHdlIGdldCBvbmUganVzdCByZXRyeSB0aGUgbG9uZyBwb2xsXG5cdFx0XHRpZiAoZGF0YS5tZXNzYWdlICE9PSAnbmV3X2NoYW5nZScpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9Mb25nUG9sbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy5mZXRjaEV2ZW50cygpO1xuXHRcdH0pXG5cdFx0LmNhdGNoKCgpID0+IHtcblx0XHRcdHRoaXMucmV0cnlQb2xsSW5mbygpO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBSZXRyaWVzIGxvbmctcG9sbGluZyBhZnRlciBhIGRlbGF5LlxuICogRG9lcyBub3QgYXR0ZW1wdCBpZiBzdHJlYW0gaXMgYWxyZWFkeSBkZXN0cm95ZWQuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50U3RyZWFtLnByb3RvdHlwZS5yZXRyeVBvbGxJbmZvID0gZnVuY3Rpb24oKSB7XG5cblx0aWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuXHRcdHRoaXMuX3JldHJ5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZ2V0TG9uZ1BvbGxJbmZvKCksIHRoaXMuX29wdGlvbnMucmV0cnlEZWxheSk7XG5cdH1cbn07XG5cbi8qKlxuICogRmV0Y2ggdGhlIGxhdGVzdCBncm91cCBvZiBldmVudHMgYW5kIHB1c2ggdGhlbSBpbnRvIHRoZSBzdHJlYW1cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudFN0cmVhbS5wcm90b3R5cGUuZmV0Y2hFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuXHRpZiAodGhpcy5kZXN0cm95ZWQpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblx0fVxuXG5cdHZhciBldmVudFBhcmFtcyA9IHtcblx0XHRzdHJlYW1fcG9zaXRpb246IHRoaXMuX3N0cmVhbVBvc2l0aW9uLFxuXHRcdGxpbWl0OiA1MDBcblx0fTtcblxuXHQvLyBHZXQgbmV3IGV2ZW50cyBhZnRlciB0aGUgcmF0ZSBsaW1pdGVyIGV4cGlyZXNcblx0cmV0dXJuIHRoaXMuX3JhdGVMaW1pdGVyLnRoZW4oKCkgPT4gdGhpcy5fY2xpZW50LmV2ZW50cy5nZXQoZXZlbnRQYXJhbXMpXG5cdFx0LnRoZW4oZXZlbnRzID0+IHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIHJhdGUgbGltaXRlclxuXHRcdFx0dGhpcy5fcmF0ZUxpbWl0ZXIgPSBQcm9taXNlLmRlbGF5KHRoaXMuX29wdGlvbnMuZmV0Y2hJbnRlcnZhbCk7XG5cblx0XHRcdC8vIElmIHRoZSByZXNwb25zZSB3YXNuJ3Qgd2hhdCB3ZSBleHBlY3RlZCwgcmUtcG9sbFxuXHRcdFx0aWYgKCFldmVudHMuZW50cmllcyB8fCAhZXZlbnRzLm5leHRfc3RyZWFtX3Bvc2l0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRvTG9uZ1BvbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3RyZWFtUG9zaXRpb24gPSBldmVudHMubmV4dF9zdHJlYW1fcG9zaXRpb247XG5cblx0XHRcdC8vIERlLWR1cGxpY2F0ZSB0aGUgZmV0Y2hlZCBldmVudHMsIHNpbmNlIHRoZSBBUEkgb2Z0ZW4gcmV0dXJuc1xuXHRcdFx0Ly8gdGhlIHNhbWUgZXZlbnRzIGF0IG11bHRpcGxlIHN1YnNlcXVlbnQgc3RyZWFtIHBvc2l0aW9uc1xuXHRcdFx0dmFyIG5ld0V2ZW50cyA9IGV2ZW50cy5lbnRyaWVzLmZpbHRlcihldmVudCA9PiAhdGhpcy5fZGVkdXBIYXNoW2V2ZW50LmV2ZW50X2lkXSk7XG5cblx0XHRcdC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbm9uLWR1cGxpY2F0ZSBldmVudHMsIGdvIGJhY2sgdG8gcG9sbGluZ1xuXHRcdFx0aWYgKG5ld0V2ZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9Mb25nUG9sbCgpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vIFBhdXNlIHRoZSBzdHJlYW0gdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdoaWxlIHB1c2hpbmcgaW4gdGhlIG5ldyBldmVudHMuXG5cdFx0XHQvLyBXaXRob3V0IHRoaXMsIF9yZWFkKCkgd291bGQgYmUgY2FsbGVkIGFnYWluIGZyb20gaW5zaWRlIGVhY2ggcHVzaCgpLFxuXHRcdFx0Ly8gcmVzdWx0aW5nIGluIG11bHRpcGxlIHBhcmFsbGVsIGNhbGxzIHRvIGZldGNoRXZlbnRzKCkuXG5cdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjAzXG5cdFx0XHR2YXIgd2FzUGF1c2VkID0gdGhpcy5pc1BhdXNlZCgpO1xuXHRcdFx0dGhpcy5wYXVzZSgpO1xuXG5cdFx0XHQvLyBQdXNoIG5ldyBldmVudHMgaW50byB0aGUgc3RyZWFtXG5cdFx0XHRuZXdFdmVudHMuZm9yRWFjaChldmVudCA9PiB7XG5cdFx0XHRcdHRoaXMuX2RlZHVwSGFzaFtldmVudC5ldmVudF9pZF0gPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnB1c2goZXZlbnQpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGlmICghd2FzUGF1c2VkKSB7XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBkZWxpdmVyIHRoZSBldmVudHMgYW5kIHRyaWdnZXIgdGhlIG5leHQgY2FsbCB0byBfcmVhZCgpIG9uY2UgdGhleSBoYXZlIGJlZW4gY29uc3VtZWQuXG5cdFx0XHRcdHRoaXMucmVzdW1lKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9uY2UgdGhlIGRlZHVwbGljYXRpb24gZmlsdGVyIGdldHMgdG9vIGJpZywgY2xlYW4gaXQgdXBcblx0XHRcdGlmIChPYmplY3Qua2V5cyh0aGlzLl9kZWR1cEhhc2gpLmxlbmd0aCA+PSB0aGlzLl9vcHRpb25zLmRlZHVwbGljYXRpb25GaWx0ZXJTaXplKSB7XG5cdFx0XHRcdHRoaXMuY2xlYW51cERlZHVwRmlsdGVyKGV2ZW50cy5lbnRyaWVzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSlcblx0XHQuY2F0Y2goZXJyID0+IHtcblxuXHRcdFx0dGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG5cblx0XHRcdHRoaXMucmV0cnlQb2xsSW5mbygpO1xuXHRcdH0pXG5cdCk7XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRoZSBkZWR1cGxpY2F0aW9uIGZpbHRlciwgdG8gcHJldmVudCBpdCBmcm9tIGdyb3dpbmdcbiAqIHRvbyBiaWcgYW5kIGVhdGluZyB1cCBtZW1vcnkuXHRXZSBsb29rIGF0IHRoZSBsYXRlc3Qgc2V0IG9mIGV2ZW50c1xuICogcmV0dXJuZWQgYW5kIGFzc3VtZSB0aGF0IGFueSBJRHMgbm90IGluIHRoYXQgc2V0IGRvbid0IG5lZWQgdG8gYmVcbiAqIHRyYWNrZWQgZm9yIGRlZHVwbGljYXRpb24gYW55IG1vcmUuXG4gKiBAcGFyYW0ge09iamVjdFtdfSBsYXRlc3RFdmVudHMgVGhlIGxhdGVzdCBldmVudHMgZnJvbSB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50U3RyZWFtLnByb3RvdHlwZS5jbGVhbnVwRGVkdXBGaWx0ZXIgPSBmdW5jdGlvbihsYXRlc3RFdmVudHMpIHtcblxuXHR2YXIgZGVkdXBJRHMgPSBPYmplY3Qua2V5cyh0aGlzLl9kZWR1cEhhc2gpO1xuXG5cdGRlZHVwSURzLmZvckVhY2goZXZlbnRJRCA9PiB7XG5cblx0XHR2YXIgaXNFdmVudENsZWFyZWQgPSAhbGF0ZXN0RXZlbnRzLmZpbmQoZSA9PiBlLmV2ZW50X2lkID09PSBldmVudElEKTtcblx0XHRpZiAoaXNFdmVudENsZWFyZWQpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9kZWR1cEhhc2hbZXZlbnRJRF07XG5cdFx0fVxuXHR9KTtcbn07XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHN0cmVhbS1pbnRlcm5hbCByZWFkIGZ1bmN0aW9uLlx0VGhpcyBpcyBjYWxsZWRcbiAqIGJ5IHRoZSBzdHJlYW0gd2hlbmV2ZXIgaXQgbmVlZHMgbW9yZSBkYXRhLCBhbmQgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluXG4gKiB1bnRpbCBkYXRhIGlzIHB1c2hlZCBpbnRvIHRoZSBzdHJlYW0uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbkV2ZW50U3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuXG5cdC8vIFN0YXJ0IHRoZSBwcm9jZXNzIG9mIGdldHRpbmcgbmV3IGV2ZW50c1xuXHR0aGlzLmdldExvbmdQb2xsSW5mbygpO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBzdHJlYW0taW50ZXJuYWwgYF9kZXN0cm95YCBmdW5jdGlvbiAodjguMC4wIGFuZCBsYXRlcikuXG4gKiBDYWxsZWQgYnkgc3RyZWFtIGNvbnN1bWVycyB0byBlZmZlY3RpdmVseSBzdG9wIHBvbGxpbmcgdmlhIHRoZSBwdWJsaWNcbiAqIGBkZXN0cm95KClgLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5FdmVudFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0Y2xlYXJUaW1lb3V0KHRoaXMuX3JldHJ5VGltZXIpO1xuXHRkZWxldGUgdGhpcy5fcmV0cnlUaW1lcjtcbn07XG5cbi8vIGJhY2t3YXJkcy1jb21wYXQgZm9yIE5vZGUuanMgcHJlLXY4LjAuMFxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgc3RyZWFtLiAgUm91Z2ggcG9seWZpbGwgZm9yIGBSZWFkYWJsZSNkZXN0cm95YC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdEV2ZW50U3RyZWFtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuXHRcdFx0cHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG5cdFx0XHRcdHRoaXMuZW1pdCgnY2xvc2UnKTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5fZGVzdHJveSgpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFN0cmVhbTtcbiJdLCJuYW1lcyI6WyJSZWFkYWJsZSIsInJlcXVpcmUiLCJxcyIsInV0aWwiLCJQcm9taXNlIiwiREVGQVVMVF9PUFRJT05TIiwiT2JqZWN0IiwiZnJlZXplIiwiZGVkdXBsaWNhdGlvbkZpbHRlclNpemUiLCJyZXRyeURlbGF5IiwiZmV0Y2hJbnRlcnZhbCIsIkV2ZW50U3RyZWFtIiwiY2xpZW50Iiwic3RyZWFtUG9zaXRpb24iLCJvcHRpb25zIiwiY2FsbCIsIm9iamVjdE1vZGUiLCJfY2xpZW50IiwiX3N0cmVhbVBvc2l0aW9uIiwiX2xvbmdQb2xsSW5mbyIsIl9sb25nUG9sbFJldHJpZXMiLCJfZGVkdXBIYXNoIiwiX3JhdGVMaW1pdGVyIiwicmVzb2x2ZSIsIl9vcHRpb25zIiwiYXNzaWduIiwiaW5oZXJpdHMiLCJwcm90b3R5cGUiLCJnZXRMb25nUG9sbEluZm8iLCJkZXN0cm95ZWQiLCJldmVudHMiLCJ0aGVuIiwibG9uZ1BvbGxJbmZvIiwiZG9Mb25nUG9sbCIsImNhdGNoIiwiZXJyIiwiZW1pdCIsImF1dGhFeHBpcmVkIiwicmV0cnlQb2xsSW5mbyIsIm1heF9yZXRyaWVzIiwidXJsIiwicXNEZWxpbSIsImluZGV4T2YiLCJxdWVyeSIsInBhcnNlIiwic3Vic3RyIiwic3RyZWFtX3Bvc2l0aW9uIiwidGltZW91dCIsInJldHJ5X3RpbWVvdXQiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwiZ2V0IiwiZGF0YSIsIm1lc3NhZ2UiLCJmZXRjaEV2ZW50cyIsIl9yZXRyeVRpbWVyIiwic2V0VGltZW91dCIsImV2ZW50UGFyYW1zIiwibGltaXQiLCJkZWxheSIsImVudHJpZXMiLCJuZXh0X3N0cmVhbV9wb3NpdGlvbiIsIm5ld0V2ZW50cyIsImZpbHRlciIsImV2ZW50IiwiZXZlbnRfaWQiLCJsZW5ndGgiLCJ3YXNQYXVzZWQiLCJpc1BhdXNlZCIsInBhdXNlIiwiZm9yRWFjaCIsInB1c2giLCJyZXN1bWUiLCJrZXlzIiwiY2xlYW51cERlZHVwRmlsdGVyIiwibGF0ZXN0RXZlbnRzIiwiZGVkdXBJRHMiLCJldmVudElEIiwiaXNFdmVudENsZWFyZWQiLCJmaW5kIiwiZSIsIl9yZWFkIiwiX2Rlc3Ryb3kiLCJjbGVhclRpbWVvdXQiLCJkZXN0cm95IiwicHJvY2VzcyIsIm5leHRUaWNrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/event-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/collaboration-whitelist.js":
/*!***************************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/collaboration-whitelist.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Collaboration Whitelist Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Collaboration Whitelist parameter constant\n * @typedef {string} CollaborationWhitelistDirection Determines the type of restriction for whitelisting for a domain\n */ // ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/collaboration_whitelist_entries\", TARGET_ENTRY_PATH = \"/collaboration_whitelist_exempt_targets\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Collaboration Whitelist' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function CollaborationWhitelist(client) {\n    this.client = client;\n}\n/**\n * Enum of valid collaboration whitelist directions\n *\n * @readonly\n * @enum {CollaborationWhitelistDirection}\n */ CollaborationWhitelist.prototype.directions = Object.freeze({\n    INBOUND: \"inbound\",\n    OUTBOUND: \"outbound\",\n    BOTH: \"both\"\n});\n/**\n * Add a domain to the enterprise's whitelist.\n *\n * API Endpoint: '/collaboration_whitelist_entries'\n * Method: POST\n *\n * @param {string} domain - The domain to be added to the whitelist\n * @param {CollaborationWhitelistDirection} direction - Inbound refers to collaboration actions within an enterprise. Outbound\n *                                                      refers to collaboration actions external to an enterprise. Both refers to\n *                                                      collaboration actions taken within and external to an enterprise\n * @param {Function} [callback] - Passed the collaboration whitelist information if it was created successfully\n * @returns {Promise<Object>} A promise resolve to the collaboration whitelist object\n */ CollaborationWhitelist.prototype.addDomain = function(domain, direction, callback) {\n    var params = {\n        body: {\n            domain,\n            direction\n        }\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Requests a collaboration whitelist entry with a given ID.\n *\n * API Endpoint: '/collaboration_whitelist_entries/:domainID'\n * Method: GET\n *\n * @param {string} domainID - Box ID of the collaboration whitelist being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the collaboration whitelist information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collaboration whitelist object\n */ CollaborationWhitelist.prototype.getWhitelistedDomain = function(domainID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, domainID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Requests all collaboration whitelist entries within an enterprise.\n *\n * API Endpoint: '/collaboration_whitelist_entries'\n * Method: GET\n *\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {int} [options.limit] - The number of collaboration whitelists to retrieve\n * @param {string} [options.marker] - Paging marker, retrieve records starting at this position in the list. Left blank to start at the beginning.\n * @param {Function} [callback] - Passed a list of collaboration whitelists if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of collaboration whitelists\n */ CollaborationWhitelist.prototype.getAllWhitelistedDomains = function(options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Delete a given collaboration whitelist entry.\n *\n * API Endpoint: '/collaboration_whitelist_entries/:domainID'\n * Method: DELETE\n *\n * @param {string} domainID - Box ID of the collaboration whitelist being requested\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ CollaborationWhitelist.prototype.removeDomain = function(domainID, callback) {\n    var apiPath = urlPath(BASE_PATH, domainID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Adds a Box User to the exempt target list.\n *\n * API Endpoint: '/collaboration_whitelist_exempt_targets'\n * Method: GET\n *\n * @param {string} userID - The ID of the Box User to be added to the whitelist\n * @param {Function} [callback] - Passed a collaboration whitelist for user if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to a user collaboration whitelist\n */ CollaborationWhitelist.prototype.addExemption = function(userID, callback) {\n    var params = {\n        body: {\n            user: {\n                id: userID,\n                type: \"user\"\n            }\n        }\n    };\n    var apiPath = urlPath(TARGET_ENTRY_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Retrieves information about a collaboration whitelist for user by whitelist ID.\n *\n * API Endpoint: '/collaboration_whitelist_exempt_targets/:exemptionID'\n * Method: GET\n *\n * @param {string} exemptionID - The ID of the collaboration whitelist\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the collaboration whitelist information for a user if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collaboration whitelist object\n */ CollaborationWhitelist.prototype.getExemption = function(exemptionID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(TARGET_ENTRY_PATH, exemptionID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Retrieve a list of all exemptions to an enterprise's collaboration whitelist.\n *\n * API Endpoint: '/collaboration_whitelist_exempt_targets'\n * Method: GET\n *\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {string} [options.limit] - The number of user collaboration whitelists to retrieve\n * @param {string} [options.marker] - Paging marker, retrieve records starting at this position in the list. Left blank to start at the beginning.\n * @param {Function} [callback] - Passed a list of user collaboration whitelists if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of user collaboration whitelists\n */ CollaborationWhitelist.prototype.getAllExemptions = function(options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(TARGET_ENTRY_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Delete a given user collaboration whitelist.\n *\n * API Endpoint: '/collaboration_whitelist_exempt_targets/:exemptionID'\n * Method: DELETE\n *\n * @param {string} exemptionID - Box ID of the user collaboration whitelist being requested\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ CollaborationWhitelist.prototype.removeExemption = function(exemptionID, callback) {\n    var apiPath = urlPath(TARGET_ENTRY_PATH, exemptionID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * @module box-node-sdk/lib/managers/collaboration-whitelists\n * @see {@Link CollaborationWhitelist}\n */ module.exports = CollaborationWhitelist;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9jb2xsYWJvcmF0aW9uLXdoaXRlbGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBQ0EsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEY7OztDQUdDLEdBRUQsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFHdEIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFDakYsSUFBSUMsWUFBWSxvQ0FDZkMsb0JBQW9CO0FBRXJCLGlGQUFpRjtBQUNqRixTQUFTO0FBQ1QsaUZBQWlGO0FBRWpGOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLHVCQUF1QkMsTUFBTTtJQUNyQyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBOzs7OztDQUtDLEdBQ0RELHVCQUF1QkUsU0FBUyxDQUFDQyxVQUFVLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQztJQUMzREMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLE1BQU07QUFDUDtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEUix1QkFBdUJFLFNBQVMsQ0FBQ08sU0FBUyxHQUFHLFNBQVNDLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxRQUFRO0lBRWhGLElBQUlDLFNBQVM7UUFDWkMsTUFBTTtZQUNMSjtZQUNBQztRQUNEO0lBQ0Q7SUFFQSxJQUFJSSxVQUFVbkIsUUFBUUU7SUFDdEIsT0FBTyxJQUFJLENBQUNHLE1BQU0sQ0FBQ2Usc0JBQXNCLENBQUMsSUFBSSxDQUFDZixNQUFNLENBQUNnQixJQUFJLEVBQUVGLFNBQVNGLFFBQVFEO0FBQzlFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNEWix1QkFBdUJFLFNBQVMsQ0FBQ2dCLG9CQUFvQixHQUFHLFNBQVNDLFFBQVEsRUFBRUMsT0FBTyxFQUFFUixRQUFRO0lBRTNGLElBQUlDLFNBQVM7UUFBRVEsSUFBSUQ7SUFBUTtJQUUzQixJQUFJTCxVQUFVbkIsUUFBUUUsV0FBV3FCO0lBQ2pDLE9BQU8sSUFBSSxDQUFDbEIsTUFBTSxDQUFDZSxzQkFBc0IsQ0FBQyxJQUFJLENBQUNmLE1BQU0sQ0FBQ3FCLEdBQUcsRUFBRVAsU0FBU0YsUUFBUUQ7QUFDN0U7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNEWix1QkFBdUJFLFNBQVMsQ0FBQ3FCLHdCQUF3QixHQUFHLFNBQVNILE9BQU8sRUFBRVIsUUFBUTtJQUVyRixJQUFJQyxTQUFTO1FBQ1pRLElBQUlEO0lBQ0w7SUFFQSxJQUFJTCxVQUFVbkIsUUFBUUU7SUFDdEIsT0FBTyxJQUFJLENBQUNHLE1BQU0sQ0FBQ2Usc0JBQXNCLENBQUMsSUFBSSxDQUFDZixNQUFNLENBQUNxQixHQUFHLEVBQUVQLFNBQVNGLFFBQVFEO0FBQzdFO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0RaLHVCQUF1QkUsU0FBUyxDQUFDc0IsWUFBWSxHQUFHLFNBQVNMLFFBQVEsRUFBRVAsUUFBUTtJQUUxRSxJQUFJRyxVQUFVbkIsUUFBUUUsV0FBV3FCO0lBQ2pDLE9BQU8sSUFBSSxDQUFDbEIsTUFBTSxDQUFDZSxzQkFBc0IsQ0FBQyxJQUFJLENBQUNmLE1BQU0sQ0FBQ3dCLEdBQUcsRUFBRVYsU0FBUyxNQUFNSDtBQUMzRTtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEWix1QkFBdUJFLFNBQVMsQ0FBQ3dCLFlBQVksR0FBRyxTQUFTQyxNQUFNLEVBQUVmLFFBQVE7SUFFeEUsSUFBSUMsU0FBUztRQUNaQyxNQUFNO1lBQ0xjLE1BQU07Z0JBQ0xDLElBQUlGO2dCQUNKRyxNQUFNO1lBQ1A7UUFDRDtJQUNEO0lBRUEsSUFBSWYsVUFBVW5CLFFBQVFHO0lBQ3RCLE9BQU8sSUFBSSxDQUFDRSxNQUFNLENBQUNlLHNCQUFzQixDQUFDLElBQUksQ0FBQ2YsTUFBTSxDQUFDZ0IsSUFBSSxFQUFFRixTQUFTRixRQUFRRDtBQUM5RTtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRFosdUJBQXVCRSxTQUFTLENBQUM2QixZQUFZLEdBQUcsU0FBU0MsV0FBVyxFQUFFWixPQUFPLEVBQUVSLFFBQVE7SUFFdEYsSUFBSUMsU0FBUztRQUNaUSxJQUFJRDtJQUNMO0lBRUEsSUFBSUwsVUFBVW5CLFFBQVFHLG1CQUFtQmlDO0lBQ3pDLE9BQU8sSUFBSSxDQUFDL0IsTUFBTSxDQUFDZSxzQkFBc0IsQ0FBQyxJQUFJLENBQUNmLE1BQU0sQ0FBQ3FCLEdBQUcsRUFBRVAsU0FBU0YsUUFBUUQ7QUFDN0U7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNEWix1QkFBdUJFLFNBQVMsQ0FBQytCLGdCQUFnQixHQUFHLFNBQVNiLE9BQU8sRUFBRVIsUUFBUTtJQUU3RSxJQUFJQyxTQUFTO1FBQ1pRLElBQUlEO0lBQ0w7SUFFQSxJQUFJTCxVQUFVbkIsUUFBUUc7SUFDdEIsT0FBTyxJQUFJLENBQUNFLE1BQU0sQ0FBQ2Usc0JBQXNCLENBQUMsSUFBSSxDQUFDZixNQUFNLENBQUNxQixHQUFHLEVBQUVQLFNBQVNGLFFBQVFEO0FBQzdFO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0RaLHVCQUF1QkUsU0FBUyxDQUFDZ0MsZUFBZSxHQUFHLFNBQVNGLFdBQVcsRUFBRXBCLFFBQVE7SUFFaEYsSUFBSUcsVUFBVW5CLFFBQVFHLG1CQUFtQmlDO0lBQ3pDLE9BQU8sSUFBSSxDQUFDL0IsTUFBTSxDQUFDZSxzQkFBc0IsQ0FBQyxJQUFJLENBQUNmLE1BQU0sQ0FBQ3dCLEdBQUcsRUFBRVYsU0FBUyxNQUFNSDtBQUMzRTtBQUVBOzs7Q0FHQyxHQUNEdUIsT0FBT0MsT0FBTyxHQUFHcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL2NvbGxhYm9yYXRpb24td2hpdGVsaXN0LmpzP2MwNjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBCb3ggQ29sbGFib3JhdGlvbiBXaGl0ZWxpc3QgUmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZWRlZnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQ29sbGFib3JhdGlvbiBXaGl0ZWxpc3QgcGFyYW1ldGVyIGNvbnN0YW50XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBDb2xsYWJvcmF0aW9uV2hpdGVsaXN0RGlyZWN0aW9uIERldGVybWluZXMgdGhlIHR5cGUgb2YgcmVzdHJpY3Rpb24gZm9yIHdoaXRlbGlzdGluZyBmb3IgYSBkb21haW5cbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEJBU0VfUEFUSCA9ICcvY29sbGFib3JhdGlvbl93aGl0ZWxpc3RfZW50cmllcycsXG5cdFRBUkdFVF9FTlRSWV9QQVRIID0gJy9jb2xsYWJvcmF0aW9uX3doaXRlbGlzdF9leGVtcHRfdGFyZ2V0cyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgJ0NvbGxhYm9yYXRpb24gV2hpdGVsaXN0JyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQ29sbGFib3JhdGlvbldoaXRlbGlzdChjbGllbnQpIHtcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogRW51bSBvZiB2YWxpZCBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdCBkaXJlY3Rpb25zXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7Q29sbGFib3JhdGlvbldoaXRlbGlzdERpcmVjdGlvbn1cbiAqL1xuQ29sbGFib3JhdGlvbldoaXRlbGlzdC5wcm90b3R5cGUuZGlyZWN0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuXHRJTkJPVU5EOiAnaW5ib3VuZCcsXG5cdE9VVEJPVU5EOiAnb3V0Ym91bmQnLFxuXHRCT1RIOiAnYm90aCdcbn0pO1xuXG4vKipcbiAqIEFkZCBhIGRvbWFpbiB0byB0aGUgZW50ZXJwcmlzZSdzIHdoaXRlbGlzdC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbl93aGl0ZWxpc3RfZW50cmllcydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW4gLSBUaGUgZG9tYWluIHRvIGJlIGFkZGVkIHRvIHRoZSB3aGl0ZWxpc3RcbiAqIEBwYXJhbSB7Q29sbGFib3JhdGlvbldoaXRlbGlzdERpcmVjdGlvbn0gZGlyZWN0aW9uIC0gSW5ib3VuZCByZWZlcnMgdG8gY29sbGFib3JhdGlvbiBhY3Rpb25zIHdpdGhpbiBhbiBlbnRlcnByaXNlLiBPdXRib3VuZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcnMgdG8gY29sbGFib3JhdGlvbiBhY3Rpb25zIGV4dGVybmFsIHRvIGFuIGVudGVycHJpc2UuIEJvdGggcmVmZXJzIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhYm9yYXRpb24gYWN0aW9ucyB0YWtlbiB3aXRoaW4gYW5kIGV4dGVybmFsIHRvIGFuIGVudGVycHJpc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0IGluZm9ybWF0aW9uIGlmIGl0IHdhcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmUgdG8gdGhlIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0IG9iamVjdFxuICovXG5Db2xsYWJvcmF0aW9uV2hpdGVsaXN0LnByb3RvdHlwZS5hZGREb21haW4gPSBmdW5jdGlvbihkb21haW4sIGRpcmVjdGlvbiwgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IHtcblx0XHRcdGRvbWFpbixcblx0XHRcdGRpcmVjdGlvblxuXHRcdH1cblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIGEgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3QgZW50cnkgd2l0aCBhIGdpdmVuIElELlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb2xsYWJvcmF0aW9uX3doaXRlbGlzdF9lbnRyaWVzLzpkb21haW5JRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRvbWFpbklEIC0gQm94IElEIG9mIHRoZSBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdCBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdCBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdCBvYmplY3RcbiAqL1xuQ29sbGFib3JhdGlvbldoaXRlbGlzdC5wcm90b3R5cGUuZ2V0V2hpdGVsaXN0ZWREb21haW4gPSBmdW5jdGlvbihkb21haW5JRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0geyBxczogb3B0aW9ucyB9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGRvbWFpbklEKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgYWxsIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0IGVudHJpZXMgd2l0aGluIGFuIGVudGVycHJpc2UuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbGxhYm9yYXRpb25fd2hpdGVsaXN0X2VudHJpZXMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5saW1pdF0gLSBUaGUgbnVtYmVyIG9mIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0cyB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtlcl0gLSBQYWdpbmcgbWFya2VyLCByZXRyaWV2ZSByZWNvcmRzIHN0YXJ0aW5nIGF0IHRoaXMgcG9zaXRpb24gaW4gdGhlIGxpc3QuIExlZnQgYmxhbmsgdG8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBsaXN0IG9mIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0cyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3RzXG4gKi9cbkNvbGxhYm9yYXRpb25XaGl0ZWxpc3QucHJvdG90eXBlLmdldEFsbFdoaXRlbGlzdGVkRG9tYWlucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBnaXZlbiBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdCBlbnRyeS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbl93aGl0ZWxpc3RfZW50cmllcy86ZG9tYWluSUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21haW5JRCAtIEJveCBJRCBvZiB0aGUgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3QgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgcmVzcG9uc2UgYm9keSBwYXNzZWQgaWYgc3VjY2Vzc2Z1bC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuQ29sbGFib3JhdGlvbldoaXRlbGlzdC5wcm90b3R5cGUucmVtb3ZlRG9tYWluID0gZnVuY3Rpb24oZG9tYWluSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZG9tYWluSUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIEJveCBVc2VyIHRvIHRoZSBleGVtcHQgdGFyZ2V0IGxpc3QuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbGxhYm9yYXRpb25fd2hpdGVsaXN0X2V4ZW1wdF90YXJnZXRzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklEIC0gVGhlIElEIG9mIHRoZSBCb3ggVXNlciB0byBiZSBhZGRlZCB0byB0aGUgd2hpdGVsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIGEgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3QgZm9yIHVzZXIgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgdXNlciBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdFxuICovXG5Db2xsYWJvcmF0aW9uV2hpdGVsaXN0LnByb3RvdHlwZS5hZGRFeGVtcHRpb24gPSBmdW5jdGlvbih1c2VySUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHR1c2VyOiB7XG5cdFx0XHRcdGlkOiB1c2VySUQsXG5cdFx0XHRcdHR5cGU6ICd1c2VyJ1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoVEFSR0VUX0VOVFJZX1BBVEgpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGluZm9ybWF0aW9uIGFib3V0IGEgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3QgZm9yIHVzZXIgYnkgd2hpdGVsaXN0IElELlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb2xsYWJvcmF0aW9uX3doaXRlbGlzdF9leGVtcHRfdGFyZ2V0cy86ZXhlbXB0aW9uSUQnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleGVtcHRpb25JRCAtIFRoZSBJRCBvZiB0aGUgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdCBpbmZvcm1hdGlvbiBmb3IgYSB1c2VyIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0IG9iamVjdFxuICovXG5Db2xsYWJvcmF0aW9uV2hpdGVsaXN0LnByb3RvdHlwZS5nZXRFeGVtcHRpb24gPSBmdW5jdGlvbihleGVtcHRpb25JRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKFRBUkdFVF9FTlRSWV9QQVRILCBleGVtcHRpb25JRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgbGlzdCBvZiBhbGwgZXhlbXB0aW9ucyB0byBhbiBlbnRlcnByaXNlJ3MgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3QuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbGxhYm9yYXRpb25fd2hpdGVsaXN0X2V4ZW1wdF90YXJnZXRzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGltaXRdIC0gVGhlIG51bWJlciBvZiB1c2VyIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0cyB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtlcl0gLSBQYWdpbmcgbWFya2VyLCByZXRyaWV2ZSByZWNvcmRzIHN0YXJ0aW5nIGF0IHRoaXMgcG9zaXRpb24gaW4gdGhlIGxpc3QuIExlZnQgYmxhbmsgdG8gc3RhcnQgYXQgdGhlIGJlZ2lubmluZy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBsaXN0IG9mIHVzZXIgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3RzIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiB1c2VyIGNvbGxhYm9yYXRpb24gd2hpdGVsaXN0c1xuICovXG5Db2xsYWJvcmF0aW9uV2hpdGVsaXN0LnByb3RvdHlwZS5nZXRBbGxFeGVtcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKFRBUkdFVF9FTlRSWV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgZ2l2ZW4gdXNlciBjb2xsYWJvcmF0aW9uIHdoaXRlbGlzdC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbl93aGl0ZWxpc3RfZXhlbXB0X3RhcmdldHMvOmV4ZW1wdGlvbklEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhlbXB0aW9uSUQgLSBCb3ggSUQgb2YgdGhlIHVzZXIgY29sbGFib3JhdGlvbiB3aGl0ZWxpc3QgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgcmVzcG9uc2UgYm9keSBwYXNzZWQgaWYgc3VjY2Vzc2Z1bC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuQ29sbGFib3JhdGlvbldoaXRlbGlzdC5wcm90b3R5cGUucmVtb3ZlRXhlbXB0aW9uID0gZnVuY3Rpb24oZXhlbXB0aW9uSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKFRBUkdFVF9FTlRSWV9QQVRILCBleGVtcHRpb25JRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvY29sbGFib3JhdGlvbi13aGl0ZWxpc3RzXG4gKiBAc2VlIHtATGluayBDb2xsYWJvcmF0aW9uV2hpdGVsaXN0fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxhYm9yYXRpb25XaGl0ZWxpc3Q7XG4iXSwibmFtZXMiOlsidXJsUGF0aCIsInJlcXVpcmUiLCJCQVNFX1BBVEgiLCJUQVJHRVRfRU5UUllfUEFUSCIsIkNvbGxhYm9yYXRpb25XaGl0ZWxpc3QiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJkaXJlY3Rpb25zIiwiT2JqZWN0IiwiZnJlZXplIiwiSU5CT1VORCIsIk9VVEJPVU5EIiwiQk9USCIsImFkZERvbWFpbiIsImRvbWFpbiIsImRpcmVjdGlvbiIsImNhbGxiYWNrIiwicGFyYW1zIiwiYm9keSIsImFwaVBhdGgiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwicG9zdCIsImdldFdoaXRlbGlzdGVkRG9tYWluIiwiZG9tYWluSUQiLCJvcHRpb25zIiwicXMiLCJnZXQiLCJnZXRBbGxXaGl0ZWxpc3RlZERvbWFpbnMiLCJyZW1vdmVEb21haW4iLCJkZWwiLCJhZGRFeGVtcHRpb24iLCJ1c2VySUQiLCJ1c2VyIiwiaWQiLCJ0eXBlIiwiZ2V0RXhlbXB0aW9uIiwiZXhlbXB0aW9uSUQiLCJnZXRBbGxFeGVtcHRpb25zIiwicmVtb3ZlRXhlbXB0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/collaboration-whitelist.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/collaborations.js":
/*!******************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/collaborations.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Collaboration Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/collaborations\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Collaboration' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Collaborations(client) {\n    this.client = client;\n}\n/**\n * Requests a collaboration object with a given ID.\n *\n * API Endpoint: '/collaborations/:collaborationID'\n * Method: GET\n *\n * @param {string} collaborationID - Box ID of the collaboration being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the collaboration information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collaboration object\n */ Collaborations.prototype.get = function(collaborationID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, collaborationID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Gets a user's pending collaborations\n *\n * API Endpoint: '/collaborations'\n * Method: GET\n *\n * @param {Function} [callback] - Called with a collection of pending collaborations if successful\n * @returns {Promise<Object>} A promise resolving to the collection of pending collaborations\n */ Collaborations.prototype.getPending = function(callback) {\n    var params = {\n        qs: {\n            status: \"pending\"\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(BASE_PATH, params, callback);\n};\n/**\n * Update some information about a given collaboration.\n *\n * API Endpoint: '/collaborations/:collaborationID'\n * Method: PUT\n *\n * @param {string} collaborationID - Box ID of the collaboration being requested\n * @param {Object} updates - Fields of the collaboration to be updated\n * @param {Function} [callback] - Passed the updated collaboration information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated collaboration object\n */ Collaborations.prototype.update = function(collaborationID, updates, callback) {\n    var params = {\n        body: updates\n    };\n    var apiPath = urlPath(BASE_PATH, collaborationID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Update the status of a pending collaboration.\n *\n * API Endpoint: '/collaborations/:collaborationID'\n * Method: PUT\n *\n * @param {string} collaborationID - Box ID of the collaboration being requested\n * @param {string} newStatus - The new collaboration status ('accepted'/'rejected')\n * @param {Function} [callback] - Passed the updated collaboration information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the accepted collaboration object\n */ Collaborations.prototype.respondToPending = function(collaborationID, newStatus, callback) {\n    var options = {\n        status: newStatus\n    };\n    return this.update(collaborationID, options, callback);\n};\n/**\n * Invite a collaborator to a folder. You'll have to create the 'accessible_by' input object\n * yourself, but the method allows for multiple types of collaborator invites. See\n * {@link http://developers.box.com/docs/#collaborations-add-a-collaboration} for formatting\n * help.\n *\n * API Endpoint: '/collaborations\n * Method: POST\n *\n * @param {Object} accessibleBy - The accessible_by object expected by the API\n * @param {string} itemID - Box ID of the item to which the user should be invited\n * @param {CollaborationRole} role - The role which the invited collaborator should have\n * @param {Object} [options] - Optional parameters for the collaboration\n * @param {ItemType} [options.type=folder] - Type of object to be collaborated\n * @param {boolean} [options.notify] - Determines if the user or group will receive email notifications\n * @param {boolean} [options.can_view_path] - Whether view path collaboration feature is enabled or not\n * @param {Function} [callback] - Called with the new collaboration if successful\n * @returns {Promise<Object>} A promise resolving to the created collaboration object\n */ Collaborations.prototype.create = function(accessibleBy, itemID, role, options, callback) {\n    var defaultOptions = {\n        type: \"folder\"\n    };\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = Object.assign({}, defaultOptions, options);\n    var params = {\n        body: {\n            item: {\n                type: options.type,\n                id: itemID\n            },\n            accessible_by: accessibleBy,\n            role\n        }\n    };\n    if (typeof options.can_view_path === \"boolean\") {\n        params.body.can_view_path = options.can_view_path;\n    }\n    if (typeof options.notify === \"boolean\") {\n        params.qs = {\n            notify: options.notify\n        };\n    }\n    return this.client.wrapWithDefaultHandler(this.client.post)(BASE_PATH, params, callback);\n};\n/**\n * Invite a user to collaborate on an item via their user ID.\n *\n * API Endpoint: '/collaborations\n * Method: POST\n *\n * @param {int} userID - The ID of the user you'll invite as a collaborator\n * @param {string} itemID - Box ID of the item to which the user should be invited\n * @param {CollaborationRole} role - The role which the invited collaborator should have\n * @param {Object} [options] - Optional parameters for the collaboration\n * @param {ItemType} [options.type=folder] - Type of object to be collaborated\n * @param {boolean} [options.notify] - Determines if the user will receive email notifications\n * @param {boolean} [options.can_view_path] - Whether view path collaboration feature is enabled or not\n * @param {Function} [callback] - Called with the new collaboration if successful\n * @returns {Promise<Object>} A promise resolving to the created collaboration object\n */ Collaborations.prototype.createWithUserID = function(userID, itemID, role, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var accessibleBy = {\n        type: \"user\",\n        id: userID\n    };\n    return this.create(accessibleBy, itemID, role, options, callback);\n};\n/**\n * Invite a user to collaborate on an item via their user login email address.\n *\n * API Endpoint: '/collaborations\n * Method: POST\n *\n * @param {string} email - The collaborator's email address\n * @param {string} itemID - Box ID of the item to which the user should be invited\n * @param {CollaborationRole} role - The role which the invited collaborator should have\n * @param {Object} [options] - Optional parameters for the collaboration\n * @param {ItemType} [options.type=folder] - Type of object to be collaborated\n * @param {boolean} [options.notify] - Determines if the user will receive email notifications\n * @param {boolean} [options.can_view_path] - Whether view path collaboration feature is enabled or not\n * @param {Function} [callback] - Called with the new collaboration if successful\n * @returns {Promise<Object>} A promise resolving to the created collaboration object\n */ Collaborations.prototype.createWithUserEmail = function(email, itemID, role, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var accessibleBy = {\n        type: \"user\",\n        login: email\n    };\n    return this.create(accessibleBy, itemID, role, options, callback);\n};\n/**\n * Invite a group to collaborate on an item via their group ID.\n *\n * API Endpoint: '/collaborations\n * Method: POST\n *\n * @param {int} groupID - The ID of the group you'll invite as a collaborator\n * @param {string} itemID - Box ID of the item to which the group should be invited\n * @param {CollaborationRole} role - The role which the invited collaborator should have\n * @param {Object} [options] - Optional parameters for the collaboration\n * @param {ItemType} [options.type=folder] - Type of object to be collaborated\n * @param {boolean} [options.notify] - Determines if the group will receive email notifications\n * @param {boolean} [options.can_view_path] - Whether view path collaboration feature is enabled or not\n * @param {Function} [callback] - Called with the new collaboration if successful\n * @returns {Promise<Object>} A promise resolving to the created collaboration object\n */ Collaborations.prototype.createWithGroupID = function(groupID, itemID, role, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var accessibleBy = {\n        type: \"group\",\n        id: groupID\n    };\n    return this.create(accessibleBy, itemID, role, options, callback);\n};\n/**\n * Delete a given collaboration.\n *\n * API Endpoint: '/collaborations/:collaborationID'\n * Method: DELETE\n *\n * @param {string} collaborationID - Box ID of the collaboration being requested\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ Collaborations.prototype.delete = function(collaborationID, callback) {\n    var apiPath = urlPath(BASE_PATH, collaborationID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * @module box-node-sdk/lib/managers/collaborations\n * @see {@Link Collaborations}\n */ module.exports = Collaborations;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9jb2xsYWJvcmF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFHdEIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFDakYsSUFBSUMsWUFBWTtBQUdoQixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxlQUFlQyxNQUFNO0lBQzdCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNERCxlQUFlRSxTQUFTLENBQUNDLEdBQUcsR0FBRyxTQUFTQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUN6RSxJQUFJQyxTQUFTO1FBQ1pDLElBQUlIO0lBQ0w7SUFDQSxJQUFJSSxVQUFVWixRQUFRRSxXQUFXSztJQUNqQyxPQUFPLElBQUksQ0FBQ0gsTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ0UsR0FBRyxFQUFFTSxTQUFTRixRQUFRRDtBQUM3RTtBQUVBOzs7Ozs7OztDQVFDLEdBQ0ROLGVBQWVFLFNBQVMsQ0FBQ1MsVUFBVSxHQUFHLFNBQVNMLFFBQVE7SUFDdEQsSUFBSUMsU0FBUztRQUNaQyxJQUFJO1lBQ0hJLFFBQVE7UUFDVDtJQUNEO0lBQ0EsT0FBTyxJQUFJLENBQUNYLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEdBQUcsRUFBRUosV0FBV1EsUUFBUUQ7QUFDL0U7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0ROLGVBQWVFLFNBQVMsQ0FBQ1csTUFBTSxHQUFHLFNBQVNULGVBQWUsRUFBRVUsT0FBTyxFQUFFUixRQUFRO0lBQzVFLElBQUlDLFNBQVM7UUFDWlEsTUFB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QyxjQUFjQyxRQUFRQyxNQUFNakIsU0FBU0M7QUFDekQ7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRE4sZUFBZUUsU0FBUyxDQUFDc0MsTUFBTSxHQUFHLFNBQVNwQyxlQUFlLEVBQUVFLFFBQVE7SUFFbkUsSUFBSUcsVUFBVVosUUFBUUUsV0FBV0s7SUFDakMsT0FBTyxJQUFJLENBQUNILE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUN3QyxHQUFHLEVBQUVoQyxTQUFTLE1BQU1IO0FBQzNFO0FBR0E7OztDQUdDLEdBQ0RvQyxPQUFPQyxPQUFPLEdBQUczQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvY29sbGFib3JhdGlvbnMuanM/OTkwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIEJveCBDb2xsYWJvcmF0aW9uIFJlc291cmNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEJBU0VfUEFUSCA9ICcvY29sbGFib3JhdGlvbnMnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgJ0NvbGxhYm9yYXRpb24nIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgLSBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBDb2xsYWJvcmF0aW9ucyhjbGllbnQpIHtcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogUmVxdWVzdHMgYSBjb2xsYWJvcmF0aW9uIG9iamVjdCB3aXRoIGEgZ2l2ZW4gSUQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbGxhYm9yYXRpb25zLzpjb2xsYWJvcmF0aW9uSUQnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsYWJvcmF0aW9uSUQgLSBCb3ggSUQgb2YgdGhlIGNvbGxhYm9yYXRpb24gYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgY29sbGFib3JhdGlvbiBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsYWJvcmF0aW9uIG9iamVjdFxuICovXG5Db2xsYWJvcmF0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY29sbGFib3JhdGlvbklELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGNvbGxhYm9yYXRpb25JRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB1c2VyJ3MgcGVuZGluZyBjb2xsYWJvcmF0aW9uc1xuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb2xsYWJvcmF0aW9ucydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIGEgY29sbGVjdGlvbiBvZiBwZW5kaW5nIGNvbGxhYm9yYXRpb25zIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgcGVuZGluZyBjb2xsYWJvcmF0aW9uc1xuICovXG5Db2xsYWJvcmF0aW9ucy5wcm90b3R5cGUuZ2V0UGVuZGluZyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IHtcblx0XHRcdHN0YXR1czogJ3BlbmRpbmcnXG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKEJBU0VfUEFUSCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBzb21lIGluZm9ybWF0aW9uIGFib3V0IGEgZ2l2ZW4gY29sbGFib3JhdGlvbi5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbnMvOmNvbGxhYm9yYXRpb25JRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbGxhYm9yYXRpb25JRCAtIEJveCBJRCBvZiB0aGUgY29sbGFib3JhdGlvbiBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIC0gRmllbGRzIG9mIHRoZSBjb2xsYWJvcmF0aW9uIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgY29sbGFib3JhdGlvbiBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIGNvbGxhYm9yYXRpb24gb2JqZWN0XG4gKi9cbkNvbGxhYm9yYXRpb25zLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihjb2xsYWJvcmF0aW9uSUQsIHVwZGF0ZXMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keTogdXBkYXRlc1xuXHR9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGNvbGxhYm9yYXRpb25JRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc3RhdHVzIG9mIGEgcGVuZGluZyBjb2xsYWJvcmF0aW9uLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb2xsYWJvcmF0aW9ucy86Y29sbGFib3JhdGlvbklEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sbGFib3JhdGlvbklEIC0gQm94IElEIG9mIHRoZSBjb2xsYWJvcmF0aW9uIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXR1cyAtIFRoZSBuZXcgY29sbGFib3JhdGlvbiBzdGF0dXMgKCdhY2NlcHRlZCcvJ3JlamVjdGVkJylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgY29sbGFib3JhdGlvbiBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhY2NlcHRlZCBjb2xsYWJvcmF0aW9uIG9iamVjdFxuICovXG5Db2xsYWJvcmF0aW9ucy5wcm90b3R5cGUucmVzcG9uZFRvUGVuZGluZyA9IGZ1bmN0aW9uKGNvbGxhYm9yYXRpb25JRCwgbmV3U3RhdHVzLCBjYWxsYmFjaykge1xuXHR2YXIgb3B0aW9ucyA9IHtcblx0XHRzdGF0dXM6IG5ld1N0YXR1c1xuXHR9O1xuXHRyZXR1cm4gdGhpcy51cGRhdGUoY29sbGFib3JhdGlvbklELCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEludml0ZSBhIGNvbGxhYm9yYXRvciB0byBhIGZvbGRlci4gWW91J2xsIGhhdmUgdG8gY3JlYXRlIHRoZSAnYWNjZXNzaWJsZV9ieScgaW5wdXQgb2JqZWN0XG4gKiB5b3Vyc2VsZiwgYnV0IHRoZSBtZXRob2QgYWxsb3dzIGZvciBtdWx0aXBsZSB0eXBlcyBvZiBjb2xsYWJvcmF0b3IgaW52aXRlcy4gU2VlXG4gKiB7QGxpbmsgaHR0cDovL2RldmVsb3BlcnMuYm94LmNvbS9kb2NzLyNjb2xsYWJvcmF0aW9ucy1hZGQtYS1jb2xsYWJvcmF0aW9ufSBmb3IgZm9ybWF0dGluZ1xuICogaGVscC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbnNcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhY2Nlc3NpYmxlQnkgLSBUaGUgYWNjZXNzaWJsZV9ieSBvYmplY3QgZXhwZWN0ZWQgYnkgdGhlIEFQSVxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1JRCAtIEJveCBJRCBvZiB0aGUgaXRlbSB0byB3aGljaCB0aGUgdXNlciBzaG91bGQgYmUgaW52aXRlZFxuICogQHBhcmFtIHtDb2xsYWJvcmF0aW9uUm9sZX0gcm9sZSAtIFRoZSByb2xlIHdoaWNoIHRoZSBpbnZpdGVkIGNvbGxhYm9yYXRvciBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjb2xsYWJvcmF0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UeXBlfSBbb3B0aW9ucy50eXBlPWZvbGRlcl0gLSBUeXBlIG9mIG9iamVjdCB0byBiZSBjb2xsYWJvcmF0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm90aWZ5XSAtIERldGVybWluZXMgaWYgdGhlIHVzZXIgb3IgZ3JvdXAgd2lsbCByZWNlaXZlIGVtYWlsIG5vdGlmaWNhdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FuX3ZpZXdfcGF0aF0gLSBXaGV0aGVyIHZpZXcgcGF0aCBjb2xsYWJvcmF0aW9uIGZlYXR1cmUgaXMgZW5hYmxlZCBvciBub3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCB0aGUgbmV3IGNvbGxhYm9yYXRpb24gaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBjb2xsYWJvcmF0aW9uIG9iamVjdFxuICovXG5Db2xsYWJvcmF0aW9ucy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oYWNjZXNzaWJsZUJ5LCBpdGVtSUQsIHJvbGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHRcdHR5cGU6ICdmb2xkZXInXG5cdH07XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHRpdGVtOiB7XG5cdFx0XHRcdHR5cGU6IG9wdGlvbnMudHlwZSxcblx0XHRcdFx0aWQ6IGl0ZW1JRFxuXHRcdFx0fSxcblx0XHRcdGFjY2Vzc2libGVfYnk6IGFjY2Vzc2libGVCeSxcblx0XHRcdHJvbGVcblx0XHR9XG5cdH07XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zLmNhbl92aWV3X3BhdGggPT09ICdib29sZWFuJykge1xuXHRcdHBhcmFtcy5ib2R5LmNhbl92aWV3X3BhdGggPSBvcHRpb25zLmNhbl92aWV3X3BhdGg7XG5cdH1cblxuXHRpZiAodHlwZW9mIG9wdGlvbnMubm90aWZ5ID09PSAnYm9vbGVhbicpIHtcblx0XHRwYXJhbXMucXMgPSB7XG5cdFx0XHRub3RpZnk6IG9wdGlvbnMubm90aWZ5XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKEJBU0VfUEFUSCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEludml0ZSBhIHVzZXIgdG8gY29sbGFib3JhdGUgb24gYW4gaXRlbSB2aWEgdGhlaXIgdXNlciBJRC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbnNcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7aW50fSB1c2VySUQgLSBUaGUgSUQgb2YgdGhlIHVzZXIgeW91J2xsIGludml0ZSBhcyBhIGNvbGxhYm9yYXRvclxuICogQHBhcmFtIHtzdHJpbmd9IGl0ZW1JRCAtIEJveCBJRCBvZiB0aGUgaXRlbSB0byB3aGljaCB0aGUgdXNlciBzaG91bGQgYmUgaW52aXRlZFxuICogQHBhcmFtIHtDb2xsYWJvcmF0aW9uUm9sZX0gcm9sZSAtIFRoZSByb2xlIHdoaWNoIHRoZSBpbnZpdGVkIGNvbGxhYm9yYXRvciBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjb2xsYWJvcmF0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UeXBlfSBbb3B0aW9ucy50eXBlPWZvbGRlcl0gLSBUeXBlIG9mIG9iamVjdCB0byBiZSBjb2xsYWJvcmF0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm90aWZ5XSAtIERldGVybWluZXMgaWYgdGhlIHVzZXIgd2lsbCByZWNlaXZlIGVtYWlsIG5vdGlmaWNhdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FuX3ZpZXdfcGF0aF0gLSBXaGV0aGVyIHZpZXcgcGF0aCBjb2xsYWJvcmF0aW9uIGZlYXR1cmUgaXMgZW5hYmxlZCBvciBub3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCB0aGUgbmV3IGNvbGxhYm9yYXRpb24gaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCBjb2xsYWJvcmF0aW9uIG9iamVjdFxuICovXG5Db2xsYWJvcmF0aW9ucy5wcm90b3R5cGUuY3JlYXRlV2l0aFVzZXJJRCA9IGZ1bmN0aW9uKHVzZXJJRCwgaXRlbUlELCByb2xlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHR2YXIgYWNjZXNzaWJsZUJ5ID0ge1xuXHRcdHR5cGU6ICd1c2VyJyxcblx0XHRpZDogdXNlcklEXG5cdH07XG5cdHJldHVybiB0aGlzLmNyZWF0ZShhY2Nlc3NpYmxlQnksIGl0ZW1JRCwgcm9sZSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBJbnZpdGUgYSB1c2VyIHRvIGNvbGxhYm9yYXRlIG9uIGFuIGl0ZW0gdmlhIHRoZWlyIHVzZXIgbG9naW4gZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbnNcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbCAtIFRoZSBjb2xsYWJvcmF0b3IncyBlbWFpbCBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlbUlEIC0gQm94IElEIG9mIHRoZSBpdGVtIHRvIHdoaWNoIHRoZSB1c2VyIHNob3VsZCBiZSBpbnZpdGVkXG4gKiBAcGFyYW0ge0NvbGxhYm9yYXRpb25Sb2xlfSByb2xlIC0gVGhlIHJvbGUgd2hpY2ggdGhlIGludml0ZWQgY29sbGFib3JhdG9yIHNob3VsZCBoYXZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGNvbGxhYm9yYXRpb25cbiAqIEBwYXJhbSB7SXRlbVR5cGV9IFtvcHRpb25zLnR5cGU9Zm9sZGVyXSAtIFR5cGUgb2Ygb2JqZWN0IHRvIGJlIGNvbGxhYm9yYXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5ub3RpZnldIC0gRGV0ZXJtaW5lcyBpZiB0aGUgdXNlciB3aWxsIHJlY2VpdmUgZW1haWwgbm90aWZpY2F0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jYW5fdmlld19wYXRoXSAtIFdoZXRoZXIgdmlldyBwYXRoIGNvbGxhYm9yYXRpb24gZmVhdHVyZSBpcyBlbmFibGVkIG9yIG5vdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIHRoZSBuZXcgY29sbGFib3JhdGlvbiBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIGNvbGxhYm9yYXRpb24gb2JqZWN0XG4gKi9cbkNvbGxhYm9yYXRpb25zLnByb3RvdHlwZS5jcmVhdGVXaXRoVXNlckVtYWlsID0gZnVuY3Rpb24oZW1haWwsIGl0ZW1JRCwgcm9sZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0dmFyIGFjY2Vzc2libGVCeSA9IHtcblx0XHR0eXBlOiAndXNlcicsXG5cdFx0bG9naW46IGVtYWlsXG5cdH07XG5cdHJldHVybiB0aGlzLmNyZWF0ZShhY2Nlc3NpYmxlQnksIGl0ZW1JRCwgcm9sZSwgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBJbnZpdGUgYSBncm91cCB0byBjb2xsYWJvcmF0ZSBvbiBhbiBpdGVtIHZpYSB0aGVpciBncm91cCBJRC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29sbGFib3JhdGlvbnNcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7aW50fSBncm91cElEIC0gVGhlIElEIG9mIHRoZSBncm91cCB5b3UnbGwgaW52aXRlIGFzIGEgY29sbGFib3JhdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gaXRlbUlEIC0gQm94IElEIG9mIHRoZSBpdGVtIHRvIHdoaWNoIHRoZSBncm91cCBzaG91bGQgYmUgaW52aXRlZFxuICogQHBhcmFtIHtDb2xsYWJvcmF0aW9uUm9sZX0gcm9sZSAtIFRoZSByb2xlIHdoaWNoIHRoZSBpbnZpdGVkIGNvbGxhYm9yYXRvciBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjb2xsYWJvcmF0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UeXBlfSBbb3B0aW9ucy50eXBlPWZvbGRlcl0gLSBUeXBlIG9mIG9iamVjdCB0byBiZSBjb2xsYWJvcmF0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm90aWZ5XSAtIERldGVybWluZXMgaWYgdGhlIGdyb3VwIHdpbGwgcmVjZWl2ZSBlbWFpbCBub3RpZmljYXRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNhbl92aWV3X3BhdGhdIC0gV2hldGhlciB2aWV3IHBhdGggY29sbGFib3JhdGlvbiBmZWF0dXJlIGlzIGVuYWJsZWQgb3Igbm90XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQ2FsbGVkIHdpdGggdGhlIG5ldyBjb2xsYWJvcmF0aW9uIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNyZWF0ZWQgY29sbGFib3JhdGlvbiBvYmplY3RcbiAqL1xuQ29sbGFib3JhdGlvbnMucHJvdG90eXBlLmNyZWF0ZVdpdGhHcm91cElEID0gZnVuY3Rpb24oZ3JvdXBJRCwgaXRlbUlELCByb2xlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHR2YXIgYWNjZXNzaWJsZUJ5ID0ge1xuXHRcdHR5cGU6ICdncm91cCcsXG5cdFx0aWQ6IGdyb3VwSURcblx0fTtcblx0cmV0dXJuIHRoaXMuY3JlYXRlKGFjY2Vzc2libGVCeSwgaXRlbUlELCByb2xlLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIGdpdmVuIGNvbGxhYm9yYXRpb24uXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbGxhYm9yYXRpb25zLzpjb2xsYWJvcmF0aW9uSUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsYWJvcmF0aW9uSUQgLSBCb3ggSUQgb2YgdGhlIGNvbGxhYm9yYXRpb24gYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgcmVzcG9uc2UgYm9keSBwYXNzZWQgaWYgc3VjY2Vzc2Z1bC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuQ29sbGFib3JhdGlvbnMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKGNvbGxhYm9yYXRpb25JRCwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBjb2xsYWJvcmF0aW9uSUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvY29sbGFib3JhdGlvbnNcbiAqIEBzZWUge0BMaW5rIENvbGxhYm9yYXRpb25zfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxhYm9yYXRpb25zO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiQkFTRV9QQVRIIiwiQ29sbGFib3JhdGlvbnMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJnZXQiLCJjb2xsYWJvcmF0aW9uSUQiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJwYXJhbXMiLCJxcyIsImFwaVBhdGgiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwiZ2V0UGVuZGluZyIsInN0YXR1cyIsInVwZGF0ZSIsInVwZGF0ZXMiLCJib2R5IiwicHV0IiwicmVzcG9uZFRvUGVuZGluZyIsIm5ld1N0YXR1cyIsImNyZWF0ZSIsImFjY2Vzc2libGVCeSIsIml0ZW1JRCIsInJvbGUiLCJkZWZhdWx0T3B0aW9ucyIsInR5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJpdGVtIiwiaWQiLCJhY2Nlc3NpYmxlX2J5IiwiY2FuX3ZpZXdfcGF0aCIsIm5vdGlmeSIsInBvc3QiLCJjcmVhdGVXaXRoVXNlcklEIiwidXNlcklEIiwiY3JlYXRlV2l0aFVzZXJFbWFpbCIsImVtYWlsIiwibG9naW4iLCJjcmVhdGVXaXRoR3JvdXBJRCIsImdyb3VwSUQiLCJkZWxldGUiLCJkZWwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/collaborations.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/collections.js":
/*!***************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/collections.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Collection Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/collections\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Collection' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Collections(client) {\n    this.client = client;\n}\n/**\n * Requests all of a user's collection objects.\n *\n * API Endpoint: '/collections'\n * Method: GET\n *\n * @param {Function} [callback] - Called with a collection of collections if successful\n * @returns {Promise<Object>} A promise resolving to the collection of collections\n */ Collections.prototype.getAll = function(callback) {\n    return this.client.wrapWithDefaultHandler(this.client.get)(BASE_PATH, {}, callback);\n};\n/**\n * Requests the items in the collection object with a given ID.\n *\n * API Endpoint: '/collections/:collectionID/items'\n * Method: GET\n *\n * @param {string} collectionID - Box ID of the collection with items being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the items information if they were acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collection of items in the collection\n */ Collections.prototype.getItems = function(collectionID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, collectionID, \"items\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * @module box-node-sdk/lib/managers/collections\n * @see {@Link Collections}\n */ module.exports = Collections;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9jb2xsZWN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFdEIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFDakYsSUFBSUMsWUFBWTtBQUVoQixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxZQUFZQyxNQUFNO0lBQzFCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDREQsWUFBWUUsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0MsUUFBUTtJQUMvQyxPQUFPLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxzQkFBc0IsQ0FBQyxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ssR0FBRyxFQUFFUCxXQUFXLENBQUMsR0FBR0s7QUFDM0U7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0RKLFlBQVlFLFNBQVMsQ0FBQ0ssUUFBUSxHQUFHLFNBQVNDLFlBQVksRUFBRUMsT0FBTyxFQUFFTCxRQUFRO0lBQ3hFLElBQUlNLFNBQVM7UUFDWkMsSUFBSUY7SUFDTDtJQUNBLElBQUlHLFVBQVVmLFFBQVFFLFdBQVdTLGNBQWM7SUFDL0MsT0FBTyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0ksc0JBQXNCLENBQUMsSUFBSSxDQUFDSixNQUFNLENBQUNLLEdBQUcsRUFBRU0sU0FBU0YsUUFBUU47QUFDN0U7QUFFQTs7O0NBR0MsR0FDRFMsT0FBT0MsT0FBTyxHQUFHZCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvY29sbGVjdGlvbnMuanM/NzZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIEJveCBDb2xsZWN0aW9uIFJlc291cmNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBCQVNFX1BBVEggPSAnL2NvbGxlY3Rpb25zJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIGFsbCAnQ29sbGVjdGlvbicgZW5kcG9pbnRzIGFuZCBhY3Rpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCAtIFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIENvbGxlY3Rpb25zKGNsaWVudCkge1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuLyoqXG4gKiBSZXF1ZXN0cyBhbGwgb2YgYSB1c2VyJ3MgY29sbGVjdGlvbiBvYmplY3RzLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb2xsZWN0aW9ucydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIGEgY29sbGVjdGlvbiBvZiBjb2xsZWN0aW9ucyBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGNvbGxlY3Rpb25zXG4gKi9cbkNvbGxlY3Rpb25zLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKEJBU0VfUEFUSCwge30sIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG9iamVjdCB3aXRoIGEgZ2l2ZW4gSUQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbGxlY3Rpb25zLzpjb2xsZWN0aW9uSUQvaXRlbXMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSUQgLSBCb3ggSUQgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCBpdGVtcyBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBpdGVtcyBpbmZvcm1hdGlvbiBpZiB0aGV5IHdlcmUgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uXG4gKi9cbkNvbGxlY3Rpb25zLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25JRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBjb2xsZWN0aW9uSUQsICdpdGVtcycpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvY29sbGVjdGlvbnNcbiAqIEBzZWUge0BMaW5rIENvbGxlY3Rpb25zfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb25zO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiQkFTRV9QQVRIIiwiQ29sbGVjdGlvbnMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJnZXRBbGwiLCJjYWxsYmFjayIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJnZXQiLCJnZXRJdGVtcyIsImNvbGxlY3Rpb25JRCIsIm9wdGlvbnMiLCJwYXJhbXMiLCJxcyIsImFwaVBhdGgiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/collections.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/comments.js":
/*!************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/comments.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Comments Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/comments\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Comment' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Comments(client) {\n    this.client = client;\n}\n/**\n * Requests a comment object with the given ID.\n *\n * API Endpoint: '/comments/:commentID'\n * Method: GET\n *\n * @param {string} commentID - Box ID of the comment being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the comment information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the comment object\n */ Comments.prototype.get = function(commentID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, commentID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Posts a new comment on a file.\n *\n * API Endpoint: '/comments\n * Method: POST\n *\n * @param {string} fileID - Box file id of the file to comment on\n * @param {string} commentBody - text of the comment\n * @param {Function} [callback] - passed the new comment data if it was posted successfully\n * @returns {Promise<Object>} A promise resolving to the new comment object\n */ Comments.prototype.create = function(fileID, commentBody, callback) {\n    // @TODO(bemerick) 2013-10-29: Don't hardcode this 'item'. Abstract to all commentable types...\n    var params = {\n        body: {\n            item: {\n                type: \"file\",\n                id: fileID\n            },\n            message: commentBody\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(BASE_PATH, params, callback);\n};\n/**\n * Posts a new tagged comment on a file.\n *\n * API Endpoint: '/comments\n * Method: POST\n *\n * @param {string} fileID - Box file id of the file to comment on\n * @param {string} commentBody - text of the tagged comment\n * @param {Function} [callback] - passed the new tagged comment data if it was posted successfully\n * @returns {Promise<Object>} A promise resolving to the new comment object\n */ Comments.prototype.createTaggedComment = function(fileID, commentBody, callback) {\n    var params = {\n        body: {\n            item: {\n                type: \"file\",\n                id: fileID\n            },\n            tagged_message: commentBody\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(BASE_PATH, params, callback);\n};\n/**\n * Posts a new comment as a reply to another comment.\n *\n * API Endpoint: '/comments\n * Method: POST\n *\n * @param {string} commentID - Comment ID of the comment to reply to\n * @param {string} commentBody - text of the comment\n * @param {Function} [callback] - passed the new comment data if it was posted successfully\n * @returns {Promise<Object>} A promise resolving to the new comment object\n */ Comments.prototype.reply = function(commentID, commentBody, callback) {\n    var params = {\n        body: {\n            item: {\n                type: \"comment\",\n                id: commentID\n            },\n            message: commentBody\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(BASE_PATH, params, callback);\n};\n/**\n * Posts a new tagged comment as a reply to another comment.\n *\n * API Endpoint: '/comments\n * Method: POST\n *\n * @param {string} commentID - Comment ID of the comment to reply to\n * @param {string} commentBody - text of the tagged comment\n * @param {Function} [callback] - passed the new tagged comment data if it was posted successfully\n * @returns {Promise<Object>} A promise resolving to the new comment object\n */ Comments.prototype.createTaggedReply = function(commentID, commentBody, callback) {\n    var params = {\n        body: {\n            item: {\n                type: \"comment\",\n                id: commentID\n            },\n            tagged_message: commentBody\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(BASE_PATH, params, callback);\n};\n/**\n * Update some information about a given comment.\n *\n * API Endpoint: '/comments/:commentID'\n * Method: PUT\n *\n * @param {string} commentID - Box ID of the comment being requested\n * @param {Object} updates - Fields to update on the comment\n * @param {Function} [callback] - Passed the updated comment information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated comment object\n */ Comments.prototype.update = function(commentID, updates, callback) {\n    var params = {\n        body: updates\n    };\n    var apiPath = urlPath(BASE_PATH, commentID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Delete a given comment.\n *\n * API Endpoint: '/comments/:commentID'\n * Method: DELETE\n *\n * @param {string} commentID - Box ID of the comment being requested\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ Comments.prototype.delete = function(commentID, callback) {\n    var apiPath = urlPath(BASE_PATH, commentID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * @module box-node-sdk/lib/managers/comments\n * @see {@Link Comments}\n */ module.exports = Comments;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9jb21tZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFHdEIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFDakYsSUFBSUMsWUFBWTtBQUdoQixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxTQUFTQyxNQUFNO0lBQ3ZCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNERCxTQUFTRSxTQUFTLENBQUNDLEdBQUcsR0FBRyxTQUFTQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUM3RCxJQUFJQyxTQUFTO1FBQ1pDLElBQUlIO0lBQ0w7SUFDQSxJQUFJSSxVQUFVWixRQUFRRSxXQUFXSztJQUNqQyxPQUFPLElBQUksQ0FBQ0gsTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ0UsR0FBRyxFQUFFTSxTQUFTRixRQUFRRDtBQUM3RTtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRE4sU0FBU0UsU0FBUyxDQUFDUyxNQUFNLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxXQUFXLEVBQUVQLFFBQVE7SUFDakUsK0ZBQStGO0lBQy9GLElBQUlDLFNBQVM7UUFDWk8sTUFBTTtZQUNMQyxNQUFNO2dCQUNMQyxNQUFNO2dCQUNOQyxJQUFJTDtZQUNMO1lBQ0FNLFNBQVNMO1FBQ1Y7SUFDRDtJQUNBLE9BQU8sSUFBSSxDQUFDWixNQUFNLENBQUNTLHNCQUFzQixDQUFDLElBQUksQ0FBQ1QsTUFBTSxDQUFDa0IsSUFBSSxFQUFFcEIsV0FBV1EsUUFBUUQ7QUFDaEY7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0ROLFNBQVNFLFNBQVMsQ0FBQ2tCLG1CQUFtQixHQUFHLFNBQVNSLE1BQU0sRUFBRUMsV0FBVyxFQUFFUCxRQUFRO0lBQzlFLElBQUlDLFNBQVM7UUFDWk8sTUFBTTtZQUNMQyxNQUFNO2dCQUNMQyxNQUFNO2dCQUNOQyxJQUFJTDtZQUNMO1lBQ0FTLGdCQUFnQlI7UUFDakI7SUFDRDtJQUNBLE9BQU8sSUFBSSxDQUFDWixNQUFNLENBQUNTLHNCQUFzQixDQUFDLElBQUksQ0FBQ1QsTUFBTSxDQUFDa0IsSUFBSSxFQUFFcEIsV0FBV1EsUUFBUUQ7QUFDaEY7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0ROLFNBQVNFLFNBQVMsQ0FBQ29CLEtBQUssR0FBRyxTQUFTbEIsU0FBUyxFQUFFUyxXQUFXLEVBQUVQLFFBQVE7SUFDbkUsSUFBSUMsU0FBUztRQUNaTyxNQUFNO1lBQ0xDLE1BQU07Z0JBQ0xDLE1BQU07Z0JBQ05DLElBQUliO1lBQ0w7WUFDQWMsU0FBU0w7UUFDVjtJQUNEO0lBQ0EsT0FBTyxJQUFJLENBQUNaLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNrQixJQUFJLEVBQUVwQixXQUFXUSxRQUFRRDtBQUNoRjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRE4sU0FBU0UsU0FBUyxDQUFDcUIsaUJBQWlCLEdBQUcsU0FBU25CLFNBQVMsRUFBRVMsV0FBVyxFQUFFUCxRQUFRO0lBQy9FLElBQUlDLFNBQVM7UUFDWk8sTUFBTTtZQUNMQyxNQUFNO2dCQUNMQyxNQUFNO2dCQUNOQyxJQUFJYjtZQUNMO1lBQ0FpQixnQkFBZ0JSO1FBQ2pCO0lBQ0Q7SUFDQSxPQUFPLElBQUksQ0FBQ1osTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ2tCLElBQUksRUFBRXBCLFdBQVdRLFFBQVFEO0FBQ2hGO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNETixTQUFTRSxTQUFTLENBQUNzQixNQUFNLEdBQUcsU0FBU3BCLFNBQVMsRUFBRXFCLE9BQU8sRUFBRW5CLFFBQVE7SUFDaEUsSUFBSUMsU0FBUztRQUNaTyxNQUFNVztJQUNQO0lBRUEsSUFBSWhCLFVBQVVaLFFBQVFFLFdBQVdLO0lBQ2pDLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUNTLHNCQUFzQixDQUFDLElBQUksQ0FBQ1QsTUFBTSxDQUFDeUIsR0FBRyxFQUFFakIsU0FBU0YsUUFBUUQ7QUFDN0U7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRE4sU0FBU0UsU0FBUyxDQUFDeUIsTUFBTSxHQUFHLFNBQVN2QixTQUFTLEVBQUVFLFFBQVE7SUFFdkQsSUFBSUcsVUFBVVosUUFBUUUsV0FBV0s7SUFDakMsT0FBTyxJQUFJLENBQUNILE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUMyQixHQUFHLEVBQUVuQixTQUFTLE1BQU1IO0FBQzNFO0FBR0E7OztDQUdDLEdBQ0R1QixPQUFPQyxPQUFPLEdBQUc5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvY29tbWVudHMuanM/ZmZjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIEJveCBDb21tZW50cyBSZXNvdXJjZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyk7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBCQVNFX1BBVEggPSAnL2NvbW1lbnRzJztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsICdDb21tZW50JyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQ29tbWVudHMoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG4vKipcbiAqIFJlcXVlc3RzIGEgY29tbWVudCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbW1lbnRzLzpjb21tZW50SUQnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50SUQgLSBCb3ggSUQgb2YgdGhlIGNvbW1lbnQgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgY29tbWVudCBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb21tZW50IG9iamVjdFxuICovXG5Db21tZW50cy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY29tbWVudElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGNvbW1lbnRJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFBvc3RzIGEgbmV3IGNvbW1lbnQgb24gYSBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb21tZW50c1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIEJveCBmaWxlIGlkIG9mIHRoZSBmaWxlIHRvIGNvbW1lbnQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50Qm9keSAtIHRleHQgb2YgdGhlIGNvbW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIG5ldyBjb21tZW50IGRhdGEgaWYgaXQgd2FzIHBvc3RlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG5ldyBjb21tZW50IG9iamVjdFxuICovXG5Db21tZW50cy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oZmlsZUlELCBjb21tZW50Qm9keSwgY2FsbGJhY2spIHtcblx0Ly8gQFRPRE8oYmVtZXJpY2spIDIwMTMtMTAtMjk6IERvbid0IGhhcmRjb2RlIHRoaXMgJ2l0ZW0nLiBBYnN0cmFjdCB0byBhbGwgY29tbWVudGFibGUgdHlwZXMuLi5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHRpdGVtOiB7XG5cdFx0XHRcdHR5cGU6ICdmaWxlJyxcblx0XHRcdFx0aWQ6IGZpbGVJRFxuXHRcdFx0fSxcblx0XHRcdG1lc3NhZ2U6IGNvbW1lbnRCb2R5XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShCQVNFX1BBVEgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQb3N0cyBhIG5ldyB0YWdnZWQgY29tbWVudCBvbiBhIGZpbGUuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2NvbW1lbnRzXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gQm94IGZpbGUgaWQgb2YgdGhlIGZpbGUgdG8gY29tbWVudCBvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRCb2R5IC0gdGV4dCBvZiB0aGUgdGFnZ2VkIGNvbW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIG5ldyB0YWdnZWQgY29tbWVudCBkYXRhIGlmIGl0IHdhcyBwb3N0ZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXcgY29tbWVudCBvYmplY3RcbiAqL1xuQ29tbWVudHMucHJvdG90eXBlLmNyZWF0ZVRhZ2dlZENvbW1lbnQgPSBmdW5jdGlvbihmaWxlSUQsIGNvbW1lbnRCb2R5LCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IHtcblx0XHRcdGl0ZW06IHtcblx0XHRcdFx0dHlwZTogJ2ZpbGUnLFxuXHRcdFx0XHRpZDogZmlsZUlEXG5cdFx0XHR9LFxuXHRcdFx0dGFnZ2VkX21lc3NhZ2U6IGNvbW1lbnRCb2R5XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShCQVNFX1BBVEgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQb3N0cyBhIG5ldyBjb21tZW50IGFzIGEgcmVwbHkgdG8gYW5vdGhlciBjb21tZW50LlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb21tZW50c1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRJRCAtIENvbW1lbnQgSUQgb2YgdGhlIGNvbW1lbnQgdG8gcmVwbHkgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50Qm9keSAtIHRleHQgb2YgdGhlIGNvbW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIG5ldyBjb21tZW50IGRhdGEgaWYgaXQgd2FzIHBvc3RlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG5ldyBjb21tZW50IG9iamVjdFxuICovXG5Db21tZW50cy5wcm90b3R5cGUucmVwbHkgPSBmdW5jdGlvbihjb21tZW50SUQsIGNvbW1lbnRCb2R5LCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IHtcblx0XHRcdGl0ZW06IHtcblx0XHRcdFx0dHlwZTogJ2NvbW1lbnQnLFxuXHRcdFx0XHRpZDogY29tbWVudElEXG5cdFx0XHR9LFxuXHRcdFx0bWVzc2FnZTogY29tbWVudEJvZHlcblx0XHR9XG5cdH07XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKEJBU0VfUEFUSCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFBvc3RzIGEgbmV3IHRhZ2dlZCBjb21tZW50IGFzIGEgcmVwbHkgdG8gYW5vdGhlciBjb21tZW50LlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9jb21tZW50c1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRJRCAtIENvbW1lbnQgSUQgb2YgdGhlIGNvbW1lbnQgdG8gcmVwbHkgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21tZW50Qm9keSAtIHRleHQgb2YgdGhlIHRhZ2dlZCBjb21tZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gcGFzc2VkIHRoZSBuZXcgdGFnZ2VkIGNvbW1lbnQgZGF0YSBpZiBpdCB3YXMgcG9zdGVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IGNvbW1lbnQgb2JqZWN0XG4gKi9cbkNvbW1lbnRzLnByb3RvdHlwZS5jcmVhdGVUYWdnZWRSZXBseSA9IGZ1bmN0aW9uKGNvbW1lbnRJRCwgY29tbWVudEJvZHksIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0aXRlbToge1xuXHRcdFx0XHR0eXBlOiAnY29tbWVudCcsXG5cdFx0XHRcdGlkOiBjb21tZW50SURcblx0XHRcdH0sXG5cdFx0XHR0YWdnZWRfbWVzc2FnZTogY29tbWVudEJvZHlcblx0XHR9XG5cdH07XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKEJBU0VfUEFUSCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBzb21lIGluZm9ybWF0aW9uIGFib3V0IGEgZ2l2ZW4gY29tbWVudC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29tbWVudHMvOmNvbW1lbnRJRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRJRCAtIEJveCBJRCBvZiB0aGUgY29tbWVudCBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIC0gRmllbGRzIHRvIHVwZGF0ZSBvbiB0aGUgY29tbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBkYXRlZCBjb21tZW50IGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgY29tbWVudCBvYmplY3RcbiAqL1xuQ29tbWVudHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGNvbW1lbnRJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB1cGRhdGVzXG5cdH07XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgY29tbWVudElEKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgZ2l2ZW4gY29tbWVudC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvY29tbWVudHMvOmNvbW1lbnRJRCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbW1lbnRJRCAtIEJveCBJRCBvZiB0aGUgY29tbWVudCBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBFbXB0eSByZXNwb25zZSBib2R5IHBhc3NlZCBpZiBzdWNjZXNzZnVsLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuICovXG5Db21tZW50cy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24oY29tbWVudElELCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGNvbW1lbnRJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9jb21tZW50c1xuICogQHNlZSB7QExpbmsgQ29tbWVudHN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQ29tbWVudHM7XG4iXSwibmFtZXMiOlsidXJsUGF0aCIsInJlcXVpcmUiLCJCQVNFX1BBVEgiLCJDb21tZW50cyIsImNsaWVudCIsInByb3RvdHlwZSIsImdldCIsImNvbW1lbnRJRCIsIm9wdGlvbnMiLCJjYWxsYmFjayIsInBhcmFtcyIsInFzIiwiYXBpUGF0aCIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJjcmVhdGUiLCJmaWxlSUQiLCJjb21tZW50Qm9keSIsImJvZHkiLCJpdGVtIiwidHlwZSIsImlkIiwibWVzc2FnZSIsInBvc3QiLCJjcmVhdGVUYWdnZWRDb21tZW50IiwidGFnZ2VkX21lc3NhZ2UiLCJyZXBseSIsImNyZWF0ZVRhZ2dlZFJlcGx5IiwidXBkYXRlIiwidXBkYXRlcyIsInB1dCIsImRlbGV0ZSIsImRlbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/comments.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/device-pins.js":
/*!***************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/device-pins.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Device Pins resource\n * @author mwiller\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/device_pinners\", ENTERPRISES_PATH = \"/enterprises\", DEVICE_PINNERS_SUBRESOURCE = \"device_pinners\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all Device Pin endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function DevicePins(client) {\n    this.client = client;\n}\n/**\n * Get a specific device pinning record\n *\n * API Endpoint: '/device_pinners/:pinID'\n * Method: GET\n *\n * @param {string} pinID - The ID of the pin to retrieve\n * @param {Object} [options] - Optional paramters, can be left null in many cases\n * @param {Function} [callback] - Passed the device pin if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the device pin object\n */ DevicePins.prototype.get = function(pinID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, pinID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Delete a specific device pinning record\n *\n * API Endpoint: '/device_pinners/:pinID'\n * Method: DELETE\n *\n * @param {string} pinID - The ID of the pin to delete\n * @param {Object} [options] - Optional paramters, can be left null in many cases\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ DevicePins.prototype.delete = function(pinID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, pinID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Get all device pin records for the current enterprise\n *\n * API Endpoint: '/enterprises/:enterpriseID/device_pinners'\n * Method: GET\n *\n * @param {Object} [options] - Optional paramters, can be left null in many cases\n * @param {Function} [callback] - Passed a list of device pins if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of device pins\n */ DevicePins.prototype.getAll = function(options, callback) {\n    return this.client.users.get(this.client.CURRENT_USER_ID, {\n        fields: \"enterprise\"\n    }).then((data)=>{\n        if (!data.enterprise || !data.enterprise.id) {\n            throw new Error(\"User must be in an enterprise to view device pins\");\n        }\n        var apiPath = urlPath(ENTERPRISES_PATH, data.enterprise.id, DEVICE_PINNERS_SUBRESOURCE), params = {\n            qs: options\n        };\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params);\n    }).asCallback(callback);\n};\nmodule.exports = DevicePins;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9kZXZpY2UtcGlucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0MsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBQ2pGLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXRCLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBQ2pGLElBQUlDLFlBQVksbUJBQ2ZDLG1CQUFtQixnQkFDbkJDLDZCQUE2QjtBQUU5QixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxXQUFXQyxNQUFNO0lBQ3pCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNERCxXQUFXRSxTQUFTLENBQUNDLEdBQUcsR0FBRyxTQUFTQyxLQUFLLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUUzRCxJQUFJQyxVQUFVWixRQUFRRSxXQUFXTyxRQUNoQ0ksU0FBUztRQUNSQyxJQUFJSjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEdBQUcsRUFBRUksU0FBU0MsUUFBUUY7QUFDN0U7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0ROLFdBQVdFLFNBQVMsQ0FBQ1MsTUFBTSxHQUFHLFNBQVNQLEtBQUssRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBRTlELElBQUlDLFVBQVVaLFFBQVFFLFdBQVdPLFFBQ2hDSSxTQUFTO1FBQ1JDLElBQUlKO0lBQ0w7SUFFRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ1csR0FBRyxFQUFFTCxTQUFTQyxRQUFRRjtBQUM3RTtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNETixXQUFXRSxTQUFTLENBQUNXLE1BQU0sR0FBRyxTQUFTUixPQUFPLEVBQUVDLFFBQVE7SUFFdkQsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQ2EsS0FBSyxDQUFDWCxHQUFHLENBQUMsSUFBSSxDQUFDRixNQUFNLENBQUNjLGVBQWUsRUFBRTtRQUFDQyxRQUFRO0lBQVksR0FDN0VDLElBQUksQ0FBQ0MsQ0FBQUE7UUFFTCxJQUFJLENBQUNBLEtBQUtDLFVBQVUsSUFBSSxDQUFDRCxLQUFLQyxVQUFVLENBQUNDLEVBQUUsRUFBRTtZQUM1QyxNQUFNLElBQUlDLE1BQU07UUFDakI7UUFFQSxJQUFJZCxVQUFVWixRQUFRRyxrQkFBa0JvQixLQUFLQyxVQUFVLENBQUNDLEVBQUUsRUFBRXJCLDZCQUMzRFMsU0FBUztZQUNSQyxJQUFJSjtRQUNMO1FBRUQsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEdBQUcsRUFBRUksU0FBU0M7SUFDckUsR0FDQ2MsVUFBVSxDQUFDaEI7QUFDZDtBQUVBaUIsT0FBT0MsT0FBTyxHQUFHeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL2RldmljZS1waW5zLmpzPzBjNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBEZXZpY2UgUGlucyByZXNvdXJjZVxuICogQGF1dGhvciBtd2lsbGVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBCQVNFX1BBVEggPSAnL2RldmljZV9waW5uZXJzJyxcblx0RU5URVJQUklTRVNfUEFUSCA9ICcvZW50ZXJwcmlzZXMnLFxuXHRERVZJQ0VfUElOTkVSU19TVUJSRVNPVVJDRSA9ICdkZXZpY2VfcGlubmVycyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgRGV2aWNlIFBpbiBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gRGV2aWNlUGlucyhjbGllbnQpIHtcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogR2V0IGEgc3BlY2lmaWMgZGV2aWNlIHBpbm5pbmcgcmVjb3JkXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2RldmljZV9waW5uZXJzLzpwaW5JRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBpbklEIC0gVGhlIElEIG9mIHRoZSBwaW4gdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbXRlcnMsIGNhbiBiZSBsZWZ0IG51bGwgaW4gbWFueSBjYXNlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgZGV2aWNlIHBpbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGRldmljZSBwaW4gb2JqZWN0XG4gKi9cbkRldmljZVBpbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBpbklELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHBpbklEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRGVsZXRlIGEgc3BlY2lmaWMgZGV2aWNlIHBpbm5pbmcgcmVjb3JkXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2RldmljZV9waW5uZXJzLzpwaW5JRCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBpbklEIC0gVGhlIElEIG9mIHRoZSBwaW4gdG8gZGVsZXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW10ZXJzLCBjYW4gYmUgbGVmdCBudWxsIGluIG1hbnkgY2FzZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgbm90aGluZyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuRGV2aWNlUGlucy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24ocGluSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgcGluSUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgYWxsIGRldmljZSBwaW4gcmVjb3JkcyBmb3IgdGhlIGN1cnJlbnQgZW50ZXJwcmlzZVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9lbnRlcnByaXNlcy86ZW50ZXJwcmlzZUlEL2RldmljZV9waW5uZXJzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW10ZXJzLCBjYW4gYmUgbGVmdCBudWxsIGluIG1hbnkgY2FzZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBsaXN0IG9mIGRldmljZSBwaW5zIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiBkZXZpY2UgcGluc1xuICovXG5EZXZpY2VQaW5zLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC51c2Vycy5nZXQodGhpcy5jbGllbnQuQ1VSUkVOVF9VU0VSX0lELCB7ZmllbGRzOiAnZW50ZXJwcmlzZSd9KVxuXHRcdC50aGVuKGRhdGEgPT4ge1xuXG5cdFx0XHRpZiAoIWRhdGEuZW50ZXJwcmlzZSB8fCAhZGF0YS5lbnRlcnByaXNlLmlkKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlciBtdXN0IGJlIGluIGFuIGVudGVycHJpc2UgdG8gdmlldyBkZXZpY2UgcGlucycpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoRU5URVJQUklTRVNfUEFUSCwgZGF0YS5lbnRlcnByaXNlLmlkLCBERVZJQ0VfUElOTkVSU19TVUJSRVNPVVJDRSksXG5cdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRxczogb3B0aW9uc1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcyk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERldmljZVBpbnM7XG4iXSwibmFtZXMiOlsidXJsUGF0aCIsInJlcXVpcmUiLCJCQVNFX1BBVEgiLCJFTlRFUlBSSVNFU19QQVRIIiwiREVWSUNFX1BJTk5FUlNfU1VCUkVTT1VSQ0UiLCJEZXZpY2VQaW5zIiwiY2xpZW50IiwicHJvdG90eXBlIiwiZ2V0IiwicGluSUQiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhcGlQYXRoIiwicGFyYW1zIiwicXMiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwiZGVsZXRlIiwiZGVsIiwiZ2V0QWxsIiwidXNlcnMiLCJDVVJSRU5UX1VTRVJfSUQiLCJmaWVsZHMiLCJ0aGVuIiwiZGF0YSIsImVudGVycHJpc2UiLCJpZCIsIkVycm9yIiwiYXNDYWxsYmFjayIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/device-pins.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/enterprise.js":
/*!**************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/enterprise.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for Enterprise resources\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/** @typedef {string} EnterpriseUserType */ /** @typedef {string} EnterpriseRole */ /** @typedef {string} EnterpriseUserStatus */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar USERS_PATH = \"/users\", INVITES_PATH = \"/invites\", FOLDERS_SUBRESOURCE = \"folders\", ROOT_FOLDER_ID = \"0\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all Enterprise endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Enterprise(client) {\n    this.client = client;\n}\n/**\n * List of valid user types\n * @readonly\n * @enum {EnterpriseUserType}\n */ Enterprise.prototype.userTypes = Object.freeze({\n    ALL: \"all\",\n    MANAGED: \"managed\",\n    EXTERNAL: \"external\"\n});\n/**\n * List of valid user statuses\n * @readonly\n * @enum {EnterpriseUserStatus}\n */ Enterprise.prototype.userStatuses = Object.freeze({\n    ACTIVE: \"active\",\n    INACTIVE: \"inactive\",\n    CANNOT_DELETE_OR_EDIT: \"cannot_delete_edit\",\n    CANNOT_DELETE_EDIT_OR_UPLOAD: \"cannot_delete_edit_upload\"\n});\n/**\n * List of valid roles\n * @readonly\n * @enum {EnterpriseRole}\n */ Enterprise.prototype.userRoles = Object.freeze({\n    USER: \"user\",\n    COADMIN: \"coadmin\"\n});\n/**\n * Get a list of users in the current enterprise\n *\n * API Endpoint: '/users'\n * Method: GET\n *\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {string} [options.filter_term] - Filter the results to only users starting with the filter_term in either the name or the login\n * @param {int} [options.limit=100] - The number of records to return\n * @param {boolean} [options.usemarker=false] - Whether or not to use marker-based pagination\n * @param {string} [options.marker=''] - The marker for the page at which to start. Default is the first page\n * @param {int} [options.offset=0] - The record at which to start\n * @param {EnterpriseUserType} [options.user_type=managed] - The type of user to search for\n * @param {Function} [callback] - Passed the list of users if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of users\n */ Enterprise.prototype.getUsers = function(options, callback) {\n    var apiPath = urlPath(USERS_PATH), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Invites a user to join the enterprise\n *\n * API Endpoint: '/invites'\n * Method: POST\n *\n * @param {string} enterpriseID - The ID of the enterprise to invite the user to\n * @param {string} email - The email address of the user to invite\n * @param {Function} [callback] - Passed the invite object if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the invite object\n */ Enterprise.prototype.inviteUser = function(enterpriseID, email, callback) {\n    var apiPath = urlPath(INVITES_PATH), params = {\n        body: {\n            enterprise: {\n                id: enterpriseID\n            },\n            actionable_by: {\n                login: email\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Create a new user in the current enterprise\n *\n * API Endpoint: '/users'\n * Method: POST\n *\n * @param {string} login - The email address this user uses to login\n * @param {string} name - The name of this user\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {EnterpriseRole} [options.role] - This users enterprise role\n * @param {string} [options.language] - The user's language\n * @param {boolean} [options.is_sync_enabled] - Whether or not this user can use Box Sync\n * @param {string} [options.job_title] - The users job title\n * @param {string} [options.phone] - The users phone number\n * @param {string} [options.address] - The users address\n * @param {int} [options.space_amount] - The users total available storage space in bytes\n * @param {Array} [options.tracking_codes] - An array of key/value pairs set by the users admin\n * @param {EnterpriseUserStatus} [options.status] - The user's status\n * @param {boolean} [options.can_see_managed_users] - Whether the user should be able to see other managed users\n * @param {string} [options.timezone] - The user's timezone\n * @param {boolean} [options.is_exempt_from_device_limits] - Whether to exempt this user from Enterprise device limits\n * @param {boolean} [options.is_exempt_from_login_verification] - Whether or not this user must use two-factor authentication\n * @param {Function} [callback] - Passed the created user if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created user\n */ Enterprise.prototype.addUser = function(login, name, options, callback) {\n    var apiPath = urlPath(USERS_PATH), params = {\n        body: {\n            login,\n            name\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Create a new app user in the current enterprise\n *\n * API Endpoint: '/users'\n * Method: POST\n *\n * @param {string} name - The name of this user\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {string} [options.language] - The user's language\n * @param {string} [options.job_title] - The users job title\n * @param {string} [options.phone] - The users phone number\n * @param {string} [options.address] - The users address\n * @param {int} [options.space_amount] - The users total available storage space in bytes\n * @param {string} [options.timezone] - The user's timezone\n * @param {Function} [callback] - Passed the created user if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created user\n */ Enterprise.prototype.addAppUser = function(name, options, callback) {\n    var apiPath = urlPath(USERS_PATH), params = {\n        body: {\n            name,\n            is_platform_access_only: true\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Transfers all of a user's files into another user's account.\n *\n * API Endpoint: '/users/:sourceUserID/folders/0'\n * Method: PUT\n *\n * @param {string} sourceUserID - The ID of the user whose files will be transferred\n * @param {string} destUserID - The ID of the user to transfer the files to\n * @param {Function} [callback] - Passed the new folder which contains all the files if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the folder containing the transferred content\n */ Enterprise.prototype.transferUserContent = function(sourceUserID, destUserID, callback) {\n    var apiPath = urlPath(USERS_PATH, sourceUserID, FOLDERS_SUBRESOURCE, ROOT_FOLDER_ID), params = {\n        body: {\n            owned_by: {\n                id: destUserID\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\nmodule.exports = Enterprise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9lbnRlcnByaXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxnRkFBZ0Y7QUFDaEYsV0FBVztBQUNYLGdGQUFnRjtBQUVoRix5Q0FBeUMsR0FFekMscUNBQXFDLEdBRXJDLDJDQUEyQyxHQUUzQyxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUNoRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV0QixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUNoRixJQUFJQyxhQUFhLFVBQ2hCQyxlQUFlLFlBQ2ZDLHNCQUFzQixXQUN0QkMsaUJBQWlCO0FBRWxCLGdGQUFnRjtBQUNoRixTQUFTO0FBQ1QsZ0ZBQWdGO0FBRWhGOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFdBQVdDLE1BQU07SUFDekIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0FBQ2Y7QUFFQTs7OztDQUlDLEdBQ0RELFdBQVdFLFNBQVMsQ0FBQ0MsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUM7SUFDOUNDLEtBQUs7SUFDTEMsU0FBUztJQUNUQyxVQUFVO0FBQ1g7QUFFQTs7OztDQUlDLEdBQ0RSLFdBQVdFLFNBQVMsQ0FBQ08sWUFBWSxHQUFHTCxPQUFPQyxNQUFNLENBQUM7SUFDakRLLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyx1QkFBdUI7SUFDdkJDLDhCQUE4QjtBQUMvQjtBQUVBOzs7O0NBSUMsR0FDRGIsV0FBV0UsU0FBUyxDQUFDWSxTQUFTLEdBQUdWLE9BQU9DLE1BQU0sQ0FBQztJQUM5Q1UsTUFBTTtJQUNOQyxTQUFTO0FBQ1Y7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRGhCLFdBQVdFLFNBQVMsQ0FBQ2UsUUFBUSxHQUFHLFNBQVNDLE9BQU8sRUFBRUMsUUFBUTtJQUV6RCxJQUFJQyxVQUFVMUIsUUFBUUUsYUFDckJ5QixTQUFTO1FBQ1JDLElBQUlKO0lBQ0w7SUFFRCxPQUFPLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ3NCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3RCLE1BQU0sQ0FBQ3VCLEdBQUcsRUFBRUosU0FBU0MsUUFBUUY7QUFDN0U7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0RuQixXQUFXRSxTQUFTLENBQUN1QixVQUFVLEdBQUcsU0FBU0MsWUFBWSxFQUFFQyxLQUFLLEVBQUVSLFFBQVE7SUFFdkUsSUFBSUMsVUFBVTFCLFFBQVFHLGVBQ3JCd0IsU0FBUztRQUNSTyxNQUFNO1lBQ0xDLFlBQVk7Z0JBQ1hDLElBQUlKO1lBQ0w7WUFDQUssZUFBZTtnQkFDZEMsT0FBT0w7WUFDUjtRQUNEO0lBQ0Q7SUFFRCxPQUFPLElBQUksQ0FBQzFCLE1BQU0sQ0FBQ3NCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3RCLE1BQU0sQ0FBQ2dDLElBQUksRUFBRWIsU0FBU0MsUUFBUUY7QUFDOUU7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ0RuQixXQUFXRSxTQUFTLENBQUNnQyxPQUFPLEdBQUcsU0FBU0YsS0FBSyxFQUFFRyxJQUFJLEVBQUVqQixPQUFPLEVBQUVDLFFBQVE7SUFFckUsSUFBSUMsVUFBVTFCLFFBQVFFLGFBQ3JCeUIsU0FBUztRQUNSTyxNQUFNO1lBQUNJO1lBQU9HO1FBQUk7SUFDbkI7SUFFRC9CLE9BQU9nQyxNQUFNLENBQUNmLE9BQU9PLElBQUksRUFBRVY7SUFFM0IsT0FBTyxJQUFJLENBQUNqQixNQUFNLENBQUNzQixzQkFBc0IsQ0FBQyxJQUFJLENBQUN0QixNQUFNLENBQUNnQyxJQUFJLEVBQUViLFNBQVNDLFFBQVFGO0FBQzlFO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDRG5CLFdBQVdFLFNBQVMsQ0FBQ21DLFVBQVUsR0FBRyxTQUFTRixJQUFJLEVBQUVqQixPQUFPLEVBQUVDLFFBQVE7SUFFakUsSUFBSUMsVUFBVTFCLFFBQVFFLGFBQ3JCeUIsU0FBUztRQUNSTyxNQUFNO1lBQ0xPO1lBQ0FHLHlCQUF5QjtRQUMxQjtJQUNEO0lBRURsQyxPQUFPZ0MsTUFBTSxDQUFDZixPQUFPTyxJQUFJLEVBQUVWO0lBRTNCLE9BQU8sSUFBSSxDQUFDakIsTUFBTSxDQUFDc0Isc0JBQXNCLENBQUMsSUFBSSxDQUFDdEIsTUFBTSxDQUFDZ0MsSUFBSSxFQUFFYixTQUFTQyxRQUFRRjtBQUM5RTtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRG5CLFdBQVdFLFNBQVMsQ0FBQ3FDLG1CQUFtQixHQUFHLFNBQVNDLFlBQVksRUFBRUMsVUFBVSxFQUFFdEIsUUFBUTtJQUVyRixJQUFJQyxVQUFVMUIsUUFBUUUsWUFBWTRDLGNBQWMxQyxxQkFBcUJDLGlCQUNwRXNCLFNBQVM7UUFDUk8sTUFBTTtZQUNMYyxVQUFVO2dCQUFDWixJQUFJVztZQUFVO1FBQzFCO0lBQ0Q7SUFFRCxPQUFPLElBQUksQ0FBQ3hDLE1BQU0sQ0FBQ3NCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3RCLE1BQU0sQ0FBQzBDLEdBQUcsRUFBRXZCLFNBQVNDLFFBQVFGO0FBQzdFO0FBRUF5QixPQUFPQyxPQUFPLEdBQUc3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvZW50ZXJwcmlzZS5qcz8xN2JmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBNYW5hZ2VyIGZvciBFbnRlcnByaXNlIHJlc291cmNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKiogQHR5cGVkZWYge3N0cmluZ30gRW50ZXJwcmlzZVVzZXJUeXBlICovXG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBFbnRlcnByaXNlUm9sZSAqL1xuXG4vKiogQHR5cGVkZWYge3N0cmluZ30gRW50ZXJwcmlzZVVzZXJTdGF0dXMgKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciB1cmxQYXRoID0gcmVxdWlyZSgnLi4vdXRpbC91cmwtcGF0aCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBVU0VSU19QQVRIID0gJy91c2VycycsXG5cdElOVklURVNfUEFUSCA9ICcvaW52aXRlcycsXG5cdEZPTERFUlNfU1VCUkVTT1VSQ0UgPSAnZm9sZGVycycsXG5cdFJPT1RfRk9MREVSX0lEID0gJzAnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIGFsbCBFbnRlcnByaXNlIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgLSBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBFbnRlcnByaXNlKGNsaWVudCkge1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIHZhbGlkIHVzZXIgdHlwZXNcbiAqIEByZWFkb25seVxuICogQGVudW0ge0VudGVycHJpc2VVc2VyVHlwZX1cbiAqL1xuRW50ZXJwcmlzZS5wcm90b3R5cGUudXNlclR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdEFMTDogJ2FsbCcsXG5cdE1BTkFHRUQ6ICdtYW5hZ2VkJyxcblx0RVhURVJOQUw6ICdleHRlcm5hbCdcbn0pO1xuXG4vKipcbiAqIExpc3Qgb2YgdmFsaWQgdXNlciBzdGF0dXNlc1xuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7RW50ZXJwcmlzZVVzZXJTdGF0dXN9XG4gKi9cbkVudGVycHJpc2UucHJvdG90eXBlLnVzZXJTdGF0dXNlcyA9IE9iamVjdC5mcmVlemUoe1xuXHRBQ1RJVkU6ICdhY3RpdmUnLFxuXHRJTkFDVElWRTogJ2luYWN0aXZlJyxcblx0Q0FOTk9UX0RFTEVURV9PUl9FRElUOiAnY2Fubm90X2RlbGV0ZV9lZGl0Jyxcblx0Q0FOTk9UX0RFTEVURV9FRElUX09SX1VQTE9BRDogJ2Nhbm5vdF9kZWxldGVfZWRpdF91cGxvYWQnXG59KTtcblxuLyoqXG4gKiBMaXN0IG9mIHZhbGlkIHJvbGVzXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtFbnRlcnByaXNlUm9sZX1cbiAqL1xuRW50ZXJwcmlzZS5wcm90b3R5cGUudXNlclJvbGVzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdFVTRVI6ICd1c2VyJyxcblx0Q09BRE1JTjogJ2NvYWRtaW4nXG59KTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIHVzZXJzIGluIHRoZSBjdXJyZW50IGVudGVycHJpc2VcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdXNlcnMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzLCBjYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5maWx0ZXJfdGVybV0gLSBGaWx0ZXIgdGhlIHJlc3VsdHMgdG8gb25seSB1c2VycyBzdGFydGluZyB3aXRoIHRoZSBmaWx0ZXJfdGVybSBpbiBlaXRoZXIgdGhlIG5hbWUgb3IgdGhlIGxvZ2luXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMubGltaXQ9MTAwXSAtIFRoZSBudW1iZXIgb2YgcmVjb3JkcyB0byByZXR1cm5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudXNlbWFya2VyPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHVzZSBtYXJrZXItYmFzZWQgcGFnaW5hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtlcj0nJ10gLSBUaGUgbWFya2VyIGZvciB0aGUgcGFnZSBhdCB3aGljaCB0byBzdGFydC4gRGVmYXVsdCBpcyB0aGUgZmlyc3QgcGFnZVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLm9mZnNldD0wXSAtIFRoZSByZWNvcmQgYXQgd2hpY2ggdG8gc3RhcnRcbiAqIEBwYXJhbSB7RW50ZXJwcmlzZVVzZXJUeXBlfSBbb3B0aW9ucy51c2VyX3R5cGU9bWFuYWdlZF0gLSBUaGUgdHlwZSBvZiB1c2VyIHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIGxpc3Qgb2YgdXNlcnMgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHVzZXJzXG4gKi9cbkVudGVycHJpc2UucHJvdG90eXBlLmdldFVzZXJzID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoVVNFUlNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEludml0ZXMgYSB1c2VyIHRvIGpvaW4gdGhlIGVudGVycHJpc2VcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvaW52aXRlcydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcnByaXNlSUQgLSBUaGUgSUQgb2YgdGhlIGVudGVycHJpc2UgdG8gaW52aXRlIHRoZSB1c2VyIHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1haWwgLSBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlciB0byBpbnZpdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIGludml0ZSBvYmplY3QgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBpbnZpdGUgb2JqZWN0XG4gKi9cbkVudGVycHJpc2UucHJvdG90eXBlLmludml0ZVVzZXIgPSBmdW5jdGlvbihlbnRlcnByaXNlSUQsIGVtYWlsLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChJTlZJVEVTX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHtcblx0XHRcdFx0ZW50ZXJwcmlzZToge1xuXHRcdFx0XHRcdGlkOiBlbnRlcnByaXNlSURcblx0XHRcdFx0fSxcblx0XHRcdFx0YWN0aW9uYWJsZV9ieToge1xuXHRcdFx0XHRcdGxvZ2luOiBlbWFpbFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHVzZXIgaW4gdGhlIGN1cnJlbnQgZW50ZXJwcmlzZVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy91c2VycydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2dpbiAtIFRoZSBlbWFpbCBhZGRyZXNzIHRoaXMgdXNlciB1c2VzIHRvIGxvZ2luXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoaXMgdXNlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMsIGNhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlc1xuICogQHBhcmFtIHtFbnRlcnByaXNlUm9sZX0gW29wdGlvbnMucm9sZV0gLSBUaGlzIHVzZXLigJlzIGVudGVycHJpc2Ugcm9sZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhbmd1YWdlXSAtIFRoZSB1c2VyJ3MgbGFuZ3VhZ2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNfc3luY19lbmFibGVkXSAtIFdoZXRoZXIgb3Igbm90IHRoaXMgdXNlciBjYW4gdXNlIEJveCBTeW5jXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuam9iX3RpdGxlXSAtIFRoZSB1c2Vy4oCZcyBqb2IgdGl0bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waG9uZV0gLSBUaGUgdXNlcuKAmXMgcGhvbmUgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWRkcmVzc10gLSBUaGUgdXNlcuKAmXMgYWRkcmVzc1xuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnNwYWNlX2Ftb3VudF0gLSBUaGUgdXNlcuKAmXMgdG90YWwgYXZhaWxhYmxlIHN0b3JhZ2Ugc3BhY2UgaW4gYnl0ZXNcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnRyYWNraW5nX2NvZGVzXSAtIEFuIGFycmF5IG9mIGtleS92YWx1ZSBwYWlycyBzZXQgYnkgdGhlIHVzZXLigJlzIGFkbWluXG4gKiBAcGFyYW0ge0VudGVycHJpc2VVc2VyU3RhdHVzfSBbb3B0aW9ucy5zdGF0dXNdIC0gVGhlIHVzZXIncyBzdGF0dXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2FuX3NlZV9tYW5hZ2VkX3VzZXJzXSAtIFdoZXRoZXIgdGhlIHVzZXIgc2hvdWxkIGJlIGFibGUgdG8gc2VlIG90aGVyIG1hbmFnZWQgdXNlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aW1lem9uZV0gLSBUaGUgdXNlcidzIHRpbWV6b25lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzX2V4ZW1wdF9mcm9tX2RldmljZV9saW1pdHNdIC0gV2hldGhlciB0byBleGVtcHQgdGhpcyB1c2VyIGZyb20gRW50ZXJwcmlzZSBkZXZpY2UgbGltaXRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzX2V4ZW1wdF9mcm9tX2xvZ2luX3ZlcmlmaWNhdGlvbl0gLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHVzZXIgbXVzdCB1c2UgdHdvLWZhY3RvciBhdXRoZW50aWNhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgY3JlYXRlZCB1c2VyIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCB1c2VyXG4gKi9cbkVudGVycHJpc2UucHJvdG90eXBlLmFkZFVzZXIgPSBmdW5jdGlvbihsb2dpbiwgbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoVVNFUlNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge2xvZ2luLCBuYW1lfVxuXHRcdH07XG5cblx0T2JqZWN0LmFzc2lnbihwYXJhbXMuYm9keSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBhcHAgdXNlciBpbiB0aGUgY3VycmVudCBlbnRlcnByaXNlXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3VzZXJzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGlzIHVzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzLCBjYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sYW5ndWFnZV0gLSBUaGUgdXNlcidzIGxhbmd1YWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuam9iX3RpdGxlXSAtIFRoZSB1c2Vy4oCZcyBqb2IgdGl0bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5waG9uZV0gLSBUaGUgdXNlcuKAmXMgcGhvbmUgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYWRkcmVzc10gLSBUaGUgdXNlcuKAmXMgYWRkcmVzc1xuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnNwYWNlX2Ftb3VudF0gLSBUaGUgdXNlcuKAmXMgdG90YWwgYXZhaWxhYmxlIHN0b3JhZ2Ugc3BhY2UgaW4gYnl0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50aW1lem9uZV0gLSBUaGUgdXNlcidzIHRpbWV6b25lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBjcmVhdGVkIHVzZXIgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIHVzZXJcbiAqL1xuRW50ZXJwcmlzZS5wcm90b3R5cGUuYWRkQXBwVXNlciA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKFVTRVJTX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHtcblx0XHRcdFx0bmFtZSxcblx0XHRcdFx0aXNfcGxhdGZvcm1fYWNjZXNzX29ubHk6IHRydWVcblx0XHRcdH1cblx0XHR9O1xuXG5cdE9iamVjdC5hc3NpZ24ocGFyYW1zLmJvZHksIG9wdGlvbnMpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBUcmFuc2ZlcnMgYWxsIG9mIGEgdXNlcidzIGZpbGVzIGludG8gYW5vdGhlciB1c2VyJ3MgYWNjb3VudC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdXNlcnMvOnNvdXJjZVVzZXJJRC9mb2xkZXJzLzAnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VVc2VySUQgLSBUaGUgSUQgb2YgdGhlIHVzZXIgd2hvc2UgZmlsZXMgd2lsbCBiZSB0cmFuc2ZlcnJlZFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RVc2VySUQgLSBUaGUgSUQgb2YgdGhlIHVzZXIgdG8gdHJhbnNmZXIgdGhlIGZpbGVzIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBuZXcgZm9sZGVyIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgZmlsZXMgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBmb2xkZXIgY29udGFpbmluZyB0aGUgdHJhbnNmZXJyZWQgY29udGVudFxuICovXG5FbnRlcnByaXNlLnByb3RvdHlwZS50cmFuc2ZlclVzZXJDb250ZW50ID0gZnVuY3Rpb24oc291cmNlVXNlcklELCBkZXN0VXNlcklELCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChVU0VSU19QQVRILCBzb3VyY2VVc2VySUQsIEZPTERFUlNfU1VCUkVTT1VSQ0UsIFJPT1RfRk9MREVSX0lEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB7XG5cdFx0XHRcdG93bmVkX2J5OiB7aWQ6IGRlc3RVc2VySUR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlcnByaXNlO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiVVNFUlNfUEFUSCIsIklOVklURVNfUEFUSCIsIkZPTERFUlNfU1VCUkVTT1VSQ0UiLCJST09UX0ZPTERFUl9JRCIsIkVudGVycHJpc2UiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJ1c2VyVHlwZXMiLCJPYmplY3QiLCJmcmVlemUiLCJBTEwiLCJNQU5BR0VEIiwiRVhURVJOQUwiLCJ1c2VyU3RhdHVzZXMiLCJBQ1RJVkUiLCJJTkFDVElWRSIsIkNBTk5PVF9ERUxFVEVfT1JfRURJVCIsIkNBTk5PVF9ERUxFVEVfRURJVF9PUl9VUExPQUQiLCJ1c2VyUm9sZXMiLCJVU0VSIiwiQ09BRE1JTiIsImdldFVzZXJzIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYXBpUGF0aCIsInBhcmFtcyIsInFzIiwid3JhcFdpdGhEZWZhdWx0SGFuZGxlciIsImdldCIsImludml0ZVVzZXIiLCJlbnRlcnByaXNlSUQiLCJlbWFpbCIsImJvZHkiLCJlbnRlcnByaXNlIiwiaWQiLCJhY3Rpb25hYmxlX2J5IiwibG9naW4iLCJwb3N0IiwiYWRkVXNlciIsIm5hbWUiLCJhc3NpZ24iLCJhZGRBcHBVc2VyIiwiaXNfcGxhdGZvcm1fYWNjZXNzX29ubHkiLCJ0cmFuc2ZlclVzZXJDb250ZW50Iiwic291cmNlVXNlcklEIiwiZGVzdFVzZXJJRCIsIm93bmVkX2J5IiwicHV0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/enterprise.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/events.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Events Resource\n */ \n// ------------------------------------------------------------------------------\n// Typedefs and Callbacks\n// ------------------------------------------------------------------------------\n/**\n * An event type constant\n * @typedef {string} EventType\n */ // ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), EventStream = __webpack_require__(/*! ../event-stream */ \"(rsc)/./node_modules/box-node-sdk/lib/event-stream.js\"), EnterpriseEventStream = __webpack_require__(/*! ../enterprise-event-stream */ \"(rsc)/./node_modules/box-node-sdk/lib/enterprise-event-stream.js\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// Base path for all files endpoints\nvar BASE_PATH = \"/events\";\n/** @const {string} */ var CURRENT_STREAM_POSITION = \"now\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Events' endpoints and actions.\n *\n * @param {BoxClient} client The Box API Client that is responsible for making calls to the API\n * @constructor\n */ function Events(client) {\n    // Attach the client, for making API calls\n    this.client = client;\n}\nEvents.prototype.CURRENT_STREAM_POSITION = CURRENT_STREAM_POSITION;\n/**\n * Get the current stream position.\n *\n * API Endpoint: '/events'\n * Method: GET\n *\n * @param {Function} [callback] Passed the current stream position if successful\n * @returns {Promise<string>} A promise resolving to the stream position\n */ Events.prototype.getCurrentStreamPosition = function(callback) {\n    var params = {\n        qs: {\n            stream_position: CURRENT_STREAM_POSITION\n        }\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.get(apiPath, params).then((response)=>{\n        if (response.statusCode !== httpStatusCodes.OK) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        return response.body.next_stream_position;\n    }).asCallback(callback);\n};\n/**\n * Get a chunk of events\n *\n * API Endpoint: '/events'\n * Method: GET\n *\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] Passed the current stream position if successful\n * @returns {Promise<Object>} A promise resolving to the collection of events\n */ Events.prototype.get = function(options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Get information for long-polling until new events are available\n *\n * API Endpoint: '/events'\n * Method: OPTIONS\n *\n * @param {Function} [callback] Passed the long poll info if successful\n * @returns {Promise<Object>} A promise resolving to the long poll info\n */ Events.prototype.getLongPollInfo = function(callback) {\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.options(apiPath, {}).then((response)=>{\n        if (response.statusCode !== httpStatusCodes.OK) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        var longpollInfo = response.body.entries.find((entry)=>entry.type === \"realtime_server\");\n        if (!longpollInfo) {\n            throw errors.buildResponseError(\"No valid long poll server specified\", response);\n        }\n        return longpollInfo;\n    }).asCallback(callback);\n};\n/**\n * Create a stream of events, using the long-poll API to wait for new events.\n *\n * API Endpoint: '/events'\n * Method: OPTIONS\n *\n * @param {string} [streamPosition] Starting stream position\n * @param {Object} [options] Optional parameters for the event stream\n * @param {int} [options.retryDelay=1000] Number of ms to wait before retrying after an error\n * @param {int} [options.deduplicationFilterSize=5000] Number of IDs to track for deduplication\n * @param {int} [options.fetchInterval=1000] Minimunm number of ms between calls for more events\n * @param {Function} [callback] Passed the events stream if successful\n * @returns {Promise<EventStream>} A promise resolving to the event stream\n */ Events.prototype.getEventStream = function(streamPosition, options, callback) {\n    var self = this;\n    if (typeof streamPosition === \"string\") {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        return Promise.resolve(new EventStream(self.client, streamPosition, options)).asCallback(callback);\n    }\n    // Fix up optional arguments\n    callback = options;\n    options = streamPosition;\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    return this.getCurrentStreamPosition().then((currentStreamPosition)=>new EventStream(self.client, currentStreamPosition, options)).asCallback(callback);\n};\n/**\n * Create a stream of enterprise events.\n *\n * By default, the stream starts from the current time.\n * Pass 'startDate' to start from a specific time.\n * Pass 'streamPosition' to start from a previous stream position, or '0' for all available past events (~1 year).\n * Once the stream catches up to the current time, it will begin polling every 'pollingInterval' seconds.\n * If 'pollingInterval' = 0, then the stream will end when it catches up to the current time (no polling).\n *\n * @param {Object} [options] - Options\n * @param {string} [options.streamPosition] - The stream position to start from (pass '0' for all past events)\n * @param {string} [options.startDate] - The date to start from\n * @param {string} [options.endDate] - The date to end at\n * @param {EventType[]} [options.eventTypeFilter] - Array of event types to return\n * @param {int} [options.pollingInterval=60] - Polling interval (in seconds).  Pass 0 for no polling.\n * @param {int} [options.chunkSize=500] - Number of events to fetch per call (max = 500)\n * @param {Function} [callback] Passed the events stream if successful\n * @returns {Promise<EnterpriseEventStream>} A promise resolving to the enterprise event stream\n */ Events.prototype.getEnterpriseEventStream = function(options, callback) {\n    var self = this;\n    return Promise.resolve(new EnterpriseEventStream(self.client, options)).asCallback(callback);\n};\n/**\n * Enum of enterprise event types\n *\n * @readonly\n * @enum {EventType}\n */ Events.prototype.enterpriseEventTypes = Object.freeze({\n    ADD_DEVICE_ASSOCIATION: \"ADD_DEVICE_ASSOCIATION\",\n    ADD_LOGIN_ACTIVITY_DEVICE: \"ADD_LOGIN_ACTIVITY_DEVICE\",\n    ADMIN_LOGIN: \"ADMIN_LOGIN\",\n    APPLICATION_PUBLIC_KEY_ADDED: \"APPLICATION_PUBLIC_KEY_ADDED\",\n    APPLICATION_PUBLIC_KEY_DELETED: \"APPLICATION_PUBLIC_KEY_DELETED\",\n    CHANGE_ADMIN_ROLE: \"CHANGE_ADMIN_ROLE\",\n    COLLABORATION_ACCEPT: \"COLLABORATION_ACCEPT\",\n    COLLABORATION_EXPIRATION: \"COLLABORATION_EXPIRATION\",\n    COLLABORATION_INVITE: \"COLLABORATION_INVITE\",\n    COLLABORATION_REMOVE: \"COLLABORATION_REMOVE\",\n    COLLABORATION_ROLE_CHANGE: \"COLLABORATION_ROLE_CHANGE\",\n    COMMENT_CREATE: \"COMMENT_CREATE\",\n    COMMENT_DELETE: \"COMMENT_DELETE\",\n    COMMENT_EDIT: \"COMMENT_EDIT\",\n    CONTENT_ACCESS: \"CONTENT_ACCESS\",\n    CONTENT_WORKFLOW_AUTOMATION_ADD: \"CONTENT_WORKFLOW_AUTOMATION_ADD\",\n    CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION: \"CONTENT_WORKFLOW_UPLOAD_POLICY_VIOLATION\",\n    COPY: \"COPY\",\n    DELETE: \"DELETE\",\n    DELETE_USER: \"DELETE_USER\",\n    DOWNLOAD: \"DOWNLOAD\",\n    EDIT: \"EDIT\",\n    EDIT_USER: \"EDIT_USER\",\n    EMAIL_ALIAS_CONFIRM: \"EMAIL_ALIAS_CONFIRM\",\n    ENABLE_TWO_FACTOR_AUTH: \"ENABLE_TWO_FACTOR_AUTH\",\n    ENTERPRISE_APP_AUTHORIZATION_DELETE: \"ENTERPRISE_APP_AUTHORIZATION_DELETE\",\n    FAILED_LOGIN: \"FAILED_LOGIN\",\n    FILE_MARKED_MALICIOUS: \"FILE_MARKED_MALICIOUS\",\n    FILE_WATERMARKED_DOWNLOAD: \"FILE_WATERMARKED_DOWNLOAD\",\n    GROUP_ADD_FILE: \"GROUP_ADD_FILE\",\n    GROUP_ADD_FOLDER: \"GROUP_ADD_FOLDER\",\n    GROUP_ADD_ITEM: \"GROUP_ADD_ITEM\",\n    GROUP_ADD_USER: \"GROUP_ADD_USER\",\n    GROUP_CREATION: \"GROUP_CREATION\",\n    GROUP_DELETION: \"GROUP_DELETION\",\n    GROUP_EDITED: \"GROUP_EDITED\",\n    GROUP_REMOVE_FILE: \"GROUP_REMOVE_FILE\",\n    GROUP_REMOVE_FOLDER: \"GROUP_REMOVE_FOLDER\",\n    GROUP_REMOVE_USER: \"GROUP_REMOVE_USER\",\n    ITEM_MODIFY: \"ITEM_MODIFY\",\n    ITEM_OPEN: \"ITEM_OPEN\",\n    ITEM_SHARED_UPDATE: \"ITEM_SHARED_UPDATE\",\n    ITEM_SYNC: \"ITEM_SYNC\",\n    ITEM_UNSYNC: \"ITEM_UNSYNC\",\n    LOCK: \"LOCK\",\n    LOGIN: \"LOGIN\",\n    METADATA_INSTANCE_CREATE: \"METADATA_INSTANCE_CREATE\",\n    METADATA_INSTANCE_DELETE: \"METADATA_INSTANCE_DELETE\",\n    METADATA_INSTANCE_UPDATE: \"METADATA_INSTANCE_UPDATE\",\n    METADATA_TEMPLATE_CREATE: \"METADATA_TEMPLATE_CREATE\",\n    METADATA_TEMPLATE_UPDATE: \"METADATA_TEMPLATE_UPDATE\",\n    MOVE: \"MOVE\",\n    NEW_USER: \"NEW_USER\",\n    PREVIEW: \"PREVIEW\",\n    REMOVE_DEVICE_ASSOCIATION: \"REMOVE_DEVICE_ASSOCIATION\",\n    REMOVE_LOGIN_ACTIVITY_DEVICE: \"REMOVE_LOGIN_ACTIVITY_DEVICE\",\n    RENAME: \"RENAME\",\n    SHARE: \"SHARE\",\n    SHARE_EXPIRATION: \"SHARE_EXPIRATION\",\n    STORAGE_EXPIRATION: \"STORAGE_EXPIRATION\",\n    TASK_ASSIGNMENT_CREATE: \"TASK_ASSIGNMENT_CREATE\",\n    TASK_ASSIGNMENT_UPDATE: \"TASK_ASSIGNMENT_UPDATE\",\n    TASK_CREATE: \"TASK_CREATE\",\n    TERMS_OF_SERVICE_AGREE: \"TERMS_OF_SERVICE_AGREE\",\n    TERMS_OF_SERVICE_REJECT: \"TERMS_OF_SERVICE_REJECT\",\n    UNDELETE: \"UNDELETE\",\n    UNLOCK: \"UNLOCK\",\n    UNSHARE: \"UNSHARE\",\n    UPDATE_COLLABORATION_EXPIRATION: \"UPDATE_COLLABORATION_EXPIRATION\",\n    UPDATE_SHARE_EXPIRATION: \"UPDATE_SHARE_EXPIRATION\",\n    UPLOAD: \"UPLOAD\",\n    WATERMARK_LABEL_CREATE: \"WATERMARK_LABEL_CREATE\",\n    WATERMARK_LABEL_DELETE: \"WATERMARK_LABEL_DELETE\"\n});\nmodule.exports = Events;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9ldmVudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUdBLGlGQUFpRjtBQUNqRix5QkFBeUI7QUFDekIsaUZBQWlGO0FBRWpGOzs7Q0FHQyxHQUVELGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBRWpGLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDLG1GQUNyQkMsU0FBU0QsbUJBQU9BLENBQUMsK0VBQ2pCRSxjQUFjRixtQkFBT0EsQ0FBQyxpRkFDdEJHLHdCQUF3QkgsbUJBQU9BLENBQUMsdUdBQ2hDSSxVQUFVSixtQkFBT0EsQ0FBQyx5RUFDbEJLLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFHM0IsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFFakYsb0NBQW9DO0FBQ3BDLElBQUlNLFlBQVk7QUFFaEIsb0JBQW9CLEdBQ3BCLElBQUlDLDBCQUEwQjtBQUU5QixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7Q0FLQyxHQUNELFNBQVNDLE9BQU9DLE1BQU07SUFDckIsMENBQTBDO0lBQzFDLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUFELE9BQU9FLFNBQVMsQ0FBQ0gsdUJBQXVCLEdBQUdBO0FBRTNDOzs7Ozs7OztDQVFDLEdBQ0RDLE9BQU9FLFNBQVMsQ0FBQ0Msd0JBQXdCLEdBQUcsU0FBU0MsUUFBUTtJQUM1RCxJQUFJQyxTQUFTO1FBQ1pDLElBQUk7WUFDSEMsaUJBQWlCUjtRQUNsQjtJQUNEO0lBQ0EsSUFBSVMsVUFBVWpCLFFBQVFPO0lBQ3RCLE9BQU8sSUFBSSxDQUFDRyxNQUFNLENBQUNRLEdBQUcsQ0FBQ0QsU0FBU0gsUUFDOUJLLElBQUksQ0FBQ0MsQ0FBQUE7UUFFTCxJQUFJQSxTQUFTQyxVQUFVLEtBQUtmLGdCQUFnQmdCLEVBQUUsRUFBRTtZQUMvQyxNQUFNcEIsT0FBT3FCLDRCQUE0QixD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O0lBQ1ZDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxxQkFBcUI7SUFDckJDLHdCQUF3QjtJQUN4QkMscUNBQXFDO0lBQ3JDQyxjQUFjO0lBQ2RDLHVCQUF1QjtJQUN2QkMsMkJBQTJCO0lBQzNCQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxnQkFBZ0I7SUFDaEJDLGdCQUFnQjtJQUNoQkMsZ0JBQWdCO0lBQ2hCQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMscUJBQXFCO0lBQ3JCQyxtQkFBbUI7SUFDbkJDLGFBQWE7SUFDYkMsV0FBVztJQUNYQyxvQkFBb0I7SUFDcEJDLFdBQVc7SUFDWEMsYUFBYTtJQUNiQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsMEJBQTBCO0lBQzFCQywwQkFBMEI7SUFDMUJDLDBCQUEwQjtJQUMxQkMsMEJBQTBCO0lBQzFCQywwQkFBMEI7SUFDMUJDLE1BQU07SUFDTkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLDJCQUEyQjtJQUMzQkMsOEJBQThCO0lBQzlCQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsa0JBQWtCO0lBQ2xCQyxvQkFBb0I7SUFDcEJDLHdCQUF3QjtJQUN4QkMsd0JBQXdCO0lBQ3hCQyxhQUFhO0lBQ2JDLHdCQUF3QjtJQUN4QkMseUJBQXlCO0lBQ3pCQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxpQ0FBaUM7SUFDakNDLHlCQUF5QjtJQUN6QkMsUUFBUTtJQUNSQyx3QkFBd0I7SUFDeEJDLHdCQUF3QjtBQUN6QjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc5RyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvZXZlbnRzLmpzP2UyODMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBCb3ggRXZlbnRzIFJlc291cmNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZWRlZnMgYW5kIENhbGxiYWNrc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQW4gZXZlbnQgdHlwZSBjb25zdGFudFxuICogQHR5cGVkZWYge3N0cmluZ30gRXZlbnRUeXBlXG4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKSxcblx0ZXJyb3JzID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvcnMnKSxcblx0RXZlbnRTdHJlYW0gPSByZXF1aXJlKCcuLi9ldmVudC1zdHJlYW0nKSxcblx0RW50ZXJwcmlzZUV2ZW50U3RyZWFtID0gcmVxdWlyZSgnLi4vZW50ZXJwcmlzZS1ldmVudC1zdHJlYW0nKSxcblx0UHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyksXG5cdGh0dHBTdGF0dXNDb2RlcyA9IHJlcXVpcmUoJ2h0dHAtc3RhdHVzJyk7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQmFzZSBwYXRoIGZvciBhbGwgZmlsZXMgZW5kcG9pbnRzXG52YXIgQkFTRV9QQVRIID0gJy9ldmVudHMnO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG52YXIgQ1VSUkVOVF9TVFJFQU1fUE9TSVRJT04gPSAnbm93JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIGFsbCAnRXZlbnRzJyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFdmVudHMoY2xpZW50KSB7XG5cdC8vIEF0dGFjaCB0aGUgY2xpZW50LCBmb3IgbWFraW5nIEFQSSBjYWxsc1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuRXZlbnRzLnByb3RvdHlwZS5DVVJSRU5UX1NUUkVBTV9QT1NJVElPTiA9IENVUlJFTlRfU1RSRUFNX1BPU0lUSU9OO1xuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBzdHJlYW0gcG9zaXRpb24uXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2V2ZW50cydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBQYXNzZWQgdGhlIGN1cnJlbnQgc3RyZWFtIHBvc2l0aW9uIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHN0cmVhbSBwb3NpdGlvblxuICovXG5FdmVudHMucHJvdG90eXBlLmdldEN1cnJlbnRTdHJlYW1Qb3NpdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IHtcblx0XHRcdHN0cmVhbV9wb3NpdGlvbjogQ1VSUkVOVF9TVFJFQU1fUE9TSVRJT05cblx0XHR9XG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQuZ2V0KGFwaVBhdGgsIHBhcmFtcylcblx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cblx0XHRcdGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSBodHRwU3RhdHVzQ29kZXMuT0spIHtcblx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzcG9uc2UuYm9keS5uZXh0X3N0cmVhbV9wb3NpdGlvbjtcblx0XHR9KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGEgY2h1bmsgb2YgZXZlbnRzXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2V2ZW50cydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIHRoZSBjdXJyZW50IHN0cmVhbSBwb3NpdGlvbiBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGV2ZW50c1xuICovXG5FdmVudHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGZvciBsb25nLXBvbGxpbmcgdW50aWwgbmV3IGV2ZW50cyBhcmUgYXZhaWxhYmxlXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2V2ZW50cydcbiAqIE1ldGhvZDogT1BUSU9OU1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIHRoZSBsb25nIHBvbGwgaW5mbyBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBsb25nIHBvbGwgaW5mb1xuICovXG5FdmVudHMucHJvdG90eXBlLmdldExvbmdQb2xsSW5mbyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC5vcHRpb25zKGFwaVBhdGgsIHt9KVxuXHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IGh0dHBTdGF0dXNDb2Rlcy5PSykge1xuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsb25ncG9sbEluZm8gPSByZXNwb25zZS5ib2R5LmVudHJpZXMuZmluZChlbnRyeSA9PiBlbnRyeS50eXBlID09PSAncmVhbHRpbWVfc2VydmVyJyk7XG5cblx0XHRcdGlmICghbG9uZ3BvbGxJbmZvKSB7XG5cdFx0XHRcdHRocm93IGVycm9ycy5idWlsZFJlc3BvbnNlRXJyb3IoJ05vIHZhbGlkIGxvbmcgcG9sbCBzZXJ2ZXIgc3BlY2lmaWVkJywgcmVzcG9uc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbG9uZ3BvbGxJbmZvO1xuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBzdHJlYW0gb2YgZXZlbnRzLCB1c2luZyB0aGUgbG9uZy1wb2xsIEFQSSB0byB3YWl0IGZvciBuZXcgZXZlbnRzLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ldmVudHMnXG4gKiBNZXRob2Q6IE9QVElPTlNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmVhbVBvc2l0aW9uXSBTdGFydGluZyBzdHJlYW0gcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGV2ZW50IHN0cmVhbVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLnJldHJ5RGVsYXk9MTAwMF0gTnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nIGFmdGVyIGFuIGVycm9yXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMuZGVkdXBsaWNhdGlvbkZpbHRlclNpemU9NTAwMF0gTnVtYmVyIG9mIElEcyB0byB0cmFjayBmb3IgZGVkdXBsaWNhdGlvblxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmZldGNoSW50ZXJ2YWw9MTAwMF0gTWluaW11bm0gbnVtYmVyIG9mIG1zIGJldHdlZW4gY2FsbHMgZm9yIG1vcmUgZXZlbnRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgZXZlbnRzIHN0cmVhbSBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxFdmVudFN0cmVhbT59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGV2ZW50IHN0cmVhbVxuICovXG5FdmVudHMucHJvdG90eXBlLmdldEV2ZW50U3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtUG9zaXRpb24sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXHRpZiAodHlwZW9mIHN0cmVhbVBvc2l0aW9uID09PSAnc3RyaW5nJykge1xuXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRXZlbnRTdHJlYW0oc2VsZi5jbGllbnQsIHN0cmVhbVBvc2l0aW9uLCBvcHRpb25zKSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG5cdH1cblxuXHQvLyBGaXggdXAgb3B0aW9uYWwgYXJndW1lbnRzXG5cdGNhbGxiYWNrID0gb3B0aW9ucztcblx0b3B0aW9ucyA9IHN0cmVhbVBvc2l0aW9uO1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZ2V0Q3VycmVudFN0cmVhbVBvc2l0aW9uKClcblx0XHQudGhlbihjdXJyZW50U3RyZWFtUG9zaXRpb24gPT4gbmV3IEV2ZW50U3RyZWFtKHNlbGYuY2xpZW50LCBjdXJyZW50U3RyZWFtUG9zaXRpb24sIG9wdGlvbnMpKVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGVudGVycHJpc2UgZXZlbnRzLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSBzdHJlYW0gc3RhcnRzIGZyb20gdGhlIGN1cnJlbnQgdGltZS5cbiAqIFBhc3MgJ3N0YXJ0RGF0ZScgdG8gc3RhcnQgZnJvbSBhIHNwZWNpZmljIHRpbWUuXG4gKiBQYXNzICdzdHJlYW1Qb3NpdGlvbicgdG8gc3RhcnQgZnJvbSBhIHByZXZpb3VzIHN0cmVhbSBwb3NpdGlvbiwgb3IgJzAnIGZvciBhbGwgYXZhaWxhYmxlIHBhc3QgZXZlbnRzICh+MSB5ZWFyKS5cbiAqIE9uY2UgdGhlIHN0cmVhbSBjYXRjaGVzIHVwIHRvIHRoZSBjdXJyZW50IHRpbWUsIGl0IHdpbGwgYmVnaW4gcG9sbGluZyBldmVyeSAncG9sbGluZ0ludGVydmFsJyBzZWNvbmRzLlxuICogSWYgJ3BvbGxpbmdJbnRlcnZhbCcgPSAwLCB0aGVuIHRoZSBzdHJlYW0gd2lsbCBlbmQgd2hlbiBpdCBjYXRjaGVzIHVwIHRvIHRoZSBjdXJyZW50IHRpbWUgKG5vIHBvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3RyZWFtUG9zaXRpb25dIC0gVGhlIHN0cmVhbSBwb3NpdGlvbiB0byBzdGFydCBmcm9tIChwYXNzICcwJyBmb3IgYWxsIHBhc3QgZXZlbnRzKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0YXJ0RGF0ZV0gLSBUaGUgZGF0ZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5kRGF0ZV0gLSBUaGUgZGF0ZSB0byBlbmQgYXRcbiAqIEBwYXJhbSB7RXZlbnRUeXBlW119IFtvcHRpb25zLmV2ZW50VHlwZUZpbHRlcl0gLSBBcnJheSBvZiBldmVudCB0eXBlcyB0byByZXR1cm5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5wb2xsaW5nSW50ZXJ2YWw9NjBdIC0gUG9sbGluZyBpbnRlcnZhbCAoaW4gc2Vjb25kcykuICBQYXNzIDAgZm9yIG5vIHBvbGxpbmcuXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMuY2h1bmtTaXplPTUwMF0gLSBOdW1iZXIgb2YgZXZlbnRzIHRvIGZldGNoIHBlciBjYWxsIChtYXggPSA1MDApXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgZXZlbnRzIHN0cmVhbSBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxFbnRlcnByaXNlRXZlbnRTdHJlYW0+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBlbnRlcnByaXNlIGV2ZW50IHN0cmVhbVxuICovXG5FdmVudHMucHJvdG90eXBlLmdldEVudGVycHJpc2VFdmVudFN0cmVhbSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgRW50ZXJwcmlzZUV2ZW50U3RyZWFtKHNlbGYuY2xpZW50LCBvcHRpb25zKSkuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEVudW0gb2YgZW50ZXJwcmlzZSBldmVudCB0eXBlc1xuICpcbiAqIEByZWFkb25seVxuICogQGVudW0ge0V2ZW50VHlwZX1cbiAqL1xuRXZlbnRzLnByb3RvdHlwZS5lbnRlcnByaXNlRXZlbnRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuXHRBRERfREVWSUNFX0FTU09DSUFUSU9OOiAnQUREX0RFVklDRV9BU1NPQ0lBVElPTicsXG5cdEFERF9MT0dJTl9BQ1RJVklUWV9ERVZJQ0U6ICdBRERfTE9HSU5fQUNUSVZJVFlfREVWSUNFJyxcblx0QURNSU5fTE9HSU46ICdBRE1JTl9MT0dJTicsXG5cdEFQUExJQ0FUSU9OX1BVQkxJQ19LRVlfQURERUQ6ICdBUFBMSUNBVElPTl9QVUJMSUNfS0VZX0FEREVEJyxcblx0QVBQTElDQVRJT05fUFVCTElDX0tFWV9ERUxFVEVEOiAnQVBQTElDQVRJT05fUFVCTElDX0tFWV9ERUxFVEVEJyxcblx0Q0hBTkdFX0FETUlOX1JPTEU6ICdDSEFOR0VfQURNSU5fUk9MRScsXG5cdENPTExBQk9SQVRJT05fQUNDRVBUOiAnQ09MTEFCT1JBVElPTl9BQ0NFUFQnLFxuXHRDT0xMQUJPUkFUSU9OX0VYUElSQVRJT046ICdDT0xMQUJPUkFUSU9OX0VYUElSQVRJT04nLFxuXHRDT0xMQUJPUkFUSU9OX0lOVklURTogJ0NPTExBQk9SQVRJT05fSU5WSVRFJyxcblx0Q09MTEFCT1JBVElPTl9SRU1PVkU6ICdDT0xMQUJPUkFUSU9OX1JFTU9WRScsXG5cdENPTExBQk9SQVRJT05fUk9MRV9DSEFOR0U6ICdDT0xMQUJPUkFUSU9OX1JPTEVfQ0hBTkdFJyxcblx0Q09NTUVOVF9DUkVBVEU6ICdDT01NRU5UX0NSRUFURScsXG5cdENPTU1FTlRfREVMRVRFOiAnQ09NTUVOVF9ERUxFVEUnLFxuXHRDT01NRU5UX0VESVQ6ICdDT01NRU5UX0VESVQnLFxuXHRDT05URU5UX0FDQ0VTUzogJ0NPTlRFTlRfQUNDRVNTJyxcblx0Q09OVEVOVF9XT1JLRkxPV19BVVRPTUFUSU9OX0FERDogJ0NPTlRFTlRfV09SS0ZMT1dfQVVUT01BVElPTl9BREQnLFxuXHRDT05URU5UX1dPUktGTE9XX1VQTE9BRF9QT0xJQ1lfVklPTEFUSU9OOiAnQ09OVEVOVF9XT1JLRkxPV19VUExPQURfUE9MSUNZX1ZJT0xBVElPTicsXG5cdENPUFk6ICdDT1BZJyxcblx0REVMRVRFOiAnREVMRVRFJyxcblx0REVMRVRFX1VTRVI6ICdERUxFVEVfVVNFUicsXG5cdERPV05MT0FEOiAnRE9XTkxPQUQnLFxuXHRFRElUOiAnRURJVCcsXG5cdEVESVRfVVNFUjogJ0VESVRfVVNFUicsXG5cdEVNQUlMX0FMSUFTX0NPTkZJUk06ICdFTUFJTF9BTElBU19DT05GSVJNJyxcblx0RU5BQkxFX1RXT19GQUNUT1JfQVVUSDogJ0VOQUJMRV9UV09fRkFDVE9SX0FVVEgnLFxuXHRFTlRFUlBSSVNFX0FQUF9BVVRIT1JJWkFUSU9OX0RFTEVURTogJ0VOVEVSUFJJU0VfQVBQX0FVVEhPUklaQVRJT05fREVMRVRFJyxcblx0RkFJTEVEX0xPR0lOOiAnRkFJTEVEX0xPR0lOJyxcblx0RklMRV9NQVJLRURfTUFMSUNJT1VTOiAnRklMRV9NQVJLRURfTUFMSUNJT1VTJyxcblx0RklMRV9XQVRFUk1BUktFRF9ET1dOTE9BRDogJ0ZJTEVfV0FURVJNQVJLRURfRE9XTkxPQUQnLFxuXHRHUk9VUF9BRERfRklMRTogJ0dST1VQX0FERF9GSUxFJyxcblx0R1JPVVBfQUREX0ZPTERFUjogJ0dST1VQX0FERF9GT0xERVInLFxuXHRHUk9VUF9BRERfSVRFTTogJ0dST1VQX0FERF9JVEVNJyxcblx0R1JPVVBfQUREX1VTRVI6ICdHUk9VUF9BRERfVVNFUicsXG5cdEdST1VQX0NSRUFUSU9OOiAnR1JPVVBfQ1JFQVRJT04nLFxuXHRHUk9VUF9ERUxFVElPTjogJ0dST1VQX0RFTEVUSU9OJyxcblx0R1JPVVBfRURJVEVEOiAnR1JPVVBfRURJVEVEJyxcblx0R1JPVVBfUkVNT1ZFX0ZJTEU6ICdHUk9VUF9SRU1PVkVfRklMRScsXG5cdEdST1VQX1JFTU9WRV9GT0xERVI6ICdHUk9VUF9SRU1PVkVfRk9MREVSJyxcblx0R1JPVVBfUkVNT1ZFX1VTRVI6ICdHUk9VUF9SRU1PVkVfVVNFUicsXG5cdElURU1fTU9ESUZZOiAnSVRFTV9NT0RJRlknLFxuXHRJVEVNX09QRU46ICdJVEVNX09QRU4nLFxuXHRJVEVNX1NIQVJFRF9VUERBVEU6ICdJVEVNX1NIQVJFRF9VUERBVEUnLFxuXHRJVEVNX1NZTkM6ICdJVEVNX1NZTkMnLFxuXHRJVEVNX1VOU1lOQzogJ0lURU1fVU5TWU5DJyxcblx0TE9DSzogJ0xPQ0snLFxuXHRMT0dJTjogJ0xPR0lOJyxcblx0TUVUQURBVEFfSU5TVEFOQ0VfQ1JFQVRFOiAnTUVUQURBVEFfSU5TVEFOQ0VfQ1JFQVRFJyxcblx0TUVUQURBVEFfSU5TVEFOQ0VfREVMRVRFOiAnTUVUQURBVEFfSU5TVEFOQ0VfREVMRVRFJyxcblx0TUVUQURBVEFfSU5TVEFOQ0VfVVBEQVRFOiAnTUVUQURBVEFfSU5TVEFOQ0VfVVBEQVRFJyxcblx0TUVUQURBVEFfVEVNUExBVEVfQ1JFQVRFOiAnTUVUQURBVEFfVEVNUExBVEVfQ1JFQVRFJyxcblx0TUVUQURBVEFfVEVNUExBVEVfVVBEQVRFOiAnTUVUQURBVEFfVEVNUExBVEVfVVBEQVRFJyxcblx0TU9WRTogJ01PVkUnLFxuXHRORVdfVVNFUjogJ05FV19VU0VSJyxcblx0UFJFVklFVzogJ1BSRVZJRVcnLFxuXHRSRU1PVkVfREVWSUNFX0FTU09DSUFUSU9OOiAnUkVNT1ZFX0RFVklDRV9BU1NPQ0lBVElPTicsXG5cdFJFTU9WRV9MT0dJTl9BQ1RJVklUWV9ERVZJQ0U6ICdSRU1PVkVfTE9HSU5fQUNUSVZJVFlfREVWSUNFJyxcblx0UkVOQU1FOiAnUkVOQU1FJyxcblx0U0hBUkU6ICdTSEFSRScsXG5cdFNIQVJFX0VYUElSQVRJT046ICdTSEFSRV9FWFBJUkFUSU9OJyxcblx0U1RPUkFHRV9FWFBJUkFUSU9OOiAnU1RPUkFHRV9FWFBJUkFUSU9OJyxcblx0VEFTS19BU1NJR05NRU5UX0NSRUFURTogJ1RBU0tfQVNTSUdOTUVOVF9DUkVBVEUnLFxuXHRUQVNLX0FTU0lHTk1FTlRfVVBEQVRFOiAnVEFTS19BU1NJR05NRU5UX1VQREFURScsXG5cdFRBU0tfQ1JFQVRFOiAnVEFTS19DUkVBVEUnLFxuXHRURVJNU19PRl9TRVJWSUNFX0FHUkVFOiAnVEVSTVNfT0ZfU0VSVklDRV9BR1JFRScsXG5cdFRFUk1TX09GX1NFUlZJQ0VfUkVKRUNUOiAnVEVSTVNfT0ZfU0VSVklDRV9SRUpFQ1QnLFxuXHRVTkRFTEVURTogJ1VOREVMRVRFJyxcblx0VU5MT0NLOiAnVU5MT0NLJyxcblx0VU5TSEFSRTogJ1VOU0hBUkUnLFxuXHRVUERBVEVfQ09MTEFCT1JBVElPTl9FWFBJUkFUSU9OOiAnVVBEQVRFX0NPTExBQk9SQVRJT05fRVhQSVJBVElPTicsXG5cdFVQREFURV9TSEFSRV9FWFBJUkFUSU9OOiAnVVBEQVRFX1NIQVJFX0VYUElSQVRJT04nLFxuXHRVUExPQUQ6ICdVUExPQUQnLFxuXHRXQVRFUk1BUktfTEFCRUxfQ1JFQVRFOiAnV0FURVJNQVJLX0xBQkVMX0NSRUFURScsXG5cdFdBVEVSTUFSS19MQUJFTF9ERUxFVEU6ICdXQVRFUk1BUktfTEFCRUxfREVMRVRFJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiZXJyb3JzIiwiRXZlbnRTdHJlYW0iLCJFbnRlcnByaXNlRXZlbnRTdHJlYW0iLCJQcm9taXNlIiwiaHR0cFN0YXR1c0NvZGVzIiwiQkFTRV9QQVRIIiwiQ1VSUkVOVF9TVFJFQU1fUE9TSVRJT04iLCJFdmVudHMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJnZXRDdXJyZW50U3RyZWFtUG9zaXRpb24iLCJjYWxsYmFjayIsInBhcmFtcyIsInFzIiwic3RyZWFtX3Bvc2l0aW9uIiwiYXBpUGF0aCIsImdldCIsInRoZW4iLCJyZXNwb25zZSIsInN0YXR1c0NvZGUiLCJPSyIsImJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IiLCJib2R5IiwibmV4dF9zdHJlYW1fcG9zaXRpb24iLCJhc0NhbGxiYWNrIiwib3B0aW9ucyIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJnZXRMb25nUG9sbEluZm8iLCJsb25ncG9sbEluZm8iLCJlbnRyaWVzIiwiZmluZCIsImVudHJ5IiwidHlwZSIsImJ1aWxkUmVzcG9uc2VFcnJvciIsImdldEV2ZW50U3RyZWFtIiwic3RyZWFtUG9zaXRpb24iLCJzZWxmIiwicmVzb2x2ZSIsImN1cnJlbnRTdHJlYW1Qb3NpdGlvbiIsImdldEVudGVycHJpc2VFdmVudFN0cmVhbSIsImVudGVycHJpc2VFdmVudFR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiQUREX0RFVklDRV9BU1NPQ0lBVElPTiIsIkFERF9MT0dJTl9BQ1RJVklUWV9ERVZJQ0UiLCJBRE1JTl9MT0dJTiIsIkFQUExJQ0FUSU9OX1BVQkxJQ19LRVlfQURERUQiLCJBUFBMSUNBVElPTl9QVUJMSUNfS0VZX0RFTEVURUQiLCJDSEFOR0VfQURNSU5fUk9MRSIsIkNPTExBQk9SQVRJT05fQUNDRVBUIiwiQ09MTEFCT1JBVElPTl9FWFBJUkFUSU9OIiwiQ09MTEFCT1JBVElPTl9JTlZJVEUiLCJDT0xMQUJPUkFUSU9OX1JFTU9WRSIsIkNPTExBQk9SQVRJT05fUk9MRV9DSEFOR0UiLCJDT01NRU5UX0NSRUFURSIsIkNPTU1FTlRfREVMRVRFIiwiQ09NTUVOVF9FRElUIiwiQ09OVEVOVF9BQ0NFU1MiLCJDT05URU5UX1dPUktGTE9XX0FVVE9NQVRJT05fQUREIiwiQ09OVEVOVF9XT1JLRkxPV19VUExPQURfUE9MSUNZX1ZJT0xBVElPTiIsIkNPUFkiLCJERUxFVEUiLCJERUxFVEVfVVNFUiIsIkRPV05MT0FEIiwiRURJVCIsIkVESVRfVVNFUiIsIkVNQUlMX0FMSUFTX0NPTkZJUk0iLCJFTkFCTEVfVFdPX0ZBQ1RPUl9BVVRIIiwiRU5URVJQUklTRV9BUFBfQVVUSE9SSVpBVElPTl9ERUxFVEUiLCJGQUlMRURfTE9HSU4iLCJGSUxFX01BUktFRF9NQUxJQ0lPVVMiLCJGSUxFX1dBVEVSTUFSS0VEX0RPV05MT0FEIiwiR1JPVVBfQUREX0ZJTEUiLCJHUk9VUF9BRERfRk9MREVSIiwiR1JPVVBfQUREX0lURU0iLCJHUk9VUF9BRERfVVNFUiIsIkdST1VQX0NSRUFUSU9OIiwiR1JPVVBfREVMRVRJT04iLCJHUk9VUF9FRElURUQiLCJHUk9VUF9SRU1PVkVfRklMRSIsIkdST1VQX1JFTU9WRV9GT0xERVIiLCJHUk9VUF9SRU1PVkVfVVNFUiIsIklURU1fTU9ESUZZIiwiSVRFTV9PUEVOIiwiSVRFTV9TSEFSRURfVVBEQVRFIiwiSVRFTV9TWU5DIiwiSVRFTV9VTlNZTkMiLCJMT0NLIiwiTE9HSU4iLCJNRVRBREFUQV9JTlNUQU5DRV9DUkVBVEUiLCJNRVRBREFUQV9JTlNUQU5DRV9ERUxFVEUiLCJNRVRBREFUQV9JTlNUQU5DRV9VUERBVEUiLCJNRVRBREFUQV9URU1QTEFURV9DUkVBVEUiLCJNRVRBREFUQV9URU1QTEFURV9VUERBVEUiLCJNT1ZFIiwiTkVXX1VTRVIiLCJQUkVWSUVXIiwiUkVNT1ZFX0RFVklDRV9BU1NPQ0lBVElPTiIsIlJFTU9WRV9MT0dJTl9BQ1RJVklUWV9ERVZJQ0UiLCJSRU5BTUUiLCJTSEFSRSIsIlNIQVJFX0VYUElSQVRJT04iLCJTVE9SQUdFX0VYUElSQVRJT04iLCJUQVNLX0FTU0lHTk1FTlRfQ1JFQVRFIiwiVEFTS19BU1NJR05NRU5UX1VQREFURSIsIlRBU0tfQ1JFQVRFIiwiVEVSTVNfT0ZfU0VSVklDRV9BR1JFRSIsIlRFUk1TX09GX1NFUlZJQ0VfUkVKRUNUIiwiVU5ERUxFVEUiLCJVTkxPQ0siLCJVTlNIQVJFIiwiVVBEQVRFX0NPTExBQk9SQVRJT05fRVhQSVJBVElPTiIsIlVQREFURV9TSEFSRV9FWFBJUkFUSU9OIiwiVVBMT0FEIiwiV0FURVJNQVJLX0xBQkVMX0NSRUFURSIsIldBVEVSTUFSS19MQUJFTF9ERUxFVEUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/files.js":
/*!*********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/files.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Files Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * A representation request type constant\n * @typedef {string} FileRepresentationType Different representations we can request from reps endpoint\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\n/**\n * @typedef {Object} UploadPart\n * @property {string} part_id An 8-character hexadecimal string identifying the part\n * @property {int} offset The byte offset of the part within the whole file\n * @property {int} size The size of the part in bytes\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\"), crypto = __webpack_require__(/*! crypto */ \"crypto\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), Readable = (__webpack_require__(/*! stream */ \"stream\").Readable), urlTemplate = __webpack_require__(/*! url-template */ \"(rsc)/./node_modules/url-template/lib/url-template.js\"), ChunkedUploader = __webpack_require__(/*! ../chunked-uploader */ \"(rsc)/./node_modules/box-node-sdk/lib/chunked-uploader.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\n// Base path for all files endpoints\nvar BASE_PATH = \"/files\", VERSIONS_SUBRESOURCE = \"/versions\", WATERMARK_SUBRESOURCE = \"/watermark\", UPLOAD_SESSION_SUBRESOURCE = \"/upload_sessions\", ZIP_DOWNLOAD_PATH = \"/zip_downloads\";\n// Enum of valid lock types\nvar lockTypes = {\n    LOCK: \"lock\",\n    UNLOCK: \"unlock\"\n};\n/**\n * Returns the multipart form value for file upload metadata.\n * @param {string} parentFolderID - the ID of the parent folder to upload to\n * @param {string} filename - the file name that the uploaded file should have\n * @param {Object} [options] - Optional metadata\n * @returns {Object} - the form value expected by the API for the 'metadata' key\n * @private\n */ function createFileMetadataFormData(parentFolderID, filename, options) {\n    // Although the filename and parent folder ID can be specified without using a\n    // metadata form field, Platform has recommended that we use the metadata form\n    // field to specify these parameters (one benefit is that UTF-8 characters can\n    // be specified in the filename).\n    var metadata = {\n        name: filename,\n        parent: {\n            id: parentFolderID\n        }\n    };\n    Object.assign(metadata, options);\n    return JSON.stringify(metadata);\n}\n/**\n * Returns the multipart form value for file upload content.\n * @param {string|Buffer|Stream} content - the content of the file being uploaded\n * @param {Object} options - options for the content\n * @returns {Object} - the form value expected by the API for the 'content' key\n * @private\n */ function createFileContentFormData(content, options) {\n    // The upload API appears to look for a form field that contains a filename\n    // property and assume that this form field contains the file content. Thus,\n    // the value of name does not actually matter (as long as it does not conflict\n    // with other field names). Similarly, the value of options.filename does not\n    // matter either (as long as it exists), since the upload API will use the\n    // filename specified in the metadata form field instead.\n    return {\n        value: content,\n        options: Object.assign({\n            filename: \"unused\"\n        }, options)\n    };\n}\n/**\n * Poll the representation info URL until representation is generated,\n * then return content URL template.\n * @param {BoxClient} client The client to use for making API calls\n * @param {string} infoURL The URL to use for getting representation info\n * @returns {Promise<string>} A promise resolving to the content URL template\n */ function pollRepresentationInfo(client, infoURL) {\n    return client.get(infoURL).then((response)=>{\n        if (response.statusCode !== 200) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        var info = response.body;\n        switch(info.status.state){\n            case \"success\":\n            case \"viewable\":\n            case \"error\":\n                return info;\n            case \"none\":\n            case \"pending\":\n                return Promise.delay(1000).then(()=>pollRepresentationInfo(client, infoURL));\n            default:\n                throw new Error(`Unknown representation status: ${info.status.state}`);\n        }\n    });\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'File' endpoints and actions.\n *\n * @param {BoxClient} client The Box API Client that is responsible for making calls to the API\n * @constructor\n */ function Files(client) {\n    // Attach the client, for making API calls\n    this.client = client;\n}\n/**\n * Requests a file object with the given ID.\n *\n * API Endpoint: '/files/:fileID'\n * Method: GET\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the file information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the file object\n */ Files.prototype.get = function(fileID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Requests a download URL for a given file.\n *\n * API Endpoint: '/files/:fileID/content'\n * Method: GET\n * Special Expected Responses:\n *   202 ACCEPTED - Download isn't available yet. Returns an error.\n *   302 FOUND - Download is available. A Download URL is returned.\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the download URL if request was successful.\n * @returns {Promise<string>} A promise resolving to the file's download URL\n */ Files.prototype.getDownloadURL = function(fileID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"/content\");\n    // Handle Special API Response\n    return this.client.get(apiPath, params).then((response)=>{\n        switch(response.statusCode){\n            // 302 - Found\n            // No data returned, but the location header points to a download link for that file.\n            case httpStatusCodes.FOUND:\n                return response.headers.location;\n            // 202 - Download isn't ready yet.\n            case httpStatusCodes.ACCEPTED:\n                throw errors.buildResponseError(response, \"Download not ready at this time\");\n            // Unexpected Response\n            default:\n                throw errors.buildUnexpectedResponseError(response);\n        }\n    }).asCallback(callback);\n};\n/**\n * Requests a Readable Stream for the given file ID.\n *\n * API Endpoint: '/files/:fileID/content'\n * Method: GET\n * Special Expected Responses:\n *   202 ACCEPTED - Download isn't available yet. Returns an error.\n *   302 FOUND - Download is available. A Download stream is returned.\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {string} [options.version] - ID of the version of this file to download\n * @param {int[]} [options.byteRange] - starting and ending bytes of the file to read, e.g. [0, 99] to read the first 100 bytes\n * @param {Function} [callback] - passed the readable stream if request was successful\n * @returns {Promise<Readable>} A promise resolving for the file stream\n */ Files.prototype.getReadStream = function(fileID, options, callback) {\n    options = options || {};\n    var downloadStreamOptions = {\n        streaming: true,\n        headers: {}\n    };\n    if (options.byteRange) {\n        var range = options.byteRange;\n        delete options.byteRange;\n        downloadStreamOptions.headers.Range = `bytes=${range[0]}-${range[1]}`;\n    }\n    // Get the download URL to download from\n    return this.getDownloadURL(fileID, options)// Return a read stream to download the file\n    .then((url)=>this.client.get(url, downloadStreamOptions)).asCallback(callback);\n};\n/**\n * Requests a Thumbnail for a given file.\n *\n * API Endpoint: '/files/:fileID/thumbnail.png'\n * Method: GET\n * Special Expected Responses:\n *   200 OK - Thumbnail available. Returns a thumbnail file.\n *   202 ACCEPTED - Thumbnail isn't available yet. Returns a `location` URL for a generic placeholder thumbnail.\n *   302 FOUND - Unable to generate thumbnail. Returns a `location` URL for a generic placeholder thumbnail.\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the thumbnail file or the URL to a placeholder thumbnail if successful.\n * @returns {Promise<Object>} A promise resolving to the thumbnail information\n */ Files.prototype.getThumbnail = function(fileID, options, callback) {\n    var params = {\n        qs: options,\n        json: false\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"/thumbnail.png\");\n    // Handle Special API Response\n    return this.client.get(apiPath, params).then((response)=>{\n        switch(response.statusCode){\n            // 202 - Thumbnail will be generated, but is not ready yet\n            // 302 - Thumbnail can not be generated\n            // return the url for a thumbnail placeholder\n            case httpStatusCodes.ACCEPTED:\n            case httpStatusCodes.FOUND:\n                return {\n                    statusCode: response.statusCode,\n                    location: response.headers.location\n                };\n            // 200 - Thumbnail image recieved\n            // return the thumbnail file\n            case httpStatusCodes.OK:\n                return {\n                    statusCode: response.statusCode,\n                    file: response.body\n                };\n            // Unexpected Response\n            default:\n                throw errors.buildUnexpectedResponseError(response);\n        }\n    }).asCallback(callback);\n};\n/**\n * Gets the comments on a file.\n *\n * API Endpoint: '/files/:fileID/comments'\n * Method: GET\n *\n * @param {string} fileID - Box file id of the file\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - passed the file comments if they were successfully acquired\n * @returns {Promise<Object>} A promise resolving to the collection of comments\n */ Files.prototype.getComments = function(fileID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"/comments\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Update some information about a given file.\n *\n * API Endpoint: '/files/:fileID'\n * Method: PUT\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} updates - File fields to update\n * @param {string} [updates.etag] Only apply the updates if the file etag matches\n * @param {Function} [callback] - Passed the updated file information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the update file object\n */ Files.prototype.update = function(fileID, updates, callback) {\n    var params = {\n        body: updates\n    };\n    if (updates && updates.etag) {\n        params.headers = {\n            \"If-Match\": updates.etag\n        };\n        delete updates.etag;\n    }\n    var apiPath = urlPath(BASE_PATH, fileID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Add a file to a given collection\n *\n * API Endpoint: '/files/:fileID'\n * Method: PUT\n *\n * @param {string} fileID - The file to add to the collection\n * @param {string} collectionID - The collection to add the file to\n * @param {Function} [callback] - Passed the updated file if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated file object\n */ Files.prototype.addToCollection = function(fileID, collectionID, callback) {\n    return this.get(fileID, {\n        fields: \"collections\"\n    }).then((data)=>{\n        var collections = data.collections || [];\n        // Convert to correct format\n        collections = collections.map((c)=>({\n                id: c.id\n            }));\n        if (!collections.find((c)=>c.id === collectionID)) {\n            collections.push({\n                id: collectionID\n            });\n        }\n        return this.update(fileID, {\n            collections\n        });\n    }).asCallback(callback);\n};\n/**\n * Remove a file from a given collection\n *\n * API Endpoint: '/files/:fileID'\n * Method: PUT\n *\n * @param {string} fileID - The file to remove from the collection\n * @param {string} collectionID - The collection to remove the file from\n * @param {Function} [callback] - Passed the updated file if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated file object\n */ Files.prototype.removeFromCollection = function(fileID, collectionID, callback) {\n    return this.get(fileID, {\n        fields: \"collections\"\n    }).then((data)=>{\n        var collections = data.collections || [];\n        // Convert to correct object format and remove the specified collection\n        collections = collections.map((c)=>({\n                id: c.id\n            })).filter((c)=>c.id !== collectionID);\n        return this.update(fileID, {\n            collections\n        });\n    }).asCallback(callback);\n};\n/**\n * Move a file into a new parent folder.\n *\n * API Endpoint: '/files/:fileID'\n * Method: PUT\n *\n * @param {string} fileID - The Box ID of the file being requested\n * @param {string} newParentID - The Box ID for the new parent folder. '0' to move to All Files.\n * @param {Function} [callback] - Passed the updated file information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated file object\n */ Files.prototype.move = function(fileID, newParentID, callback) {\n    var params = {\n        body: {\n            parent: {\n                id: newParentID\n            }\n        }\n    };\n    var apiPath = urlPath(BASE_PATH, fileID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Copy a file into a new folder.\n *\n * API Endpoint: '/files/:fileID/copy\n * Method: POST\n *\n * @param {string} fileID - The Box ID of the file being requested\n * @param {string} newParentID - The Box ID for the new parent folder. '0' to copy to All Files.\n * @param {Object} [options] - Optional parameters for the copy operation, can be left null in most cases\n * @param {string} [options.name] - A new name to use if there is an identically-named item in the new parent folder\n * @param {Function} [callback] - passed the new file info if call was successful\n * @returns {Promise<Object>} A promise resolving to the new file object\n */ Files.prototype.copy = function(fileID, newParentID, options, callback) {\n    // @NOTE(mwiller) 2016-10-25: Shuffle arguments to maintain backward compatibility\n    //  This can be removed at the v2.0 update\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = options || {};\n    options.parent = {\n        id: newParentID\n    };\n    var params = {\n        body: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"/copy\");\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Delete a given file.\n *\n * API Endpoint: '/files/:fileID'\n * Method: DELETE\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} [options] Optional parameters\n * @param {string} [options.etag] Only delete the file if the etag value matches\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ Files.prototype.delete = function(fileID, options, callback) {\n    // Switch around arguments if necessary for backwards compatibility\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var params = {};\n    if (options && options.etag) {\n        params.headers = {\n            \"If-Match\": options.etag\n        };\n    }\n    var apiPath = urlPath(BASE_PATH, fileID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Get preflight information for a new file upload.  Without any file data,\n * this will return an upload URL and token to be used when uploading the file.\n * Using this upload URL will allow for the fastest upload, and the one-time\n * token can be passed to a worker or other client to actually perform the\n * upload with.  If file data (e.g. size, parent, name) is passed, it will be\n * validated as if the actual file were being uploaded.  This enables checking\n * of preconditions such as name uniqueness and available storage space before\n * attempting a large file upload.\n *\n * API Endpoint: '/files/content'\n * Method: OPTIONS\n *\n * @param {string} parentFolderID - The id of the parent folder to upload to\n * @param {Object} [fileData] - Optional data about the file to be uploaded\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Called with upload data if successful, or err if the upload would not succeed\n * @returns {Promise<Object>} A promise resolving to the upload data\n */ Files.prototype.preflightUploadFile = function(parentFolderID, fileData, options, callback) {\n    var params = {\n        body: {\n            parent: {\n                id: parentFolderID\n            }\n        },\n        qs: options\n    };\n    if (fileData) {\n        Object.assign(params.body, fileData);\n    }\n    var apiPath = urlPath(BASE_PATH, \"/content\");\n    return this.client.wrapWithDefaultHandler(this.client.options)(apiPath, params, callback);\n};\n/**\n * Get preflight information for a file version upload.  Without any file data,\n * this will return an upload URL and token to be used when uploading the file.\n * Using this upload URL will allow for the fastest upload, and the one-time\n * token can be passed to a worker or other client to actually perform the\n * upload with.  If file data (e.g. size, parent, name) is passed, it will be\n * validated as if the actual file were being uploaded.  This enables checking\n * of preconditions such as name uniqueness and available storage space before\n * attempting a large file upload.\n *\n * API Endpoint: '/files/:fileID/content'\n * Method: OPTIONS\n *\n * @param {string} fileID - The file ID to which a new version will be uploaded\n * @param {Object} [fileData] - Optional data about the file to be uploaded\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Called with upload data if successful, or err if the upload would not succeed\n * @returns {Promise<Object>} A promise resolving to the upload data\n */ Files.prototype.preflightUploadNewFileVersion = function(fileID, fileData, options, callback) {\n    var params = {\n        qs: options\n    };\n    if (fileData) {\n        params.body = fileData;\n    }\n    var apiPath = urlPath(BASE_PATH, fileID, \"/content\");\n    return this.client.wrapWithDefaultHandler(this.client.options)(apiPath, params, callback);\n};\n/**\n * If there are previous versions of this file, this method can be used to promote one of the older\n * versions to the top of the stack. This actually mints a copy of the old version and puts it on\n * the top of the versions stack. The file will have the exact same contents, the same SHA1/etag,\n * and the same name as the original. Other properties such as comments do not get updated to their former values.\n *\n * API Endpoint: '/files/:fileID/versions/current'\n * Method: POST\n *\n * @param {string} fileID - The file ID which version will be promoted\n * @param {string} versionID - The ID of the file_version that you want to make current\n * @param {Function} [callback] - Passed the promoted file version information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the promoted file version\n */ Files.prototype.promoteVersion = function(fileID, versionID, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, VERSIONS_SUBRESOURCE, \"/current\"), params = {\n        body: {\n            type: \"file_version\",\n            id: versionID\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Uploads a new file. Unlike non-upload methods, this method will not perform any retries.\n * This method currently does not support any optional parameters such as contentModifiedAt.\n *\n * API Endpoint: '/files/content'\n * Method: POST\n *\n * @param {string} parentFolderID - the id of the parent folder to upload to\n * @param {string} filename - the file name that the uploaded file should have\n * @param {string|Buffer|ReadStream} content - the content of the file. It can be a string, a Buffer, or a read stream\n * (like that returned by fs.createReadStream()).\n * @param {Object} [options] - Optional parameters\n * @param {string} [options.content_created_at] - RFC 3339 timestamp when the file was created\n * @param {string} [options.content_modified_at] - RFC 3339 timestamp when the file was last modified\n * @param {int} [options.content_length] - Optional length of the content. Required if content is a read stream of any type other than fs stream.\n * @param {Function} [callback] - called with data about the upload if successful, or an error if the\n * upload failed\n * @returns {Promise<Object>} A promise resolving to the uploaded file\n */ Files.prototype.uploadFile = function(parentFolderID, filename, content, options, callback) {\n    // Shuffle around optional parameter\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var formOptions = {};\n    if (options && options.hasOwnProperty(\"content_length\")) {\n        formOptions.knownLength = options.content_length;\n        // Delete content_length from options so it's not added to the attributes of the form\n        delete options.content_length;\n    }\n    var apiPath = urlPath(BASE_PATH, \"/content\"), multipartFormData = {\n        attributes: createFileMetadataFormData(parentFolderID, filename, options),\n        content: createFileContentFormData(content, formOptions)\n    };\n    return this.client.wrapWithDefaultHandler(this.client.upload)(apiPath, null, multipartFormData, callback);\n};\n/**\n * Uploads a new version of a file. Unlike non-upload methods, this method will not perform any retries.\n * This method currently does not support any optional parameters such as contentModifiedAt.\n *\n * API Endpoint: '/files/:fileID/content'\n * Method: POST\n *\n * @param {string} fileID - the id of the file to upload a new version of\n * @param {string|Buffer|Stream} content - the content of the file. It can be a string, a Buffer, or a read stream\n * (like that returned by fs.createReadStream()).\n * @param {Object} [options] - Optional parameters\n * @param {string} [options.content_modified_at] - RFC 3339 timestamp when the file was last modified\n * @param {string} [options.name] - A new name for the file\n * @param {int} [options.content_length] - Optional length of the content. Required if content is a read stream of any type other than fs stream.\n * @param {Function} [callback] - called with data about the upload if successful, or an error if the\n * upload failed\n * @returns {Promise<Object>} A promise resolving to the uploaded file\n */ Files.prototype.uploadNewFileVersion = function(fileID, content, options, callback) {\n    // Shuffle around optional parameter\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var apiPath = urlPath(BASE_PATH, fileID, \"/content\"), multipartFormData = {};\n    var formOptions = {};\n    if (options) {\n        if (options.hasOwnProperty(\"content_length\")) {\n            formOptions.knownLength = options.content_length;\n            // Delete content_length from options so it's not added to the attributes of the form\n            delete options.content_length;\n        }\n        multipartFormData.attributes = JSON.stringify(options);\n    }\n    multipartFormData.content = createFileContentFormData(content, formOptions);\n    return this.client.wrapWithDefaultHandler(this.client.upload)(apiPath, null, multipartFormData, callback);\n};\n/**\n * Retrieves all metadata associated with a file.\n *\n * API Endpoint: '/files/:fileID/metadata'\n * Method: GET\n *\n * @param {string} fileID - the ID of the file to get metadata for\n * @param {Function} [callback] - called with an array of metadata when successful\n * @returns {Promise<Object>} A promise resolving to a collection of metadata on the file\n */ Files.prototype.getAllMetadata = function(fileID, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, \"metadata\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n};\n/**\n * Retrieve a single metadata template instance for a file.\n *\n * API Endpoint: '/files/:fileID/metadata/:scope/:template'\n * Method: GET\n *\n * @param {string} fileID - The ID of the file to retrive the metadata of\n * @param {string} scope - The scope of the metadata template, e.g. \"global\"\n * @param {string} template - The metadata template to retrieve\n * @param {Function} [callback] - Passed the metadata template if successful\n * @returns {Promise<Object>} A promise resolving to the metadata template\n */ Files.prototype.getMetadata = function(fileID, scope, template, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, \"metadata\", scope, template);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n};\n/**\n * Adds metadata to a file.  Metadata must either match a template schema or\n * be placed into the unstructured \"properties\" template in global scope.\n *\n * API Endpoint: '/files/:fileID/metadata/:scope/:template'\n * Method: POST\n *\n * @param {string} fileID - The ID of the file to add metadata to\n * @param {string} scope - The scope of the metadata template, e.g. \"enterprise\"\n * @param {string} template - The metadata template schema to add\n * @param {Object} data - Key/value pairs tp add as metadata\n * @param {Function} [callback] - Called with error if unsuccessful\n * @returns {Promise<Object>} A promise resolving to the new metadata\n */ Files.prototype.addMetadata = function(fileID, scope, template, data, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, \"metadata\", scope, template), params = {\n        body: data\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Updates a metadata template instance with JSON Patch-formatted data.\n *\n * API Endpoint: '/files/:fileID/metadata/:scope/:template'\n * Method: PUT\n *\n * @param {string} fileID - The file to update metadata for\n * @param {string} scope - The scope of the template to update\n * @param {string} template - The template to update\n * @param {Object} patch - The patch data\n * @param {Function} [callback] - Called with updated metadata if successful\n * @returns {Promise<Object>} A promise resolving to the updated metadata\n */ Files.prototype.updateMetadata = function(fileID, scope, template, patch, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, \"metadata\", scope, template), params = {\n        body: patch,\n        headers: {\n            \"Content-Type\": \"application/json-patch+json\"\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Sets metadata on a file, overwriting any metadata that exists for the provided keys.\n *\n * @param {string} fileID - The file to set metadata on\n * @param {string} scope - The scope of the metadata template\n * @param {string} template - The key of the metadata template\n * @param {Object} metadata - The metadata to set\n * @param {Function} [callback] - Called with updated metadata if successful\n * @returns {Promise<Object>} A promise resolving to the updated metadata\n */ Files.prototype.setMetadata = function(fileID, scope, template, metadata, callback) {\n    return this.addMetadata(fileID, scope, template, metadata).catch((err)=>{\n        if (err.statusCode !== 409) {\n            throw err;\n        }\n        // Metadata already exists on the file; update instead\n        var updates = Object.keys(metadata).map((key)=>({\n                op: \"add\",\n                path: `/${key}`,\n                value: metadata[key]\n            }));\n        return this.updateMetadata(fileID, scope, template, updates);\n    }).asCallback(callback);\n};\n/**\n * Deletes a metadata template from a file.\n *\n * API Endpoint: '/files/:fileID/metadata/:scope/:template'\n * Method: DELETE\n *\n * @param {string} fileID - The ID of the file to remove metadata from\n * @param {string} scope - The scope of the metadata template\n * @param {string} template - The template to remove from the file\n * @param {Function} [callback] - Called with nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Files.prototype.deleteMetadata = function(fileID, scope, template, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, \"metadata\", scope, template);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Permanently deletes an item that is in the trash. The item will no longer exist in Box. This action cannot be undone.\n *\n * API Endpoint: '/files/:fileID/trash'\n * Method: DELETE\n *\n * @param {string} fileID - The ID of the file to remove metadata from\n * @param {Object} [options] Optional parameters\n * @param {string} [options.etag] Only delete the file if the etag matches\n * @param {Function} [callback] - Called with nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Files.prototype.deletePermanently = function(fileID, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var params = {};\n    if (options && options.etag) {\n        params.headers = {\n            \"If-Match\": options.etag\n        };\n    }\n    var apiPath = urlPath(BASE_PATH, fileID, \"/trash\");\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Retrieves a file that has been moved to the trash.\n *\n * API Endpoint: '/files/:fileID/trash'\n * Method: GET\n *\n * @param {string} fileID - The ID of the file being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the trashed file information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the trashed file\n */ Files.prototype.getTrashedFile = function(fileID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"trash\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Retrieves all of the tasks for given file.\n *\n * API Endpoint: '/files/:fileID/tasks'\n * Method: GET\n *\n * @param {string} fileID - The ID of the file to get tasks for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the file tasks if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to a collections of tasks on the file\n */ Files.prototype.getTasks = function(fileID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"/tasks\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Used to retrieve an expiring URL for creating an embedded preview session.\n * The URL will expire after 60 seconds and the preview session will expire after 60 minutes.\n *\n * API Endpoint: '/files/:fileID?fields=expiring_embed_link'\n * Method: GET\n *\n * @param {string} fileID - The ID of the file to generate embed link for\n * @param {Function} [callback] - Passed with the embed link if successful, error otherwise\n * @returns {Promise<string>} A promise resolving to the file embed link URL\n */ Files.prototype.getEmbedLink = function(fileID, callback) {\n    var params = {\n        qs: {\n            fields: \"expiring_embed_link\"\n        }\n    };\n    var apiPath = urlPath(BASE_PATH, fileID);\n    return this.client.get(apiPath, params).then((response)=>{\n        if (response.statusCode !== httpStatusCodes.OK) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        return response.body.expiring_embed_link.url;\n    }).asCallback(callback);\n};\n/**\n * Locks  a file.\n *\n * API Endpoint: '/files/:fileID'\n * Method: PUT\n *\n * @param {string} fileID - The ID of the file to lock\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {?string} [options.expires_at] - The time the lock expires\n * @param {boolean} [options.is_download_prevented] - Whether or not the file can be downloaded while locked\n * @param {Function} [callback] - Passed with the locked file information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the locked file object\n */ Files.prototype.lock = function(fileID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID), params = {\n        body: {\n            lock: {\n                type: lockTypes.LOCK\n            }\n        }\n    };\n    Object.assign(params.body.lock, options);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Unlocks a file.\n *\n * API Endpoint: '/files/:fileID'\n *  Method: PUT\n *\n * @param {string} fileID - The ID of the file to unlock\n * @param {Function} [callback] - Passed with the unlocked file information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the unlocked file object\n */ Files.prototype.unlock = function(fileID, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID), params = {\n        body: {\n            lock: null\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Restores an item that has been moved to the trash. Default behavior is to\n * restore the item to the folder it was in before it was moved to the trash.\n * If that parent folder no longer exists or if there is now an item with the\n * same name in that parent folder, the new parent folder and/or new name will\n * need to be included in the request.\n *\n * API Endpoint: '/files/:fileID'\n * Method: POST\n *\n * @param {string} fileID - The ID of the file to restore\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {string} [options.name] - The new name for this item\n * @param {string} [options.parent_id] - The new parent folder for this item\n * @param {Function} [callback] - Called with item information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the restored file object\n */ Files.prototype.restoreFromTrash = function(fileID, options, callback) {\n    // Set up the parent_id parameter\n    if (options && options.parent_id) {\n        options.parent = {\n            id: options.parent_id\n        };\n        delete options.parent_id;\n    }\n    var apiPath = urlPath(BASE_PATH, fileID), params = {\n        body: options || {}\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * If there are previous versions of this file, this method can be used to retrieve information\n * about the older versions.\n *\n * API Endpoint: '/files/:fileID/versions'\n * Method: GET\n *\n * @param {string} fileID - The ID of the file to view version for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed a list of previous file versions if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of file versions\n */ Files.prototype.getVersions = function(fileID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, VERSIONS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Used to retrieve the watermark for a corresponding Box file.\n *\n * API Endpoint: '/files/:fileID/watermark'\n * Method: GET\n *\n * @param {string} fileID - The Box ID of the file to get watermark for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the watermark information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the watermark info\n */ Files.prototype.getWatermark = function(fileID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, WATERMARK_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.get(apiPath, params).then((response)=>{\n        if (response.statusCode !== 200) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        return response.body.watermark;\n    }).asCallback(callback);\n};\n/**\n * Used to apply or update the watermark for a corresponding Box file.\n *\n * API Endpoint: '/files/:fileID/watermark'\n * Method: PUT\n *\n * @param {string} fileID - The Box ID of the file to update watermark for\n * @param {Object} [options] - Optional parameters, can be left null\n * @param {Function} [callback] - Passed the watermark information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the watermark info\n */ Files.prototype.applyWatermark = function(fileID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, WATERMARK_SUBRESOURCE), params = {\n        body: {\n            watermark: {\n                imprint: \"default\" // Currently the API only supports default imprint\n            }\n        }\n    };\n    Object.assign(params.body.watermark, options);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Used to remove the watermark for a corresponding Box file.\n *\n * API Endpoint: '/files/:fileID/watermark'\n * Method: DELETE\n *\n * @param {string} fileID - The Box ID of the file to remove watermark from\n * @param {Function} [callback] - Empty response body passed if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Files.prototype.removeWatermark = function(fileID, callback) {\n    var apiPath = urlPath(BASE_PATH, fileID, WATERMARK_SUBRESOURCE);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Discards a specific file version to the trash. Depending on the enterprise settings\n * for this user, the item will either be actually deleted from Box or moved to the trash.\n *\n * API Endpoint: '/files/:fileID/version/:versionID'\n * Method: DELETE\n *\n * @param {string} fileID - The file ID which old version will be moved to the trash or delete permanently\n * @param {string} versionID - The ID of the version to move to the trash or delete permanently\n * @param {Object} [options] Optional parameters\n * @param {string} [options.etag] Only delete the version of the file etag matches\n * @param {Function} [callback] - Empty response body, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Files.prototype.deleteVersion = function(fileID, versionID, options, callback) {\n    // Switch around arguments if necessary for backwwards compatibility\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var params = {};\n    if (options && options.etag) {\n        params.headers = {\n            \"If-Match\": options.etag\n        };\n    }\n    var apiPath = urlPath(BASE_PATH, fileID, VERSIONS_SUBRESOURCE, versionID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Creates a session used to upload a new file in chunks..  This will first\n * verify that the file can be created and then open a session for uploading\n * pieces of the file.\n *\n * API Endpoint: '/files/upload_sessions'\n * Method: POST\n *\n * @param {string} folderID - The ID of the folder to upload the file to\n * @param {int} size - The size of the file that will be uploaded\n * @param {string} name - The name of the file to be created\n * @param {Function} [callback] - Passed the upload session info if successful\n * @returns {Promise<Object>} A promise resolving to the new upload session object\n */ Files.prototype.createUploadSession = function(folderID, size, name, callback) {\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, UPLOAD_SESSION_SUBRESOURCE), params = {\n        body: {\n            folder_id: folderID,\n            file_size: size,\n            file_name: name\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiURL, params, callback);\n};\n/**\n * Creates a session used to upload a new version of a file in chunks.  This\n * will first verify that the version can be created and then open a session for\n * uploading pieces of the file.\n *\n * API Endpoint: '/files/:fileID/upload_sessions'\n * Method: POST\n *\n * @param {string} fileID - The ID of the file to upload a new version of\n * @param {int} size - The size of the file that will be uploaded\n * @param {Function} [callback] - Passed the upload session info if successful\n * @returns {Promise<Object>} A promise resolving to the new upload session object\n */ Files.prototype.createNewVersionUploadSession = function(fileID, size, callback) {\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, fileID, UPLOAD_SESSION_SUBRESOURCE), params = {\n        body: {\n            file_size: size\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiURL, params, callback);\n};\n/**\n * Uploads a chunk of a file to an open upload session\n *\n * API Endpoint: '/files/upload_sessions/:sessionID'\n * Method: PUT\n *\n * @param {string} sessionID - The ID of the upload session to upload to\n * @param {Buffer|string} part - The chunk of the file to upload\n * @param {int} offset - The byte position where the chunk begins in the file\n * @param {int} totalSize - The total size of the file being uploaded\n * @param {Function} [callback] - Passed the part definition if successful\n * @returns {Promise<Object>} A promise resolving to the part object\n */ Files.prototype.uploadPart = function(sessionID, part, offset, totalSize, callback) {\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, UPLOAD_SESSION_SUBRESOURCE, sessionID);\n    var hash = crypto.createHash(\"sha1\").update(part).digest(\"base64\");\n    var params = {\n        headers: {\n            \"Content-Type\": \"application/octet-stream\",\n            Digest: `SHA=${hash}`,\n            \"Content-Range\": `bytes ${offset}-${offset + part.length - 1}/${totalSize}`\n        },\n        json: false,\n        body: part\n    };\n    return this.client.put(apiURL, params).then((response)=>{\n        if (response.statusCode !== 200) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        return JSON.parse(response.body);\n    }).asCallback(callback);\n};\n/**\n * Commit an upload session after all parts have been uploaded, creating the new file\n *\n * API Endpoint: '/files/upload_sessions/:sessionID/commit'\n * Method: POST\n *\n * @param {string} sessionID - The ID of the upload session to commit\n * @param {string} fileHash - The base64-encoded SHA-1 hash of the file being uploaded\n * @param {Object} [options] - Optional parameters set on the created file, can be left null\n * @param {UploadPart[]} [options.parts] The list of uploaded parts to be committed, will be fetched from the API otherwise\n * @param {Function} [callback] - Passed the new file information if successful\n * @returns {Promise<Object>} A promise resolving to the uploaded file object\n */ Files.prototype.commitUploadSession = function(sessionID, fileHash, options, callback) {\n    options = options || {};\n    var userParts;\n    if (options.parts) {\n        userParts = options.parts;\n        delete options.parts;\n    }\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, UPLOAD_SESSION_SUBRESOURCE, sessionID, \"commit\"), params = {\n        headers: {\n            Digest: `SHA=${fileHash}`\n        },\n        body: {\n            attributes: options\n        }\n    };\n    var fetchParts = (offset, fetchedParts)=>{\n        let pagingOptions = {\n            limit: 1000,\n            offset\n        };\n        return this.getUploadSessionParts(sessionID, pagingOptions).then((data)=>{\n            fetchedParts = fetchedParts.concat(data.entries);\n            if (data.offset + data.entries.length >= data.total_count) {\n                return Promise.resolve(fetchedParts);\n            }\n            return fetchParts(offset + data.limit, fetchedParts);\n        });\n    };\n    return (userParts ? Promise.resolve(userParts) : fetchParts(0, [])).then((parts)=>{\n        // Commit the upload with the list of parts\n        params.body.parts = parts;\n        return this.client.post(apiURL, params);\n    }).then((response)=>{\n        if (response.statusCode === 201) {\n            return response.body;\n        }\n        if (response.statusCode === 202) {\n            var retryInterval = response.headers[\"retry-after\"] || 1;\n            return Promise.delay(retryInterval * 1000).then(()=>{\n                // Ensure we don't have to fetch parts from the API again on retry\n                options = Object.assign({}, options, {\n                    parts: params.body.parts\n                });\n                return this.commitUploadSession(sessionID, fileHash, options);\n            });\n        }\n        throw errors.buildUnexpectedResponseError(response);\n    }).asCallback(callback);\n};\n/**\n * Abort an upload session, discarding any chunks that were uploaded to it\n *\n * API Endpoint: '/files/upload_sessions/:sessionID'\n * Method: DELETE\n *\n * @param {string} sessionID - The ID of the upload session to commit\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Files.prototype.abortUploadSession = function(sessionID, callback) {\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, UPLOAD_SESSION_SUBRESOURCE, sessionID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiURL, null, callback);\n};\n/**\n * Get a list of all parts that have been uploaded to an upload session\n *\n * API Endpoint: '/files/upload_sessions/:sessionID/parts'\n * Method: GET\n *\n * @param {string} sessionID - The ID of the session to get a list of parts from\n * @param {Object} [options] - Optional parameters, can be left null\n * @param {string} [options.offset] - Paging offset for the list of parts\n * @param {int} [options.limit] - Maximum number of parts to return\n * @param {Function} [callback] - Passed the list of parts if successful\n * @returns {Promise<Object>} A promise resolving to the collection of uploaded parts\n */ Files.prototype.getUploadSessionParts = function(sessionID, options, callback) {\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, UPLOAD_SESSION_SUBRESOURCE, sessionID, \"parts\"), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiURL, params, callback);\n};\n/**\n * Get the status of an upload session, e.g. whether or not is has started or\n * finished committing\n *\n * API Endpoint: '/files/upload_sessions/:sessionID'\n * Method: GET\n *\n * @param {string} sessionID - The ID of the upload session to get the status of\n * @param {Function} [callback] - Passed the session status if successful\n * @returns {Promise<Object>} A promise resolving to the upload session object\n */ Files.prototype.getUploadSession = function(sessionID, callback) {\n    var apiURL = this.client._uploadBaseURL + urlPath(BASE_PATH, UPLOAD_SESSION_SUBRESOURCE, sessionID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiURL, null, callback);\n};\n/**\n * Upload a file in chunks, which is generally faster and more reliable for\n * large files.\n *\n * API Endpoint: '/files/upload_sessions'\n * Method: POST\n *\n * @param {string} folderID - The ID of the folder to upload the file to\n * @param {int} size - The size of the file that will be uploaded\n * @param {string} name - The name of the file to be created\n * @param {Buffer|string|Readable} file - The file to upload\n * @param {Object} [options] - Optional parameters for the upload\n * @param {int} [options.parallelism] The number of chunks to upload concurrently\n * @param {int} [options.retryInterval] The amount of time to wait before retrying a failed chunk upload, in ms\n * @param {Object} [options.fileAttributes] Attributes to set on the newly-uploaded file\n * @param {Function} [callback] - Passed the uploader if successful\n * @returns {Promise<ChunkedUploader>} A promise resolving to the chunked uploader\n */ Files.prototype.getChunkedUploader = function(folderID, size, name, file, options, callback) {\n    if (file instanceof Readable) {\n        // Need to pause the stream immediately to prevent certain libraries,\n        // e.g. request from placing the stream into flowing mode and consuming bytes\n        file.pause();\n    }\n    return this.createUploadSession(folderID, size, name).then((sessionInfo)=>new ChunkedUploader(this.client, sessionInfo, file, size, options)).asCallback(callback);\n};\n/**\n * Upload a new file version in chunks, which is generally faster and more\n * reliable for large files.\n *\n * API Endpoint: '/files/:fileID/upload_sessions'\n * Method: POST\n *\n * @param {string} fileID - The ID of the file to upload a new version of\n * @param {int} size - The size of the file that will be uploaded\n * @param {Buffer|string|Readable} file - The file to upload\n * @param {Object} [options] - Optional parameters for the upload\n * @param {int} [options.parallelism] The number of chunks to upload concurrently\n * @param {int} [options.retryInterval] The amount of time to wait before retrying a failed chunk upload, in ms\n * @param {Object} [options.fileAttributes] Attributes to set on the updated file object\n * @param {Function} [callback] - Passed the uploader if successful\n * @returns {Promise<ChunkedUploader>} A promise resolving to the chunked uploader\n */ Files.prototype.getNewVersionChunkedUploader = function(fileID, size, file, options, callback) {\n    if (file instanceof Readable) {\n        // Need to pause the stream immediately to prevent certain libraries,\n        // e.g. request from placing the stream into flowing mode and consuming bytes\n        file.pause();\n    }\n    return this.createNewVersionUploadSession(fileID, size).then((sessionInfo)=>new ChunkedUploader(this.client, sessionInfo, file, size, options)).asCallback(callback);\n};\n/**\n * Requests collaborations on a given file.\n *\n * API Endpoint: '/files/:fileID/collaborations'\n * Method: GET\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {int} [options.limit] - The maximum number of collaborations to return\n * @param {int} [options.offset] - Paging parameter for the collaborations collection\n * @param {string} [options.fields] - Comma-separated list of fields to return on the collaboration objects\n * @param {Function} [callback] - Passed the collaborations if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of collaborations on the file\n */ Files.prototype.getCollaborations = function(fileID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, fileID, \"/collaborations\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Enum of valid x-rep- hint values for generating representation info\n *\n * @readonly\n * @enum {FileRepresentationType}\n */ Files.prototype.representation = {\n    PDF: \"[pdf]\",\n    THUMBNAIL: \"[jpg?dimensions=320x320]\",\n    IMAGE_MEDIUM: \"[jpg?dimensions=1024x1024][png?dimensions=1024x1024]\",\n    IMAGE_LARGE: \"[jpg?dimensions=2048x2048][png?dimensions=2048x2048]\",\n    EXTRACTED_TEXT: \"[extracted_text]\"\n};\n/**\n * Requests information for all representation objects generated for a specific Box file\n *\n * API Endpoint: '/files/:fileID?fields=representations'\n * Method : GET\n *\n * @param {string} fileID - Box ID of the file being requested\n * @param {client.files.representation} representationType - The x-rep-hints value the application should create a\n *    representation for. This value can either come from FileRepresentationType enum or manually created\n * @param {Object} [options] - Additional options. Can be left empty\n * @param {boolean} [options.generateRepresentations = false] - Set to true to return representation info where all states resolve to success.\n * @param {Function} [callback] - Passed an array of representaton objects if successful\n * @returns {Promise<Object>} A promise resolving to the representation response objects\n*/ Files.prototype.getRepresentationInfo = function(fileID, representationType, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    if (!representationType && options && options.generateRepresentations) {\n        throw new Error(\"Must provide a valid X-Rep-Hints string to get representations with a success status\");\n    }\n    var params = {\n        qs: {\n            fields: \"representations\"\n        },\n        headers: {\n            \"x-rep-hints\": representationType\n        }\n    };\n    var apiPath = urlPath(BASE_PATH, fileID);\n    return this.client.get(apiPath, params).then((response)=>{\n        switch(response.statusCode){\n            // 202 - A Box file representation will be generated, but is not ready yet\n            case httpStatusCodes.ACCEPTED:\n                throw errors.buildResponseError(response, \"Representation not ready at this time\");\n            // 200 - A Boxfile representation generated successfully\n            // return the representation object\n            case httpStatusCodes.OK:\n                if (options && options.generateRepresentations) {\n                    var data = response.body.representations.entries;\n                    var promiseArray = data.map((entry)=>{\n                        switch(entry.status.state){\n                            case \"success\":\n                            case \"viewable\":\n                            case \"error\":\n                                return Promise.resolve(entry);\n                            default:\n                                return pollRepresentationInfo(this.client, entry.info.url);\n                        }\n                    });\n                    return Promise.all(promiseArray).then((entries)=>({\n                            entries\n                        }));\n                }\n                return response.body.representations;\n            // Unexpected Response\n            default:\n                throw errors.buildUnexpectedResponseError(response);\n        }\n    }).asCallback(callback);\n};\n/**\n * Get the contents of a representation of a file, e.g, the binary content of an image or pdf.\n *\n * API Endpoint: '/files/:fileID?fields=representations'\n * Method : GET\n *\n * @param {string} fileID The file ID to get the representation of\n * @param {string} representationType The X-Rep-Hints type to request\n * @param {Object} [options] Optional parameters\n * @param {string} [options.assetPath] Asset path for representations with multiple files\n * @param {Function} [callback] Passed a stream over the representation contents if successful\n * @returns {Promise<Readable>} A promise resolving to a stream over the representation contents\n */ Files.prototype.getRepresentationContent = function(fileID, representationType, options, callback) {\n    if (!representationType) {\n        throw new Error(\"Must provide a valid X-Rep-Hints string\");\n    }\n    options = Object.assign({\n        assetPath: \"\"\n    }, options);\n    return this.getRepresentationInfo(fileID, representationType).then((reps)=>{\n        var repInfo = reps.entries.pop();\n        if (!repInfo) {\n            throw new Error(\"Could not get information for requested representation\");\n        }\n        switch(repInfo.status.state){\n            case \"success\":\n            case \"viewable\":\n                return repInfo.content.url_template;\n            case \"error\":\n                throw new Error(\"Representation had error status\");\n            case \"none\":\n            case \"pending\":\n                return pollRepresentationInfo(this.client, repInfo.info.url).then((info)=>{\n                    if (info.status.state === \"error\") {\n                        throw new Error(\"Representation had error status\");\n                    }\n                    return info.content.url_template;\n                });\n            default:\n                throw new Error(`Unknown representation status: ${repInfo.status.state}`);\n        }\n    }).then((assetURLTemplate)=>{\n        var url = urlTemplate.parse(assetURLTemplate).expand({\n            asset_path: options.assetPath\n        });\n        return this.client.get(url, {\n            streaming: true\n        });\n    }).asCallback(callback);\n};\n/**\n * Creates a zip of multiple files and folders.\n *\n * API Endpoint: '/zip_downloads'\n * Method: POST\n *\n * @param {name} name - The name of the zip file to be created\n * @param {Array} items - Array of files or folders to be part of the created zip\n * @param {Function} [callback] Passed a zip information object\n * @returns {Promise<string>} A promise resolving to a zip information object\n */ Files.prototype.createZip = function(name, items, callback) {\n    var params = {\n        body: {\n            download_file_name: name,\n            items\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(ZIP_DOWNLOAD_PATH, params, callback);\n};\n/**\n * Creates a zip of multiple files and folders and downloads it.\n *\n * API Endpoint: '/zip_downloads'\n * Method: GET\n *\n * @param {name} name - The name of the zip file to be created\n * @param {Array} items - Array of files or folders to be part of the created zip\n * @param {Stream} stream - Stream to pipe the readable stream of the zip file\n * @param {Function} [callback] - Passed a zip download status object\n * @returns {Promise<Readable>} A promise resolving to a zip download status object\n */ Files.prototype.downloadZip = function(name, items, stream, callback) {\n    var downloadStreamOptions = {\n        streaming: true,\n        headers: {}\n    };\n    var params = {\n        body: {\n            download_file_name: name,\n            items\n        }\n    };\n    return this.client.post(ZIP_DOWNLOAD_PATH, params).then((response)=>this.client.get(response.body.download_url, downloadStreamOptions).then((responseStream)=>{\n            responseStream.pipe(stream);\n            // eslint-disable-next-line promise/avoid-new\n            return new Promise((resolve, reject)=>{\n                responseStream.on(\"end\", ()=>resolve(\"Done downloading\"));\n                responseStream.on(\"error\", (error)=>reject(error));\n            }).then(()=>this.client.get(response.body.status_url).then((responseStatus)=>responseStatus.body));\n        })).asCallback(callback);\n};\n/**\n * @module box-node-sdk/lib/managers/files\n * @see {@Link Files}\n */ module.exports = Files;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9maWxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBQ0EsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEY7OztDQUdDLEdBRUQsZ0ZBQWdGO0FBQ2hGLGVBQWU7QUFDZixnRkFBZ0Y7QUFFaEY7Ozs7O0NBS0MsR0FFRCxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUVoRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQyxtRkFDckJDLFNBQVNELG1CQUFPQSxDQUFDLCtFQUNqQkUsa0JBQWtCRixtQkFBT0EsQ0FBQyxxRUFDMUJHLFNBQVNILG1CQUFPQSxDQUFDLHlCQUNqQkksVUFBVUosbUJBQU9BLENBQUMseUVBQ2xCSyxXQUFXTCxzREFBMEIsRUFDckNNLGNBQWNOLG1CQUFPQSxDQUFDLDhFQUN0Qk8sa0JBQWtCUCxtQkFBT0EsQ0FBQztBQUUzQixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUVoRixvQ0FBb0M7QUFDcEMsSUFBSVEsWUFBWSxVQUNmQyx1QkFBdUIsYUFDdkJDLHdCQUF3QixjQUN4QkMsNkJBQTZCLG9CQUM3QkMsb0JBQW9CO0FBRXJCLDJCQUEyQjtBQUMzQixJQUFJQyxZQUFZO0lBQ2ZDLE1BQU07SUFDTkMsUUFBUTtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLDJCQUEyQkMsY0FBYyxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDcEUsOEVBQThFO0lBQzlFLDhFQUE4RTtJQUM5RSw4RUFBOEU7SUFDOUUsaUNBQWlDO0lBQ2pDLElBQUlDLFdBQVc7UUFDZEMsTUFBTUg7UUFDTkksUUFBUTtZQUFFQyxJQUFJTjtRQUFlO0lBQzlCO0lBRUFPLE9BQU9DLE1BQU0sQ0FBQ0wsVUFBVUQ7SUFFeEIsT0FBT08sS0FBS0MsU0FBUyxDQUFDUDtBQUN2QjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNRLDBCQUEw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RDtJQUVBLE9BQU8sSUFBSSxDQUFDM0ssTUFBTSxDQUFDMEQsSUFBSSxDQUFDOUUsbUJBQW1CcUMsUUFDekNkLElBQUksQ0FBQ0MsQ0FBQUEsV0FBWSxJQUFJLENBQUNKLE1BQU0sQ0FBQ0UsR0FBRyxDQUFDRSxTQUFTSSxJQUFJLENBQUN1SyxZQUFZLEVBQUVsSix1QkFDNUQxQixJQUFJLENBQUM2SyxDQUFBQTtZQUNMQSxlQUFlQyxJQUFJLENBQUNIO1lBQ3BCLDZDQUE2QztZQUM3QyxPQUFPLElBQUkxTSxRQUFRLENBQUN1SyxTQUFTdUM7Z0JBQzVCRixlQUFlRyxFQUFFLENBQUMsT0FBTyxJQUFNeEMsUUFBUTtnQkFDdkNxQyxlQUFlRyxFQUFFLENBQUMsU0FBU0MsQ0FBQUEsUUFBU0YsT0FBT0U7WUFDNUMsR0FBR2pMLElBQUksQ0FBQyxJQUFNLElBQUksQ0FBQ0gsTUFBTSxDQUFDRSxHQUFHLENBQUNFLFNBQVNJLElBQUksQ0FBQzZLLFVBQVUsRUFBRWxMLElBQUksQ0FBQ21MLENBQUFBLGlCQUFrQkEsZUFBZTlLLElBQUk7UUFDbkcsSUFFQW1CLFVBQVUsQ0FBQ1g7QUFDZDtBQUVBOzs7Q0FHQyxHQUNEdUssT0FBT0MsT0FBTyxHQUFHM0siLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL2ZpbGVzLmpzP2Y1ZGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBCb3ggRmlsZXMgUmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZWRlZnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiByZXF1ZXN0IHR5cGUgY29uc3RhbnRcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IEZpbGVSZXByZXNlbnRhdGlvblR5cGUgRGlmZmVyZW50IHJlcHJlc2VudGF0aW9ucyB3ZSBjYW4gcmVxdWVzdCBmcm9tIHJlcHMgZW5kcG9pbnRcbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVwbG9hZFBhcnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXJ0X2lkIEFuIDgtY2hhcmFjdGVyIGhleGFkZWNpbWFsIHN0cmluZyBpZGVudGlmeWluZyB0aGUgcGFydFxuICogQHByb3BlcnR5IHtpbnR9IG9mZnNldCBUaGUgYnl0ZSBvZmZzZXQgb2YgdGhlIHBhcnQgd2l0aGluIHRoZSB3aG9sZSBmaWxlXG4gKiBAcHJvcGVydHkge2ludH0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgcGFydCBpbiBieXRlc1xuICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciB1cmxQYXRoID0gcmVxdWlyZSgnLi4vdXRpbC91cmwtcGF0aCcpLFxuXHRlcnJvcnMgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9ycycpLFxuXHRodHRwU3RhdHVzQ29kZXMgPSByZXF1aXJlKCdodHRwLXN0YXR1cycpLFxuXHRjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKSxcblx0UHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyksXG5cdFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGUsXG5cdHVybFRlbXBsYXRlID0gcmVxdWlyZSgndXJsLXRlbXBsYXRlJyksXG5cdENodW5rZWRVcGxvYWRlciA9IHJlcXVpcmUoJy4uL2NodW5rZWQtdXBsb2FkZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEJhc2UgcGF0aCBmb3IgYWxsIGZpbGVzIGVuZHBvaW50c1xudmFyIEJBU0VfUEFUSCA9ICcvZmlsZXMnLFxuXHRWRVJTSU9OU19TVUJSRVNPVVJDRSA9ICcvdmVyc2lvbnMnLFxuXHRXQVRFUk1BUktfU1VCUkVTT1VSQ0UgPSAnL3dhdGVybWFyaycsXG5cdFVQTE9BRF9TRVNTSU9OX1NVQlJFU09VUkNFID0gJy91cGxvYWRfc2Vzc2lvbnMnLFxuXHRaSVBfRE9XTkxPQURfUEFUSCA9ICcvemlwX2Rvd25sb2Fkcyc7XG5cbi8vIEVudW0gb2YgdmFsaWQgbG9jayB0eXBlc1xudmFyIGxvY2tUeXBlcyA9IHtcblx0TE9DSzogJ2xvY2snLFxuXHRVTkxPQ0s6ICd1bmxvY2snXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG11bHRpcGFydCBmb3JtIHZhbHVlIGZvciBmaWxlIHVwbG9hZCBtZXRhZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRGb2xkZXJJRCAtIHRoZSBJRCBvZiB0aGUgcGFyZW50IGZvbGRlciB0byB1cGxvYWQgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIHRoZSBmaWxlIG5hbWUgdGhhdCB0aGUgdXBsb2FkZWQgZmlsZSBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIG1ldGFkYXRhXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHRoZSBmb3JtIHZhbHVlIGV4cGVjdGVkIGJ5IHRoZSBBUEkgZm9yIHRoZSAnbWV0YWRhdGEnIGtleVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsZU1ldGFkYXRhRm9ybURhdGEocGFyZW50Rm9sZGVySUQsIGZpbGVuYW1lLCBvcHRpb25zKSB7XG5cdC8vIEFsdGhvdWdoIHRoZSBmaWxlbmFtZSBhbmQgcGFyZW50IGZvbGRlciBJRCBjYW4gYmUgc3BlY2lmaWVkIHdpdGhvdXQgdXNpbmcgYVxuXHQvLyBtZXRhZGF0YSBmb3JtIGZpZWxkLCBQbGF0Zm9ybSBoYXMgcmVjb21tZW5kZWQgdGhhdCB3ZSB1c2UgdGhlIG1ldGFkYXRhIGZvcm1cblx0Ly8gZmllbGQgdG8gc3BlY2lmeSB0aGVzZSBwYXJhbWV0ZXJzIChvbmUgYmVuZWZpdCBpcyB0aGF0IFVURi04IGNoYXJhY3RlcnMgY2FuXG5cdC8vIGJlIHNwZWNpZmllZCBpbiB0aGUgZmlsZW5hbWUpLlxuXHR2YXIgbWV0YWRhdGEgPSB7XG5cdFx0bmFtZTogZmlsZW5hbWUsXG5cdFx0cGFyZW50OiB7IGlkOiBwYXJlbnRGb2xkZXJJRCB9XG5cdH07XG5cblx0T2JqZWN0LmFzc2lnbihtZXRhZGF0YSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtdWx0aXBhcnQgZm9ybSB2YWx1ZSBmb3IgZmlsZSB1cGxvYWQgY29udGVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxTdHJlYW19IGNvbnRlbnQgLSB0aGUgY29udGVudCBvZiB0aGUgZmlsZSBiZWluZyB1cGxvYWRlZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgY29udGVudFxuICogQHJldHVybnMge09iamVjdH0gLSB0aGUgZm9ybSB2YWx1ZSBleHBlY3RlZCBieSB0aGUgQVBJIGZvciB0aGUgJ2NvbnRlbnQnIGtleVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsZUNvbnRlbnRGb3JtRGF0YShjb250ZW50LCBvcHRpb25zKSB7XG5cdC8vIFRoZSB1cGxvYWQgQVBJIGFwcGVhcnMgdG8gbG9vayBmb3IgYSBmb3JtIGZpZWxkIHRoYXQgY29udGFpbnMgYSBmaWxlbmFtZVxuXHQvLyBwcm9wZXJ0eSBhbmQgYXNzdW1lIHRoYXQgdGhpcyBmb3JtIGZpZWxkIGNvbnRhaW5zIHRoZSBmaWxlIGNvbnRlbnQuIFRodXMsXG5cdC8vIHRoZSB2YWx1ZSBvZiBuYW1lIGRvZXMgbm90IGFjdHVhbGx5IG1hdHRlciAoYXMgbG9uZyBhcyBpdCBkb2VzIG5vdCBjb25mbGljdFxuXHQvLyB3aXRoIG90aGVyIGZpZWxkIG5hbWVzKS4gU2ltaWxhcmx5LCB0aGUgdmFsdWUgb2Ygb3B0aW9ucy5maWxlbmFtZSBkb2VzIG5vdFxuXHQvLyBtYXR0ZXIgZWl0aGVyIChhcyBsb25nIGFzIGl0IGV4aXN0cyksIHNpbmNlIHRoZSB1cGxvYWQgQVBJIHdpbGwgdXNlIHRoZVxuXHQvLyBmaWxlbmFtZSBzcGVjaWZpZWQgaW4gdGhlIG1ldGFkYXRhIGZvcm0gZmllbGQgaW5zdGVhZC5cblx0cmV0dXJuIHtcblx0XHR2YWx1ZTogY29udGVudCxcblx0XHRvcHRpb25zOiBPYmplY3QuYXNzaWduKHsgZmlsZW5hbWU6ICd1bnVzZWQnIH0sIG9wdGlvbnMpXG5cdH07XG59XG5cbi8qKlxuICogUG9sbCB0aGUgcmVwcmVzZW50YXRpb24gaW5mbyBVUkwgdW50aWwgcmVwcmVzZW50YXRpb24gaXMgZ2VuZXJhdGVkLFxuICogdGhlbiByZXR1cm4gY29udGVudCBVUkwgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IFRoZSBjbGllbnQgdG8gdXNlIGZvciBtYWtpbmcgQVBJIGNhbGxzXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5mb1VSTCBUaGUgVVJMIHRvIHVzZSBmb3IgZ2V0dGluZyByZXByZXNlbnRhdGlvbiBpbmZvXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb250ZW50IFVSTCB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiBwb2xsUmVwcmVzZW50YXRpb25JbmZvKGNsaWVudCwgaW5mb1VSTCkge1xuXG5cdHJldHVybiBjbGllbnQuZ2V0KGluZm9VUkwpXG5cdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG5cdFx0XHRcdHRocm93IGVycm9ycy5idWlsZFVuZXhwZWN0ZWRSZXNwb25zZUVycm9yKHJlc3BvbnNlKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGluZm8gPSByZXNwb25zZS5ib2R5O1xuXG5cdFx0XHRzd2l0Y2ggKGluZm8uc3RhdHVzLnN0YXRlKSB7XG5cblx0XHRcdGNhc2UgJ3N1Y2Nlc3MnOlxuXHRcdFx0Y2FzZSAndmlld2FibGUnOlxuXHRcdFx0Y2FzZSAnZXJyb3InOlxuXHRcdFx0XHRyZXR1cm4gaW5mbztcblx0XHRcdGNhc2UgJ25vbmUnOlxuXHRcdFx0Y2FzZSAncGVuZGluZyc6XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmRlbGF5KDEwMDApLnRoZW4oKCkgPT4gcG9sbFJlcHJlc2VudGF0aW9uSW5mbyhjbGllbnQsIGluZm9VUkwpKTtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5rbm93biByZXByZXNlbnRhdGlvbiBzdGF0dXM6ICR7aW5mby5zdGF0dXMuc3RhdGV9YCk7XG5cdFx0XHR9XG5cdFx0fSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgJ0ZpbGUnIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGVzKGNsaWVudCkge1xuXHQvLyBBdHRhY2ggdGhlIGNsaWVudCwgZm9yIG1ha2luZyBBUEkgY2FsbHNcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogUmVxdWVzdHMgYSBmaWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBJRC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIEJveCBJRCBvZiB0aGUgZmlsZSBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBmaWxlIGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGZpbGUgb2JqZWN0XG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnNcblx0fTtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlEKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgYSBkb3dubG9hZCBVUkwgZm9yIGEgZ2l2ZW4gZmlsZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC9jb250ZW50J1xuICogTWV0aG9kOiBHRVRcbiAqIFNwZWNpYWwgRXhwZWN0ZWQgUmVzcG9uc2VzOlxuICogICAyMDIgQUNDRVBURUQgLSBEb3dubG9hZCBpc24ndCBhdmFpbGFibGUgeWV0LiBSZXR1cm5zIGFuIGVycm9yLlxuICogICAzMDIgRk9VTkQgLSBEb3dubG9hZCBpcyBhdmFpbGFibGUuIEEgRG93bmxvYWQgVVJMIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBCb3ggSUQgb2YgdGhlIGZpbGUgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgZG93bmxvYWQgVVJMIGlmIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBmaWxlJ3MgZG93bmxvYWQgVVJMXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXREb3dubG9hZFVSTCA9IGZ1bmN0aW9uKGZpbGVJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJy9jb250ZW50Jyk7XG5cblx0Ly8gSGFuZGxlIFNwZWNpYWwgQVBJIFJlc3BvbnNlXG5cdHJldHVybiB0aGlzLmNsaWVudC5nZXQoYXBpUGF0aCwgcGFyYW1zKVxuXHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0c3dpdGNoIChyZXNwb25zZS5zdGF0dXNDb2RlKSB7XG5cblx0XHRcdC8vIDMwMiAtIEZvdW5kXG5cdFx0XHQvLyBObyBkYXRhIHJldHVybmVkLCBidXQgdGhlIGxvY2F0aW9uIGhlYWRlciBwb2ludHMgdG8gYSBkb3dubG9hZCBsaW5rIGZvciB0aGF0IGZpbGUuXG5cdFx0XHRjYXNlIGh0dHBTdGF0dXNDb2Rlcy5GT1VORDpcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG5cblx0XHRcdFx0Ly8gMjAyIC0gRG93bmxvYWQgaXNuJ3QgcmVhZHkgeWV0LlxuXHRcdFx0Y2FzZSBodHRwU3RhdHVzQ29kZXMuQUNDRVBURUQ6XG5cdFx0XHRcdHRocm93IGVycm9ycy5idWlsZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UsICdEb3dubG9hZCBub3QgcmVhZHkgYXQgdGhpcyB0aW1lJyk7XG5cblx0XHRcdFx0Ly8gVW5leHBlY3RlZCBSZXNwb25zZVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyBhIFJlYWRhYmxlIFN0cmVhbSBmb3IgdGhlIGdpdmVuIGZpbGUgSUQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQvY29udGVudCdcbiAqIE1ldGhvZDogR0VUXG4gKiBTcGVjaWFsIEV4cGVjdGVkIFJlc3BvbnNlczpcbiAqICAgMjAyIEFDQ0VQVEVEIC0gRG93bmxvYWQgaXNuJ3QgYXZhaWxhYmxlIHlldC4gUmV0dXJucyBhbiBlcnJvci5cbiAqICAgMzAyIEZPVU5EIC0gRG93bmxvYWQgaXMgYXZhaWxhYmxlLiBBIERvd25sb2FkIHN0cmVhbSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gQm94IElEIG9mIHRoZSBmaWxlIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52ZXJzaW9uXSAtIElEIG9mIHRoZSB2ZXJzaW9uIG9mIHRoaXMgZmlsZSB0byBkb3dubG9hZFxuICogQHBhcmFtIHtpbnRbXX0gW29wdGlvbnMuYnl0ZVJhbmdlXSAtIHN0YXJ0aW5nIGFuZCBlbmRpbmcgYnl0ZXMgb2YgdGhlIGZpbGUgdG8gcmVhZCwgZS5nLiBbMCwgOTldIHRvIHJlYWQgdGhlIGZpcnN0IDEwMCBieXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHBhc3NlZCB0aGUgcmVhZGFibGUgc3RyZWFtIGlmIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRhYmxlPn0gQSBwcm9taXNlIHJlc29sdmluZyBmb3IgdGhlIGZpbGUgc3RyZWFtXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXRSZWFkU3RyZWFtID0gZnVuY3Rpb24oZmlsZUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdHZhciBkb3dubG9hZFN0cmVhbU9wdGlvbnMgPSB7XG5cdFx0c3RyZWFtaW5nOiB0cnVlLFxuXHRcdGhlYWRlcnM6IHt9XG5cdH07XG5cblx0aWYgKG9wdGlvbnMuYnl0ZVJhbmdlKSB7XG5cdFx0dmFyIHJhbmdlID0gb3B0aW9ucy5ieXRlUmFuZ2U7XG5cdFx0ZGVsZXRlIG9wdGlvbnMuYnl0ZVJhbmdlO1xuXHRcdGRvd25sb2FkU3RyZWFtT3B0aW9ucy5oZWFkZXJzLlJhbmdlID0gYGJ5dGVzPSR7cmFuZ2VbMF19LSR7cmFuZ2VbMV19YDtcblx0fVxuXG5cdC8vIEdldCB0aGUgZG93bmxvYWQgVVJMIHRvIGRvd25sb2FkIGZyb21cblx0cmV0dXJuIHRoaXMuZ2V0RG93bmxvYWRVUkwoZmlsZUlELCBvcHRpb25zKVxuXHRcdC8vIFJldHVybiBhIHJlYWQgc3RyZWFtIHRvIGRvd25sb2FkIHRoZSBmaWxlXG5cdFx0LnRoZW4odXJsID0+IHRoaXMuY2xpZW50LmdldCh1cmwsIGRvd25sb2FkU3RyZWFtT3B0aW9ucykpXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyBhIFRodW1ibmFpbCBmb3IgYSBnaXZlbiBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3RodW1ibmFpbC5wbmcnXG4gKiBNZXRob2Q6IEdFVFxuICogU3BlY2lhbCBFeHBlY3RlZCBSZXNwb25zZXM6XG4gKiAgIDIwMCBPSyAtIFRodW1ibmFpbCBhdmFpbGFibGUuIFJldHVybnMgYSB0aHVtYm5haWwgZmlsZS5cbiAqICAgMjAyIEFDQ0VQVEVEIC0gVGh1bWJuYWlsIGlzbid0IGF2YWlsYWJsZSB5ZXQuIFJldHVybnMgYSBgbG9jYXRpb25gIFVSTCBmb3IgYSBnZW5lcmljIHBsYWNlaG9sZGVyIHRodW1ibmFpbC5cbiAqICAgMzAyIEZPVU5EIC0gVW5hYmxlIHRvIGdlbmVyYXRlIHRodW1ibmFpbC4gUmV0dXJucyBhIGBsb2NhdGlvbmAgVVJMIGZvciBhIGdlbmVyaWMgcGxhY2Vob2xkZXIgdGh1bWJuYWlsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBCb3ggSUQgb2YgdGhlIGZpbGUgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGh1bWJuYWlsIGZpbGUgb3IgdGhlIFVSTCB0byBhIHBsYWNlaG9sZGVyIHRodW1ibmFpbCBpZiBzdWNjZXNzZnVsLlxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdGh1bWJuYWlsIGluZm9ybWF0aW9uXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXRUaHVtYm5haWwgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnMsXG5cdFx0anNvbjogZmFsc2Vcblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmaWxlSUQsICcvdGh1bWJuYWlsLnBuZycpO1xuXG5cdC8vIEhhbmRsZSBTcGVjaWFsIEFQSSBSZXNwb25zZVxuXHRyZXR1cm4gdGhpcy5jbGllbnQuZ2V0KGFwaVBhdGgsIHBhcmFtcylcblx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cblx0XHRcdHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuXG5cdFx0XHQvLyAyMDIgLSBUaHVtYm5haWwgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCBpcyBub3QgcmVhZHkgeWV0XG5cdFx0XHQvLyAzMDIgLSBUaHVtYm5haWwgY2FuIG5vdCBiZSBnZW5lcmF0ZWRcblx0XHRcdC8vIHJldHVybiB0aGUgdXJsIGZvciBhIHRodW1ibmFpbCBwbGFjZWhvbGRlclxuXHRcdFx0Y2FzZSBodHRwU3RhdHVzQ29kZXMuQUNDRVBURUQ6XG5cdFx0XHRjYXNlIGh0dHBTdGF0dXNDb2Rlcy5GT1VORDpcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuXHRcdFx0XHRcdGxvY2F0aW9uOiByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gMjAwIC0gVGh1bWJuYWlsIGltYWdlIHJlY2lldmVkXG5cdFx0XHRcdC8vIHJldHVybiB0aGUgdGh1bWJuYWlsIGZpbGVcblx0XHRcdGNhc2UgaHR0cFN0YXR1c0NvZGVzLk9LOlxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG5cdFx0XHRcdFx0ZmlsZTogcmVzcG9uc2UuYm9keVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIFVuZXhwZWN0ZWQgUmVzcG9uc2Vcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRocm93IGVycm9ycy5idWlsZFVuZXhwZWN0ZWRSZXNwb25zZUVycm9yKHJlc3BvbnNlKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY29tbWVudHMgb24gYSBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL2NvbW1lbnRzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gQm94IGZpbGUgaWQgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gcGFzc2VkIHRoZSBmaWxlIGNvbW1lbnRzIGlmIHRoZXkgd2VyZSBzdWNjZXNzZnVsbHkgYWNxdWlyZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY29tbWVudHNcbiAqL1xuRmlsZXMucHJvdG90eXBlLmdldENvbW1lbnRzID0gZnVuY3Rpb24oZmlsZUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJy9jb21tZW50cycpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuXG4vKipcbiAqIFVwZGF0ZSBzb21lIGluZm9ybWF0aW9uIGFib3V0IGEgZ2l2ZW4gZmlsZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIEJveCBJRCBvZiB0aGUgZmlsZSBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIC0gRmlsZSBmaWVsZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMuZXRhZ10gT25seSBhcHBseSB0aGUgdXBkYXRlcyBpZiB0aGUgZmlsZSBldGFnIG1hdGNoZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgZmlsZSBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGUgZmlsZSBvYmplY3RcbiAqL1xuRmlsZXMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGZpbGVJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IHVwZGF0ZXNcblx0fTtcblxuXHRpZiAodXBkYXRlcyAmJiB1cGRhdGVzLmV0YWcpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IHtcblx0XHRcdCdJZi1NYXRjaCc6IHVwZGF0ZXMuZXRhZ1xuXHRcdH07XG5cdFx0ZGVsZXRlIHVwZGF0ZXMuZXRhZztcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGZpbGUgdG8gYSBnaXZlbiBjb2xsZWN0aW9uXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBUaGUgZmlsZSB0byBhZGQgdG8gdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSUQgLSBUaGUgY29sbGVjdGlvbiB0byBhZGQgdGhlIGZpbGUgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgZmlsZSBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgZmlsZSBvYmplY3RcbiAqL1xuRmlsZXMucHJvdG90eXBlLmFkZFRvQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGZpbGVJRCwgY29sbGVjdGlvbklELCBjYWxsYmFjaykge1xuXG5cdHJldHVybiB0aGlzLmdldChmaWxlSUQsIHsgZmllbGRzOiAnY29sbGVjdGlvbnMnIH0pXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG5cblx0XHRcdHZhciBjb2xsZWN0aW9ucyA9IGRhdGEuY29sbGVjdGlvbnMgfHwgW107XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gY29ycmVjdCBmb3JtYXRcblx0XHRcdGNvbGxlY3Rpb25zID0gY29sbGVjdGlvbnMubWFwKGMgPT4gKHsgaWQ6IGMuaWQgfSkpO1xuXG5cdFx0XHRpZiAoIWNvbGxlY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBjb2xsZWN0aW9uSUQpKSB7XG5cblx0XHRcdFx0Y29sbGVjdGlvbnMucHVzaCh7IGlkOiBjb2xsZWN0aW9uSUQgfSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLnVwZGF0ZShmaWxlSUQsIHsgY29sbGVjdGlvbnMgfSk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGZpbGUgZnJvbSBhIGdpdmVuIGNvbGxlY3Rpb25cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBmaWxlIHRvIHJlbW92ZSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklEIC0gVGhlIGNvbGxlY3Rpb24gdG8gcmVtb3ZlIHRoZSBmaWxlIGZyb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgZmlsZSBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgZmlsZSBvYmplY3RcbiAqL1xuRmlsZXMucHJvdG90eXBlLnJlbW92ZUZyb21Db2xsZWN0aW9uID0gZnVuY3Rpb24oZmlsZUlELCBjb2xsZWN0aW9uSUQsIGNhbGxiYWNrKSB7XG5cblx0cmV0dXJuIHRoaXMuZ2V0KGZpbGVJRCwgeyBmaWVsZHM6ICdjb2xsZWN0aW9ucycgfSlcblx0XHQudGhlbihkYXRhID0+IHtcblxuXHRcdFx0dmFyIGNvbGxlY3Rpb25zID0gZGF0YS5jb2xsZWN0aW9ucyB8fCBbXTtcblx0XHRcdC8vIENvbnZlcnQgdG8gY29ycmVjdCBvYmplY3QgZm9ybWF0IGFuZCByZW1vdmUgdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uXG5cdFx0XHRjb2xsZWN0aW9ucyA9IGNvbGxlY3Rpb25zLm1hcChjID0+ICh7IGlkOiBjLmlkIH0pKS5maWx0ZXIoYyA9PiBjLmlkICE9PSBjb2xsZWN0aW9uSUQpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy51cGRhdGUoZmlsZUlELCB7IGNvbGxlY3Rpb25zIH0pO1xuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBNb3ZlIGEgZmlsZSBpbnRvIGEgbmV3IHBhcmVudCBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBUaGUgQm94IElEIG9mIHRoZSBmaWxlIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhcmVudElEIC0gVGhlIEJveCBJRCBmb3IgdGhlIG5ldyBwYXJlbnQgZm9sZGVyLiAnMCcgdG8gbW92ZSB0byBBbGwgRmlsZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIGZpbGUgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCBmaWxlIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGZpbGVJRCwgbmV3UGFyZW50SUQsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0cGFyZW50OiB7XG5cdFx0XHRcdGlkOiBuZXdQYXJlbnRJRFxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlEKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ29weSBhIGZpbGUgaW50byBhIG5ldyBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQvY29weVxuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIGZpbGUgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFyZW50SUQgLSBUaGUgQm94IElEIGZvciB0aGUgbmV3IHBhcmVudCBmb2xkZXIuICcwJyB0byBjb3B5IHRvIEFsbCBGaWxlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgY29weSBvcGVyYXRpb24sIGNhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWVdIC0gQSBuZXcgbmFtZSB0byB1c2UgaWYgdGhlcmUgaXMgYW4gaWRlbnRpY2FsbHktbmFtZWQgaXRlbSBpbiB0aGUgbmV3IHBhcmVudCBmb2xkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIG5ldyBmaWxlIGluZm8gaWYgY2FsbCB3YXMgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IGZpbGUgb2JqZWN0XG4gKi9cbkZpbGVzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oZmlsZUlELCBuZXdQYXJlbnRJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHQvLyBATk9URShtd2lsbGVyKSAyMDE2LTEwLTI1OiBTaHVmZmxlIGFyZ3VtZW50cyB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cdC8vICBUaGlzIGNhbiBiZSByZW1vdmVkIGF0IHRoZSB2Mi4wIHVwZGF0ZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5wYXJlbnQgPSB7XG5cdFx0aWQ6IG5ld1BhcmVudElEXG5cdH07XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJy9jb3B5Jyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBnaXZlbiBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gQm94IElEIG9mIHRoZSBmaWxlIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZXRhZ10gT25seSBkZWxldGUgdGhlIGZpbGUgaWYgdGhlIGV0YWcgdmFsdWUgbWF0Y2hlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEVtcHR5IHJlc3BvbnNlIGJvZHkgcGFzc2VkIGlmIHN1Y2Nlc3NmdWwuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0Ly8gU3dpdGNoIGFyb3VuZCBhcmd1bWVudHMgaWYgbmVjZXNzYXJ5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0dmFyIHBhcmFtcyA9IHt9O1xuXG5cdGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXRhZykge1xuXHRcdHBhcmFtcy5oZWFkZXJzID0ge1xuXHRcdFx0J0lmLU1hdGNoJzogb3B0aW9ucy5ldGFnXG5cdFx0fTtcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBwcmVmbGlnaHQgaW5mb3JtYXRpb24gZm9yIGEgbmV3IGZpbGUgdXBsb2FkLiAgV2l0aG91dCBhbnkgZmlsZSBkYXRhLFxuICogdGhpcyB3aWxsIHJldHVybiBhbiB1cGxvYWQgVVJMIGFuZCB0b2tlbiB0byBiZSB1c2VkIHdoZW4gdXBsb2FkaW5nIHRoZSBmaWxlLlxuICogVXNpbmcgdGhpcyB1cGxvYWQgVVJMIHdpbGwgYWxsb3cgZm9yIHRoZSBmYXN0ZXN0IHVwbG9hZCwgYW5kIHRoZSBvbmUtdGltZVxuICogdG9rZW4gY2FuIGJlIHBhc3NlZCB0byBhIHdvcmtlciBvciBvdGhlciBjbGllbnQgdG8gYWN0dWFsbHkgcGVyZm9ybSB0aGVcbiAqIHVwbG9hZCB3aXRoLiAgSWYgZmlsZSBkYXRhIChlLmcuIHNpemUsIHBhcmVudCwgbmFtZSkgaXMgcGFzc2VkLCBpdCB3aWxsIGJlXG4gKiB2YWxpZGF0ZWQgYXMgaWYgdGhlIGFjdHVhbCBmaWxlIHdlcmUgYmVpbmcgdXBsb2FkZWQuICBUaGlzIGVuYWJsZXMgY2hlY2tpbmdcbiAqIG9mIHByZWNvbmRpdGlvbnMgc3VjaCBhcyBuYW1lIHVuaXF1ZW5lc3MgYW5kIGF2YWlsYWJsZSBzdG9yYWdlIHNwYWNlIGJlZm9yZVxuICogYXR0ZW1wdGluZyBhIGxhcmdlIGZpbGUgdXBsb2FkLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy9jb250ZW50J1xuICogTWV0aG9kOiBPUFRJT05TXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudEZvbGRlcklEIC0gVGhlIGlkIG9mIHRoZSBwYXJlbnQgZm9sZGVyIHRvIHVwbG9hZCB0b1xuICogQHBhcmFtIHtPYmplY3R9IFtmaWxlRGF0YV0gLSBPcHRpb25hbCBkYXRhIGFib3V0IHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIHVwbG9hZCBkYXRhIGlmIHN1Y2Nlc3NmdWwsIG9yIGVyciBpZiB0aGUgdXBsb2FkIHdvdWxkIG5vdCBzdWNjZWVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGxvYWQgZGF0YVxuICovXG5GaWxlcy5wcm90b3R5cGUucHJlZmxpZ2h0VXBsb2FkRmlsZSA9IGZ1bmN0aW9uKHBhcmVudEZvbGRlcklELCBmaWxlRGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0aWQ6IHBhcmVudEZvbGRlcklEXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXG5cdGlmIChmaWxlRGF0YSkge1xuXHRcdE9iamVjdC5hc3NpZ24ocGFyYW1zLmJvZHksIGZpbGVEYXRhKTtcblx0fVxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCAnL2NvbnRlbnQnKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQub3B0aW9ucykoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBwcmVmbGlnaHQgaW5mb3JtYXRpb24gZm9yIGEgZmlsZSB2ZXJzaW9uIHVwbG9hZC4gIFdpdGhvdXQgYW55IGZpbGUgZGF0YSxcbiAqIHRoaXMgd2lsbCByZXR1cm4gYW4gdXBsb2FkIFVSTCBhbmQgdG9rZW4gdG8gYmUgdXNlZCB3aGVuIHVwbG9hZGluZyB0aGUgZmlsZS5cbiAqIFVzaW5nIHRoaXMgdXBsb2FkIFVSTCB3aWxsIGFsbG93IGZvciB0aGUgZmFzdGVzdCB1cGxvYWQsIGFuZCB0aGUgb25lLXRpbWVcbiAqIHRva2VuIGNhbiBiZSBwYXNzZWQgdG8gYSB3b3JrZXIgb3Igb3RoZXIgY2xpZW50IHRvIGFjdHVhbGx5IHBlcmZvcm0gdGhlXG4gKiB1cGxvYWQgd2l0aC4gIElmIGZpbGUgZGF0YSAoZS5nLiBzaXplLCBwYXJlbnQsIG5hbWUpIGlzIHBhc3NlZCwgaXQgd2lsbCBiZVxuICogdmFsaWRhdGVkIGFzIGlmIHRoZSBhY3R1YWwgZmlsZSB3ZXJlIGJlaW5nIHVwbG9hZGVkLiAgVGhpcyBlbmFibGVzIGNoZWNraW5nXG4gKiBvZiBwcmVjb25kaXRpb25zIHN1Y2ggYXMgbmFtZSB1bmlxdWVuZXNzIGFuZCBhdmFpbGFibGUgc3RvcmFnZSBzcGFjZSBiZWZvcmVcbiAqIGF0dGVtcHRpbmcgYSBsYXJnZSBmaWxlIHVwbG9hZC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC9jb250ZW50J1xuICogTWV0aG9kOiBPUFRJT05TXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBmaWxlIElEIHRvIHdoaWNoIGEgbmV3IHZlcnNpb24gd2lsbCBiZSB1cGxvYWRlZFxuICogQHBhcmFtIHtPYmplY3R9IFtmaWxlRGF0YV0gLSBPcHRpb25hbCBkYXRhIGFib3V0IHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIHVwbG9hZCBkYXRhIGlmIHN1Y2Nlc3NmdWwsIG9yIGVyciBpZiB0aGUgdXBsb2FkIHdvdWxkIG5vdCBzdWNjZWVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGxvYWQgZGF0YVxuICovXG5GaWxlcy5wcm90b3R5cGUucHJlZmxpZ2h0VXBsb2FkTmV3RmlsZVZlcnNpb24gPSBmdW5jdGlvbihmaWxlSUQsIGZpbGVEYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cblx0aWYgKGZpbGVEYXRhKSB7XG5cdFx0cGFyYW1zLmJvZHkgPSBmaWxlRGF0YTtcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJy9jb250ZW50Jyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50Lm9wdGlvbnMpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBJZiB0aGVyZSBhcmUgcHJldmlvdXMgdmVyc2lvbnMgb2YgdGhpcyBmaWxlLCB0aGlzIG1ldGhvZCBjYW4gYmUgdXNlZCB0byBwcm9tb3RlIG9uZSBvZiB0aGUgb2xkZXJcbiAqIHZlcnNpb25zIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrLiBUaGlzIGFjdHVhbGx5IG1pbnRzIGEgY29weSBvZiB0aGUgb2xkIHZlcnNpb24gYW5kIHB1dHMgaXQgb25cbiAqIHRoZSB0b3Agb2YgdGhlIHZlcnNpb25zIHN0YWNrLiBUaGUgZmlsZSB3aWxsIGhhdmUgdGhlIGV4YWN0IHNhbWUgY29udGVudHMsIHRoZSBzYW1lIFNIQTEvZXRhZyxcbiAqIGFuZCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbC4gT3RoZXIgcHJvcGVydGllcyBzdWNoIGFzIGNvbW1lbnRzIGRvIG5vdCBnZXQgdXBkYXRlZCB0byB0aGVpciBmb3JtZXIgdmFsdWVzLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3ZlcnNpb25zL2N1cnJlbnQnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIGZpbGUgSUQgd2hpY2ggdmVyc2lvbiB3aWxsIGJlIHByb21vdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbklEIC0gVGhlIElEIG9mIHRoZSBmaWxlX3ZlcnNpb24gdGhhdCB5b3Ugd2FudCB0byBtYWtlIGN1cnJlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHByb21vdGVkIGZpbGUgdmVyc2lvbiBpbmZvcm1hdGlvbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHByb21vdGVkIGZpbGUgdmVyc2lvblxuICovXG5GaWxlcy5wcm90b3R5cGUucHJvbW90ZVZlcnNpb24gPSBmdW5jdGlvbihmaWxlSUQsIHZlcnNpb25JRCwgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlELCBWRVJTSU9OU19TVUJSRVNPVVJDRSwgJy9jdXJyZW50JyksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHR0eXBlOiAnZmlsZV92ZXJzaW9uJyxcblx0XHRcdFx0aWQ6IHZlcnNpb25JRFxuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwbG9hZHMgYSBuZXcgZmlsZS4gVW5saWtlIG5vbi11cGxvYWQgbWV0aG9kcywgdGhpcyBtZXRob2Qgd2lsbCBub3QgcGVyZm9ybSBhbnkgcmV0cmllcy5cbiAqIFRoaXMgbWV0aG9kIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IGFueSBvcHRpb25hbCBwYXJhbWV0ZXJzIHN1Y2ggYXMgY29udGVudE1vZGlmaWVkQXQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzL2NvbnRlbnQnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50Rm9sZGVySUQgLSB0aGUgaWQgb2YgdGhlIHBhcmVudCBmb2xkZXIgdG8gdXBsb2FkIHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSB0aGUgZmlsZSBuYW1lIHRoYXQgdGhlIHVwbG9hZGVkIGZpbGUgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxSZWFkU3RyZWFtfSBjb250ZW50IC0gdGhlIGNvbnRlbnQgb2YgdGhlIGZpbGUuIEl0IGNhbiBiZSBhIHN0cmluZywgYSBCdWZmZXIsIG9yIGEgcmVhZCBzdHJlYW1cbiAqIChsaWtlIHRoYXQgcmV0dXJuZWQgYnkgZnMuY3JlYXRlUmVhZFN0cmVhbSgpKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29udGVudF9jcmVhdGVkX2F0XSAtIFJGQyAzMzM5IHRpbWVzdGFtcCB3aGVuIHRoZSBmaWxlIHdhcyBjcmVhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29udGVudF9tb2RpZmllZF9hdF0gLSBSRkMgMzMzOSB0aW1lc3RhbXAgd2hlbiB0aGUgZmlsZSB3YXMgbGFzdCBtb2RpZmllZFxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmNvbnRlbnRfbGVuZ3RoXSAtIE9wdGlvbmFsIGxlbmd0aCBvZiB0aGUgY29udGVudC4gUmVxdWlyZWQgaWYgY29udGVudCBpcyBhIHJlYWQgc3RyZWFtIG9mIGFueSB0eXBlIG90aGVyIHRoYW4gZnMgc3RyZWFtLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGNhbGxlZCB3aXRoIGRhdGEgYWJvdXQgdGhlIHVwbG9hZCBpZiBzdWNjZXNzZnVsLCBvciBhbiBlcnJvciBpZiB0aGVcbiAqIHVwbG9hZCBmYWlsZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwbG9hZGVkIGZpbGVcbiAqL1xuRmlsZXMucHJvdG90eXBlLnVwbG9hZEZpbGUgPSBmdW5jdGlvbihwYXJlbnRGb2xkZXJJRCwgZmlsZW5hbWUsIGNvbnRlbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0Ly8gU2h1ZmZsZSBhcm91bmQgb3B0aW9uYWwgcGFyYW1ldGVyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHR2YXIgZm9ybU9wdGlvbnMgPSB7fTtcblx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29udGVudF9sZW5ndGgnKSkge1xuXHRcdGZvcm1PcHRpb25zLmtub3duTGVuZ3RoID0gb3B0aW9ucy5jb250ZW50X2xlbmd0aDtcblx0XHQvLyBEZWxldGUgY29udGVudF9sZW5ndGggZnJvbSBvcHRpb25zIHNvIGl0J3Mgbm90IGFkZGVkIHRvIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBmb3JtXG5cdFx0ZGVsZXRlIG9wdGlvbnMuY29udGVudF9sZW5ndGg7XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCAnL2NvbnRlbnQnKSxcblx0XHRtdWx0aXBhcnRGb3JtRGF0YSA9IHtcblx0XHRcdGF0dHJpYnV0ZXM6IGNyZWF0ZUZpbGVNZXRhZGF0YUZvcm1EYXRhKHBhcmVudEZvbGRlcklELCBmaWxlbmFtZSwgb3B0aW9ucyksXG5cdFx0XHRjb250ZW50OiBjcmVhdGVGaWxlQ29udGVudEZvcm1EYXRhKGNvbnRlbnQsIGZvcm1PcHRpb25zKVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQudXBsb2FkKShhcGlQYXRoLCBudWxsLCBtdWx0aXBhcnRGb3JtRGF0YSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGxvYWRzIGEgbmV3IHZlcnNpb24gb2YgYSBmaWxlLiBVbmxpa2Ugbm9uLXVwbG9hZCBtZXRob2RzLCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBwZXJmb3JtIGFueSByZXRyaWVzLlxuICogVGhpcyBtZXRob2QgY3VycmVudGx5IGRvZXMgbm90IHN1cHBvcnQgYW55IG9wdGlvbmFsIHBhcmFtZXRlcnMgc3VjaCBhcyBjb250ZW50TW9kaWZpZWRBdC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC9jb250ZW50J1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIHRoZSBpZCBvZiB0aGUgZmlsZSB0byB1cGxvYWQgYSBuZXcgdmVyc2lvbiBvZlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFN0cmVhbX0gY29udGVudCAtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlLiBJdCBjYW4gYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBvciBhIHJlYWQgc3RyZWFtXG4gKiAobGlrZSB0aGF0IHJldHVybmVkIGJ5IGZzLmNyZWF0ZVJlYWRTdHJlYW0oKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRfbW9kaWZpZWRfYXRdIC0gUkZDIDMzMzkgdGltZXN0YW1wIHdoZW4gdGhlIGZpbGUgd2FzIGxhc3QgbW9kaWZpZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSAtIEEgbmV3IG5hbWUgZm9yIHRoZSBmaWxlXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMuY29udGVudF9sZW5ndGhdIC0gT3B0aW9uYWwgbGVuZ3RoIG9mIHRoZSBjb250ZW50LiBSZXF1aXJlZCBpZiBjb250ZW50IGlzIGEgcmVhZCBzdHJlYW0gb2YgYW55IHR5cGUgb3RoZXIgdGhhbiBmcyBzdHJlYW0uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gY2FsbGVkIHdpdGggZGF0YSBhYm91dCB0aGUgdXBsb2FkIGlmIHN1Y2Nlc3NmdWwsIG9yIGFuIGVycm9yIGlmIHRoZVxuICogdXBsb2FkIGZhaWxlZFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBsb2FkZWQgZmlsZVxuICovXG5GaWxlcy5wcm90b3R5cGUudXBsb2FkTmV3RmlsZVZlcnNpb24gPSBmdW5jdGlvbihmaWxlSUQsIGNvbnRlbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0Ly8gU2h1ZmZsZSBhcm91bmQgb3B0aW9uYWwgcGFyYW1ldGVyXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmaWxlSUQsICcvY29udGVudCcpLFxuXHRcdG11bHRpcGFydEZvcm1EYXRhID0ge307XG5cblxuXHR2YXIgZm9ybU9wdGlvbnMgPSB7fTtcblx0aWYgKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnY29udGVudF9sZW5ndGgnKSkge1xuXHRcdFx0Zm9ybU9wdGlvbnMua25vd25MZW5ndGggPSBvcHRpb25zLmNvbnRlbnRfbGVuZ3RoO1xuXHRcdFx0Ly8gRGVsZXRlIGNvbnRlbnRfbGVuZ3RoIGZyb20gb3B0aW9ucyBzbyBpdCdzIG5vdCBhZGRlZCB0byB0aGUgYXR0cmlidXRlcyBvZiB0aGUgZm9ybVxuXHRcdFx0ZGVsZXRlIG9wdGlvbnMuY29udGVudF9sZW5ndGg7XG5cdFx0fVxuXHRcdG11bHRpcGFydEZvcm1EYXRhLmF0dHJpYnV0ZXMgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcblx0fVxuXG5cdG11bHRpcGFydEZvcm1EYXRhLmNvbnRlbnQgPSBjcmVhdGVGaWxlQ29udGVudEZvcm1EYXRhKGNvbnRlbnQsIGZvcm1PcHRpb25zKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC51cGxvYWQpKGFwaVBhdGgsIG51bGwsIG11bHRpcGFydEZvcm1EYXRhLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbGwgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZmlsZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC9tZXRhZGF0YSdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIHRoZSBJRCBvZiB0aGUgZmlsZSB0byBnZXQgbWV0YWRhdGEgZm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbWV0YWRhdGEgd2hlbiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBvbiB0aGUgZmlsZVxuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0QWxsTWV0YWRhdGEgPSBmdW5jdGlvbihmaWxlSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlELCAnbWV0YWRhdGEnKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgc2luZ2xlIG1ldGFkYXRhIHRlbXBsYXRlIGluc3RhbmNlIGZvciBhIGZpbGUuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQvbWV0YWRhdGEvOnNjb3BlLzp0ZW1wbGF0ZSdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBJRCBvZiB0aGUgZmlsZSB0byByZXRyaXZlIHRoZSBtZXRhZGF0YSBvZlxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSBtZXRhZGF0YSB0ZW1wbGF0ZSwgZS5nLiBcImdsb2JhbFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgLSBUaGUgbWV0YWRhdGEgdGVtcGxhdGUgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIG1ldGFkYXRhIHRlbXBsYXRlIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1ldGFkYXRhIHRlbXBsYXRlXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXRNZXRhZGF0YSA9IGZ1bmN0aW9uKGZpbGVJRCwgc2NvcGUsIHRlbXBsYXRlLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJ21ldGFkYXRhJywgc2NvcGUsIHRlbXBsYXRlKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFkZHMgbWV0YWRhdGEgdG8gYSBmaWxlLiAgTWV0YWRhdGEgbXVzdCBlaXRoZXIgbWF0Y2ggYSB0ZW1wbGF0ZSBzY2hlbWEgb3JcbiAqIGJlIHBsYWNlZCBpbnRvIHRoZSB1bnN0cnVjdHVyZWQgXCJwcm9wZXJ0aWVzXCIgdGVtcGxhdGUgaW4gZ2xvYmFsIHNjb3BlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL21ldGFkYXRhLzpzY29wZS86dGVtcGxhdGUnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIElEIG9mIHRoZSBmaWxlIHRvIGFkZCBtZXRhZGF0YSB0b1xuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSBtZXRhZGF0YSB0ZW1wbGF0ZSwgZS5nLiBcImVudGVycHJpc2VcIlxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIC0gVGhlIG1ldGFkYXRhIHRlbXBsYXRlIHNjaGVtYSB0byBhZGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gS2V5L3ZhbHVlIHBhaXJzIHRwIGFkZCBhcyBtZXRhZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIGVycm9yIGlmIHVuc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IG1ldGFkYXRhXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5hZGRNZXRhZGF0YSA9IGZ1bmN0aW9uKGZpbGVJRCwgc2NvcGUsIHRlbXBsYXRlLCBkYXRhLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJ21ldGFkYXRhJywgc2NvcGUsIHRlbXBsYXRlKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiBkYXRhXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyBhIG1ldGFkYXRhIHRlbXBsYXRlIGluc3RhbmNlIHdpdGggSlNPTiBQYXRjaC1mb3JtYXR0ZWQgZGF0YS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC9tZXRhZGF0YS86c2NvcGUvOnRlbXBsYXRlJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIGZpbGUgdG8gdXBkYXRlIG1ldGFkYXRhIGZvclxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSB0ZW1wbGF0ZSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSAtIFRoZSB0ZW1wbGF0ZSB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaCAtIFRoZSBwYXRjaCBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQ2FsbGVkIHdpdGggdXBkYXRlZCBtZXRhZGF0YSBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIG1ldGFkYXRhXG4gKi9cbkZpbGVzLnByb3RvdHlwZS51cGRhdGVNZXRhZGF0YSA9IGZ1bmN0aW9uKGZpbGVJRCwgc2NvcGUsIHRlbXBsYXRlLCBwYXRjaCwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmaWxlSUQsICdtZXRhZGF0YScsIHNjb3BlLCB0ZW1wbGF0ZSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogcGF0Y2gsXG5cdFx0XHRoZWFkZXJzOiB7XG5cdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbi1wYXRjaCtqc29uJ1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2V0cyBtZXRhZGF0YSBvbiBhIGZpbGUsIG92ZXJ3cml0aW5nIGFueSBtZXRhZGF0YSB0aGF0IGV4aXN0cyBmb3IgdGhlIHByb3ZpZGVkIGtleXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBmaWxlIHRvIHNldCBtZXRhZGF0YSBvblxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSBtZXRhZGF0YSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIC0gVGhlIGtleSBvZiB0aGUgbWV0YWRhdGEgdGVtcGxhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSAtIFRoZSBtZXRhZGF0YSB0byBzZXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCB1cGRhdGVkIG1ldGFkYXRhIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgbWV0YWRhdGFcbiAqL1xuRmlsZXMucHJvdG90eXBlLnNldE1ldGFkYXRhID0gZnVuY3Rpb24oZmlsZUlELCBzY29wZSwgdGVtcGxhdGUsIG1ldGFkYXRhLCBjYWxsYmFjaykge1xuXG5cdHJldHVybiB0aGlzLmFkZE1ldGFkYXRhKGZpbGVJRCwgc2NvcGUsIHRlbXBsYXRlLCBtZXRhZGF0YSlcblx0XHQuY2F0Y2goZXJyID0+IHtcblxuXHRcdFx0aWYgKGVyci5zdGF0dXNDb2RlICE9PSA0MDkpIHtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNZXRhZGF0YSBhbHJlYWR5IGV4aXN0cyBvbiB0aGUgZmlsZTsgdXBkYXRlIGluc3RlYWRcblx0XHRcdHZhciB1cGRhdGVzID0gT2JqZWN0LmtleXMobWV0YWRhdGEpLm1hcChrZXkgPT4gKHtcblx0XHRcdFx0b3A6ICdhZGQnLFxuXHRcdFx0XHRwYXRoOiBgLyR7a2V5fWAsXG5cdFx0XHRcdHZhbHVlOiBtZXRhZGF0YVtrZXldLFxuXHRcdFx0fSkpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy51cGRhdGVNZXRhZGF0YShmaWxlSUQsIHNjb3BlLCB0ZW1wbGF0ZSwgdXBkYXRlcyk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBtZXRhZGF0YSB0ZW1wbGF0ZSBmcm9tIGEgZmlsZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC9tZXRhZGF0YS86c2NvcGUvOnRlbXBsYXRlJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIElEIG9mIHRoZSBmaWxlIHRvIHJlbW92ZSBtZXRhZGF0YSBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgLSBUaGUgc2NvcGUgb2YgdGhlIG1ldGFkYXRhIHRlbXBsYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgLSBUaGUgdGVtcGxhdGUgdG8gcmVtb3ZlIGZyb20gdGhlIGZpbGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCBub3RoaW5nIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuICovXG5GaWxlcy5wcm90b3R5cGUuZGVsZXRlTWV0YWRhdGEgPSBmdW5jdGlvbihmaWxlSUQsIHNjb3BlLCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmaWxlSUQsICdtZXRhZGF0YScsIHNjb3BlLCB0ZW1wbGF0ZSk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBQZXJtYW5lbnRseSBkZWxldGVzIGFuIGl0ZW0gdGhhdCBpcyBpbiB0aGUgdHJhc2guIFRoZSBpdGVtIHdpbGwgbm8gbG9uZ2VyIGV4aXN0IGluIEJveC4gVGhpcyBhY3Rpb24gY2Fubm90IGJlIHVuZG9uZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC90cmFzaCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBJRCBvZiB0aGUgZmlsZSB0byByZW1vdmUgbWV0YWRhdGEgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZXRhZ10gT25seSBkZWxldGUgdGhlIGZpbGUgaWYgdGhlIGV0YWcgbWF0Y2hlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5kZWxldGVQZXJtYW5lbnRseSA9IGZ1bmN0aW9uKGZpbGVJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0dmFyIHBhcmFtcyA9IHt9O1xuXG5cdGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXRhZykge1xuXHRcdHBhcmFtcy5oZWFkZXJzID0ge1xuXHRcdFx0J0lmLU1hdGNoJzogb3B0aW9ucy5ldGFnXG5cdFx0fTtcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJy90cmFzaCcpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBmaWxlIHRoYXQgaGFzIGJlZW4gbW92ZWQgdG8gdGhlIHRyYXNoLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3RyYXNoJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIElEIG9mIHRoZSBmaWxlIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHRyYXNoZWQgZmlsZSBpbmZvcm1hdGlvbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRyYXNoZWQgZmlsZVxuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0VHJhc2hlZEZpbGUgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJ3RyYXNoJyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbGwgb2YgdGhlIHRhc2tzIGZvciBnaXZlbiBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3Rhc2tzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIElEIG9mIHRoZSBmaWxlIHRvIGdldCB0YXNrcyBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBmaWxlIHRhc2tzIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGNvbGxlY3Rpb25zIG9mIHRhc2tzIG9uIHRoZSBmaWxlXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXRUYXNrcyA9IGZ1bmN0aW9uKGZpbGVJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlELCAnL3Rhc2tzJyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gcmV0cmlldmUgYW4gZXhwaXJpbmcgVVJMIGZvciBjcmVhdGluZyBhbiBlbWJlZGRlZCBwcmV2aWV3IHNlc3Npb24uXG4gKiBUaGUgVVJMIHdpbGwgZXhwaXJlIGFmdGVyIDYwIHNlY29uZHMgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gd2lsbCBleHBpcmUgYWZ0ZXIgNjAgbWludXRlcy5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRD9maWVsZHM9ZXhwaXJpbmdfZW1iZWRfbGluaydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBJRCBvZiB0aGUgZmlsZSB0byBnZW5lcmF0ZSBlbWJlZCBsaW5rIGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB3aXRoIHRoZSBlbWJlZCBsaW5rIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgZmlsZSBlbWJlZCBsaW5rIFVSTFxuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0RW1iZWRMaW5rID0gZnVuY3Rpb24oZmlsZUlELCBjYWxsYmFjaykge1xuXG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IHtcblx0XHRcdGZpZWxkczogJ2V4cGlyaW5nX2VtYmVkX2xpbmsnXG5cdFx0fVxuXHR9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC5nZXQoYXBpUGF0aCwgcGFyYW1zKVxuXHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IGh0dHBTdGF0dXNDb2Rlcy5PSykge1xuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5LmV4cGlyaW5nX2VtYmVkX2xpbmsudXJsO1xuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBMb2NrcyAgYSBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIElEIG9mIHRoZSBmaWxlIHRvIGxvY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzLCBjYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXNcbiAqIEBwYXJhbSB7P3N0cmluZ30gW29wdGlvbnMuZXhwaXJlc19hdF0gLSBUaGUgdGltZSB0aGUgbG9jayBleHBpcmVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzX2Rvd25sb2FkX3ByZXZlbnRlZF0gLSBXaGV0aGVyIG9yIG5vdCB0aGUgZmlsZSBjYW4gYmUgZG93bmxvYWRlZCB3aGlsZSBsb2NrZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgd2l0aCB0aGUgbG9ja2VkIGZpbGUgaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBsb2NrZWQgZmlsZSBvYmplY3RcbiAqL1xuRmlsZXMucHJvdG90eXBlLmxvY2sgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB7XG5cdFx0XHRcdGxvY2s6IHtcblx0XHRcdFx0XHR0eXBlOiBsb2NrVHlwZXMuTE9DS1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRPYmplY3QuYXNzaWduKHBhcmFtcy5ib2R5LmxvY2ssIG9wdGlvbnMpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVubG9ja3MgYSBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEJ1xuICogIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1bmxvY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgd2l0aCB0aGUgdW5sb2NrZWQgZmlsZSBpbmZvcm1hdGlvbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVubG9ja2VkIGZpbGUgb2JqZWN0XG4gKi9cbkZpbGVzLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbihmaWxlSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB7XG5cdFx0XHRcdGxvY2s6IG51bGxcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlc3RvcmVzIGFuIGl0ZW0gdGhhdCBoYXMgYmVlbiBtb3ZlZCB0byB0aGUgdHJhc2guIERlZmF1bHQgYmVoYXZpb3IgaXMgdG9cbiAqIHJlc3RvcmUgdGhlIGl0ZW0gdG8gdGhlIGZvbGRlciBpdCB3YXMgaW4gYmVmb3JlIGl0IHdhcyBtb3ZlZCB0byB0aGUgdHJhc2guXG4gKiBJZiB0aGF0IHBhcmVudCBmb2xkZXIgbm8gbG9uZ2VyIGV4aXN0cyBvciBpZiB0aGVyZSBpcyBub3cgYW4gaXRlbSB3aXRoIHRoZVxuICogc2FtZSBuYW1lIGluIHRoYXQgcGFyZW50IGZvbGRlciwgdGhlIG5ldyBwYXJlbnQgZm9sZGVyIGFuZC9vciBuZXcgbmFtZSB3aWxsXG4gKiBuZWVkIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZXF1ZXN0LlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBJRCBvZiB0aGUgZmlsZSB0byByZXN0b3JlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gLSBUaGUgbmV3IG5hbWUgZm9yIHRoaXMgaXRlbVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhcmVudF9pZF0gLSBUaGUgbmV3IHBhcmVudCBmb2xkZXIgZm9yIHRoaXMgaXRlbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIGl0ZW0gaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXN0b3JlZCBmaWxlIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUucmVzdG9yZUZyb21UcmFzaCA9IGZ1bmN0aW9uKGZpbGVJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHQvLyBTZXQgdXAgdGhlIHBhcmVudF9pZCBwYXJhbWV0ZXJcblx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJlbnRfaWQpIHtcblxuXHRcdG9wdGlvbnMucGFyZW50ID0ge1xuXHRcdFx0aWQ6IG9wdGlvbnMucGFyZW50X2lkXG5cdFx0fTtcblxuXHRcdGRlbGV0ZSBvcHRpb25zLnBhcmVudF9pZDtcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogb3B0aW9ucyB8fCB7fVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIElmIHRoZXJlIGFyZSBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGlzIGZpbGUsIHRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIHJldHJpZXZlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUgb2xkZXIgdmVyc2lvbnMuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQvdmVyc2lvbnMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gdmlldyB2ZXJzaW9uIGZvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBsaXN0IG9mIHByZXZpb3VzIGZpbGUgdmVyc2lvbnMgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZpbGUgdmVyc2lvbnNcbiAqL1xuRmlsZXMucHJvdG90eXBlLmdldFZlcnNpb25zID0gZnVuY3Rpb24oZmlsZUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgVkVSU0lPTlNfU1VCUkVTT1VSQ0UpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVc2VkIHRvIHJldHJpZXZlIHRoZSB3YXRlcm1hcmsgZm9yIGEgY29ycmVzcG9uZGluZyBCb3ggZmlsZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRC93YXRlcm1hcmsnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBUaGUgQm94IElEIG9mIHRoZSBmaWxlIHRvIGdldCB3YXRlcm1hcmsgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgd2F0ZXJtYXJrIGluZm9ybWF0aW9uIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgd2F0ZXJtYXJrIGluZm9cbiAqL1xuRmlsZXMucHJvdG90eXBlLmdldFdhdGVybWFyayA9IGZ1bmN0aW9uKGZpbGVJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmaWxlSUQsIFdBVEVSTUFSS19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC5nZXQoYXBpUGF0aCwgcGFyYW1zKVxuXHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5LndhdGVybWFyaztcblx0XHR9KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBhcHBseSBvciB1cGRhdGUgdGhlIHdhdGVybWFyayBmb3IgYSBjb3JyZXNwb25kaW5nIEJveCBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3dhdGVybWFyaydcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIGZpbGUgdG8gdXBkYXRlIHdhdGVybWFyayBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzLCBjYW4gYmUgbGVmdCBudWxsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB3YXRlcm1hcmsgaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB3YXRlcm1hcmsgaW5mb1xuICovXG5GaWxlcy5wcm90b3R5cGUuYXBwbHlXYXRlcm1hcmsgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgV0FURVJNQVJLX1NVQlJFU09VUkNFKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB7XG5cdFx0XHRcdHdhdGVybWFyazoge1xuXHRcdFx0XHRcdGltcHJpbnQ6ICdkZWZhdWx0JyAvLyBDdXJyZW50bHkgdGhlIEFQSSBvbmx5IHN1cHBvcnRzIGRlZmF1bHQgaW1wcmludFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRPYmplY3QuYXNzaWduKHBhcmFtcy5ib2R5LndhdGVybWFyaywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byByZW1vdmUgdGhlIHdhdGVybWFyayBmb3IgYSBjb3JyZXNwb25kaW5nIEJveCBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3dhdGVybWFyaydcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIGZpbGUgdG8gcmVtb3ZlIHdhdGVybWFyayBmcm9tXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgcmVzcG9uc2UgYm9keSBwYXNzZWQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5yZW1vdmVXYXRlcm1hcmsgPSBmdW5jdGlvbihmaWxlSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlELCBXQVRFUk1BUktfU1VCUkVTT1VSQ0UpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEaXNjYXJkcyBhIHNwZWNpZmljIGZpbGUgdmVyc2lvbiB0byB0aGUgdHJhc2guIERlcGVuZGluZyBvbiB0aGUgZW50ZXJwcmlzZSBzZXR0aW5nc1xuICogZm9yIHRoaXMgdXNlciwgdGhlIGl0ZW0gd2lsbCBlaXRoZXIgYmUgYWN0dWFsbHkgZGVsZXRlZCBmcm9tIEJveCBvciBtb3ZlZCB0byB0aGUgdHJhc2guXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQvdmVyc2lvbi86dmVyc2lvbklEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIGZpbGUgSUQgd2hpY2ggb2xkIHZlcnNpb24gd2lsbCBiZSBtb3ZlZCB0byB0aGUgdHJhc2ggb3IgZGVsZXRlIHBlcm1hbmVudGx5XG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbklEIC0gVGhlIElEIG9mIHRoZSB2ZXJzaW9uIHRvIG1vdmUgdG8gdGhlIHRyYXNoIG9yIGRlbGV0ZSBwZXJtYW5lbnRseVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZXRhZ10gT25seSBkZWxldGUgdGhlIHZlcnNpb24gb2YgdGhlIGZpbGUgZXRhZyBtYXRjaGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgcmVzcG9uc2UgYm9keSwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5kZWxldGVWZXJzaW9uID0gZnVuY3Rpb24oZmlsZUlELCB2ZXJzaW9uSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0Ly8gU3dpdGNoIGFyb3VuZCBhcmd1bWVudHMgaWYgbmVjZXNzYXJ5IGZvciBiYWNrd3dhcmRzIGNvbXBhdGliaWxpdHlcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXG5cdHZhciBwYXJhbXMgPSB7fTtcblxuXHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmV0YWcpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IHtcblx0XHRcdCdJZi1NYXRjaCc6IG9wdGlvbnMuZXRhZ1xuXHRcdH07XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmaWxlSUQsIFZFUlNJT05TX1NVQlJFU09VUkNFLCB2ZXJzaW9uSUQpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXNzaW9uIHVzZWQgdG8gdXBsb2FkIGEgbmV3IGZpbGUgaW4gY2h1bmtzLi4gIFRoaXMgd2lsbCBmaXJzdFxuICogdmVyaWZ5IHRoYXQgdGhlIGZpbGUgY2FuIGJlIGNyZWF0ZWQgYW5kIHRoZW4gb3BlbiBhIHNlc3Npb24gZm9yIHVwbG9hZGluZ1xuICogcGllY2VzIG9mIHRoZSBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy91cGxvYWRfc2Vzc2lvbnMnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgSUQgb2YgdGhlIGZvbGRlciB0byB1cGxvYWQgdGhlIGZpbGUgdG9cbiAqIEBwYXJhbSB7aW50fSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIGZpbGUgdGhhdCB3aWxsIGJlIHVwbG9hZGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwbG9hZCBzZXNzaW9uIGluZm8gaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IHVwbG9hZCBzZXNzaW9uIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUuY3JlYXRlVXBsb2FkU2Vzc2lvbiA9IGZ1bmN0aW9uKGZvbGRlcklELCBzaXplLCBuYW1lLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlVUkwgPSB0aGlzLmNsaWVudC5fdXBsb2FkQmFzZVVSTCArIHVybFBhdGgoQkFTRV9QQVRILCBVUExPQURfU0VTU0lPTl9TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRmb2xkZXJfaWQ6IGZvbGRlcklELFxuXHRcdFx0XHRmaWxlX3NpemU6IHNpemUsXG5cdFx0XHRcdGZpbGVfbmFtZTogbmFtZVxuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpVVJMLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlc3Npb24gdXNlZCB0byB1cGxvYWQgYSBuZXcgdmVyc2lvbiBvZiBhIGZpbGUgaW4gY2h1bmtzLiAgVGhpc1xuICogd2lsbCBmaXJzdCB2ZXJpZnkgdGhhdCB0aGUgdmVyc2lvbiBjYW4gYmUgY3JlYXRlZCBhbmQgdGhlbiBvcGVuIGEgc2Vzc2lvbiBmb3JcbiAqIHVwbG9hZGluZyBwaWVjZXMgb2YgdGhlIGZpbGUuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzLzpmaWxlSUQvdXBsb2FkX3Nlc3Npb25zJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIFRoZSBJRCBvZiB0aGUgZmlsZSB0byB1cGxvYWQgYSBuZXcgdmVyc2lvbiBvZlxuICogQHBhcmFtIHtpbnR9IHNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgZmlsZSB0aGF0IHdpbGwgYmUgdXBsb2FkZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwbG9hZCBzZXNzaW9uIGluZm8gaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IHVwbG9hZCBzZXNzaW9uIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUuY3JlYXRlTmV3VmVyc2lvblVwbG9hZFNlc3Npb24gPSBmdW5jdGlvbihmaWxlSUQsIHNpemUsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVVSTCA9IHRoaXMuY2xpZW50Ll91cGxvYWRCYXNlVVJMICsgdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgVVBMT0FEX1NFU1NJT05fU1VCUkVTT1VSQ0UpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHtcblx0XHRcdFx0ZmlsZV9zaXplOiBzaXplXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlVUkwsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGxvYWRzIGEgY2h1bmsgb2YgYSBmaWxlIHRvIGFuIG9wZW4gdXBsb2FkIHNlc3Npb25cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvdXBsb2FkX3Nlc3Npb25zLzpzZXNzaW9uSUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXNzaW9uSUQgLSBUaGUgSUQgb2YgdGhlIHVwbG9hZCBzZXNzaW9uIHRvIHVwbG9hZCB0b1xuICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfSBwYXJ0IC0gVGhlIGNodW5rIG9mIHRoZSBmaWxlIHRvIHVwbG9hZFxuICogQHBhcmFtIHtpbnR9IG9mZnNldCAtIFRoZSBieXRlIHBvc2l0aW9uIHdoZXJlIHRoZSBjaHVuayBiZWdpbnMgaW4gdGhlIGZpbGVcbiAqIEBwYXJhbSB7aW50fSB0b3RhbFNpemUgLSBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgZmlsZSBiZWluZyB1cGxvYWRlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgcGFydCBkZWZpbml0aW9uIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHBhcnQgb2JqZWN0XG4gKi9cbkZpbGVzLnByb3RvdHlwZS51cGxvYWRQYXJ0ID0gZnVuY3Rpb24oc2Vzc2lvbklELCBwYXJ0LCBvZmZzZXQsIHRvdGFsU2l6ZSwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpVVJMID0gdGhpcy5jbGllbnQuX3VwbG9hZEJhc2VVUkwgKyB1cmxQYXRoKEJBU0VfUEFUSCwgVVBMT0FEX1NFU1NJT05fU1VCUkVTT1VSQ0UsIHNlc3Npb25JRCk7XG5cdHZhciBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKS51cGRhdGUocGFydClcblx0XHQuZGlnZXN0KCdiYXNlNjQnKTtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGhlYWRlcnM6IHtcblx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcblx0XHRcdERpZ2VzdDogYFNIQT0ke2hhc2h9YCxcblx0XHRcdCdDb250ZW50LVJhbmdlJzogYGJ5dGVzICR7b2Zmc2V0fS0ke29mZnNldCArIHBhcnQubGVuZ3RoIC0gMX0vJHt0b3RhbFNpemV9YFxuXHRcdH0sXG5cdFx0anNvbjogZmFsc2UsXG5cdFx0Ym9keTogcGFydFxuXHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC5wdXQoYXBpVVJMLCBwYXJhbXMpXG5cdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG5cdFx0XHRcdHRocm93IGVycm9ycy5idWlsZFVuZXhwZWN0ZWRSZXNwb25zZUVycm9yKHJlc3BvbnNlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENvbW1pdCBhbiB1cGxvYWQgc2Vzc2lvbiBhZnRlciBhbGwgcGFydHMgaGF2ZSBiZWVuIHVwbG9hZGVkLCBjcmVhdGluZyB0aGUgbmV3IGZpbGVcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvdXBsb2FkX3Nlc3Npb25zLzpzZXNzaW9uSUQvY29tbWl0J1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JRCAtIFRoZSBJRCBvZiB0aGUgdXBsb2FkIHNlc3Npb24gdG8gY29tbWl0XG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUhhc2ggLSBUaGUgYmFzZTY0LWVuY29kZWQgU0hBLTEgaGFzaCBvZiB0aGUgZmlsZSBiZWluZyB1cGxvYWRlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgc2V0IG9uIHRoZSBjcmVhdGVkIGZpbGUsIGNhbiBiZSBsZWZ0IG51bGxcbiAqIEBwYXJhbSB7VXBsb2FkUGFydFtdfSBbb3B0aW9ucy5wYXJ0c10gVGhlIGxpc3Qgb2YgdXBsb2FkZWQgcGFydHMgdG8gYmUgY29tbWl0dGVkLCB3aWxsIGJlIGZldGNoZWQgZnJvbSB0aGUgQVBJIG90aGVyd2lzZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbmV3IGZpbGUgaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBsb2FkZWQgZmlsZSBvYmplY3RcbiAqL1xuRmlsZXMucHJvdG90eXBlLmNvbW1pdFVwbG9hZFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uSUQsIGZpbGVIYXNoLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdHZhciB1c2VyUGFydHM7XG5cdGlmIChvcHRpb25zLnBhcnRzKSB7XG5cdFx0dXNlclBhcnRzID0gb3B0aW9ucy5wYXJ0cztcblx0XHRkZWxldGUgb3B0aW9ucy5wYXJ0cztcblx0fVxuXG5cdHZhciBhcGlVUkwgPSB0aGlzLmNsaWVudC5fdXBsb2FkQmFzZVVSTCArIHVybFBhdGgoQkFTRV9QQVRILCBVUExPQURfU0VTU0lPTl9TVUJSRVNPVVJDRSwgc2Vzc2lvbklELCAnY29tbWl0JyksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHREaWdlc3Q6IGBTSEE9JHtmaWxlSGFzaH1gXG5cdFx0XHR9LFxuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRhdHRyaWJ1dGVzOiBvcHRpb25zXG5cdFx0XHR9XG5cdFx0fTtcblxuXHR2YXIgZmV0Y2hQYXJ0cyA9IChvZmZzZXQsIGZldGNoZWRQYXJ0cykgPT4ge1xuXG5cdFx0bGV0IHBhZ2luZ09wdGlvbnMgPSB7XG5cdFx0XHRsaW1pdDogMTAwMCxcblx0XHRcdG9mZnNldFxuXHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRVcGxvYWRTZXNzaW9uUGFydHMoc2Vzc2lvbklELCBwYWdpbmdPcHRpb25zKVxuXHRcdFx0LnRoZW4oZGF0YSA9PiB7XG5cblx0XHRcdFx0ZmV0Y2hlZFBhcnRzID0gZmV0Y2hlZFBhcnRzLmNvbmNhdChkYXRhLmVudHJpZXMpO1xuXG5cdFx0XHRcdGlmIChkYXRhLm9mZnNldCArIGRhdGEuZW50cmllcy5sZW5ndGggPj0gZGF0YS50b3RhbF9jb3VudCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmV0Y2hlZFBhcnRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmZXRjaFBhcnRzKG9mZnNldCArIGRhdGEubGltaXQsIGZldGNoZWRQYXJ0cyk7XG5cdFx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gKHVzZXJQYXJ0cyA/IFByb21pc2UucmVzb2x2ZSh1c2VyUGFydHMpIDogZmV0Y2hQYXJ0cygwLCBbXSkpXG5cdFx0LnRoZW4ocGFydHMgPT4ge1xuXG5cdFx0XHQvLyBDb21taXQgdGhlIHVwbG9hZCB3aXRoIHRoZSBsaXN0IG9mIHBhcnRzXG5cdFx0XHRwYXJhbXMuYm9keS5wYXJ0cyA9IHBhcnRzO1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xpZW50LnBvc3QoYXBpVVJMLCBwYXJhbXMpO1xuXHRcdH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuXG5cdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAxKSB7XG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAyKSB7XG5cdFx0XHRcdHZhciByZXRyeUludGVydmFsID0gcmVzcG9uc2UuaGVhZGVyc1sncmV0cnktYWZ0ZXInXSB8fCAxO1xuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5kZWxheShyZXRyeUludGVydmFsICogMTAwMClcblx0XHRcdFx0XHQudGhlbigoKSA9PiB7XG5cblx0XHRcdFx0XHRcdC8vIEVuc3VyZSB3ZSBkb24ndCBoYXZlIHRvIGZldGNoIHBhcnRzIGZyb20gdGhlIEFQSSBhZ2FpbiBvbiByZXRyeVxuXHRcdFx0XHRcdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgcGFydHM6IHBhcmFtcy5ib2R5LnBhcnRzIH0pO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuY29tbWl0VXBsb2FkU2Vzc2lvbihzZXNzaW9uSUQsIGZpbGVIYXNoLCBvcHRpb25zKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBYm9ydCBhbiB1cGxvYWQgc2Vzc2lvbiwgZGlzY2FyZGluZyBhbnkgY2h1bmtzIHRoYXQgd2VyZSB1cGxvYWRlZCB0byBpdFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy91cGxvYWRfc2Vzc2lvbnMvOnNlc3Npb25JRCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JRCAtIFRoZSBJRCBvZiB0aGUgdXBsb2FkIHNlc3Npb24gdG8gY29tbWl0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5hYm9ydFVwbG9hZFNlc3Npb24gPSBmdW5jdGlvbihzZXNzaW9uSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVVSTCA9IHRoaXMuY2xpZW50Ll91cGxvYWRCYXNlVVJMICsgdXJsUGF0aChCQVNFX1BBVEgsIFVQTE9BRF9TRVNTSU9OX1NVQlJFU09VUkNFLCBzZXNzaW9uSUQpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpVVJMLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIHBhcnRzIHRoYXQgaGF2ZSBiZWVuIHVwbG9hZGVkIHRvIGFuIHVwbG9hZCBzZXNzaW9uXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVzL3VwbG9hZF9zZXNzaW9ucy86c2Vzc2lvbklEL3BhcnRzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2Vzc2lvbklEIC0gVGhlIElEIG9mIHRoZSBzZXNzaW9uIHRvIGdldCBhIGxpc3Qgb2YgcGFydHMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMsIGNhbiBiZSBsZWZ0IG51bGxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vZmZzZXRdIC0gUGFnaW5nIG9mZnNldCBmb3IgdGhlIGxpc3Qgb2YgcGFydHNcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5saW1pdF0gLSBNYXhpbXVtIG51bWJlciBvZiBwYXJ0cyB0byByZXR1cm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIGxpc3Qgb2YgcGFydHMgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiB1cGxvYWRlZCBwYXJ0c1xuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0VXBsb2FkU2Vzc2lvblBhcnRzID0gZnVuY3Rpb24oc2Vzc2lvbklELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlVUkwgPSB0aGlzLmNsaWVudC5fdXBsb2FkQmFzZVVSTCArIHVybFBhdGgoQkFTRV9QQVRILCBVUExPQURfU0VTU0lPTl9TVUJSRVNPVVJDRSwgc2Vzc2lvbklELCAncGFydHMnKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlVUkwsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0YXR1cyBvZiBhbiB1cGxvYWQgc2Vzc2lvbiwgZS5nLiB3aGV0aGVyIG9yIG5vdCBpcyBoYXMgc3RhcnRlZCBvclxuICogZmluaXNoZWQgY29tbWl0dGluZ1xuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy91cGxvYWRfc2Vzc2lvbnMvOnNlc3Npb25JRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlc3Npb25JRCAtIFRoZSBJRCBvZiB0aGUgdXBsb2FkIHNlc3Npb24gdG8gZ2V0IHRoZSBzdGF0dXMgb2ZcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHNlc3Npb24gc3RhdHVzIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwbG9hZCBzZXNzaW9uIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0VXBsb2FkU2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb25JRCwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpVVJMID0gdGhpcy5jbGllbnQuX3VwbG9hZEJhc2VVUkwgKyB1cmxQYXRoKEJBU0VfUEFUSCwgVVBMT0FEX1NFU1NJT05fU1VCUkVTT1VSQ0UsIHNlc3Npb25JRCk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlVUkwsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBsb2FkIGEgZmlsZSBpbiBjaHVua3MsIHdoaWNoIGlzIGdlbmVyYWxseSBmYXN0ZXIgYW5kIG1vcmUgcmVsaWFibGUgZm9yXG4gKiBsYXJnZSBmaWxlcy5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvdXBsb2FkX3Nlc3Npb25zJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gVGhlIElEIG9mIHRoZSBmb2xkZXIgdG8gdXBsb2FkIHRoZSBmaWxlIHRvXG4gKiBAcGFyYW0ge2ludH0gc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBmaWxlIHRoYXQgd2lsbCBiZSB1cGxvYWRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBjcmVhdGVkXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd8UmVhZGFibGV9IGZpbGUgLSBUaGUgZmlsZSB0byB1cGxvYWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgdXBsb2FkXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucGFyYWxsZWxpc21dIFRoZSBudW1iZXIgb2YgY2h1bmtzIHRvIHVwbG9hZCBjb25jdXJyZW50bHlcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5yZXRyeUludGVydmFsXSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgcmV0cnlpbmcgYSBmYWlsZWQgY2h1bmsgdXBsb2FkLCBpbiBtc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZpbGVBdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgbmV3bHktdXBsb2FkZWQgZmlsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBsb2FkZXIgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8Q2h1bmtlZFVwbG9hZGVyPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY2h1bmtlZCB1cGxvYWRlclxuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0Q2h1bmtlZFVwbG9hZGVyID0gZnVuY3Rpb24oZm9sZGVySUQsIHNpemUsIG5hbWUsIGZpbGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0aWYgKGZpbGUgaW5zdGFuY2VvZiBSZWFkYWJsZSkge1xuXHRcdC8vIE5lZWQgdG8gcGF1c2UgdGhlIHN0cmVhbSBpbW1lZGlhdGVseSB0byBwcmV2ZW50IGNlcnRhaW4gbGlicmFyaWVzLFxuXHRcdC8vIGUuZy4gcmVxdWVzdCBmcm9tIHBsYWNpbmcgdGhlIHN0cmVhbSBpbnRvIGZsb3dpbmcgbW9kZSBhbmQgY29uc3VtaW5nIGJ5dGVzXG5cdFx0ZmlsZS5wYXVzZSgpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuY3JlYXRlVXBsb2FkU2Vzc2lvbihmb2xkZXJJRCwgc2l6ZSwgbmFtZSlcblx0XHQudGhlbihzZXNzaW9uSW5mbyA9PiBuZXcgQ2h1bmtlZFVwbG9hZGVyKHRoaXMuY2xpZW50LCBzZXNzaW9uSW5mbywgZmlsZSwgc2l6ZSwgb3B0aW9ucykpXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGxvYWQgYSBuZXcgZmlsZSB2ZXJzaW9uIGluIGNodW5rcywgd2hpY2ggaXMgZ2VuZXJhbGx5IGZhc3RlciBhbmQgbW9yZVxuICogcmVsaWFibGUgZm9yIGxhcmdlIGZpbGVzLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL3VwbG9hZF9zZXNzaW9ucydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlSUQgLSBUaGUgSUQgb2YgdGhlIGZpbGUgdG8gdXBsb2FkIGEgbmV3IHZlcnNpb24gb2ZcbiAqIEBwYXJhbSB7aW50fSBzaXplIC0gVGhlIHNpemUgb2YgdGhlIGZpbGUgdGhhdCB3aWxsIGJlIHVwbG9hZGVkXG4gKiBAcGFyYW0ge0J1ZmZlcnxzdHJpbmd8UmVhZGFibGV9IGZpbGUgLSBUaGUgZmlsZSB0byB1cGxvYWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgdXBsb2FkXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucGFyYWxsZWxpc21dIFRoZSBudW1iZXIgb2YgY2h1bmtzIHRvIHVwbG9hZCBjb25jdXJyZW50bHlcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5yZXRyeUludGVydmFsXSBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgcmV0cnlpbmcgYSBmYWlsZWQgY2h1bmsgdXBsb2FkLCBpbiBtc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZpbGVBdHRyaWJ1dGVzXSBBdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgdXBkYXRlZCBmaWxlIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBsb2FkZXIgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8Q2h1bmtlZFVwbG9hZGVyPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY2h1bmtlZCB1cGxvYWRlclxuICovXG5GaWxlcy5wcm90b3R5cGUuZ2V0TmV3VmVyc2lvbkNodW5rZWRVcGxvYWRlciA9IGZ1bmN0aW9uKGZpbGVJRCwgc2l6ZSwgZmlsZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRpZiAoZmlsZSBpbnN0YW5jZW9mIFJlYWRhYmxlKSB7XG5cdFx0Ly8gTmVlZCB0byBwYXVzZSB0aGUgc3RyZWFtIGltbWVkaWF0ZWx5IHRvIHByZXZlbnQgY2VydGFpbiBsaWJyYXJpZXMsXG5cdFx0Ly8gZS5nLiByZXF1ZXN0IGZyb20gcGxhY2luZyB0aGUgc3RyZWFtIGludG8gZmxvd2luZyBtb2RlIGFuZCBjb25zdW1pbmcgYnl0ZXNcblx0XHRmaWxlLnBhdXNlKCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5jcmVhdGVOZXdWZXJzaW9uVXBsb2FkU2Vzc2lvbihmaWxlSUQsIHNpemUpXG5cdFx0LnRoZW4oc2Vzc2lvbkluZm8gPT4gbmV3IENodW5rZWRVcGxvYWRlcih0aGlzLmNsaWVudCwgc2Vzc2lvbkluZm8sIGZpbGUsIHNpemUsIG9wdGlvbnMpKVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgY29sbGFib3JhdGlvbnMgb24gYSBnaXZlbiBmaWxlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEL2NvbGxhYm9yYXRpb25zJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gQm94IElEIG9mIHRoZSBmaWxlIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucy4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmxpbWl0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjb2xsYWJvcmF0aW9ucyB0byByZXR1cm5cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5vZmZzZXRdIC0gUGFnaW5nIHBhcmFtZXRlciBmb3IgdGhlIGNvbGxhYm9yYXRpb25zIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5maWVsZHNdIC0gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIHRvIHJldHVybiBvbiB0aGUgY29sbGFib3JhdGlvbiBvYmplY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBjb2xsYWJvcmF0aW9ucyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY29sbGFib3JhdGlvbnMgb24gdGhlIGZpbGVcbiAqL1xuRmlsZXMucHJvdG90eXBlLmdldENvbGxhYm9yYXRpb25zID0gZnVuY3Rpb24oZmlsZUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZpbGVJRCwgJy9jb2xsYWJvcmF0aW9ucycpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBFbnVtIG9mIHZhbGlkIHgtcmVwLSBoaW50IHZhbHVlcyBmb3IgZ2VuZXJhdGluZyByZXByZXNlbnRhdGlvbiBpbmZvXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7RmlsZVJlcHJlc2VudGF0aW9uVHlwZX1cbiAqL1xuRmlsZXMucHJvdG90eXBlLnJlcHJlc2VudGF0aW9uID0ge1xuXHRQREY6ICdbcGRmXScsXG5cdFRIVU1CTkFJTDogJ1tqcGc/ZGltZW5zaW9ucz0zMjB4MzIwXScsXG5cdElNQUdFX01FRElVTTogJ1tqcGc/ZGltZW5zaW9ucz0xMDI0eDEwMjRdW3BuZz9kaW1lbnNpb25zPTEwMjR4MTAyNF0nLFxuXHRJTUFHRV9MQVJHRTogJ1tqcGc/ZGltZW5zaW9ucz0yMDQ4eDIwNDhdW3BuZz9kaW1lbnNpb25zPTIwNDh4MjA0OF0nLFxuXHRFWFRSQUNURURfVEVYVDogJ1tleHRyYWN0ZWRfdGV4dF0nXG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIGluZm9ybWF0aW9uIGZvciBhbGwgcmVwcmVzZW50YXRpb24gb2JqZWN0cyBnZW5lcmF0ZWQgZm9yIGEgc3BlY2lmaWMgQm94IGZpbGVcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZXMvOmZpbGVJRD9maWVsZHM9cmVwcmVzZW50YXRpb25zJ1xuICogTWV0aG9kIDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVJRCAtIEJveCBJRCBvZiB0aGUgZmlsZSBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7Y2xpZW50LmZpbGVzLnJlcHJlc2VudGF0aW9ufSByZXByZXNlbnRhdGlvblR5cGUgLSBUaGUgeC1yZXAtaGludHMgdmFsdWUgdGhlIGFwcGxpY2F0aW9uIHNob3VsZCBjcmVhdGUgYVxuICogICAgcmVwcmVzZW50YXRpb24gZm9yLiBUaGlzIHZhbHVlIGNhbiBlaXRoZXIgY29tZSBmcm9tIEZpbGVSZXByZXNlbnRhdGlvblR5cGUgZW51bSBvciBtYW51YWxseSBjcmVhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLiBDYW4gYmUgbGVmdCBlbXB0eVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5nZW5lcmF0ZVJlcHJlc2VudGF0aW9ucyA9IGZhbHNlXSAtIFNldCB0byB0cnVlIHRvIHJldHVybiByZXByZXNlbnRhdGlvbiBpbmZvIHdoZXJlIGFsbCBzdGF0ZXMgcmVzb2x2ZSB0byBzdWNjZXNzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCBhbiBhcnJheSBvZiByZXByZXNlbnRhdG9uIG9iamVjdHMgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVwcmVzZW50YXRpb24gcmVzcG9uc2Ugb2JqZWN0c1xuKi9cbkZpbGVzLnByb3RvdHlwZS5nZXRSZXByZXNlbnRhdGlvbkluZm8gPSBmdW5jdGlvbihmaWxlSUQsIHJlcHJlc2VudGF0aW9uVHlwZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0aWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2FsbGJhY2sgPSBvcHRpb25zO1xuXHRcdG9wdGlvbnMgPSB7fTtcblx0fVxuXHRpZiAoIXJlcHJlc2VudGF0aW9uVHlwZSAmJiBvcHRpb25zICYmIG9wdGlvbnMuZ2VuZXJhdGVSZXByZXNlbnRhdGlvbnMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIHZhbGlkIFgtUmVwLUhpbnRzIHN0cmluZyB0byBnZXQgcmVwcmVzZW50YXRpb25zIHdpdGggYSBzdWNjZXNzIHN0YXR1cycpO1xuXHR9XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IHtcblx0XHRcdGZpZWxkczogJ3JlcHJlc2VudGF0aW9ucydcblx0XHR9LFxuXHRcdGhlYWRlcnM6IHtcblx0XHRcdCd4LXJlcC1oaW50cyc6IHJlcHJlc2VudGF0aW9uVHlwZVxuXHRcdH1cblx0fTtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZmlsZUlEKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQuZ2V0KGFwaVBhdGgsIHBhcmFtcylcblx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcblx0XHRcdC8vIDIwMiAtIEEgQm94IGZpbGUgcmVwcmVzZW50YXRpb24gd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCBpcyBub3QgcmVhZHkgeWV0XG5cdFx0XHRjYXNlIGh0dHBTdGF0dXNDb2Rlcy5BQ0NFUFRFRDpcblx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgJ1JlcHJlc2VudGF0aW9uIG5vdCByZWFkeSBhdCB0aGlzIHRpbWUnKTtcblxuXHRcdFx0Ly8gMjAwIC0gQSBCb3hmaWxlIHJlcHJlc2VudGF0aW9uIGdlbmVyYXRlZCBzdWNjZXNzZnVsbHlcblx0XHRcdC8vIHJldHVybiB0aGUgcmVwcmVzZW50YXRpb24gb2JqZWN0XG5cdFx0XHRjYXNlIGh0dHBTdGF0dXNDb2Rlcy5PSzpcblxuXHRcdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdlbmVyYXRlUmVwcmVzZW50YXRpb25zKSB7XG5cblx0XHRcdFx0XHR2YXIgZGF0YSA9IHJlc3BvbnNlLmJvZHkucmVwcmVzZW50YXRpb25zLmVudHJpZXM7XG5cdFx0XHRcdFx0dmFyIHByb21pc2VBcnJheSA9IGRhdGEubWFwKGVudHJ5ID0+IHtcblx0XHRcdFx0XHRcdHN3aXRjaCAoZW50cnkuc3RhdHVzLnN0YXRlKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdzdWNjZXNzJzpcblx0XHRcdFx0XHRcdGNhc2UgJ3ZpZXdhYmxlJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShlbnRyeSk7XG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcG9sbFJlcHJlc2VudGF0aW9uSW5mbyh0aGlzLmNsaWVudCwgZW50cnkuaW5mby51cmwpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VBcnJheSkudGhlbihlbnRyaWVzID0+ICh7ZW50cmllc30pICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5LnJlcHJlc2VudGF0aW9ucztcblxuXHRcdFx0Ly8gVW5leHBlY3RlZCBSZXNwb25zZVxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuXG5cbn07XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZW50cyBvZiBhIHJlcHJlc2VudGF0aW9uIG9mIGEgZmlsZSwgZS5nLCB0aGUgYmluYXJ5IGNvbnRlbnQgb2YgYW4gaW1hZ2Ugb3IgcGRmLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlcy86ZmlsZUlEP2ZpZWxkcz1yZXByZXNlbnRhdGlvbnMnXG4gKiBNZXRob2QgOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIFRoZSBmaWxlIElEIHRvIGdldCB0aGUgcmVwcmVzZW50YXRpb24gb2ZcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXByZXNlbnRhdGlvblR5cGUgVGhlIFgtUmVwLUhpbnRzIHR5cGUgdG8gcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXNzZXRQYXRoXSBBc3NldCBwYXRoIGZvciByZXByZXNlbnRhdGlvbnMgd2l0aCBtdWx0aXBsZSBmaWxlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBQYXNzZWQgYSBzdHJlYW0gb3ZlciB0aGUgcmVwcmVzZW50YXRpb24gY29udGVudHMgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8UmVhZGFibGU+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgc3RyZWFtIG92ZXIgdGhlIHJlcHJlc2VudGF0aW9uIGNvbnRlbnRzXG4gKi9cbkZpbGVzLnByb3RvdHlwZS5nZXRSZXByZXNlbnRhdGlvbkNvbnRlbnQgPSBmdW5jdGlvbihmaWxlSUQsIHJlcHJlc2VudGF0aW9uVHlwZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRpZiAoIXJlcHJlc2VudGF0aW9uVHlwZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgdmFsaWQgWC1SZXAtSGludHMgc3RyaW5nJyk7XG5cdH1cblxuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGFzc2V0UGF0aDogJycgfSwgb3B0aW9ucyk7XG5cblx0cmV0dXJuIHRoaXMuZ2V0UmVwcmVzZW50YXRpb25JbmZvKGZpbGVJRCwgcmVwcmVzZW50YXRpb25UeXBlKVxuXHRcdC50aGVuKHJlcHMgPT4ge1xuXG5cdFx0XHR2YXIgcmVwSW5mbyA9IHJlcHMuZW50cmllcy5wb3AoKTtcblx0XHRcdGlmICghcmVwSW5mbykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgaW5mb3JtYXRpb24gZm9yIHJlcXVlc3RlZCByZXByZXNlbnRhdGlvbicpO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKHJlcEluZm8uc3RhdHVzLnN0YXRlKSB7XG5cblx0XHRcdGNhc2UgJ3N1Y2Nlc3MnOlxuXHRcdFx0Y2FzZSAndmlld2FibGUnOlxuXHRcdFx0XHRyZXR1cm4gcmVwSW5mby5jb250ZW50LnVybF90ZW1wbGF0ZTtcblx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZXByZXNlbnRhdGlvbiBoYWQgZXJyb3Igc3RhdHVzJyk7XG5cdFx0XHRjYXNlICdub25lJzpcblx0XHRcdGNhc2UgJ3BlbmRpbmcnOlxuXHRcdFx0XHRyZXR1cm4gcG9sbFJlcHJlc2VudGF0aW9uSW5mbyh0aGlzLmNsaWVudCwgcmVwSW5mby5pbmZvLnVybClcblx0XHRcdFx0XHQudGhlbihpbmZvID0+IHtcblx0XHRcdFx0XHRcdGlmIChpbmZvLnN0YXR1cy5zdGF0ZSA9PT0gJ2Vycm9yJykge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1JlcHJlc2VudGF0aW9uIGhhZCBlcnJvciBzdGF0dXMnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBpbmZvLmNvbnRlbnQudXJsX3RlbXBsYXRlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHJlcHJlc2VudGF0aW9uIHN0YXR1czogJHtyZXBJbmZvLnN0YXR1cy5zdGF0ZX1gKTtcblx0XHRcdH1cblx0XHR9KVxuXHRcdC50aGVuKGFzc2V0VVJMVGVtcGxhdGUgPT4ge1xuXHRcdFx0dmFyIHVybCA9IHVybFRlbXBsYXRlLnBhcnNlKGFzc2V0VVJMVGVtcGxhdGUpLmV4cGFuZCh7IGFzc2V0X3BhdGg6IG9wdGlvbnMuYXNzZXRQYXRoIH0pO1xuXHRcdFx0cmV0dXJuIHRoaXMuY2xpZW50LmdldCh1cmwsIHsgc3RyZWFtaW5nOiB0cnVlIH0pO1xuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgemlwIG9mIG11bHRpcGxlIGZpbGVzIGFuZCBmb2xkZXJzLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy96aXBfZG93bmxvYWRzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtuYW1lfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHppcCBmaWxlIHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gQXJyYXkgb2YgZmlsZXMgb3IgZm9sZGVycyB0byBiZSBwYXJ0IG9mIHRoZSBjcmVhdGVkIHppcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBQYXNzZWQgYSB6aXAgaW5mb3JtYXRpb24gb2JqZWN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgemlwIGluZm9ybWF0aW9uIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUuY3JlYXRlWmlwID0gZnVuY3Rpb24obmFtZSwgaXRlbXMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0ZG93bmxvYWRfZmlsZV9uYW1lOiBuYW1lLFxuXHRcdFx0aXRlbXNcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoWklQX0RPV05MT0FEX1BBVEgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgemlwIG9mIG11bHRpcGxlIGZpbGVzIGFuZCBmb2xkZXJzIGFuZCBkb3dubG9hZHMgaXQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3ppcF9kb3dubG9hZHMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7bmFtZX0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB6aXAgZmlsZSB0byBiZSBjcmVhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBpdGVtcyAtIEFycmF5IG9mIGZpbGVzIG9yIGZvbGRlcnMgdG8gYmUgcGFydCBvZiB0aGUgY3JlYXRlZCB6aXBcbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gLSBTdHJlYW0gdG8gcGlwZSB0aGUgcmVhZGFibGUgc3RyZWFtIG9mIHRoZSB6aXAgZmlsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCBhIHppcCBkb3dubG9hZCBzdGF0dXMgb2JqZWN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkYWJsZT59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYSB6aXAgZG93bmxvYWQgc3RhdHVzIG9iamVjdFxuICovXG5GaWxlcy5wcm90b3R5cGUuZG93bmxvYWRaaXAgPSBmdW5jdGlvbihuYW1lLCBpdGVtcywgc3RyZWFtLCBjYWxsYmFjaykge1xuXHR2YXIgZG93bmxvYWRTdHJlYW1PcHRpb25zID0ge1xuXHRcdHN0cmVhbWluZzogdHJ1ZSxcblx0XHRoZWFkZXJzOiB7fVxuXHR9O1xuXG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0ZG93bmxvYWRfZmlsZV9uYW1lOiBuYW1lLFxuXHRcdFx0aXRlbXNcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LnBvc3QoWklQX0RPV05MT0FEX1BBVEgsIHBhcmFtcylcblx0XHQudGhlbihyZXNwb25zZSA9PiB0aGlzLmNsaWVudC5nZXQocmVzcG9uc2UuYm9keS5kb3dubG9hZF91cmwsIGRvd25sb2FkU3RyZWFtT3B0aW9ucylcblx0XHRcdC50aGVuKHJlc3BvbnNlU3RyZWFtID0+IHtcblx0XHRcdFx0cmVzcG9uc2VTdHJlYW0ucGlwZShzdHJlYW0pO1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9hdm9pZC1uZXdcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbS5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgnRG9uZSBkb3dubG9hZGluZycpKTtcblx0XHRcdFx0XHRyZXNwb25zZVN0cmVhbS5vbignZXJyb3InLCBlcnJvciA9PiByZWplY3QoZXJyb3IpKTtcblx0XHRcdFx0fSkudGhlbigoKSA9PiB0aGlzLmNsaWVudC5nZXQocmVzcG9uc2UuYm9keS5zdGF0dXNfdXJsKS50aGVuKHJlc3BvbnNlU3RhdHVzID0+IHJlc3BvbnNlU3RhdHVzLmJvZHkpKTtcblx0XHRcdH0pXG5cdFx0KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQG1vZHVsZSBib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL2ZpbGVzXG4gKiBAc2VlIHtATGluayBGaWxlc31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBGaWxlcztcbiJdLCJuYW1lcyI6WyJ1cmxQYXRoIiwicmVxdWlyZSIsImVycm9ycyIsImh0dHBTdGF0dXNDb2RlcyIsImNyeXB0byIsIlByb21pc2UiLCJSZWFkYWJsZSIsInVybFRlbXBsYXRlIiwiQ2h1bmtlZFVwbG9hZGVyIiwiQkFTRV9QQVRIIiwiVkVSU0lPTlNfU1VCUkVTT1VSQ0UiLCJXQVRFUk1BUktfU1VCUkVTT1VSQ0UiLCJVUExPQURfU0VTU0lPTl9TVUJSRVNPVVJDRSIsIlpJUF9ET1dOTE9BRF9QQVRIIiwibG9ja1R5cGVzIiwiTE9DSyIsIlVOTE9DSyIsImNyZWF0ZUZpbGVNZXRhZGF0YUZvcm1EYXRhIiwicGFyZW50Rm9sZGVySUQiLCJmaWxlbmFtZSIsIm9wdGlvbnMiLCJtZXRhZGF0YSIsIm5hbWUiLCJwYXJlbnQiLCJpZCIsIk9iamVjdCIsImFzc2lnbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJjcmVhdGVGaWxlQ29udGVudEZvcm1EYXRhIiwiY29udGVudCIsInZhbHVlIiwicG9sbFJlcHJlc2VudGF0aW9uSW5mbyIsImNsaWVudCIsImluZm9VUkwiLCJnZXQiLCJ0aGVuIiwicmVzcG9uc2UiLCJzdGF0dXNDb2RlIiwiYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsImluZm8iLCJib2R5Iiwic3RhdHVzIiwic3RhdGUiLCJkZWxheSIsIkVycm9yIiwiRmlsZXMiLCJwcm90b3R5cGUiLCJmaWxlSUQiLCJjYWxsYmFjayIsInBhcmFtcyIsInFzIiwiYXBpUGF0aCIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJnZXREb3dubG9hZFVSTCIsIkZPVU5EIiwiaGVhZGVycyIsImxvY2F0aW9uIiwiQUNDRVBURUQiLCJidWlsZFJlc3BvbnNlRXJyb3IiLCJhc0NhbGxiYWNrIiwiZ2V0UmVhZFN0cmVhbSIsImRvd25sb2FkU3RyZWFtT3B0aW9ucyIsInN0cmVhbWluZyIsImJ5dGVSYW5nZSIsInJhbmdlIiwiUmFuZ2UiLCJ1cmwiLCJnZXRUaHVtYm5haWwiLCJqc29uIiwiT0siLCJmaWxlIiwiZ2V0Q29tbWVudHMiLCJ1cGRhdGUiLCJ1cGRhdGVzIiwiZXRhZyIsInB1dCIsImFkZFRvQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25JRCIsImZpZWxkcyIsImRhdGEiLCJjb2xsZWN0aW9ucyIsIm1hcCIsImMiLCJmaW5kIiwicHVzaCIsInJlbW92ZUZyb21Db2xsZWN0aW9uIiwiZmlsdGVyIiwibW92ZSIsIm5ld1BhcmVudElEIiwiY29weSIsInBvc3QiLCJkZWxldGUiLCJkZWwiLCJwcmVmbGlnaHRVcGxvYWRGaWxlIiwiZmlsZURhdGEiLCJwcmVmbGlnaHRVcGxvYWROZXdGaWxlVmVyc2lvbiIsInByb21vdGVWZXJzaW9uIiwidmVyc2lvbklEIiwidHlwZSIsInVwbG9hZEZpbGUiLCJmb3JtT3B0aW9ucyIsImhhc093blByb3BlcnR5Iiwia25vd25MZW5ndGgiLCJjb250ZW50X2xlbmd0aCIsIm11bHRpcGFydEZvcm1EYXRhIiwiYXR0cmlidXRlcyIsInVwbG9hZCIsInVwbG9hZE5ld0ZpbGVWZXJzaW9uIiwiZ2V0QWxsTWV0YWRhdGEiLCJnZXRNZXRhZGF0YSIsInNjb3BlIiwidGVtcGxhdGUiLCJhZGRNZXRhZGF0YSIsInVwZGF0ZU1ldGFkYXRhIiwicGF0Y2giLCJzZXRNZXRhZGF0YSIsImNhdGNoIiwiZXJyIiwia2V5cyIsImtleSIsIm9wIiwicGF0aCIsImRlbGV0ZU1ldGFkYXRhIiwiZGVsZXRlUGVybWFuZW50bHkiLCJnZXRUcmFzaGVkRmlsZSIsImdldFRhc2tzIiwiZ2V0RW1iZWRMaW5rIiwiZXhwaXJpbmdfZW1iZWRfbGluayIsImxvY2siLCJ1bmxvY2siLCJyZXN0b3JlRnJvbVRyYXNoIiwicGFyZW50X2lkIiwiZ2V0VmVyc2lvbnMiLCJnZXRXYXRlcm1hcmsiLCJ3YXRlcm1hcmsiLCJhcHBseVdhdGVybWFyayIsImltcHJpbnQiLCJyZW1vdmVXYXRlcm1hcmsiLCJkZWxldGVWZXJzaW9uIiwiY3JlYXRlVXBsb2FkU2Vzc2lvbiIsImZvbGRlcklEIiwic2l6ZSIsImFwaVVSTCIsIl91cGxvYWRCYXNlVVJMIiwiZm9sZGVyX2lkIiwiZmlsZV9zaXplIiwiZmlsZV9uYW1lIiwiY3JlYXRlTmV3VmVyc2lvblVwbG9hZFNlc3Npb24iLCJ1cGxvYWRQYXJ0Iiwic2Vzc2lvbklEIiwicGFydCIsIm9mZnNldCIsInRvdGFsU2l6ZSIsImhhc2giLCJjcmVhdGVIYXNoIiwiZGlnZXN0IiwiRGlnZXN0IiwibGVuZ3RoIiwicGFyc2UiLCJjb21taXRVcGxvYWRTZXNzaW9uIiwiZmlsZUhhc2giLCJ1c2VyUGFydHMiLCJwYXJ0cyIsImZldGNoUGFydHMiLCJmZXRjaGVkUGFydHMiLCJwYWdpbmdPcHRpb25zIiwibGltaXQiLCJnZXRVcGxvYWRTZXNzaW9uUGFydHMiLCJjb25jYXQiLCJlbnRyaWVzIiwidG90YWxfY291bnQiLCJyZXNvbHZlIiwicmV0cnlJbnRlcnZhbCIsImFib3J0VXBsb2FkU2Vzc2lvbiIsImdldFVwbG9hZFNlc3Npb24iLCJnZXRDaHVua2VkVXBsb2FkZXIiLCJwYXVzZSIsInNlc3Npb25JbmZvIiwiZ2V0TmV3VmVyc2lvbkNodW5rZWRVcGxvYWRlciIsImdldENvbGxhYm9yYXRpb25zIiwicmVwcmVzZW50YXRpb24iLCJQREYiLCJUSFVNQk5BSUwiLCJJTUFHRV9NRURJVU0iLCJJTUFHRV9MQVJHRSIsIkVYVFJBQ1RFRF9URVhUIiwiZ2V0UmVwcmVzZW50YXRpb25JbmZvIiwicmVwcmVzZW50YXRpb25UeXBlIiwiZ2VuZXJhdGVSZXByZXNlbnRhdGlvbnMiLCJyZXByZXNlbnRhdGlvbnMiLCJwcm9taXNlQXJyYXkiLCJlbnRyeSIsImFsbCIsImdldFJlcHJlc2VudGF0aW9uQ29udGVudCIsImFzc2V0UGF0aCIsInJlcHMiLCJyZXBJbmZvIiwicG9wIiwidXJsX3RlbXBsYXRlIiwiYXNzZXRVUkxUZW1wbGF0ZSIsImV4cGFuZCIsImFzc2V0X3BhdGgiLCJjcmVhdGVaaXAiLCJpdGVtcyIsImRvd25sb2FkX2ZpbGVfbmFtZSIsImRvd25sb2FkWmlwIiwic3RyZWFtIiwiZG93bmxvYWRfdXJsIiwicmVzcG9uc2VTdHJlYW0iLCJwaXBlIiwicmVqZWN0Iiwib24iLCJlcnJvciIsInN0YXR1c191cmwiLCJyZXNwb25zZVN0YXR1cyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/files.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/folders.js":
/*!***********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/folders.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Folders Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/folders\", FOLDER_LOCK = \"/folder_locks\", WATERMARK_SUBRESOURCE = \"/watermark\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Folder' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Folders(client) {\n    this.client = client;\n}\n/**\n * Requests a folder object with the given ID.\n *\n * API Endpoint: '/folders/:folderID'\n * Method: GET\n *\n * @param {string} folderID - Box ID of the folder being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the folder information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the folder object\n */ Folders.prototype.get = function(folderID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, folderID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Requests items contained within a given folder.\n *\n * API Endpoint: '/folders/:folderID/items'\n * Method: GET\n *\n * @param {string} folderID - Box ID of the folder being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the folder information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collection of the items in the folder\n */ Folders.prototype.getItems = function(folderID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, folderID, \"/items\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Requests collaborations on a given folder.\n *\n * API Endpoint: '/folders/:folderID/collaborations'\n * Method: GET\n *\n * @param {string} folderID - Box ID of the folder being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the folder information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collection of collaborations\n */ Folders.prototype.getCollaborations = function(folderID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, folderID, \"/collaborations\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Creates a new Folder within a parent folder\n *\n * API Endpoint: '/folders\n * Method: POST\n *\n * @param {string} parentFolderID - Box folder id of the folder to add into\n * @param {string} name - The name for the new folder\n * @param {Function} [callback] - passed the new folder info if call was successful\n * @returns {Promise<Object>} A promise resolving to the created folder object\n */ Folders.prototype.create = function(parentFolderID, name, callback) {\n    var params = {\n        body: {\n            name,\n            parent: {\n                id: parentFolderID\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(BASE_PATH, params, callback);\n};\n/**\n * Copy a folder into a new, different folder\n *\n * API Endpoint: '/folders/:folderID/copy\n * Method: POST\n *\n * @param {string} folderID - The Box ID of the folder being requested\n * @param {string} newParentID - The Box ID for the new parent folder. '0' to copy to All Files.\n * @param {Object} [options] - Optional parameters for the copy operation, can be left null in most cases\n * @param {string} [options.name] - A new name to use if there is an identically-named item in the new parent folder\n * @param {Function} [callback] - passed the new folder info if call was successful\n * @returns {Promise<Object>} A promise resolving to the new folder object\n */ Folders.prototype.copy = function(folderID, newParentID, options, callback) {\n    // @NOTE(mwiller) 2016-10-25: Shuffle arguments to maintain backward compatibility\n    //  This can be removed at the v2.0 update\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    options = options || {};\n    options.parent = {\n        id: newParentID\n    };\n    var params = {\n        body: options\n    };\n    var apiPath = urlPath(BASE_PATH, folderID, \"/copy\");\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Update some information about a given folder.\n *\n * API Endpoint: '/folders/:folderID'\n * Method: PUT\n *\n * @param {string} folderID - The Box ID of the folder being requested\n * @param {Object} updates - Folder fields to update\n * @param {string} [updates.etag] Only update the folder if the ETag matches\n * @param {Function} [callback] - Passed the updated folder information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated folder object\n */ Folders.prototype.update = function(folderID, updates, callback) {\n    var params = {\n        body: updates\n    };\n    if (updates && updates.etag) {\n        params.headers = {\n            \"If-Match\": updates.etag\n        };\n        delete updates.etag;\n    }\n    var apiPath = urlPath(BASE_PATH, folderID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Add a folder to a given collection\n *\n * API Endpoint: '/folders/:folderID'\n * Method: PUT\n *\n * @param {string} folderID - The folder to add to the collection\n * @param {string} collectionID - The collection to add the folder to\n * @param {Function} [callback] - Passed the updated folder if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated folder object\n */ Folders.prototype.addToCollection = function(folderID, collectionID, callback) {\n    return this.get(folderID, {\n        fields: \"collections\"\n    }).then((data)=>{\n        var collections = data.collections || [];\n        // Convert to correct format\n        collections = collections.map((c)=>({\n                id: c.id\n            }));\n        if (!collections.find((c)=>c.id === collectionID)) {\n            collections.push({\n                id: collectionID\n            });\n        }\n        return this.update(folderID, {\n            collections\n        });\n    }).asCallback(callback);\n};\n/**\n * Remove a folder from a given collection\n *\n * API Endpoint: '/folders/:folderID'\n * Method: PUT\n *\n * @param {string} folderID - The folder to remove from the collection\n * @param {string} collectionID - The collection to remove the folder from\n * @param {Function} [callback] - Passed the updated folder if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated folder object\n */ Folders.prototype.removeFromCollection = function(folderID, collectionID, callback) {\n    return this.get(folderID, {\n        fields: \"collections\"\n    }).then((data)=>{\n        var collections = data.collections || [];\n        // Convert to correct object format and remove the specified collection\n        collections = collections.map((c)=>({\n                id: c.id\n            })).filter((c)=>c.id !== collectionID);\n        return this.update(folderID, {\n            collections\n        });\n    }).asCallback(callback);\n};\n/**\n * Move a folder into a new parent folder.\n *\n * API Endpoint: '/folders/:folderID'\n * Method: PUT\n *\n * @param {string} folderID - The Box ID of the folder being requested\n * @param {string} newParentID - The Box ID for the new parent folder. '0' to move to All Files.\n * @param {Function} [callback] - Passed the updated folder information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated folder object\n */ Folders.prototype.move = function(folderID, newParentID, callback) {\n    var params = {\n        body: {\n            parent: {\n                id: newParentID\n            }\n        }\n    };\n    var apiPath = urlPath(BASE_PATH, folderID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Delete a given folder.\n *\n * API Endpoint: '/folders/:folderID'\n * Method: DELETE\n *\n * @param {string} folderID - Box ID of the folder being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {string} [options.etag] Only delete the folder if the ETag matches\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ Folders.prototype.delete = function(folderID, options, callback) {\n    var params = {\n        qs: options\n    };\n    if (options && options.etag) {\n        params.headers = {\n            \"If-Match\": options.etag\n        };\n        delete options.etag;\n    }\n    var apiPath = urlPath(BASE_PATH, folderID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Retrieves all metadata associated with a folder.\n *\n * API Endpoint: '/folders/:folderID/metadata'\n * Method: GET\n *\n * @param {string} folderID - the ID of the folder to get metadata for\n * @param {Function} [callback] - called with an array of metadata when successful\n * @returns {Promise<Object>} A promise resolving to the collection of metadata on the folder\n */ Folders.prototype.getAllMetadata = function(folderID, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, \"metadata\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n};\n/**\n * Retrieve a single metadata template instance for a folder.\n *\n * API Endpoint: '/folders/:folderID/metadata/:scope/:template'\n * Method: GET\n *\n * @param {string} folderID - The ID of the folder to retrive the metadata of\n * @param {string} scope - The scope of the metadata template, e.g. \"global\"\n * @param {string} template - The metadata template to retrieve\n * @param {Function} [callback] - Passed the metadata template if successful\n * @returns {Promise<Object>} A promise resolving to the metadata template\n */ Folders.prototype.getMetadata = function(folderID, scope, template, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, \"metadata\", scope, template);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n};\n/**\n * Adds metadata to a folder.  Metadata must either match a template schema or\n * be placed into the unstructured \"properties\" template in global scope.\n *\n * API Endpoint: '/folders/:folderID/metadata/:scope/:template'\n * Method: POST\n *\n * @param {string} folderID - The ID of the folder to add metadata to\n * @param {string} scope - The scope of the metadata template, e.g. \"enterprise\"\n * @param {string} template - The metadata template schema to add\n * @param {Object} data - Key/value pairs tp add as metadata\n * @param {Function} [callback] - Called with error if unsuccessful\n * @returns {Promise<Object>} A promise resolving to the created metadata\n */ Folders.prototype.addMetadata = function(folderID, scope, template, data, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, \"metadata\", scope, template), params = {\n        body: data\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Updates a metadata template instance with JSON Patch-formatted data.\n *\n * API Endpoint: '/folders/:folderID/metadata/:scope/:template'\n * Method: PUT\n *\n * @param {string} folderID - The folder to update metadata for\n * @param {string} scope - The scope of the template to update\n * @param {string} template - The template to update\n * @param {Object} patch - The patch data\n * @param {Function} [callback] - Called with updated metadata if successful\n * @returns {Promise<Object>} A promise resolving to the updated metadata\n */ Folders.prototype.updateMetadata = function(folderID, scope, template, patch, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, \"metadata\", scope, template), params = {\n        body: patch,\n        headers: {\n            \"Content-Type\": \"application/json-patch+json\"\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Sets metadata on a folder, overwriting any metadata that exists for the provided keys.\n *\n * @param {string} folderID - The folder to set metadata on\n * @param {string} scope - The scope of the metadata template\n * @param {string} template - The key of the metadata template\n * @param {Object} metadata - The metadata to set\n * @param {Function} [callback] - Called with updated metadata if successful\n * @returns {Promise<Object>} A promise resolving to the updated metadata\n */ Folders.prototype.setMetadata = function(folderID, scope, template, metadata, callback) {\n    return this.addMetadata(folderID, scope, template, metadata).catch((err)=>{\n        if (err.statusCode !== 409) {\n            throw err;\n        }\n        // Metadata already exists on the file; update instead\n        var updates = Object.keys(metadata).map((key)=>({\n                op: \"add\",\n                path: `/${key}`,\n                value: metadata[key]\n            }));\n        return this.updateMetadata(folderID, scope, template, updates);\n    }).asCallback(callback);\n};\n/**\n * Deletes a metadata template from a folder.\n *\n * API Endpoint: '/folders/:folderID/metadata/:scope/:template'\n * Method: DELETE\n *\n * @param {string} folderID - The ID of the folder to remove metadata from\n * @param {string} scope - The scope of the metadata template\n * @param {string} template - The template to remove from the folder\n * @param {Function} [callback] - Called with nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Folders.prototype.deleteMetadata = function(folderID, scope, template, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, \"metadata\", scope, template);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Retrieves a folder that has been moved to the trash\n *\n * API Endpoint: '/folders/:folderID/trash'\n * Method: GET\n *\n * @param  {string} folderID  - The ID of the folder being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param  {Funnction} [callback]  - Passed the folder information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the trashed folder object\n */ Folders.prototype.getTrashedFolder = function(folderID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, folderID, \"trash\");\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Restores an item that has been moved to the trash. Default behavior is to restore the item\n * to the folder it was in before it was moved to the trash. If that parent folder no longer\n * exists or if there is now an item with the same name in that parent folder, the new parent\n * older and/or new name will need to be included in the request.\n *\n * API Endpoint: '/folders/:folderID'\n * Method: POST\n *\n * @param {string} folderID - The ID of the folder to restore\n * @param {Object} [options] - Optional parameters, can be left null\n * @param {?string} [options.name] - The new name for this item\n * @param {string} [options.parent_id] - The new parent folder for this item\n * @param {Function} [callback] - Called with folder information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the restored folder object\n */ Folders.prototype.restoreFromTrash = function(folderID, options, callback) {\n    // Set up the parent_id parameter\n    if (options && options.parent_id) {\n        options.parent = {\n            id: options.parent_id\n        };\n        delete options.parent_id;\n    }\n    var apiPath = urlPath(BASE_PATH, folderID), params = {\n        body: options || {}\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Permanently deletes an folder that is in the trash. The item will no longer exist in Box. This action cannot be undone\n *\n * API Endpoint: '/folders/:folderID/trash'\n * Method: DELETE\n *\n * @param  {string} folderID Box ID of the folder being requested\n * @param {Object} [options] Optional parameters\n * @param {string} [options.etag] Only delete the folder if the ETag matches\n * @param  {Function} [callback] Called with nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Folders.prototype.deletePermanently = function(folderID, options, callback) {\n    // Switch around arguments if necessary for backwards compatibility\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var params = {};\n    if (options && options.etag) {\n        params.headers = {\n            \"If-Match\": options.etag\n        };\n    }\n    var apiPath = urlPath(BASE_PATH, folderID, \"/trash\");\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Used to retrieve the watermark for a corresponding Box folder.\n *\n * API Endpoint: '/folders/:folderID/watermark'\n * Method: GET\n *\n * @param {string} folderID - The Box ID of the folder to get watermark for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the watermark information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the watermark info\n */ Folders.prototype.getWatermark = function(folderID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, WATERMARK_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.get(apiPath, params).then((response)=>{\n        if (response.statusCode !== 200) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        return response.body.watermark;\n    }).asCallback(callback);\n};\n/**\n * Used to apply or update the watermark for a corresponding Box folder.\n *\n * API Endpoint: '/folders/:folderID/watermark'\n * Method: PUT\n *\n * @param {string} folderID - The Box ID of the folder to update watermark for\n * @param {Object} [options] - Optional parameters, can be left null\n * @param {Function} [callback] - Passed the watermark information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the watermark info\n */ Folders.prototype.applyWatermark = function(folderID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, WATERMARK_SUBRESOURCE), params = {\n        body: {\n            watermark: {\n                imprint: \"default\" // Currently the API only supports default imprint\n            }\n        }\n    };\n    Object.assign(params.body.watermark, options);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Used to remove the watermark for a corresponding Box folder.\n *\n * API Endpoint: '/folders/:folderID/watermark'\n * Method: DELETE\n *\n * @param {string} folderID - The Box ID of the folder to remove watermark from\n * @param {Function} [callback] - Empty response body passed if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Folders.prototype.removeWatermark = function(folderID, callback) {\n    var apiPath = urlPath(BASE_PATH, folderID, WATERMARK_SUBRESOURCE);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Used to lock a Box folder.\n *\n * API Endpoint: '/folder_locks'\n * Method: POST\n *\n * @param {string} folderID - The Box ID of the folder to lock\n * @param {Function} [callback] - Passed the folder lock object if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to a folder lock object\n */ Folders.prototype.lock = function(folderID, callback) {\n    var params = {\n        body: {\n            folder: {\n                type: \"folder\",\n                id: folderID\n            },\n            locked_operations: {\n                move: true,\n                delete: true\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(FOLDER_LOCK, params, callback);\n};\n/**\n * Used to get all locks on a folder.\n *\n * API Endpoint: '/folder_locks'\n * Method: GET\n *\n * @param {string} folderID - The Box ID of the folder to lock\n * @param {Function} [callback] - Passed a collection of folder lock objects if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to a collection of folder lock objects\n */ Folders.prototype.getLocks = function(folderID, callback) {\n    var params = {\n        qs: {\n            folder_id: folderID\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(FOLDER_LOCK, params, callback);\n};\n/**\n * Used to delete a lock on a folder.\n *\n * API Endpoint: '/folder_locks/:folderLockID'\n * Method: DELETE\n *\n * @param {string} folderLockID - The Box ID of the folder lock\n * @param {Function} [callback] - Empty response body passed if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Folders.prototype.deleteLock = function(folderLockID, callback) {\n    var apiPath = urlPath(FOLDER_LOCK, folderLockID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * @module box-node-sdk/lib/managers/folders\n * @see {@Link Folders}\n */ module.exports = Folders;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9mb2xkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxpRkFBaUY7QUFDakYsZUFBZTtBQUNmLGlGQUFpRjtBQUNqRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQyxtRkFDckJDLFNBQVNELG1CQUFPQSxDQUFDO0FBR2xCLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBQ2pGLElBQUlFLFlBQVksWUFDZkMsY0FBYyxpQkFDZEMsd0JBQXdCO0FBR3pCLGlGQUFpRjtBQUNqRixTQUFTO0FBQ1QsaUZBQWlGO0FBRWpGOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFFBQVFDLE1BQU07SUFDdEIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0FBQ2Y7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0RELFFBQVFFLFNBQVMsQ0FBQ0MsR0FBRyxHQUFHLFNBQVNDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBQzNELElBQUlDLFNBQVM7UUFDWkMsSUFBSUg7SUFDTDtJQUNBLElBQUlJLFVBQVVmLFFBQVFHLFdBQVdPO0lBQ2pDLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUNTLHNCQUFzQixDQUFDLElBQUksQ0FBQ1QsTUFBTSxDQUFDRSxHQUFHLEVBQUVNLFNBQVNGLFFBQVFEO0FBQzdFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNETixRQUFRRSxTQUFTLENBQUNTLFFBQVEsR0FBRyxTQUFTUCxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUNoRSxJQUFJQyxTQUFTO1FBQ1pDLElBQUlIO0lBQ0w7SUFDQSxJQUFJSSxVQUFVZixRQUFRRyxXQUFXTyxVQUFVO0lBQzNDLE9BQU8sSUFBSSxDQUFDSCxNQUFNLENBQUNTLHNCQUFzQixDQUFDLElBQUksQ0FBQ1QsTUFBTSxDQUFDRSxHQUFHLEVBQUVNLFNBQVNGLFFBQVFEO0FBQzdFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNE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LElBQUlHLFVBQVVmLFFBQVFJLGFBQWFtRjtJQUVuQyxPQUFPLElBQUksQ0FBQ2hGLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUN5QyxHQUFHLEVBQUVqQyxTQUFTLE1BQU1IO0FBQzNFO0FBQ0E7OztDQUdDLEdBQ0Q0RSxPQUFPQyxPQUFPLEdBQUduRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvZm9sZGVycy5qcz81YjlhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBNYW5hZ2VyIGZvciB0aGUgQm94IEZvbGRlcnMgUmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciB1cmxQYXRoID0gcmVxdWlyZSgnLi4vdXRpbC91cmwtcGF0aCcpLFxuXHRlcnJvcnMgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9ycycpO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy9mb2xkZXJzJyxcblx0Rk9MREVSX0xPQ0sgPSAnL2ZvbGRlcl9sb2NrcycsXG5cdFdBVEVSTUFSS19TVUJSRVNPVVJDRSA9ICcvd2F0ZXJtYXJrJztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsICdGb2xkZXInIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgLSBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBGb2xkZXJzKGNsaWVudCkge1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuLyoqXG4gKiBSZXF1ZXN0cyBhIGZvbGRlciBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBCb3ggSUQgb2YgdGhlIGZvbGRlciBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBmb2xkZXIgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgZm9sZGVyIG9iamVjdFxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmb2xkZXJJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIGl0ZW1zIGNvbnRhaW5lZCB3aXRoaW4gYSBnaXZlbiBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEL2l0ZW1zJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBCb3ggSUQgb2YgdGhlIGZvbGRlciBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBmb2xkZXIgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiB0aGUgaXRlbXMgaW4gdGhlIGZvbGRlclxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uKGZvbGRlcklELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZvbGRlcklELCAnL2l0ZW1zJyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIGNvbGxhYm9yYXRpb25zIG9uIGEgZ2l2ZW4gZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC9jb2xsYWJvcmF0aW9ucydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gQm94IElEIG9mIHRoZSBmb2xkZXIgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgZm9sZGVyIGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY29sbGFib3JhdGlvbnNcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUuZ2V0Q29sbGFib3JhdGlvbnMgPSBmdW5jdGlvbihmb2xkZXJJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczogb3B0aW9uc1xuXHR9O1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCwgJy9jb2xsYWJvcmF0aW9ucycpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEZvbGRlciB3aXRoaW4gYSBwYXJlbnQgZm9sZGVyXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnNcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRGb2xkZXJJRCAtIEJveCBmb2xkZXIgaWQgb2YgdGhlIGZvbGRlciB0byBhZGQgaW50b1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBmb3IgdGhlIG5ldyBmb2xkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIG5ldyBmb2xkZXIgaW5mbyBpZiBjYWxsIHdhcyBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIGZvbGRlciBvYmplY3RcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24ocGFyZW50Rm9sZGVySUQsIG5hbWUsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0bmFtZSxcblx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRpZDogcGFyZW50Rm9sZGVySURcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKEJBU0VfUEFUSCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENvcHkgYSBmb2xkZXIgaW50byBhIG5ldywgZGlmZmVyZW50IGZvbGRlclxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC9jb3B5XG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgQm94IElEIG9mIHRoZSBmb2xkZXIgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFyZW50SUQgLSBUaGUgQm94IElEIGZvciB0aGUgbmV3IHBhcmVudCBmb2xkZXIuICcwJyB0byBjb3B5IHRvIEFsbCBGaWxlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgY29weSBvcGVyYXRpb24sIGNhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWVdIC0gQSBuZXcgbmFtZSB0byB1c2UgaWYgdGhlcmUgaXMgYW4gaWRlbnRpY2FsbHktbmFtZWQgaXRlbSBpbiB0aGUgbmV3IHBhcmVudCBmb2xkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIG5ldyBmb2xkZXIgaW5mbyBpZiBjYWxsIHdhcyBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXcgZm9sZGVyIG9iamVjdFxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oZm9sZGVySUQsIG5ld1BhcmVudElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdC8vIEBOT1RFKG13aWxsZXIpIDIwMTYtMTAtMjU6IFNodWZmbGUgYXJndW1lbnRzIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblx0Ly8gIFRoaXMgY2FuIGJlIHJlbW92ZWQgYXQgdGhlIHYyLjAgdXBkYXRlXG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gb3B0aW9ucztcblx0XHRvcHRpb25zID0ge307XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLnBhcmVudCA9IHtcblx0XHRpZDogbmV3UGFyZW50SURcblx0fTtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IG9wdGlvbnNcblx0fTtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQsICcvY29weScpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHNvbWUgaW5mb3JtYXRpb24gYWJvdXQgYSBnaXZlbiBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgQm94IElEIG9mIHRoZSBmb2xkZXIgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcyAtIEZvbGRlciBmaWVsZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMuZXRhZ10gT25seSB1cGRhdGUgdGhlIGZvbGRlciBpZiB0aGUgRVRhZyBtYXRjaGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIGZvbGRlciBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIGZvbGRlciBvYmplY3RcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZm9sZGVySUQsIHVwZGF0ZXMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keTogdXBkYXRlc1xuXHR9O1xuXG5cdGlmICh1cGRhdGVzICYmIHVwZGF0ZXMuZXRhZykge1xuXHRcdHBhcmFtcy5oZWFkZXJzID0ge1xuXHRcdFx0J0lmLU1hdGNoJzogdXBkYXRlcy5ldGFnXG5cdFx0fTtcblx0XHRkZWxldGUgdXBkYXRlcy5ldGFnO1xuXHR9XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBZGQgYSBmb2xkZXIgdG8gYSBnaXZlbiBjb2xsZWN0aW9uXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgZm9sZGVyIHRvIGFkZCB0byB0aGUgY29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNvbGxlY3Rpb25JRCAtIFRoZSBjb2xsZWN0aW9uIHRvIGFkZCB0aGUgZm9sZGVyIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIGZvbGRlciBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgZm9sZGVyIG9iamVjdFxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5hZGRUb0NvbGxlY3Rpb24gPSBmdW5jdGlvbihmb2xkZXJJRCwgY29sbGVjdGlvbklELCBjYWxsYmFjaykge1xuXG5cdHJldHVybiB0aGlzLmdldChmb2xkZXJJRCwge2ZpZWxkczogJ2NvbGxlY3Rpb25zJ30pXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG5cblx0XHRcdHZhciBjb2xsZWN0aW9ucyA9IGRhdGEuY29sbGVjdGlvbnMgfHwgW107XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gY29ycmVjdCBmb3JtYXRcblx0XHRcdGNvbGxlY3Rpb25zID0gY29sbGVjdGlvbnMubWFwKGMgPT4gKHtpZDogYy5pZH0pKTtcblxuXHRcdFx0aWYgKCFjb2xsZWN0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gY29sbGVjdGlvbklEKSkge1xuXG5cdFx0XHRcdGNvbGxlY3Rpb25zLnB1c2goe2lkOiBjb2xsZWN0aW9uSUR9KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMudXBkYXRlKGZvbGRlcklELCB7Y29sbGVjdGlvbnN9KTtcblx0XHR9KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgZm9sZGVyIGZyb20gYSBnaXZlbiBjb2xsZWN0aW9uXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgZm9sZGVyIHRvIHJlbW92ZSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklEIC0gVGhlIGNvbGxlY3Rpb24gdG8gcmVtb3ZlIHRoZSBmb2xkZXIgZnJvbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBkYXRlZCBmb2xkZXIgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIGZvbGRlciBvYmplY3RcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUucmVtb3ZlRnJvbUNvbGxlY3Rpb24gPSBmdW5jdGlvbihmb2xkZXJJRCwgY29sbGVjdGlvbklELCBjYWxsYmFjaykge1xuXG5cdHJldHVybiB0aGlzLmdldChmb2xkZXJJRCwge2ZpZWxkczogJ2NvbGxlY3Rpb25zJ30pXG5cdFx0LnRoZW4oZGF0YSA9PiB7XG5cblx0XHRcdHZhciBjb2xsZWN0aW9ucyA9IGRhdGEuY29sbGVjdGlvbnMgfHwgW107XG5cdFx0XHQvLyBDb252ZXJ0IHRvIGNvcnJlY3Qgb2JqZWN0IGZvcm1hdCBhbmQgcmVtb3ZlIHRoZSBzcGVjaWZpZWQgY29sbGVjdGlvblxuXHRcdFx0Y29sbGVjdGlvbnMgPSBjb2xsZWN0aW9ucy5tYXAoYyA9PiAoe2lkOiBjLmlkfSkpLmZpbHRlcihjID0+IGMuaWQgIT09IGNvbGxlY3Rpb25JRCk7XG5cblx0XHRcdHJldHVybiB0aGlzLnVwZGF0ZShmb2xkZXJJRCwge2NvbGxlY3Rpb25zfSk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIE1vdmUgYSBmb2xkZXIgaW50byBhIG5ldyBwYXJlbnQgZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gVGhlIEJveCBJRCBvZiB0aGUgZm9sZGVyIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhcmVudElEIC0gVGhlIEJveCBJRCBmb3IgdGhlIG5ldyBwYXJlbnQgZm9sZGVyLiAnMCcgdG8gbW92ZSB0byBBbGwgRmlsZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIGZvbGRlciBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIGZvbGRlciBvYmplY3RcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGZvbGRlcklELCBuZXdQYXJlbnRJRCwgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHRwYXJlbnQ6IHtcblx0XHRcdFx0aWQ6IG5ld1BhcmVudElEXG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIGdpdmVuIGZvbGRlci5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZm9sZGVycy86Zm9sZGVySUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXJJRCAtIEJveCBJRCBvZiB0aGUgZm9sZGVyIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldGFnXSBPbmx5IGRlbGV0ZSB0aGUgZm9sZGVyIGlmIHRoZSBFVGFnIG1hdGNoZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBFbXB0eSByZXNwb25zZSBib2R5IHBhc3NlZCBpZiBzdWNjZXNzZnVsLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihmb2xkZXJJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cblx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ldGFnKSB7XG5cdFx0cGFyYW1zLmhlYWRlcnMgPSB7XG5cdFx0XHQnSWYtTWF0Y2gnOiBvcHRpb25zLmV0YWdcblx0XHR9O1xuXHRcdGRlbGV0ZSBvcHRpb25zLmV0YWc7XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbGwgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC9tZXRhZGF0YSdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gdGhlIElEIG9mIHRoZSBmb2xkZXIgdG8gZ2V0IG1ldGFkYXRhIGZvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIGNhbGxlZCB3aXRoIGFuIGFycmF5IG9mIG1ldGFkYXRhIHdoZW4gc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBvbiB0aGUgZm9sZGVyXG4gKi9cbkZvbGRlcnMucHJvdG90eXBlLmdldEFsbE1ldGFkYXRhID0gZnVuY3Rpb24oZm9sZGVySUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQsICdtZXRhZGF0YScpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSBzaW5nbGUgbWV0YWRhdGEgdGVtcGxhdGUgaW5zdGFuY2UgZm9yIGEgZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC9tZXRhZGF0YS86c2NvcGUvOnRlbXBsYXRlJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgSUQgb2YgdGhlIGZvbGRlciB0byByZXRyaXZlIHRoZSBtZXRhZGF0YSBvZlxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSBtZXRhZGF0YSB0ZW1wbGF0ZSwgZS5nLiBcImdsb2JhbFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgLSBUaGUgbWV0YWRhdGEgdGVtcGxhdGUgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIG1ldGFkYXRhIHRlbXBsYXRlIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1ldGFkYXRhIHRlbXBsYXRlXG4gKi9cbkZvbGRlcnMucHJvdG90eXBlLmdldE1ldGFkYXRhID0gZnVuY3Rpb24oZm9sZGVySUQsIHNjb3BlLCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCwgJ21ldGFkYXRhJywgc2NvcGUsIHRlbXBsYXRlKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFkZHMgbWV0YWRhdGEgdG8gYSBmb2xkZXIuICBNZXRhZGF0YSBtdXN0IGVpdGhlciBtYXRjaCBhIHRlbXBsYXRlIHNjaGVtYSBvclxuICogYmUgcGxhY2VkIGludG8gdGhlIHVuc3RydWN0dXJlZCBcInByb3BlcnRpZXNcIiB0ZW1wbGF0ZSBpbiBnbG9iYWwgc2NvcGUuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEL21ldGFkYXRhLzpzY29wZS86dGVtcGxhdGUnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgSUQgb2YgdGhlIGZvbGRlciB0byBhZGQgbWV0YWRhdGEgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIFRoZSBzY29wZSBvZiB0aGUgbWV0YWRhdGEgdGVtcGxhdGUsIGUuZy4gXCJlbnRlcnByaXNlXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSAtIFRoZSBtZXRhZGF0YSB0ZW1wbGF0ZSBzY2hlbWEgdG8gYWRkXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEtleS92YWx1ZSBwYWlycyB0cCBhZGQgYXMgbWV0YWRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCBlcnJvciBpZiB1bnN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNyZWF0ZWQgbWV0YWRhdGFcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUuYWRkTWV0YWRhdGEgPSBmdW5jdGlvbihmb2xkZXJJRCwgc2NvcGUsIHRlbXBsYXRlLCBkYXRhLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZvbGRlcklELCAnbWV0YWRhdGEnLCBzY29wZSwgdGVtcGxhdGUpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IGRhdGFcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIGEgbWV0YWRhdGEgdGVtcGxhdGUgaW5zdGFuY2Ugd2l0aCBKU09OIFBhdGNoLWZvcm1hdHRlZCBkYXRhLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC9tZXRhZGF0YS86c2NvcGUvOnRlbXBsYXRlJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgZm9sZGVyIHRvIHVwZGF0ZSBtZXRhZGF0YSBmb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIFRoZSBzY29wZSBvZiB0aGUgdGVtcGxhdGUgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgLSBUaGUgdGVtcGxhdGUgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2ggLSBUaGUgcGF0Y2ggZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIHVwZGF0ZWQgbWV0YWRhdGEgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCBtZXRhZGF0YVxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS51cGRhdGVNZXRhZGF0YSA9IGZ1bmN0aW9uKGZvbGRlcklELCBzY29wZSwgdGVtcGxhdGUsIHBhdGNoLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZvbGRlcklELCAnbWV0YWRhdGEnLCBzY29wZSwgdGVtcGxhdGUpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHBhdGNoLFxuXHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHQnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24tcGF0Y2granNvbidcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgbWV0YWRhdGEgb24gYSBmb2xkZXIsIG92ZXJ3cml0aW5nIGFueSBtZXRhZGF0YSB0aGF0IGV4aXN0cyBmb3IgdGhlIHByb3ZpZGVkIGtleXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gVGhlIGZvbGRlciB0byBzZXQgbWV0YWRhdGEgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIFRoZSBzY29wZSBvZiB0aGUgbWV0YWRhdGEgdGVtcGxhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSAtIFRoZSBrZXkgb2YgdGhlIG1ldGFkYXRhIHRlbXBsYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWV0YWRhdGEgLSBUaGUgbWV0YWRhdGEgdG8gc2V0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQ2FsbGVkIHdpdGggdXBkYXRlZCBtZXRhZGF0YSBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIG1ldGFkYXRhXG4gKi9cbkZvbGRlcnMucHJvdG90eXBlLnNldE1ldGFkYXRhID0gZnVuY3Rpb24oZm9sZGVySUQsIHNjb3BlLCB0ZW1wbGF0ZSwgbWV0YWRhdGEsIGNhbGxiYWNrKSB7XG5cblx0cmV0dXJuIHRoaXMuYWRkTWV0YWRhdGEoZm9sZGVySUQsIHNjb3BlLCB0ZW1wbGF0ZSwgbWV0YWRhdGEpXG5cdFx0LmNhdGNoKGVyciA9PiB7XG5cblx0XHRcdGlmIChlcnIuc3RhdHVzQ29kZSAhPT0gNDA5KSB7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWV0YWRhdGEgYWxyZWFkeSBleGlzdHMgb24gdGhlIGZpbGU7IHVwZGF0ZSBpbnN0ZWFkXG5cdFx0XHR2YXIgdXBkYXRlcyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhKS5tYXAoa2V5ID0+ICh7XG5cdFx0XHRcdG9wOiAnYWRkJyxcblx0XHRcdFx0cGF0aDogYC8ke2tleX1gLFxuXHRcdFx0XHR2YWx1ZTogbWV0YWRhdGFba2V5XSxcblx0XHRcdH0pKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMudXBkYXRlTWV0YWRhdGEoZm9sZGVySUQsIHNjb3BlLCB0ZW1wbGF0ZSwgdXBkYXRlcyk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSBtZXRhZGF0YSB0ZW1wbGF0ZSBmcm9tIGEgZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC9tZXRhZGF0YS86c2NvcGUvOnRlbXBsYXRlJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgSUQgb2YgdGhlIGZvbGRlciB0byByZW1vdmUgbWV0YWRhdGEgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSBtZXRhZGF0YSB0ZW1wbGF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIC0gVGhlIHRlbXBsYXRlIHRvIHJlbW92ZSBmcm9tIHRoZSBmb2xkZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCBub3RoaW5nIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5kZWxldGVNZXRhZGF0YSA9IGZ1bmN0aW9uKGZvbGRlcklELCBzY29wZSwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQsICdtZXRhZGF0YScsIHNjb3BlLCB0ZW1wbGF0ZSk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBmb2xkZXIgdGhhdCBoYXMgYmVlbiBtb3ZlZCB0byB0aGUgdHJhc2hcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZm9sZGVycy86Zm9sZGVySUQvdHJhc2gnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZm9sZGVySUQgIC0gVGhlIElEIG9mIHRoZSBmb2xkZXIgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtICB7RnVubmN0aW9ufSBbY2FsbGJhY2tdICAtIFBhc3NlZCB0aGUgZm9sZGVyIGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRyYXNoZWQgZm9sZGVyIG9iamVjdFxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5nZXRUcmFzaGVkRm9sZGVyID0gZnVuY3Rpb24oZm9sZGVySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnNcblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCwgJ3RyYXNoJyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJlc3RvcmVzIGFuIGl0ZW0gdGhhdCBoYXMgYmVlbiBtb3ZlZCB0byB0aGUgdHJhc2guIERlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmVzdG9yZSB0aGUgaXRlbVxuICogdG8gdGhlIGZvbGRlciBpdCB3YXMgaW4gYmVmb3JlIGl0IHdhcyBtb3ZlZCB0byB0aGUgdHJhc2guIElmIHRoYXQgcGFyZW50IGZvbGRlciBubyBsb25nZXJcbiAqIGV4aXN0cyBvciBpZiB0aGVyZSBpcyBub3cgYW4gaXRlbSB3aXRoIHRoZSBzYW1lIG5hbWUgaW4gdGhhdCBwYXJlbnQgZm9sZGVyLCB0aGUgbmV3IHBhcmVudFxuICogb2xkZXIgYW5kL29yIG5ldyBuYW1lIHdpbGwgbmVlZCB0byBiZSBpbmNsdWRlZCBpbiB0aGUgcmVxdWVzdC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZm9sZGVycy86Zm9sZGVySUQnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgLSBUaGUgSUQgb2YgdGhlIGZvbGRlciB0byByZXN0b3JlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbFxuICogQHBhcmFtIHs/c3RyaW5nfSBbb3B0aW9ucy5uYW1lXSAtIFRoZSBuZXcgbmFtZSBmb3IgdGhpcyBpdGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGFyZW50X2lkXSAtIFRoZSBuZXcgcGFyZW50IGZvbGRlciBmb3IgdGhpcyBpdGVtXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQ2FsbGVkIHdpdGggZm9sZGVyIGluZm9ybWF0aW9uIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVzdG9yZWQgZm9sZGVyIG9iamVjdFxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5yZXN0b3JlRnJvbVRyYXNoID0gZnVuY3Rpb24oZm9sZGVySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0Ly8gU2V0IHVwIHRoZSBwYXJlbnRfaWQgcGFyYW1ldGVyXG5cdGlmIChvcHRpb25zICYmIG9wdGlvbnMucGFyZW50X2lkKSB7XG5cblx0XHRvcHRpb25zLnBhcmVudCA9IHtcblx0XHRcdGlkOiBvcHRpb25zLnBhcmVudF9pZFxuXHRcdH07XG5cblx0XHRkZWxldGUgb3B0aW9ucy5wYXJlbnRfaWQ7XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBmb2xkZXJJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogb3B0aW9ucyB8fCB7fVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFBlcm1hbmVudGx5IGRlbGV0ZXMgYW4gZm9sZGVyIHRoYXQgaXMgaW4gdGhlIHRyYXNoLiBUaGUgaXRlbSB3aWxsIG5vIGxvbmdlciBleGlzdCBpbiBCb3guIFRoaXMgYWN0aW9uIGNhbm5vdCBiZSB1bmRvbmVcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZm9sZGVycy86Zm9sZGVySUQvdHJhc2gnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZm9sZGVySUQgQm94IElEIG9mIHRoZSBmb2xkZXIgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5ldGFnXSBPbmx5IGRlbGV0ZSB0aGUgZm9sZGVyIGlmIHRoZSBFVGFnIG1hdGNoZXNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxlZCB3aXRoIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkZvbGRlcnMucHJvdG90eXBlLmRlbGV0ZVBlcm1hbmVudGx5ID0gZnVuY3Rpb24oZm9sZGVySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0Ly8gU3dpdGNoIGFyb3VuZCBhcmd1bWVudHMgaWYgbmVjZXNzYXJ5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0dmFyIHBhcmFtcyA9IHt9O1xuXG5cdGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXRhZykge1xuXHRcdHBhcmFtcy5oZWFkZXJzID0ge1xuXHRcdFx0J0lmLU1hdGNoJzogb3B0aW9ucy5ldGFnXG5cdFx0fTtcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGZvbGRlcklELCAnL3RyYXNoJyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gcmV0cmlldmUgdGhlIHdhdGVybWFyayBmb3IgYSBjb3JyZXNwb25kaW5nIEJveCBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEL3dhdGVybWFyaydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gVGhlIEJveCBJRCBvZiB0aGUgZm9sZGVyIHRvIGdldCB3YXRlcm1hcmsgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgd2F0ZXJtYXJrIGluZm9ybWF0aW9uIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgd2F0ZXJtYXJrIGluZm9cbiAqL1xuRm9sZGVycy5wcm90b3R5cGUuZ2V0V2F0ZXJtYXJrID0gZnVuY3Rpb24oZm9sZGVySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQsIFdBVEVSTUFSS19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC5nZXQoYXBpUGF0aCwgcGFyYW1zKVxuXHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5LndhdGVybWFyaztcblx0XHR9KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBhcHBseSBvciB1cGRhdGUgdGhlIHdhdGVybWFyayBmb3IgYSBjb3JyZXNwb25kaW5nIEJveCBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcnMvOmZvbGRlcklEL3dhdGVybWFyaydcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIC0gVGhlIEJveCBJRCBvZiB0aGUgZm9sZGVyIHRvIHVwZGF0ZSB3YXRlcm1hcmsgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgd2F0ZXJtYXJrIGluZm9ybWF0aW9uIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgd2F0ZXJtYXJrIGluZm9cbiAqL1xuRm9sZGVycy5wcm90b3R5cGUuYXBwbHlXYXRlcm1hcmsgPSBmdW5jdGlvbihmb2xkZXJJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQsIFdBVEVSTUFSS19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHR3YXRlcm1hcms6IHtcblx0XHRcdFx0XHRpbXByaW50OiAnZGVmYXVsdCcgLy8gQ3VycmVudGx5IHRoZSBBUEkgb25seSBzdXBwb3J0cyBkZWZhdWx0IGltcHJpbnRcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0T2JqZWN0LmFzc2lnbihwYXJhbXMuYm9keS53YXRlcm1hcmssIG9wdGlvbnMpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVtb3ZlIHRoZSB3YXRlcm1hcmsgZm9yIGEgY29ycmVzcG9uZGluZyBCb3ggZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzLzpmb2xkZXJJRC93YXRlcm1hcmsnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXJJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIGZvbGRlciB0byByZW1vdmUgd2F0ZXJtYXJrIGZyb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBFbXB0eSByZXNwb25zZSBib2R5IHBhc3NlZCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUucmVtb3ZlV2F0ZXJtYXJrID0gZnVuY3Rpb24oZm9sZGVySUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgZm9sZGVySUQsIFdBVEVSTUFSS19TVUJSRVNPVVJDRSk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gbG9jayBhIEJveCBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZvbGRlcl9sb2NrcydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXJJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIGZvbGRlciB0byBsb2NrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBmb2xkZXIgbG9jayBvYmplY3QgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGZvbGRlciBsb2NrIG9iamVjdFxuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5sb2NrID0gZnVuY3Rpb24oZm9sZGVySUQsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0Zm9sZGVyOiB7XG5cdFx0XHRcdHR5cGU6ICdmb2xkZXInLFxuXHRcdFx0XHRpZDogZm9sZGVySURcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWRfb3BlcmF0aW9uczoge1xuXHRcdFx0XHRtb3ZlOiB0cnVlLFxuXHRcdFx0XHRkZWxldGU6IHRydWVcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKEZPTERFUl9MT0NLLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBnZXQgYWxsIGxvY2tzIG9uIGEgZm9sZGVyLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJfbG9ja3MnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXJJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIGZvbGRlciB0byBsb2NrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIGEgY29sbGVjdGlvbiBvZiBmb2xkZXIgbG9jayBvYmplY3RzIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYSBjb2xsZWN0aW9uIG9mIGZvbGRlciBsb2NrIG9iamVjdHNcbiAqL1xuRm9sZGVycy5wcm90b3R5cGUuZ2V0TG9ja3MgPSBmdW5jdGlvbihmb2xkZXJJRCwgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRxczoge1xuXHRcdFx0Zm9sZGVyX2lkOiBmb2xkZXJJRFxuXHRcdH1cblx0fTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShGT0xERVJfTE9DSywgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gZGVsZXRlIGEgbG9jayBvbiBhIGZvbGRlci5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZm9sZGVyX2xvY2tzLzpmb2xkZXJMb2NrSUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXJMb2NrSUQgLSBUaGUgQm94IElEIG9mIHRoZSBmb2xkZXIgbG9ja1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEVtcHR5IHJlc3BvbnNlIGJvZHkgcGFzc2VkIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuICovXG5Gb2xkZXJzLnByb3RvdHlwZS5kZWxldGVMb2NrID0gZnVuY3Rpb24oZm9sZGVyTG9ja0lELCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChGT0xERVJfTE9DSywgZm9sZGVyTG9ja0lEKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9mb2xkZXJzXG4gKiBAc2VlIHtATGluayBGb2xkZXJzfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEZvbGRlcnM7XG4iXSwibmFtZXMiOlsidXJsUGF0aCIsInJlcXVpcmUiLCJlcnJvcnMiLCJCQVNFX1BBVEgiLCJGT0xERVJfTE9DSyIsIldBVEVSTUFSS19TVUJSRVNPVVJDRSIsIkZvbGRlcnMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJnZXQiLCJmb2xkZXJJRCIsIm9wdGlvbnMiLCJjYWxsYmFjayIsInBhcmFtcyIsInFzIiwiYXBpUGF0aCIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJnZXRJdGVtcyIsImdldENvbGxhYm9yYXRpb25zIiwiY3JlYXRlIiwicGFyZW50Rm9sZGVySUQiLCJuYW1lIiwiYm9keSIsInBhcmVudCIsImlkIiwicG9zdCIsImNvcHkiLCJuZXdQYXJlbnRJRCIsInVwZGF0ZSIsInVwZGF0ZXMiLCJldGFnIiwiaGVhZGVycyIsInB1dCIsImFkZFRvQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25JRCIsImZpZWxkcyIsInRoZW4iLCJkYXRhIiwiY29sbGVjdGlvbnMiLCJtYXAiLCJjIiwiZmluZCIsInB1c2giLCJhc0NhbGxiYWNrIiwicmVtb3ZlRnJvbUNvbGxlY3Rpb24iLCJmaWx0ZXIiLCJtb3ZlIiwiZGVsZXRlIiwiZGVsIiwiZ2V0QWxsTWV0YWRhdGEiLCJnZXRNZXRhZGF0YSIsInNjb3BlIiwidGVtcGxhdGUiLCJhZGRNZXRhZGF0YSIsInVwZGF0ZU1ldGFkYXRhIiwicGF0Y2giLCJzZXRNZXRhZGF0YSIsIm1ldGFkYXRhIiwiY2F0Y2giLCJlcnIiLCJzdGF0dXNDb2RlIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsIm9wIiwicGF0aCIsInZhbHVlIiwiZGVsZXRlTWV0YWRhdGEiLCJnZXRUcmFzaGVkRm9sZGVyIiwicmVzdG9yZUZyb21UcmFzaCIsInBhcmVudF9pZCIsImRlbGV0ZVBlcm1hbmVudGx5IiwiZ2V0V2F0ZXJtYXJrIiwicmVzcG9uc2UiLCJidWlsZFVuZXhwZWN0ZWRSZXNwb25zZUVycm9yIiwid2F0ZXJtYXJrIiwiYXBwbHlXYXRlcm1hcmsiLCJpbXByaW50IiwiYXNzaWduIiwicmVtb3ZlV2F0ZXJtYXJrIiwibG9jayIsImZvbGRlciIsInR5cGUiLCJsb2NrZWRfb3BlcmF0aW9ucyIsImdldExvY2tzIiwiZm9sZGVyX2lkIiwiZGVsZXRlTG9jayIsImZvbGRlckxvY2tJRCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/folders.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/groups.js":
/*!**********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/groups.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Groups resource\n * @author mwiller\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Describes what types of users can perform certain actions on a group\n * @typedef {string} GroupAccessLevel\n */ /**\n * Role of the user in the group\n * @typedef {string} GroupUserRole\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar BASE_PATH = \"/groups\", MEMBERSHIPS_PATH = \"/group_memberships\", MEMBERSHIPS_SUBRESOURCE = \"memberships\", COLLABORATIONS_SUBRESOURCE = \"collaborations\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Groups' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Groups(client) {\n    this.client = client;\n}\n/**\n * Enum of valid access levels for groups, which are used to specify who can\n * perform certain actions on the group.\n * @enum {GroupAccessLevel}\n */ Groups.prototype.accessLevels = Object.freeze({\n    ADMINS: \"admins_only\",\n    MEMBERS: \"admins_and_members\",\n    ALL_USERS: \"all_managed_users\"\n});\n/**\n * Enum of valid user roles within a group\n * @enum {GroupUserRole}\n */ Groups.prototype.userRoles = Object.freeze({\n    MEMBER: \"member\",\n    ADMIN: \"admin\"\n});\n/**\n * Used to create a new group\n *\n * API Endpoint: '/groups'\n * Method: POST\n *\n * @param {string} name - The name for the new group\n * @param {Object} [options] - Additional parameters\n * @param {string} [options.provenance] - Used to track the external source where the group is coming from\n * @param {string} [options.external_sync_identifier] - Used as a group identifier for groups coming from an external source\n * @param {string} [options.description] - Description of the group\n * @param {GroupAccessLevel} [options.invitability_level] - Specifies who can invite this group to collaborate on folders\n * @param {GroupAccessLevel} [options.member_viewability_level] - Specifies who can view the members of this group\n * @param {Function} [callback] - Passed the new group object if it was created successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the new group object\n */ Groups.prototype.create = function(name, options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        body: options || {}\n    };\n    params.body.name = name;\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Used to fetch information about a group\n *\n * API Endpoint: '/groups/:groupID'\n * Method: GET\n *\n * @param {string} groupID - The ID of the group to retrieve\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the group object if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the group object\n */ Groups.prototype.get = function(groupID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, groupID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Used to update or modify a group object\n *\n * API Endpoint: '/groups/:groupID'\n * Method: PUT\n *\n * @param {string} groupID - The ID of the group to update\n * @param {Object} updates - Group fields to update\n * @param {Function} [callback] - Passed the updated group object if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated group object\n */ Groups.prototype.update = function(groupID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, groupID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Delete a group\n *\n * API Endpoint: '/groups/:groupID'\n * Method: DELETE\n *\n * @param {string} groupID - The ID of the group to delete\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Groups.prototype.delete = function(groupID, callback) {\n    var apiPath = urlPath(BASE_PATH, groupID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Add a user to a group, which creates a membership record for the user\n *\n * API Endpoint: '/group_memberships'\n * Method: POST\n *\n * @param {string} groupID - The ID of the group to add the user to\n * @param {string} userID - The ID of the user to add the the group\n * @param {Object} [options] - Optional parameters for adding the user, can be left null in most cases\n * @param {GroupUserRole} [options.role] - The role of the user in the group\n * @param {Function} [callback] - Passed the membership record if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the new membership object\n */ Groups.prototype.addUser = function(groupID, userID, options, callback) {\n    var apiPath = urlPath(MEMBERSHIPS_PATH), params = {\n        body: {\n            user: {\n                id: userID\n            },\n            group: {\n                id: groupID\n            }\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Fetch a specific membership record, which shows that a given user is a member\n * of some group.\n *\n * API Endpoint: '/group_memberships/:membershipID'\n * Method: GET\n *\n * @param {string} membershipID - The ID of the membership to fetch\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the membership record if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the membership object\n */ Groups.prototype.getMembership = function(membershipID, options, callback) {\n    var apiPath = urlPath(MEMBERSHIPS_PATH, membershipID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Used to update or modify a group object\n *\n * API Endpoint: '/group_memberships/:membershipID'\n * Method: PUT\n *\n * @param {string} membershipID - The ID of the membership to update\n * @param {Object} options - Membership record fields to update\n * @param {Function} [callback] - Passed the updated membership object if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated membership object\n */ Groups.prototype.updateMembership = function(membershipID, options, callback) {\n    var apiPath = urlPath(MEMBERSHIPS_PATH, membershipID), params = {\n        body: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Used to remove a group membership\n *\n * API Endpoint: '/group_memberships/:membershipID'\n * Method: DELETE\n *\n * @param {string} membershipID - The ID of the membership to be removed\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Groups.prototype.removeMembership = function(membershipID, callback) {\n    var apiPath = urlPath(MEMBERSHIPS_PATH, membershipID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Retreieve a list of memberships for the group, which show which users\n * belong to the group\n *\n * API Endpoint: '/groups/:groupID/memberships'\n * Method: GET\n *\n * @param {string} groupID - The ID of the group to get memberships for\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {int} [options.limit] - The number of memberships to retrieve\n * @param {int} [options.offset] - Paging marker, retrieve records starting at this position in the list\n * @param {Function} [callback] - Passed a list of memberships if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of memberships\n */ Groups.prototype.getMemberships = function(groupID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, groupID, MEMBERSHIPS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Retreieve a list of groups in the caller's enterprise.  This ability is\n * restricted to certain users with permission to view groups.\n *\n * API Endpoint: '/groups'\n * Method: GET\n *\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {string} [options.filter_term] - Limits the results to only groups whose name starts with the search term\n * @param {int} [options.limit] - The number of memberships to retrieve\n * @param {int} [options.offset] - Paging marker, retrieve records starting at this position in the list\n * @param {Function} [callback] - Passed a list of groups if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of groups\n */ Groups.prototype.getAll = function(options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Retreieve a list of collaborations for the group, which show which items the\n * group has access to.\n *\n * API Endpoint: '/groups/:groupID/collaborations'\n * Method: GET\n *\n * @param {string} groupID - The ID of the group to get collaborations for\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {int} [options.limit] - The number of memberships to retrieve\n * @param {int} [options.offset] - Paging marker, retrieve records starting at this position in the list\n * @param {Function} [callback] - Passed a list of collaborations if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of collaborations for the group\n */ Groups.prototype.getCollaborations = function(groupID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, groupID, COLLABORATIONS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\nmodule.exports = Groups;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9ncm91cHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDLEdBRUQ7QUFFQSxnRkFBZ0Y7QUFDaEYsV0FBVztBQUNYLGdGQUFnRjtBQUVoRjs7O0NBR0MsR0FFRDs7O0NBR0MsR0FFRCxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUNoRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV0QixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUNoRixJQUFJQyxZQUFZLFdBQ2ZDLG1CQUFtQixzQkFDbkJDLDBCQUEwQixlQUMxQkMsNkJBQTZCO0FBRTlCLGdGQUFnRjtBQUNoRixTQUFTO0FBQ1QsZ0ZBQWdGO0FBRWhGOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLE9BQU9DLE1BQU07SUFDckIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0FBQ2Y7QUFFQTs7OztDQUlDLEdBQ0RELE9BQU9FLFNBQVMsQ0FBQ0MsWUFBWSxHQUFHQyxPQUFPQyxNQUFNLENBQUM7SUFDN0NDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxXQUFXO0FBQ1o7QUFFQTs7O0NBR0MsR0FDRFIsT0FBT0UsU0FBUyxDQUFDTyxTQUFTLEdBQUdMLE9BQU9DLE1BQU0sQ0FBQztJQUMxQ0ssUUFBUTtJQUNSQyxPQUFPO0FBQ1I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRFgsT0FBT0UsU0FBUyxDQUFDVSxNQUFNLEdBQUcsU0FBU0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFFekQsSUFBSUMsVUFBVXRCLFFBQVFFLFlBQ3JCcUIsU0FBUztRQUNSQyxNQUFNSixXQUFXLENBQUM7SUFDbkI7SUFFREcsT0FBT0MsSUFBSSxDQUFDTCxJQUFJLEdBQUdBO0lBRW5CLE9BQU8sSUFBSSxDQUFDWixNQUFNLENBQUNrQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNsQixNQUFNLENBQUNtQixJQUFJLEVBQUVKLFNB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Q0FhQyxHQUNEZixPQUFPRSxTQUFTLENBQUNxQyxjQUFjLEdBQUcsU0FBU2pCLE9BQU8sRUFBRVIsT0FBTyxFQUFFQyxRQUFRO0lBRXBFLElBQUlDLFVBQVV0QixRQUFRRSxXQUFXMEIsU0FBU3hCLDBCQUN6Q21CLFNBQVM7UUFDUk0sSUFBSVQ7SUFDTDtJQUVELE9BQU8sSUFBSSxDQUFDYixNQUFNLENBQUNrQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNsQixNQUFNLENBQUNvQixHQUFHLEVBQUVMLFNBQVNDLFFBQVFGO0FBQzdFO0FBRUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNEZixPQUFPRSxTQUFTLENBQUNzQyxNQUFNLEdBQUcsU0FBUzFCLE9BQU8sRUFBRUMsUUFBUTtJQUVuRCxJQUFJQyxVQUFVdEIsUUFBUUUsWUFDckJxQixTQUFTO1FBQ1JNLElBQUlUO0lBQ0w7SUFFRCxPQUFPLElBQUksQ0FBQ2IsTUFBTSxDQUFDa0Isc0JBQXNCLENBQUMsSUFBSSxDQUFDbEIsTUFBTSxDQUFDb0IsR0FBRyxFQUFFTCxTQUFTQyxRQUFRRjtBQUM3RTtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRGYsT0FBT0UsU0FBUyxDQUFDdUMsaUJBQWlCLEdBQUcsU0FBU25CLE9BQU8sRUFBRVIsT0FBTyxFQUFFQyxRQUFRO0lBRXZFLElBQUlDLFVBQVV0QixRQUFRRSxXQUFXMEIsU0FBU3ZCLDZCQUN6Q2tCLFNBQVM7UUFDUk0sSUFBSVQ7SUFDTDtJQUVELE9BQU8sSUFBSSxDQUFDYixNQUFNLENBQUNrQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNsQixNQUFNLENBQUNvQixHQUFHLEVBQUVMLFNBQVNDLFFBQVFGO0FBQzdFO0FBRUEyQixPQUFPQyxPQUFPLEdBQUczQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvZ3JvdXBzLmpzPzQ3NTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBHcm91cHMgcmVzb3VyY2VcbiAqIEBhdXRob3IgbXdpbGxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIERlc2NyaWJlcyB3aGF0IHR5cGVzIG9mIHVzZXJzIGNhbiBwZXJmb3JtIGNlcnRhaW4gYWN0aW9ucyBvbiBhIGdyb3VwXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBHcm91cEFjY2Vzc0xldmVsXG4gKi9cblxuLyoqXG4gKiBSb2xlIG9mIHRoZSB1c2VyIGluIHRoZSBncm91cFxuICogQHR5cGVkZWYge3N0cmluZ30gR3JvdXBVc2VyUm9sZVxuICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy9ncm91cHMnLFxuXHRNRU1CRVJTSElQU19QQVRIID0gJy9ncm91cF9tZW1iZXJzaGlwcycsXG5cdE1FTUJFUlNISVBTX1NVQlJFU09VUkNFID0gJ21lbWJlcnNoaXBzJyxcblx0Q09MTEFCT1JBVElPTlNfU1VCUkVTT1VSQ0UgPSAnY29sbGFib3JhdGlvbnMnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIGFsbCAnR3JvdXBzJyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gR3JvdXBzKGNsaWVudCkge1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuLyoqXG4gKiBFbnVtIG9mIHZhbGlkIGFjY2VzcyBsZXZlbHMgZm9yIGdyb3Vwcywgd2hpY2ggYXJlIHVzZWQgdG8gc3BlY2lmeSB3aG8gY2FuXG4gKiBwZXJmb3JtIGNlcnRhaW4gYWN0aW9ucyBvbiB0aGUgZ3JvdXAuXG4gKiBAZW51bSB7R3JvdXBBY2Nlc3NMZXZlbH1cbiAqL1xuR3JvdXBzLnByb3RvdHlwZS5hY2Nlc3NMZXZlbHMgPSBPYmplY3QuZnJlZXplKHtcblx0QURNSU5TOiAnYWRtaW5zX29ubHknLFxuXHRNRU1CRVJTOiAnYWRtaW5zX2FuZF9tZW1iZXJzJyxcblx0QUxMX1VTRVJTOiAnYWxsX21hbmFnZWRfdXNlcnMnXG59KTtcblxuLyoqXG4gKiBFbnVtIG9mIHZhbGlkIHVzZXIgcm9sZXMgd2l0aGluIGEgZ3JvdXBcbiAqIEBlbnVtIHtHcm91cFVzZXJSb2xlfVxuICovXG5Hcm91cHMucHJvdG90eXBlLnVzZXJSb2xlcyA9IE9iamVjdC5mcmVlemUoe1xuXHRNRU1CRVI6ICdtZW1iZXInLFxuXHRBRE1JTjogJ2FkbWluJ1xufSk7XG5cbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBuZXcgZ3JvdXBcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZ3JvdXBzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBmb3IgdGhlIG5ldyBncm91cFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByb3ZlbmFuY2VdIC0gVXNlZCB0byB0cmFjayB0aGUgZXh0ZXJuYWwgc291cmNlIHdoZXJlIHRoZSBncm91cCBpcyBjb21pbmcgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmV4dGVybmFsX3N5bmNfaWRlbnRpZmllcl0gLSBVc2VkIGFzIGEgZ3JvdXAgaWRlbnRpZmllciBmb3IgZ3JvdXBzIGNvbWluZyBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSAtIERlc2NyaXB0aW9uIG9mIHRoZSBncm91cFxuICogQHBhcmFtIHtHcm91cEFjY2Vzc0xldmVsfSBbb3B0aW9ucy5pbnZpdGFiaWxpdHlfbGV2ZWxdIC0gU3BlY2lmaWVzIHdobyBjYW4gaW52aXRlIHRoaXMgZ3JvdXAgdG8gY29sbGFib3JhdGUgb24gZm9sZGVyc1xuICogQHBhcmFtIHtHcm91cEFjY2Vzc0xldmVsfSBbb3B0aW9ucy5tZW1iZXJfdmlld2FiaWxpdHlfbGV2ZWxdIC0gU3BlY2lmaWVzIHdobyBjYW4gdmlldyB0aGUgbWVtYmVycyBvZiB0aGlzIGdyb3VwXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBuZXcgZ3JvdXAgb2JqZWN0IGlmIGl0IHdhcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseSwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXcgZ3JvdXAgb2JqZWN0XG4gKi9cbkdyb3Vwcy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiBvcHRpb25zIHx8IHt9XG5cdFx0fTtcblxuXHRwYXJhbXMuYm9keS5uYW1lID0gbmFtZTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byBmZXRjaCBpbmZvcm1hdGlvbiBhYm91dCBhIGdyb3VwXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2dyb3Vwcy86Z3JvdXBJRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwSUQgLSBUaGUgSUQgb2YgdGhlIGdyb3VwIHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgZ3JvdXAgb2JqZWN0IGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgZ3JvdXAgb2JqZWN0XG4gKi9cbkdyb3Vwcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZ3JvdXBJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBncm91cElEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byB1cGRhdGUgb3IgbW9kaWZ5IGEgZ3JvdXAgb2JqZWN0XG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2dyb3Vwcy86Z3JvdXBJRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyb3VwSUQgLSBUaGUgSUQgb2YgdGhlIGdyb3VwIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXMgLSBHcm91cCBmaWVsZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIGdyb3VwIG9iamVjdCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgZ3JvdXAgb2JqZWN0XG4gKi9cbkdyb3Vwcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZ3JvdXBJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBncm91cElEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB1cGRhdGVzXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBncm91cFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ncm91cHMvOmdyb3VwSUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBncm91cElEIC0gVGhlIElEIG9mIHRoZSBncm91cCB0byBkZWxldGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgbm90aGluZyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuR3JvdXBzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihncm91cElELCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGdyb3VwSUQpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBZGQgYSB1c2VyIHRvIGEgZ3JvdXAsIHdoaWNoIGNyZWF0ZXMgYSBtZW1iZXJzaGlwIHJlY29yZCBmb3IgdGhlIHVzZXJcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZ3JvdXBfbWVtYmVyc2hpcHMnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBJRCAtIFRoZSBJRCBvZiB0aGUgZ3JvdXAgdG8gYWRkIHRoZSB1c2VyIHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklEIC0gVGhlIElEIG9mIHRoZSB1c2VyIHRvIGFkZCB0aGUgdGhlIGdyb3VwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgYWRkaW5nIHRoZSB1c2VyLCBjYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXNcbiAqIEBwYXJhbSB7R3JvdXBVc2VyUm9sZX0gW29wdGlvbnMucm9sZV0gLSBUaGUgcm9sZSBvZiB0aGUgdXNlciBpbiB0aGUgZ3JvdXBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIG1lbWJlcnNoaXAgcmVjb3JkIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IG1lbWJlcnNoaXAgb2JqZWN0XG4gKi9cbkdyb3Vwcy5wcm90b3R5cGUuYWRkVXNlciA9IGZ1bmN0aW9uKGdyb3VwSUQsIHVzZXJJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoTUVNQkVSU0hJUFNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHR1c2VyOiB7XG5cdFx0XHRcdFx0aWQ6IHVzZXJJRFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRncm91cDoge1xuXHRcdFx0XHRcdGlkOiBncm91cElEXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdE9iamVjdC5hc3NpZ24ocGFyYW1zLmJvZHksIG9wdGlvbnMpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xuXG59O1xuXG4vKipcbiAqIEZldGNoIGEgc3BlY2lmaWMgbWVtYmVyc2hpcCByZWNvcmQsIHdoaWNoIHNob3dzIHRoYXQgYSBnaXZlbiB1c2VyIGlzIGEgbWVtYmVyXG4gKiBvZiBzb21lIGdyb3VwLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ncm91cF9tZW1iZXJzaGlwcy86bWVtYmVyc2hpcElEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElEIC0gVGhlIElEIG9mIHRoZSBtZW1iZXJzaGlwIHRvIGZldGNoXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbWVtYmVyc2hpcCByZWNvcmQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBtZW1iZXJzaGlwIG9iamVjdFxuICovXG5Hcm91cHMucHJvdG90eXBlLmdldE1lbWJlcnNoaXAgPSBmdW5jdGlvbihtZW1iZXJzaGlwSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKE1FTUJFUlNISVBTX1BBVEgsIG1lbWJlcnNoaXBJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gdXBkYXRlIG9yIG1vZGlmeSBhIGdyb3VwIG9iamVjdFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ncm91cF9tZW1iZXJzaGlwcy86bWVtYmVyc2hpcElEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVtYmVyc2hpcElEIC0gVGhlIElEIG9mIHRoZSBtZW1iZXJzaGlwIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBNZW1iZXJzaGlwIHJlY29yZCBmaWVsZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIG1lbWJlcnNoaXAgb2JqZWN0IGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCBtZW1iZXJzaGlwIG9iamVjdFxuICovXG5Hcm91cHMucHJvdG90eXBlLnVwZGF0ZU1lbWJlcnNoaXAgPSBmdW5jdGlvbihtZW1iZXJzaGlwSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKE1FTUJFUlNISVBTX1BBVEgsIG1lbWJlcnNoaXBJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlZCB0byByZW1vdmUgYSBncm91cCBtZW1iZXJzaGlwXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2dyb3VwX21lbWJlcnNoaXBzLzptZW1iZXJzaGlwSUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZW1iZXJzaGlwSUQgLSBUaGUgSUQgb2YgdGhlIG1lbWJlcnNoaXAgdG8gYmUgcmVtb3ZlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCBub3RoaW5nIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuICovXG5Hcm91cHMucHJvdG90eXBlLnJlbW92ZU1lbWJlcnNoaXAgPSBmdW5jdGlvbihtZW1iZXJzaGlwSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKE1FTUJFUlNISVBTX1BBVEgsIG1lbWJlcnNoaXBJRCk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJlaWV2ZSBhIGxpc3Qgb2YgbWVtYmVyc2hpcHMgZm9yIHRoZSBncm91cCwgd2hpY2ggc2hvdyB3aGljaCB1c2Vyc1xuICogYmVsb25nIHRvIHRoZSBncm91cFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ncm91cHMvOmdyb3VwSUQvbWVtYmVyc2hpcHMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBncm91cElEIC0gVGhlIElEIG9mIHRoZSBncm91cCB0byBnZXQgbWVtYmVyc2hpcHMgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMubGltaXRdIC0gVGhlIG51bWJlciBvZiBtZW1iZXJzaGlwcyB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLm9mZnNldF0gLSBQYWdpbmcgbWFya2VyLCByZXRyaWV2ZSByZWNvcmRzIHN0YXJ0aW5nIGF0IHRoaXMgcG9zaXRpb24gaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBsaXN0IG9mIG1lbWJlcnNoaXBzIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiBtZW1iZXJzaGlwc1xuICovXG5Hcm91cHMucHJvdG90eXBlLmdldE1lbWJlcnNoaXBzID0gZnVuY3Rpb24oZ3JvdXBJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBncm91cElELCBNRU1CRVJTSElQU19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJlaWV2ZSBhIGxpc3Qgb2YgZ3JvdXBzIGluIHRoZSBjYWxsZXIncyBlbnRlcnByaXNlLiAgVGhpcyBhYmlsaXR5IGlzXG4gKiByZXN0cmljdGVkIHRvIGNlcnRhaW4gdXNlcnMgd2l0aCBwZXJtaXNzaW9uIHRvIHZpZXcgZ3JvdXBzLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ncm91cHMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzLCBjYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5maWx0ZXJfdGVybV0gLSBMaW1pdHMgdGhlIHJlc3VsdHMgdG8gb25seSBncm91cHMgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCB0aGUgc2VhcmNoIHRlcm1cbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5saW1pdF0gLSBUaGUgbnVtYmVyIG9mIG1lbWJlcnNoaXBzIHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMub2Zmc2V0XSAtIFBhZ2luZyBtYXJrZXIsIHJldHJpZXZlIHJlY29yZHMgc3RhcnRpbmcgYXQgdGhpcyBwb3NpdGlvbiBpbiB0aGUgbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCBhIGxpc3Qgb2YgZ3JvdXBzIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiBncm91cHNcbiAqL1xuR3JvdXBzLnByb3RvdHlwZS5nZXRBbGwgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZXRyZWlldmUgYSBsaXN0IG9mIGNvbGxhYm9yYXRpb25zIGZvciB0aGUgZ3JvdXAsIHdoaWNoIHNob3cgd2hpY2ggaXRlbXMgdGhlXG4gKiBncm91cCBoYXMgYWNjZXNzIHRvLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9ncm91cHMvOmdyb3VwSUQvY29sbGFib3JhdGlvbnMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBncm91cElEIC0gVGhlIElEIG9mIHRoZSBncm91cCB0byBnZXQgY29sbGFib3JhdGlvbnMgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMubGltaXRdIC0gVGhlIG51bWJlciBvZiBtZW1iZXJzaGlwcyB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLm9mZnNldF0gLSBQYWdpbmcgbWFya2VyLCByZXRyaWV2ZSByZWNvcmRzIHN0YXJ0aW5nIGF0IHRoaXMgcG9zaXRpb24gaW4gdGhlIGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBsaXN0IG9mIGNvbGxhYm9yYXRpb25zIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiBjb2xsYWJvcmF0aW9ucyBmb3IgdGhlIGdyb3VwXG4gKi9cbkdyb3Vwcy5wcm90b3R5cGUuZ2V0Q29sbGFib3JhdGlvbnMgPSBmdW5jdGlvbihncm91cElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIGdyb3VwSUQsIENPTExBQk9SQVRJT05TX1NVQlJFU09VUkNFKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBzO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiQkFTRV9QQVRIIiwiTUVNQkVSU0hJUFNfUEFUSCIsIk1FTUJFUlNISVBTX1NVQlJFU09VUkNFIiwiQ09MTEFCT1JBVElPTlNfU1VCUkVTT1VSQ0UiLCJHcm91cHMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJhY2Nlc3NMZXZlbHMiLCJPYmplY3QiLCJmcmVlemUiLCJBRE1JTlMiLCJNRU1CRVJTIiwiQUxMX1VTRVJTIiwidXNlclJvbGVzIiwiTUVNQkVSIiwiQURNSU4iLCJjcmVhdGUiLCJuYW1lIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYXBpUGF0aCIsInBhcmFtcyIsImJvZHkiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwicG9zdCIsImdldCIsImdyb3VwSUQiLCJxcyIsInVwZGF0ZSIsInVwZGF0ZXMiLCJwdXQiLCJkZWxldGUiLCJkZWwiLCJhZGRVc2VyIiwidXNlcklEIiwidXNlciIsImlkIiwiZ3JvdXAiLCJhc3NpZ24iLCJnZXRNZW1iZXJzaGlwIiwibWVtYmVyc2hpcElEIiwidXBkYXRlTWVtYmVyc2hpcCIsInJlbW92ZU1lbWJlcnNoaXAiLCJnZXRNZW1iZXJzaGlwcyIsImdldEFsbCIsImdldENvbGxhYm9yYXRpb25zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/groups.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/legal-hold-policies.js":
/*!***********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/legal-hold-policies.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Legal Hold Policies Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Policy assignment types, which specify what type of object the hold applies to\n * @typedef {string} LegalHoldPolicyAssignmentType\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar BASE_PATH = \"/legal_hold_policies\", ASSIGNMENTS_PATH = \"/legal_hold_policy_assignments\", FILE_VERSION_LEGAL_HOLDS_PATH = \"/file_version_legal_holds\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all Legal Holds endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function LegalHoldPolicies(client) {\n    this.client = client;\n}\n/**\n * Enum of valid policy assignment types, which specify what object the policy applies to\n * @readonly\n * @enum {LegalHoldPolicyAssignmentType}\n */ LegalHoldPolicies.prototype.assignmentTypes = Object.freeze({\n    FOLDER: \"folder\",\n    USER: \"user\",\n    FILE: \"file\",\n    FILE_VERSION: \"file_version\"\n});\n/**\n * Used to create a single legal hold policy for an enterprise\n *\n * API Endpoint: '/legal_hold_policies'\n * Method: POST\n *\n * @param {string} name - The name of the legal hold policy to be created\n * @param {Object} [options] - Additional parameters\n * @param {string} [options.description] - Description of the legal hold policy\n * @param {string} [options.filter_started_at] - Date filter, any Custodian assignments will apply only to file versions created or uploaded inside of the date range\n * @param {string} [options.filter_ended_at] - Date filter, any Custodian assignments will apply only to file versions created or uploaded inside of the date range\n * @param {boolean} [options.is_ongoing] - After initialization, Assignments under this Policy will continue applying to files based on events, indefinitely\n * @param {Function} [callback] - Passed the new policy information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created policy\n */ LegalHoldPolicies.prototype.create = function(name, options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        body: options || {}\n    };\n    params.body.policy_name = name;\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Fetches details about a specific legal hold policy\n *\n * API Endpoint: '/legal_hold_policies/:policyID'\n * Method: GET\n *\n * @param {string} policyID - The Box ID of the legal hold policy being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the policy information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the policy object\n */ LegalHoldPolicies.prototype.get = function(policyID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, policyID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Update or modify a legal hold policy.\n *\n * API Endpoint: '/legal_hold_policies/:policyID'\n * Method: PUT\n *\n * @param {string} policyID - The Box ID of the legal hold policy to update\n * @param {Object} updates - The information to be updated\n * @param {string} [updates.policy_name] - Name of Legal Hold Policy\n * @param {string} [updates.description] - Description of Legal Hold Policy\n * @param {string} [updates.release_notes] - Notes around why the policy was released\n * @param {Function} [callback] - Passed the updated policy information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated policy\n */ LegalHoldPolicies.prototype.update = function(policyID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, policyID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Fetches a list of legal hold policies for the enterprise\n *\n * API Endpoint: '/legal_hold_policies'\n * Method: GET\n *\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {string} [options.policy_name] - A full or partial name to filter the legal hold policies by\n * @param {int} [options.limit] - Limit result size to this number\n * @param {string} [options.marker] - Paging marker, leave blank to start at the first page\n * @param {Function} [callback] - Passed the policy objects if they were acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of policies\n */ LegalHoldPolicies.prototype.getAll = function(options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Sends request to delete an existing legal hold policy. Note that this is an\n * asynchronous process - the policy will not be fully deleted yet when the\n * response comes back.\n *\n * API Endpoint: '/legal_hold_policies/:policyID'\n * Method: DELETE\n *\n * @param {string} policyID - The legal hold policy to delete\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ LegalHoldPolicies.prototype.delete = function(policyID, callback) {\n    var apiPath = urlPath(BASE_PATH, policyID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Fetch a list of assignments for a given legal hold policy\n *\n * API Endpoint: '/legal_hold_policies/:policyID/assignments'\n * Method: GET\n *\n * @param {string} policyID - The Box ID of the legal hold policy to get assignments for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {LegalHoldPolicyAssignmentType} [options.assign_to_type] - Filter assignments of this type only\n * @param {string} [options.assign_to_id] - Filter assignments to this ID only. Note that this will only show assignments applied directly to this entity.\n * @param {Function} [callback] - Passed the assignment objects if they were acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of policy assignments\n */ LegalHoldPolicies.prototype.getAssignments = function(policyID, options, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n        qs: Object.assign({\n            policy_id: policyID\n        }, options)\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Assign a lehal hold policy to an object\n *\n * API Endpoint: '/legal_hold_policy_assignments\n * Method: POST\n *\n * @param {string} policyID - The ID of the policy to assign\n * @param {LegalHoldPolicyAssignmentType} assignType - The type of object the policy will be assigned to\n * @param {string} assignID - The Box ID of the object to assign the legal hold policy to\n * @param {Function} [callback] - Passed the new assignment object if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created assignment object\n */ LegalHoldPolicies.prototype.assign = function(policyID, assignType, assignID, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n        body: {\n            policy_id: policyID,\n            assign_to: {\n                type: assignType,\n                id: assignID\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Fetch a specific policy assignment\n *\n * API Endpoint: '/legal_hold_policy_assignments/:assignmentID'\n * Method: GET\n *\n * @param {string} assignmentID - The Box ID of the policy assignment object to fetch\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the assignment object if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the assignment object\n */ LegalHoldPolicies.prototype.getAssignment = function(assignmentID, options, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Sends request to delete an existing legal hold policy. Note that this is an\n * asynchronous process - the policy will not be fully deleted yet when the\n * response comes back.\n *\n * API Endpoint: '/legal_hold_policy_assignments/:assignmentID'\n * Method: DELETE\n *\n * @param {string} assignmentID - The legal hold policy assignment to delete\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ LegalHoldPolicies.prototype.deleteAssignment = function(assignmentID, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Get the specific legal hold record for a held file version.\n *\n * API Endpoint: '/file_version_legal_holds/:legalHoldID'\n * Method: GET\n *\n * @param {string} legalHoldID - The ID for the file legal hold record to retrieve\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Pass the file version legal hold record if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the legal hold record\n */ LegalHoldPolicies.prototype.getFileVersionLegalHold = function(legalHoldID, options, callback) {\n    var apiPath = urlPath(FILE_VERSION_LEGAL_HOLDS_PATH, legalHoldID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Get a list of legal hold records for held file versions in an enterprise.\n *\n * API Endpoint: '/file_version_legal_holds'\n * Method: GET\n *\n * @param {string} policyID - ID of Legal Hold Policy to get File Version Legal Holds for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Pass the file version legal holds records if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of all file version legal holds\n */ LegalHoldPolicies.prototype.getAllFileVersionLegalHolds = function(policyID, options, callback) {\n    var apiPath = urlPath(FILE_VERSION_LEGAL_HOLDS_PATH), params = {\n        qs: Object.assign({\n            policy_id: policyID\n        }, options)\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\nmodule.exports = LegalHoldPolicies;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9sZWdhbC1ob2xkLXBvbGljaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxnRkFBZ0Y7QUFDaEYsV0FBVztBQUNYLGdGQUFnRjtBQUVoRjs7O0NBR0MsR0FFRCxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUNoRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV0QixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUNoRixJQUFJQyxZQUFZLHdCQUNmQyxtQkFBbUIsa0NBQ25CQyxnQ0FBZ0M7QUFFakMsZ0ZBQWdGO0FBQ2hGLFNBQVM7QUFDVCxnRkFBZ0Y7QUFFaEY7Ozs7OztDQU1DLEdBQ0QsU0FBU0Msa0JBQWtCQyxNQUFNO0lBQ2hDLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUE7Ozs7Q0FJQyxHQUNERCxrQkFBa0JFLFNBQVMsQ0FBQ0MsZUFBZSxHQUFHQyxPQUFPQyxNQUFNLENBQUM7SUFDM0RDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLGNBQWM7QUFDZjtBQUVBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0RULGtCQUFrQkUsU0FBUyxDQUFDUSxNQUFNLEdBQUcsU0FBU0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFDcEUsSUFBSUMsVUFBVW5CLFFBQVFFLFlBQ3JCa0IsU0FBUztRQUNSQyxNQUFNSixXQUFXLENBQUM7SUFDbkI7SUFFREcsT0FBT0MsSUFBSSxDQUFDQyxXQUFXLEdBQUdOO0lBRTFCLE9BQU8sSUFBSSxDQUFDVixNQUFNLENBQUNpQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNqQixNQUFNLENBQUNrQixJQUFJLEVBQUVMLFNBQVNDLFFBQVFGO0FBQzlFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNEYixrQkFBa0JFLFNBQVMsQ0FBQ2tCLEdBQUcsR0FBRyxTQUFTQyxRQUFRLEVBQUVU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SUFFN0UsSUFBSUMsVUFBVW5CLFFBQVFHLGtCQUFrQndDO0lBRXhDLE9BQU8sSUFBSSxDQUFDckMsTUFBTSxDQUFDaUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDakIsTUFBTSxDQUFDMkIsR0FBRyxFQUFFZCxTQUFTLE1BQU1EO0FBQzNFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNEYixrQkFBa0JFLFNBQVMsQ0FBQ3NDLHVCQUF1QixHQUFHLFNBQVNDLFdBQVcsRUFBRTdCLE9BQU8sRUFBRUMsUUFBUTtJQUU1RixJQUFJQyxVQUFVbkIsUUFBUUksK0JBQStCMEMsY0FDcEQxQixTQUFTO1FBQ1JPLElBQUlWO0lBQ0w7SUFFRCxPQUFPLElBQUksQ0FBQ1gsTUFBTSxDQUFDaUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDakIsTUFBTSxDQUFDbUIsR0FBRyxFQUFFTixTQUFTQyxRQUFRRjtBQUM3RTtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRGIsa0JBQWtCRSxTQUFTLENBQUN3QywyQkFBMkIsR0FBRyxTQUFTckIsUUFBUSxFQUFFVCxPQUFPLEVBQUVDLFFBQVE7SUFFN0YsSUFBSUMsVUFBVW5CLFFBQVFJLGdDQUNyQmdCLFNBQVM7UUFDUk8sSUFBSWxCLE9BQU8wQixNQUFNLENBQUM7WUFBRUMsV0FBV1Y7UUFBUyxHQUFHVDtJQUM1QztJQUVELE9BQU8sSUFBSSxDQUFDWCxNQUFNLENBQUNpQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNqQixNQUFNLENBQUNtQixHQUFHLEVBQUVOLFNBQVNDLFFBQVFGO0FBQzdFO0FBRUE4QixPQUFPQyxPQUFPLEdBQUc1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvbGVnYWwtaG9sZC1wb2xpY2llcy5qcz85ZjQ3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBNYW5hZ2VyIGZvciB0aGUgTGVnYWwgSG9sZCBQb2xpY2llcyBSZXNvdXJjZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFBvbGljeSBhc3NpZ25tZW50IHR5cGVzLCB3aGljaCBzcGVjaWZ5IHdoYXQgdHlwZSBvZiBvYmplY3QgdGhlIGhvbGQgYXBwbGllcyB0b1xuICogQHR5cGVkZWYge3N0cmluZ30gTGVnYWxIb2xkUG9saWN5QXNzaWdubWVudFR5cGVcbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEJBU0VfUEFUSCA9ICcvbGVnYWxfaG9sZF9wb2xpY2llcycsXG5cdEFTU0lHTk1FTlRTX1BBVEggPSAnL2xlZ2FsX2hvbGRfcG9saWN5X2Fzc2lnbm1lbnRzJyxcblx0RklMRV9WRVJTSU9OX0xFR0FMX0hPTERTX1BBVEggPSAnL2ZpbGVfdmVyc2lvbl9sZWdhbF9ob2xkcyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsIExlZ2FsIEhvbGRzIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgLSBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBMZWdhbEhvbGRQb2xpY2llcyhjbGllbnQpIHtcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogRW51bSBvZiB2YWxpZCBwb2xpY3kgYXNzaWdubWVudCB0eXBlcywgd2hpY2ggc3BlY2lmeSB3aGF0IG9iamVjdCB0aGUgcG9saWN5IGFwcGxpZXMgdG9cbiAqIEByZWFkb25seVxuICogQGVudW0ge0xlZ2FsSG9sZFBvbGljeUFzc2lnbm1lbnRUeXBlfVxuICovXG5MZWdhbEhvbGRQb2xpY2llcy5wcm90b3R5cGUuYXNzaWdubWVudFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdEZPTERFUjogJ2ZvbGRlcicsXG5cdFVTRVI6ICd1c2VyJyxcblx0RklMRTogJ2ZpbGUnLFxuXHRGSUxFX1ZFUlNJT046ICdmaWxlX3ZlcnNpb24nXG59KTtcblxuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIHNpbmdsZSBsZWdhbCBob2xkIHBvbGljeSBmb3IgYW4gZW50ZXJwcmlzZVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9sZWdhbF9ob2xkX3BvbGljaWVzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbGVnYWwgaG9sZCBwb2xpY3kgdG8gYmUgY3JlYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRlc2NyaXB0aW9uXSAtIERlc2NyaXB0aW9uIG9mIHRoZSBsZWdhbCBob2xkIHBvbGljeVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpbHRlcl9zdGFydGVkX2F0XSAtIERhdGUgZmlsdGVyLCBhbnkgQ3VzdG9kaWFuIGFzc2lnbm1lbnRzIHdpbGwgYXBwbHkgb25seSB0byBmaWxlIHZlcnNpb25zIGNyZWF0ZWQgb3IgdXBsb2FkZWQgaW5zaWRlIG9mIHRoZSBkYXRlIHJhbmdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmlsdGVyX2VuZGVkX2F0XSAtIERhdGUgZmlsdGVyLCBhbnkgQ3VzdG9kaWFuIGFzc2lnbm1lbnRzIHdpbGwgYXBwbHkgb25seSB0byBmaWxlIHZlcnNpb25zIGNyZWF0ZWQgb3IgdXBsb2FkZWQgaW5zaWRlIG9mIHRoZSBkYXRlIHJhbmdlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzX29uZ29pbmddIC0gQWZ0ZXIgaW5pdGlhbGl6YXRpb24sIEFzc2lnbm1lbnRzIHVuZGVyIHRoaXMgUG9saWN5IHdpbGwgY29udGludWUgYXBwbHlpbmcgdG8gZmlsZXMgYmFzZWQgb24gZXZlbnRzLCBpbmRlZmluaXRlbHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIG5ldyBwb2xpY3kgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseSwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIHBvbGljeVxuICovXG5MZWdhbEhvbGRQb2xpY2llcy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogb3B0aW9ucyB8fCB7fVxuXHRcdH07XG5cblx0cGFyYW1zLmJvZHkucG9saWN5X25hbWUgPSBuYW1lO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBGZXRjaGVzIGRldGFpbHMgYWJvdXQgYSBzcGVjaWZpYyBsZWdhbCBob2xkIHBvbGljeVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9sZWdhbF9ob2xkX3BvbGljaWVzLzpwb2xpY3lJRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBvbGljeUlEIC0gVGhlIEJveCBJRCBvZiB0aGUgbGVnYWwgaG9sZCBwb2xpY3kgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgcG9saWN5IGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHksIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgcG9saWN5IG9iamVjdFxuICovXG5MZWdhbEhvbGRQb2xpY2llcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocG9saWN5SUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHBvbGljeUlEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIG9yIG1vZGlmeSBhIGxlZ2FsIGhvbGQgcG9saWN5LlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9sZWdhbF9ob2xkX3BvbGljaWVzLzpwb2xpY3lJRCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBvbGljeUlEIC0gVGhlIEJveCBJRCBvZiB0aGUgbGVnYWwgaG9sZCBwb2xpY3kgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcyAtIFRoZSBpbmZvcm1hdGlvbiB0byBiZSB1cGRhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMucG9saWN5X25hbWVdIC0gTmFtZSBvZiBMZWdhbCBIb2xkIFBvbGljeVxuICogQHBhcmFtIHtzdHJpbmd9IFt1cGRhdGVzLmRlc2NyaXB0aW9uXSAtIERlc2NyaXB0aW9uIG9mIExlZ2FsIEhvbGQgUG9saWN5XG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMucmVsZWFzZV9ub3Rlc10gLSBOb3RlcyBhcm91bmQgd2h5IHRoZSBwb2xpY3kgd2FzIHJlbGVhc2VkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIHBvbGljeSBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgcG9saWN5XG4gKi9cbkxlZ2FsSG9sZFBvbGljaWVzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihwb2xpY3lJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBwb2xpY3lJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogdXBkYXRlc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2hlcyBhIGxpc3Qgb2YgbGVnYWwgaG9sZCBwb2xpY2llcyBmb3IgdGhlIGVudGVycHJpc2VcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvbGVnYWxfaG9sZF9wb2xpY2llcydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb2xpY3lfbmFtZV0gLSBBIGZ1bGwgb3IgcGFydGlhbCBuYW1lIHRvIGZpbHRlciB0aGUgbGVnYWwgaG9sZCBwb2xpY2llcyBieVxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmxpbWl0XSAtIExpbWl0IHJlc3VsdCBzaXplIHRvIHRoaXMgbnVtYmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFya2VyXSAtIFBhZ2luZyBtYXJrZXIsIGxlYXZlIGJsYW5rIHRvIHN0YXJ0IGF0IHRoZSBmaXJzdCBwYWdlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBwb2xpY3kgb2JqZWN0cyBpZiB0aGV5IHdlcmUgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgcG9saWNpZXNcbiAqL1xuTGVnYWxIb2xkUG9saWNpZXMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTZW5kcyByZXF1ZXN0IHRvIGRlbGV0ZSBhbiBleGlzdGluZyBsZWdhbCBob2xkIHBvbGljeS4gTm90ZSB0aGF0IHRoaXMgaXMgYW5cbiAqIGFzeW5jaHJvbm91cyBwcm9jZXNzIC0gdGhlIHBvbGljeSB3aWxsIG5vdCBiZSBmdWxseSBkZWxldGVkIHlldCB3aGVuIHRoZVxuICogcmVzcG9uc2UgY29tZXMgYmFjay5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvbGVnYWxfaG9sZF9wb2xpY2llcy86cG9saWN5SUQnXG4gKiBNZXRob2Q6IERFTEVURVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2xpY3lJRCAtIFRoZSBsZWdhbCBob2xkIHBvbGljeSB0byBkZWxldGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgbm90aGluZyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuTGVnYWxIb2xkUG9saWNpZXMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKHBvbGljeUlELCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHBvbGljeUlEKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBsaXN0IG9mIGFzc2lnbm1lbnRzIGZvciBhIGdpdmVuIGxlZ2FsIGhvbGQgcG9saWN5XG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2xlZ2FsX2hvbGRfcG9saWNpZXMvOnBvbGljeUlEL2Fzc2lnbm1lbnRzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9saWN5SUQgLSBUaGUgQm94IElEIG9mIHRoZSBsZWdhbCBob2xkIHBvbGljeSB0byBnZXQgYXNzaWdubWVudHMgZm9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtMZWdhbEhvbGRQb2xpY3lBc3NpZ25tZW50VHlwZX0gW29wdGlvbnMuYXNzaWduX3RvX3R5cGVdIC0gRmlsdGVyIGFzc2lnbm1lbnRzIG9mIHRoaXMgdHlwZSBvbmx5XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYXNzaWduX3RvX2lkXSAtIEZpbHRlciBhc3NpZ25tZW50cyB0byB0aGlzIElEIG9ubHkuIE5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSBzaG93IGFzc2lnbm1lbnRzIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhpcyBlbnRpdHkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBhc3NpZ25tZW50IG9iamVjdHMgaWYgdGhleSB3ZXJlIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseSwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHBvbGljeSBhc3NpZ25tZW50c1xuICovXG5MZWdhbEhvbGRQb2xpY2llcy5wcm90b3R5cGUuZ2V0QXNzaWdubWVudHMgPSBmdW5jdGlvbihwb2xpY3lJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVNTSUdOTUVOVFNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IE9iamVjdC5hc3NpZ24oeyBwb2xpY3lfaWQ6IHBvbGljeUlEIH0sIG9wdGlvbnMpXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBc3NpZ24gYSBsZWhhbCBob2xkIHBvbGljeSB0byBhbiBvYmplY3RcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvbGVnYWxfaG9sZF9wb2xpY3lfYXNzaWdubWVudHNcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb2xpY3lJRCAtIFRoZSBJRCBvZiB0aGUgcG9saWN5IHRvIGFzc2lnblxuICogQHBhcmFtIHtMZWdhbEhvbGRQb2xpY3lBc3NpZ25tZW50VHlwZX0gYXNzaWduVHlwZSAtIFRoZSB0eXBlIG9mIG9iamVjdCB0aGUgcG9saWN5IHdpbGwgYmUgYXNzaWduZWQgdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBhc3NpZ25JRCAtIFRoZSBCb3ggSUQgb2YgdGhlIG9iamVjdCB0byBhc3NpZ24gdGhlIGxlZ2FsIGhvbGQgcG9saWN5IHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBuZXcgYXNzaWdubWVudCBvYmplY3QgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIGFzc2lnbm1lbnQgb2JqZWN0XG4gKi9cbkxlZ2FsSG9sZFBvbGljaWVzLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbihwb2xpY3lJRCwgYXNzaWduVHlwZSwgYXNzaWduSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEFTU0lHTk1FTlRTX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHtcblx0XHRcdFx0cG9saWN5X2lkOiBwb2xpY3lJRCxcblx0XHRcdFx0YXNzaWduX3RvOiB7XG5cdFx0XHRcdFx0dHlwZTogYXNzaWduVHlwZSxcblx0XHRcdFx0XHRpZDogYXNzaWduSURcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEZldGNoIGEgc3BlY2lmaWMgcG9saWN5IGFzc2lnbm1lbnRcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvbGVnYWxfaG9sZF9wb2xpY3lfYXNzaWdubWVudHMvOmFzc2lnbm1lbnRJRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFzc2lnbm1lbnRJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIHBvbGljeSBhc3NpZ25tZW50IG9iamVjdCB0byBmZXRjaFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIGFzc2lnbm1lbnQgb2JqZWN0IGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHksIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgYXNzaWdubWVudCBvYmplY3RcbiAqL1xuTGVnYWxIb2xkUG9saWNpZXMucHJvdG90eXBlLmdldEFzc2lnbm1lbnQgPSBmdW5jdGlvbihhc3NpZ25tZW50SUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEFTU0lHTk1FTlRTX1BBVEgsIGFzc2lnbm1lbnRJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNlbmRzIHJlcXVlc3QgdG8gZGVsZXRlIGFuIGV4aXN0aW5nIGxlZ2FsIGhvbGQgcG9saWN5LiBOb3RlIHRoYXQgdGhpcyBpcyBhblxuICogYXN5bmNocm9ub3VzIHByb2Nlc3MgLSB0aGUgcG9saWN5IHdpbGwgbm90IGJlIGZ1bGx5IGRlbGV0ZWQgeWV0IHdoZW4gdGhlXG4gKiByZXNwb25zZSBjb21lcyBiYWNrLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9sZWdhbF9ob2xkX3BvbGljeV9hc3NpZ25tZW50cy86YXNzaWdubWVudElEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXNzaWdubWVudElEIC0gVGhlIGxlZ2FsIGhvbGQgcG9saWN5IGFzc2lnbm1lbnQgdG8gZGVsZXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbkxlZ2FsSG9sZFBvbGljaWVzLnByb3RvdHlwZS5kZWxldGVBc3NpZ25tZW50ID0gZnVuY3Rpb24oYXNzaWdubWVudElELCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChBU1NJR05NRU5UU19QQVRILCBhc3NpZ25tZW50SUQpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmRlbCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljIGxlZ2FsIGhvbGQgcmVjb3JkIGZvciBhIGhlbGQgZmlsZSB2ZXJzaW9uLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9maWxlX3ZlcnNpb25fbGVnYWxfaG9sZHMvOmxlZ2FsSG9sZElEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGVnYWxIb2xkSUQgLSBUaGUgSUQgZm9yIHRoZSBmaWxlIGxlZ2FsIGhvbGQgcmVjb3JkIHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3MgdGhlIGZpbGUgdmVyc2lvbiBsZWdhbCBob2xkIHJlY29yZCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGxlZ2FsIGhvbGQgcmVjb3JkXG4gKi9cbkxlZ2FsSG9sZFBvbGljaWVzLnByb3RvdHlwZS5nZXRGaWxlVmVyc2lvbkxlZ2FsSG9sZCA9IGZ1bmN0aW9uKGxlZ2FsSG9sZElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChGSUxFX1ZFUlNJT05fTEVHQUxfSE9MRFNfUEFUSCwgbGVnYWxIb2xkSUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIGxlZ2FsIGhvbGQgcmVjb3JkcyBmb3IgaGVsZCBmaWxlIHZlcnNpb25zIGluIGFuIGVudGVycHJpc2UuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL2ZpbGVfdmVyc2lvbl9sZWdhbF9ob2xkcydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBvbGljeUlEIC0gSUQgb2YgTGVnYWwgSG9sZCBQb2xpY3kgdG8gZ2V0IEZpbGUgVmVyc2lvbiBMZWdhbCBIb2xkcyBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzcyB0aGUgZmlsZSB2ZXJzaW9uIGxlZ2FsIGhvbGRzIHJlY29yZHMgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGFsbCBmaWxlIHZlcnNpb24gbGVnYWwgaG9sZHNcbiAqL1xuTGVnYWxIb2xkUG9saWNpZXMucHJvdG90eXBlLmdldEFsbEZpbGVWZXJzaW9uTGVnYWxIb2xkcyA9IGZ1bmN0aW9uKHBvbGljeUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChGSUxFX1ZFUlNJT05fTEVHQUxfSE9MRFNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IE9iamVjdC5hc3NpZ24oeyBwb2xpY3lfaWQ6IHBvbGljeUlEIH0sIG9wdGlvbnMpXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZWdhbEhvbGRQb2xpY2llcztcbiJdLCJuYW1lcyI6WyJ1cmxQYXRoIiwicmVxdWlyZSIsIkJBU0VfUEFUSCIsIkFTU0lHTk1FTlRTX1BBVEgiLCJGSUxFX1ZFUlNJT05fTEVHQUxfSE9MRFNfUEFUSCIsIkxlZ2FsSG9sZFBvbGljaWVzIiwiY2xpZW50IiwicHJvdG90eXBlIiwiYXNzaWdubWVudFR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiRk9MREVSIiwiVVNFUiIsIkZJTEUiLCJGSUxFX1ZFUlNJT04iLCJjcmVhdGUiLCJuYW1lIiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYXBpUGF0aCIsInBhcmFtcyIsImJvZHkiLCJwb2xpY3lfbmFtZSIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJwb3N0IiwiZ2V0IiwicG9saWN5SUQiLCJxcyIsInVwZGF0ZSIsInVwZGF0ZXMiLCJwdXQiLCJnZXRBbGwiLCJkZWxldGUiLCJkZWwiLCJnZXRBc3NpZ25tZW50cyIsImFzc2lnbiIsInBvbGljeV9pZCIsImFzc2lnblR5cGUiLCJhc3NpZ25JRCIsImFzc2lnbl90byIsInR5cGUiLCJpZCIsImdldEFzc2lnbm1lbnQiLCJhc3NpZ25tZW50SUQiLCJkZWxldGVBc3NpZ25tZW50IiwiZ2V0RmlsZVZlcnNpb25MZWdhbEhvbGQiLCJsZWdhbEhvbGRJRCIsImdldEFsbEZpbGVWZXJzaW9uTGVnYWxIb2xkcyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/legal-hold-policies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/metadata.js":
/*!************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/metadata.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Metadata Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/** @typedef {string} MetadataFieldType */ /**\n * Metadata enum option\n * @typedef {Object} MetadataEnumOption\n * @property {string} key The option value\n */ /**\n * Field definition for a metadata template\n * @typedef {Object} MetadataTemplateField\n * @property {MetadataFieldType} type The type of the field\n * @property {string} key The programmatic name of the field\n * @property {string} displayName The display name of the field\n * @property {MetadataEnumOption[]} [options] For enum fields, the options\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), merge = __webpack_require__(/*! merge-options */ \"(rsc)/./node_modules/merge-options/index.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar PROPERTIES_TEMPLATE = \"properties\", BASE_PATH = \"/metadata_templates\", SCHEMA_SUBRESOURCE = \"schema\", ENTERPRISE_SCOPE = \"enterprise\", GLOBAL_SCOPE = \"global\", CASCADE_POLICIES_PATH = \"/metadata_cascade_policies\", QUERY_PATH = \"/metadata_queries/execute_read\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all metadata endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Metadata(client) {\n    this.client = client;\n}\nMetadata.prototype = {\n    templates: {\n        PROPERTIES: PROPERTIES_TEMPLATE\n    },\n    scopes: {\n        ENTERPRISE: ENTERPRISE_SCOPE,\n        GLOBAL: GLOBAL_SCOPE\n    },\n    cascadeResolution: Object.freeze({\n        PRESERVE_EXISTING: \"none\",\n        OVERWRITE: \"overwrite\"\n    }),\n    /**\n\t * Valid metadata field types\n\t * @readonly\n\t * @enum {MetadataFieldType}\n\t */ fieldTypes: Object.freeze({\n        STRING: \"string\",\n        ENUM: \"enum\",\n        NUMBER: \"float\",\n        DATE: \"date\",\n        MULTI_SELECT: \"multiSelect\"\n    }),\n    /**\n\t * Retrieve the schema definition for a metadata template\n\t *\n\t * API Endpoint: '/metadata_templates/:scope/:template'\n\t * Method: GET\n\t *\n\t * @param {string} scope - The scope of the template, e.g. \"enterprise\"\n\t * @param {string} template - The template to retrieve\n\t * @param {Function} [callback] - Called with the template schema if successful\n\t * @returns {Promise<Object>} A promise resolving to the template schema\n\t */ getTemplateSchema (scope, template, callback) {\n        var apiPath = urlPath(BASE_PATH, scope, template, SCHEMA_SUBRESOURCE);\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n    },\n    /**\n\t * Retrieve the schema definition for a metadata template by ID\n\t *\n\t * API Endpoint: '/metadata_templates/:id'\n\t * Method: GET\n\t *\n\t * @param {string} templateID - The ID of the template to retrieve\n\t * @param {Function} [callback] - Called with the template schema if successful\n\t * @returns {Promise<Object>} A promise resolving to the template schema\n\t */ getTemplateByID (templateID, callback) {\n        var apiPath = urlPath(BASE_PATH, templateID);\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n    },\n    /**\n\t * Get all templates in a given scope\n\t *\n\t * API Endpoint: '/metadata_templates/:scope'\n\t * Method: GET\n\t *\n\t * @param {string} scope - The scope to retrieve templates for\n\t * @param {Function} [callback] - Called with an array of templates when successful\n\t * @returns {Promise<Object>} A promise resolving to the collection of templates\n\t */ getTemplates (scope, callback) {\n        var apiPath = urlPath(BASE_PATH, scope);\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n    },\n    /**\n\t * Create a new metadata template\n\t *\n\t * API Endpoint: '/metadata_templates/schema',\n\t * Method: POST\n\t *\n\t * @param {string} templateName - The name of the metadata template\n\t * @param {MetadataTemplateField[]} fields - A list of fields for the template\n\t * @param {Object} [options] - Optional parameters, can be left null in many cases\n\t * @param {string} [options.templateKey] - The programmatic key for the template\n\t * @param {boolean} [options.hidden] - Whether the template should be hidden in the UI\n\t * @param {string} [options.scope=enterprise] - The scope for the template, only 'enterprise' is supported for now\n\t * @param {boolean} [options.copyInstanceOnItemCopy] - Whether to include the metadata when a file or folder is copied\n\t * @param {Function} [callback] - Passed the template if successful, error otherwise\n\t * @returns {Promise<Object>} A promise resolving to the created template\n\t */ createTemplate (templateName, fields, options, callback) {\n        var apiPath = urlPath(BASE_PATH, SCHEMA_SUBRESOURCE), params = {\n            body: {\n                scope: ENTERPRISE_SCOPE,\n                displayName: templateName,\n                fields\n            }\n        };\n        Object.assign(params.body, options);\n        return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n    },\n    /**\n\t * Update a metadata template via one or more non-breaking operations.  Each\n\t * operation is a an object descrbing one change to the template or its\n\t * fields.\n\t *\n\t * API Endpoint: '/metadata_templates/:scope/:template/schema'\n\t * Method: PUT\n\t *\n\t * @param {string} scope - The scope of the template to modify\n\t * @param {string} template - The template to modify\n\t * @param {Object[]} operations - The operations to perform\n\t * @param {Function} [callback] - Passed the updated template if successful, error otherwise\n\t * @returns {Promise<Object>} A promise resolving to the updated template\n\t * @see {@link https://developer.box.com/en/reference/put-metadata-templates-id-id-schema/}\n\t */ updateTemplate (scope, template, operations, callback) {\n        var apiPath = urlPath(BASE_PATH, scope, template, SCHEMA_SUBRESOURCE), params = {\n            body: operations\n        };\n        return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n    },\n    /**\n\t * Delete a metadata template from an enterprise.\n\t *\n\t * API Endpoint: '/metadata_templates/:scope/:template/schema'\n\t * Method: DELETE\n\t *\n\t * @param {string} scope - The scope of the template to delete\n\t * @param {string} template - The template to delete\n\t * @param {Function} [callback] - Passed empty response body if successful, err otherwise\n\t * @returns {Promise<void>} A promise resolving to nothing\n\t * @see {@link https://developer.box.com/en/reference/delete-metadata-templates-id-id-schema/}\n\t */ deleteTemplate (scope, template, callback) {\n        var apiPath = urlPath(BASE_PATH, scope, template, SCHEMA_SUBRESOURCE);\n        return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n    },\n    /**\n\t * Get the cascade policies associated with a given folder.\n\t *\n\t * API Endpoint: '/metadata_cascade_policies'\n\t * Method: GET\n\t *\n\t * @param {string} folderID The ID of the folder to get cascade policies for\n\t * @param {Object} [options] Optional parameters\n\t * @param {string} [options.owner_enterprise_id] ID of the enterprise to get policies for\n\t * @param {Function} [callback] Passed the collection of policies if successful\n\t * @returns {Promise<Object>} Promise resolving to the collection of policies\n\t */ getCascadePolicies (folderID, options, callback) {\n        var apiPath = urlPath(CASCADE_POLICIES_PATH), params = {\n            qs: Object.assign({\n                folder_id: folderID\n            }, options)\n        };\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n    },\n    /**\n\t * Get a metadata cascade policy object by ID\n\t *\n\t * API Endpoint: '/metadata_cascade_policies/:policyID'\n\t * Method: GET\n\t *\n\t * @param {string} policyID The ID of the policy to retrieve\n\t * @param {Function} [callback] Passed the cascade policy if successful\n\t * @returns {Promise<Object>} Promise resolving to the cascade policy\n\t */ getCascadePolicy (policyID, callback) {\n        var apiPath = urlPath(CASCADE_POLICIES_PATH, policyID);\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n    },\n    /**\n\t * Add a new cascade policy to a folder/metadata template, causing the\n\t * metadata template to be applied to all items and subfolders inside the\n\t * folder.\n\t *\n\t * API Endpoint: '/metadata_cascade_policies'\n\t * Method: POST\n\t *\n\t * @param {string} scope Metadata template scope for the template to cascade\n\t * @param {string} templateKey Metadata template key for the template to cascade\n\t * @param {string} folderID The ID of the folder to cascade over\n\t * @param {Function} [callback] Passed the cascade policy if successful\n\t * @returns {Promise<Object>} Promise resolving to the cascade policy\n\t */ createCascadePolicy (scope, templateKey, folderID, callback) {\n        var apiPath = urlPath(CASCADE_POLICIES_PATH), params = {\n            body: {\n                folder_id: folderID,\n                scope,\n                templateKey\n            }\n        };\n        return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n    },\n    /**\n\t * Delete the metadata cascade policy with the given ID\n\t *\n\t * API Endpoint: '/metadata_cascade_policies/:policyID'\n\t * Method: DELETE\n\t *\n\t * @param {string} policyID The ID of the policy to delete\n\t * @param {Function} [callback] Passed nothing if successful\n\t * @returns {Promise<void>} Promise resolving to nothing\n\t */ deleteCascadePolicy (policyID, callback) {\n        var apiPath = urlPath(CASCADE_POLICIES_PATH, policyID);\n        return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n    },\n    /**\n\t * If a policy already exists on a folder, this will apply that policy to all existing files and\n\t * sub-folders within the target folder.\n\t *\n\t * API Endpoint: '/metadata_cascade_policies/:policyID/apply'\n\t * Method: POST\n\t *\n\t * @param {string} policyID The ID of the policy to delete\n\t * @param {string} resolutionMethod How to resolve conflicts, either \"none\" or \"overwrite\"\n\t * @param {Function} [callback] Passed nothing if successful\n\t * @returns {Promise<void>} Promise resolving to nothing\n\t */ forceApplyCascadePolicy (policyID, resolutionMethod, callback) {\n        var apiPath = urlPath(CASCADE_POLICIES_PATH, policyID, \"apply\"), params = {\n            body: {\n                conflict_resolution: resolutionMethod\n            }\n        };\n        return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n    },\n    /**\n\t * Query Box items by their metadata\n\t *\n\t * API Endpoint: '/metadata_queries/execute_read'\n\t * Method: POST\n\t *\n\t * @param {string} from - The template used in the query. Must be in the form scope.templateKey\n\t * @param {string} ancestorFolderId - The folder_id to which to restrain the query\n\t * @param {Object} options - Optional parameters\n\t * @param {string} [options.query] - The logical expression of the query\n\t * @param {Object} [options.query_parameters] - Required if query present. The arguments for the query\n\t * @param {string} [options.index_name] - The name of the Index to use\n\t * @param {Object} [options.order_by] - The field_key(s) to order on and the corresponding direction(s)\n\t * @param {Array} [options.fields] - An array of fields to return\n\t * @param {Function} [callback] - Passed a collection of items and their associated metadata\n\t * @returns {Promise<void>} Promise resolving to a collection of items and their associated metadata\n\t */ query (from, ancestorFolderId, options, callback) {\n        var body = {\n            from,\n            ancestor_folder_id: ancestorFolderId\n        };\n        var params = {\n            body: merge(body, options)\n        };\n        return this.client.wrapWithDefaultHandler(this.client.post)(QUERY_PATH, params, callback);\n    }\n};\nmodule.exports = Metadata;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9tZXRhZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEYsd0NBQXdDLEdBRXhDOzs7O0NBSUMsR0FFRDs7Ozs7OztDQU9DLEdBRUQsZ0ZBQWdGO0FBQ2hGLGVBQWU7QUFDZixnRkFBZ0Y7QUFDaEYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUMsbUZBQ3JCQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUVqQixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUNoRixJQUFJRSxzQkFBc0IsY0FDekJDLFlBQVksdUJBQ1pDLHFCQUFxQixVQUNyQkMsbUJBQW1CLGNBQ25CQyxlQUFlLFVBQ2ZDLHdCQUF3Qiw4QkFDeEJDLGFBQWE7QUFFZCxnRkFBZ0Y7QUFDaEYsU0FBUztBQUNULGdGQUFnRjtBQUVoRjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxTQUFTQyxNQUFNO0lBQ3ZCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBR0FELFNBQVNFLFNBQVMsR0FBRztJQUVwQkMsV0FBVztRQUNWQyxZQUFZWDtJQUNiO0lBRUFZLFFBQVE7UUFDUEMsWUFBWVY7UUFDWlcsUUFBUVY7SUFDVDtJQUVBVyxtQkFBbUJDLE9BQU9DLE1BQU0sQ0FBQztRQUNoQ0MsbUJBQW1CO1FBQ25CQyxXQUFXO0lBQ1o7SUFFQTs7OztFQUlDLEdBQ0RDLFlBQVlKLE9BQU9DLE1BQU0sQ0FBQztRQUN6QkksUUFBUTtRQUNSQyxNQUFNO1FBQ05DLFFBQVE7UUFDUkMsTUFBTTtRQUNOQyxjQUFjO0lBQ2Y7SUFFQTs7Ozs7Ozs7OztFQVVDLEdBQ0RDLG1CQUFrQkMsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLFFBQVE7UUFFMUMsSUFBSUMsVUFBVWpDLFFBQVFJLFdBQVcwQixPQUFPQyxVQUFVMUI7UUFDbEQsT0FBTyxJQUFJLENBQUNNLE1BQU0sQ0FBQ3VCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3dCLEdBQUcsRUFBRUYsU0FBUyxNQUFNRDtJQUMzRTtJQUVBOzs7Ozs7Ozs7RUFTQyxHQUNESSxpQkFBZ0JDLFVBQVUsRUFBRUwsUUFBUTtRQUVuQyxJQUFJQyxVQUFVakMsUUFBUUksV0FBV2lDO1FBQ2pDLE9BQU8sSUFBSSxDQUFDMUIsTUFBTSxDQUFDdUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDdkIsTUFBTSxDQUFDd0IsR0FBRyxFQUFFRixTQUFTLE1BQU1EO0lBQzNFO0lBRUE7Ozs7Ozs7OztFQVNDLEdBQ0RNLGNBQWFSLEtBQUssRUFBRUUsUUFBUTtRQUUzQixJQUFJQyxVQUFVakMsUUFBUUksV0FBVzBCO1FBQ2pDLE9BQU8sSUFBSSxDQUFDbkIsTUFBTSxDQUFDdUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDdkIsTUFBTSxDQUFDd0IsR0FBRyxFQUFFRixTQUFTLE1BQU1EO0lBQzNFO0lBRUE7Ozs7Ozs7Ozs7Ozs7OztFQWVDLEdBQ0RPLGdCQUFlQyxZQUFZLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFVixRQUFRO1FBRXJELElBQUlDLFVBQVVqQyxRQUFRSSxXQUFXQyxxQkFDaENzQyxTQUFTO1lBQ1JDLE1BQU07Z0JBQ0xkLE9BQU94QjtnQkFDUHVDLGFBQWFMO2dCQUNiQztZQUNEO1FBQ0Q7UUFFRHRCLE9BQU8yQixNQUFNLENBQUNILE9BQU9DLElBQUksRUFBRUY7UUFFM0IsT0FBTyxJQUFJLENBQUMvQixNQUFNLENBQUN1QixzQkFBc0IsQ0FBQyxJQUFJLENBQUN2QixNQUFNLENBQUNvQyxJQUFJLEVBQUVkLFNBQVNVLFFBQVFYO0lBQzlFO0lBRUE7Ozs7Ozs7Ozs7Ozs7O0VBY0MsR0FDRGdCLGdCQUFlbEIsS0FBSyxFQUFFQyxRQUFRLEVBQUVrQixVQUFVLEVBQUVqQixRQUFRO1FBRW5ELElBQUlDLFVBQVVqQyxRQUFRSSxXQUFXMEIsT0FBT0MsVUFBVTFCLHFCQUNqRHNDLFNBQVM7WUFDUkMsTUFBTUs7UUFDUDtRQUVELE9BQU8sSUFBSSxDQUFDdEMsTUFBTSxDQUFDdUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDdkIsTUFBTSxDQUFDdUMsR0FBRyxFQUFFakIsU0FBU1UsUUFBUVg7SUFDN0U7SUFFQTs7Ozs7Ozs7Ozs7RUFXQyxHQUNEbUIsZ0JBQWVyQixLQUFLLEVBQUVDLFFBQVEsRUFBRUMsUUFBUTtRQUV2QyxJQUFJQyxVQUFVakMsUUFBUUksV0FBVzBCLE9BQU9DLFVBQVUxQjtRQUNsRCxPQUFPLElBQUksQ0FBQ00sTUFBTSxDQUFDdUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDdkIsTUFBTSxDQUFDeUMsR0FBRyxFQUFFbkIsU0FBUyxNQUFNRDtJQUMzRTtJQUVBOzs7Ozs7Ozs7OztFQVdDLEdBQ0RxQixvQkFBbUJDLFFBQVEsRUFBRVosT0FBTyxFQUFFVixRQUFRO1FBRTdDLElBQUlDLFVBQVVqQyxRQUFRUSx3QkFDckJtQyxTQUFTO1lBQ1JZLElBQUlwQyxPQUFPMkIsTUFBTSxDQUFDO2dCQUFFVSxXQUFXRjtZQUFTLEdBQUdaO1FBQzVDO1FBRUQsT0FBTyxJQUFJLENBQUMvQixNQUFNLENBQUN1QixzQkFBc0IsQ0FBQyxJQUFJLENBQUN2QixNQUFNLENBQUN3QixHQUFHLEVBQUVGLFNBQVNVLFFBQVFYO0lBQzdFO0lBRUE7Ozs7Ozs7OztFQVNDLEdBQ0R5QixrQkFBaUJDLFFBQVEsRUFBRTFCLFFBQVE7UUFFbEMsSUFBSUMsVUFBVWpDLFFBQVFRLHVCQUF1QmtEO1FBRTdDLE9BQU8sSUFBSSxDQUFDL0MsTUFBTSxDQUFDdUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDdkIsTUFBTSxDQUFDd0IsR0FBRyxFQUFFRixTQUFTLE1BQU1EO0lBQzNFO0lBRUE7Ozs7Ozs7Ozs7Ozs7RUFhQyxHQUNEMkIscUJBQW9CN0IsS0FBSyxFQUFFOEIsV0FBVyxFQUFFTixRQUFRLEVBQUV0QixRQUFRO1FBRXpELElBQUlDLFVBQVVqQyxRQUFRUSx3QkFDckJtQyxTQUFTO1lBQ1JDLE1BQU07Z0JBQ0xZLFdBQVdGO2dCQUNYeEI7Z0JBQ0E4QjtZQUNEO1FBQ0Q7UUFFRCxPQUFPLElBQUksQ0FBQ2pELE1BQU0sQ0FBQ3VCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ29DLElBQUksRUFBRWQsU0FBU1UsUUFBUVg7SUFDOUU7SUFFQTs7Ozs7Ozs7O0VBU0MsR0FDRDZCLHFCQUFvQkgsUUFBUSxFQUFFMUIsUUFBUTtRQUVyQyxJQUFJQyxVQUFVakMsUUFBUVEsdUJBQXVCa0Q7UUFDN0MsT0FBTyxJQUFJLENBQUMvQyxNQUFNLENBQUN1QixzQkFBc0IsQ0FBQyxJQUFJLENBQUN2QixNQUFNLENBQUN5QyxHQUFHLEVBQUVuQixTQUFTLE1BQU1EO0lBQzNFO0lBRUE7Ozs7Ozs7Ozs7O0VBV0MsR0FDRDhCLHlCQUF3QkosUUFBUSxFQUFFSyxnQkFBZ0IsRUFBRS9CLFFBQVE7UUFFM0QsSUFBSUMsVUFBVWpDLFFBQVFRLHVCQUF1QmtELFVBQVUsVUFDdERmLFNBQVM7WUFDUkMsTUFBTTtnQkFDTG9CLHFCQUFxQkQ7WUFDdEI7UUFDRDtRQUVELE9BQU8sSUFBSSxDQUFDcEQsTUFBTSxDQUFDdUIsc0JBQXNCLENBQUMsSUFBSSxDQUFDdkIsTUFBTSxDQUFDb0MsSUFBSSxFQUFFZCxTQUFTVSxRQUFRWDtJQUM5RTtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JDLEdBQ0RpQyxPQUFNQyxJQUFJLEVBQUVDLGdCQUFnQixFQUFFekIsT0FBTyxFQUFFVixRQUFRO1FBQzlDLElBQUlZLE9BQU87WUFDVnNCO1lBQ0FFLG9CQUFvQkQ7UUFDckI7UUFFQSxJQUFJeEIsU0FBUztZQUNaQyxNQUFNMUMsTUFBTTBDLE1BQU1GO1FBQ25CO1FBRUEsT0FBTyxJQUFJLENBQUMvQixNQUFNLENBQUN1QixzQkFBc0IsQ0FBQyxJQUFJLENBQUN2QixNQUFNLENBQUNvQyxJQUFJLEVBQUV0QyxZQUFZa0MsUUFBUVg7SUFDakY7QUFDRDtBQUVBcUMsT0FBT0MsT0FBTyxHQUFHNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL21ldGFkYXRhLmpzPzYzOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBCb3ggTWV0YWRhdGEgUmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlZGVmc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqIEB0eXBlZGVmIHtzdHJpbmd9IE1ldGFkYXRhRmllbGRUeXBlICovXG5cbi8qKlxuICogTWV0YWRhdGEgZW51bSBvcHRpb25cbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhRW51bU9wdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleSBUaGUgb3B0aW9uIHZhbHVlXG4gKi9cblxuLyoqXG4gKiBGaWVsZCBkZWZpbml0aW9uIGZvciBhIG1ldGFkYXRhIHRlbXBsYXRlXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhZGF0YVRlbXBsYXRlRmllbGRcbiAqIEBwcm9wZXJ0eSB7TWV0YWRhdGFGaWVsZFR5cGV9IHR5cGUgVGhlIHR5cGUgb2YgdGhlIGZpZWxkXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5IFRoZSBwcm9ncmFtbWF0aWMgbmFtZSBvZiB0aGUgZmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkaXNwbGF5TmFtZSBUaGUgZGlzcGxheSBuYW1lIG9mIHRoZSBmaWVsZFxuICogQHByb3BlcnR5IHtNZXRhZGF0YUVudW1PcHRpb25bXX0gW29wdGlvbnNdIEZvciBlbnVtIGZpZWxkcywgdGhlIG9wdGlvbnNcbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyksXG5cdG1lcmdlID0gcmVxdWlyZSgnbWVyZ2Utb3B0aW9ucycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBQUk9QRVJUSUVTX1RFTVBMQVRFID0gJ3Byb3BlcnRpZXMnLFxuXHRCQVNFX1BBVEggPSAnL21ldGFkYXRhX3RlbXBsYXRlcycsXG5cdFNDSEVNQV9TVUJSRVNPVVJDRSA9ICdzY2hlbWEnLFxuXHRFTlRFUlBSSVNFX1NDT1BFID0gJ2VudGVycHJpc2UnLFxuXHRHTE9CQUxfU0NPUEUgPSAnZ2xvYmFsJyxcblx0Q0FTQ0FERV9QT0xJQ0lFU19QQVRIID0gJy9tZXRhZGF0YV9jYXNjYWRlX3BvbGljaWVzJyxcblx0UVVFUllfUEFUSCA9ICcvbWV0YWRhdGFfcXVlcmllcy9leGVjdXRlX3JlYWQnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIGFsbCBtZXRhZGF0YSBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gTWV0YWRhdGEoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG5cbk1ldGFkYXRhLnByb3RvdHlwZSA9IHtcblxuXHR0ZW1wbGF0ZXM6IHtcblx0XHRQUk9QRVJUSUVTOiBQUk9QRVJUSUVTX1RFTVBMQVRFXG5cdH0sXG5cblx0c2NvcGVzOiB7XG5cdFx0RU5URVJQUklTRTogRU5URVJQUklTRV9TQ09QRSxcblx0XHRHTE9CQUw6IEdMT0JBTF9TQ09QRVxuXHR9LFxuXG5cdGNhc2NhZGVSZXNvbHV0aW9uOiBPYmplY3QuZnJlZXplKHtcblx0XHRQUkVTRVJWRV9FWElTVElORzogJ25vbmUnLFxuXHRcdE9WRVJXUklURTogJ292ZXJ3cml0ZSdcblx0fSksXG5cblx0LyoqXG5cdCAqIFZhbGlkIG1ldGFkYXRhIGZpZWxkIHR5cGVzXG5cdCAqIEByZWFkb25seVxuXHQgKiBAZW51bSB7TWV0YWRhdGFGaWVsZFR5cGV9XG5cdCAqL1xuXHRmaWVsZFR5cGVzOiBPYmplY3QuZnJlZXplKHtcblx0XHRTVFJJTkc6ICdzdHJpbmcnLFxuXHRcdEVOVU06ICdlbnVtJyxcblx0XHROVU1CRVI6ICdmbG9hdCcsXG5cdFx0REFURTogJ2RhdGUnLFxuXHRcdE1VTFRJX1NFTEVDVDogJ211bHRpU2VsZWN0J1xuXHR9KSxcblxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIHNjaGVtYSBkZWZpbml0aW9uIGZvciBhIG1ldGFkYXRhIHRlbXBsYXRlXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV90ZW1wbGF0ZXMvOnNjb3BlLzp0ZW1wbGF0ZSdcblx0ICogTWV0aG9kOiBHRVRcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlIC0gVGhlIHNjb3BlIG9mIHRoZSB0ZW1wbGF0ZSwgZS5nLiBcImVudGVycHJpc2VcIlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGUgLSBUaGUgdGVtcGxhdGUgdG8gcmV0cmlldmVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIHRoZSB0ZW1wbGF0ZSBzY2hlbWEgaWYgc3VjY2Vzc2Z1bFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZW1wbGF0ZSBzY2hlbWFcblx0ICovXG5cdGdldFRlbXBsYXRlU2NoZW1hKHNjb3BlLCB0ZW1wbGF0ZSwgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHNjb3BlLCB0ZW1wbGF0ZSwgU0NIRU1BX1NVQlJFU09VUkNFKTtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIHNjaGVtYSBkZWZpbml0aW9uIGZvciBhIG1ldGFkYXRhIHRlbXBsYXRlIGJ5IElEXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV90ZW1wbGF0ZXMvOmlkJ1xuXHQgKiBNZXRob2Q6IEdFVFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVJRCAtIFRoZSBJRCBvZiB0aGUgdGVtcGxhdGUgdG8gcmV0cmlldmVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aXRoIHRoZSB0ZW1wbGF0ZSBzY2hlbWEgaWYgc3VjY2Vzc2Z1bFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZW1wbGF0ZSBzY2hlbWFcblx0ICovXG5cdGdldFRlbXBsYXRlQnlJRCh0ZW1wbGF0ZUlELCBjYWxsYmFjaykge1xuXG5cdFx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgdGVtcGxhdGVJRCk7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbGwgdGVtcGxhdGVzIGluIGEgZ2l2ZW4gc2NvcGVcblx0ICpcblx0ICogQVBJIEVuZHBvaW50OiAnL21ldGFkYXRhX3RlbXBsYXRlcy86c2NvcGUnXG5cdCAqIE1ldGhvZDogR0VUXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIFRoZSBzY29wZSB0byByZXRyaWV2ZSB0ZW1wbGF0ZXMgZm9yXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBDYWxsZWQgd2l0aCBhbiBhcnJheSBvZiB0ZW1wbGF0ZXMgd2hlbiBzdWNjZXNzZnVsXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgdGVtcGxhdGVzXG5cdCAqL1xuXHRnZXRUZW1wbGF0ZXMoc2NvcGUsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBzY29wZSk7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBtZXRhZGF0YSB0ZW1wbGF0ZVxuXHQgKlxuXHQgKiBBUEkgRW5kcG9pbnQ6ICcvbWV0YWRhdGFfdGVtcGxhdGVzL3NjaGVtYScsXG5cdCAqIE1ldGhvZDogUE9TVFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1ldGFkYXRhIHRlbXBsYXRlXG5cdCAqIEBwYXJhbSB7TWV0YWRhdGFUZW1wbGF0ZUZpZWxkW119IGZpZWxkcyAtIEEgbGlzdCBvZiBmaWVsZHMgZm9yIHRoZSB0ZW1wbGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbCBpbiBtYW55IGNhc2VzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50ZW1wbGF0ZUtleV0gLSBUaGUgcHJvZ3JhbW1hdGljIGtleSBmb3IgdGhlIHRlbXBsYXRlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGlkZGVuXSAtIFdoZXRoZXIgdGhlIHRlbXBsYXRlIHNob3VsZCBiZSBoaWRkZW4gaW4gdGhlIFVJXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zY29wZT1lbnRlcnByaXNlXSAtIFRoZSBzY29wZSBmb3IgdGhlIHRlbXBsYXRlLCBvbmx5ICdlbnRlcnByaXNlJyBpcyBzdXBwb3J0ZWQgZm9yIG5vd1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvcHlJbnN0YW5jZU9uSXRlbUNvcHldIC0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBtZXRhZGF0YSB3aGVuIGEgZmlsZSBvciBmb2xkZXIgaXMgY29waWVkXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHRlbXBsYXRlIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIHRlbXBsYXRlXG5cdCAqL1xuXHRjcmVhdGVUZW1wbGF0ZSh0ZW1wbGF0ZU5hbWUsIGZpZWxkcywgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIFNDSEVNQV9TVUJSRVNPVVJDRSksXG5cdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdGJvZHk6IHtcblx0XHRcdFx0XHRzY29wZTogRU5URVJQUklTRV9TQ09QRSxcblx0XHRcdFx0XHRkaXNwbGF5TmFtZTogdGVtcGxhdGVOYW1lLFxuXHRcdFx0XHRcdGZpZWxkc1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0T2JqZWN0LmFzc2lnbihwYXJhbXMuYm9keSwgb3B0aW9ucyk7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIGEgbWV0YWRhdGEgdGVtcGxhdGUgdmlhIG9uZSBvciBtb3JlIG5vbi1icmVha2luZyBvcGVyYXRpb25zLiAgRWFjaFxuXHQgKiBvcGVyYXRpb24gaXMgYSBhbiBvYmplY3QgZGVzY3JiaW5nIG9uZSBjaGFuZ2UgdG8gdGhlIHRlbXBsYXRlIG9yIGl0c1xuXHQgKiBmaWVsZHMuXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV90ZW1wbGF0ZXMvOnNjb3BlLzp0ZW1wbGF0ZS9zY2hlbWEnXG5cdCAqIE1ldGhvZDogUFVUXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIFRoZSBzY29wZSBvZiB0aGUgdGVtcGxhdGUgdG8gbW9kaWZ5XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSAtIFRoZSB0ZW1wbGF0ZSB0byBtb2RpZnlcblx0ICogQHBhcmFtIHtPYmplY3RbXX0gb3BlcmF0aW9ucyAtIFRoZSBvcGVyYXRpb25zIHRvIHBlcmZvcm1cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBkYXRlZCB0ZW1wbGF0ZSBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2Vcblx0ICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCB0ZW1wbGF0ZVxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5ib3guY29tL2VuL3JlZmVyZW5jZS9wdXQtbWV0YWRhdGEtdGVtcGxhdGVzLWlkLWlkLXNjaGVtYS99XG5cdCAqL1xuXHR1cGRhdGVUZW1wbGF0ZShzY29wZSwgdGVtcGxhdGUsIG9wZXJhdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBzY29wZSwgdGVtcGxhdGUsIFNDSEVNQV9TVUJSRVNPVVJDRSksXG5cdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdGJvZHk6IG9wZXJhdGlvbnNcblx0XHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWxldGUgYSBtZXRhZGF0YSB0ZW1wbGF0ZSBmcm9tIGFuIGVudGVycHJpc2UuXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV90ZW1wbGF0ZXMvOnNjb3BlLzp0ZW1wbGF0ZS9zY2hlbWEnXG5cdCAqIE1ldGhvZDogREVMRVRFXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIFRoZSBzY29wZSBvZiB0aGUgdGVtcGxhdGUgdG8gZGVsZXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZSAtIFRoZSB0ZW1wbGF0ZSB0byBkZWxldGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCBlbXB0eSByZXNwb25zZSBib2R5IGlmIHN1Y2Nlc3NmdWwsIGVyciBvdGhlcndpc2Vcblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuXHQgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5ib3guY29tL2VuL3JlZmVyZW5jZS9kZWxldGUtbWV0YWRhdGEtdGVtcGxhdGVzLWlkLWlkLXNjaGVtYS99XG5cdCAqL1xuXHRkZWxldGVUZW1wbGF0ZShzY29wZSwgdGVtcGxhdGUsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBzY29wZSwgdGVtcGxhdGUsIFNDSEVNQV9TVUJSRVNPVVJDRSk7XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgY2FzY2FkZSBwb2xpY2llcyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBmb2xkZXIuXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV9jYXNjYWRlX3BvbGljaWVzJ1xuXHQgKiBNZXRob2Q6IEdFVFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVySUQgVGhlIElEIG9mIHRoZSBmb2xkZXIgdG8gZ2V0IGNhc2NhZGUgcG9saWNpZXMgZm9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub3duZXJfZW50ZXJwcmlzZV9pZF0gSUQgb2YgdGhlIGVudGVycHJpc2UgdG8gZ2V0IHBvbGljaWVzIGZvclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgY29sbGVjdGlvbiBvZiBwb2xpY2llcyBpZiBzdWNjZXNzZnVsXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHBvbGljaWVzXG5cdCAqL1xuXHRnZXRDYXNjYWRlUG9saWNpZXMoZm9sZGVySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQ0FTQ0FERV9QT0xJQ0lFU19QQVRIKSxcblx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0cXM6IE9iamVjdC5hc3NpZ24oeyBmb2xkZXJfaWQ6IGZvbGRlcklEIH0sIG9wdGlvbnMpXG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGEgbWV0YWRhdGEgY2FzY2FkZSBwb2xpY3kgb2JqZWN0IGJ5IElEXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV9jYXNjYWRlX3BvbGljaWVzLzpwb2xpY3lJRCdcblx0ICogTWV0aG9kOiBHRVRcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBvbGljeUlEIFRoZSBJRCBvZiB0aGUgcG9saWN5IHRvIHJldHJpZXZlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIHRoZSBjYXNjYWRlIHBvbGljeSBpZiBzdWNjZXNzZnVsXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjYXNjYWRlIHBvbGljeVxuXHQgKi9cblx0Z2V0Q2FzY2FkZVBvbGljeShwb2xpY3lJRCwgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChDQVNDQURFX1BPTElDSUVTX1BBVEgsIHBvbGljeUlEKTtcblxuXHRcdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgbnVsbCwgY2FsbGJhY2spO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYSBuZXcgY2FzY2FkZSBwb2xpY3kgdG8gYSBmb2xkZXIvbWV0YWRhdGEgdGVtcGxhdGUsIGNhdXNpbmcgdGhlXG5cdCAqIG1ldGFkYXRhIHRlbXBsYXRlIHRvIGJlIGFwcGxpZWQgdG8gYWxsIGl0ZW1zIGFuZCBzdWJmb2xkZXJzIGluc2lkZSB0aGVcblx0ICogZm9sZGVyLlxuXHQgKlxuXHQgKiBBUEkgRW5kcG9pbnQ6ICcvbWV0YWRhdGFfY2FzY2FkZV9wb2xpY2llcydcblx0ICogTWV0aG9kOiBQT1NUXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSBNZXRhZGF0YSB0ZW1wbGF0ZSBzY29wZSBmb3IgdGhlIHRlbXBsYXRlIHRvIGNhc2NhZGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlS2V5IE1ldGFkYXRhIHRlbXBsYXRlIGtleSBmb3IgdGhlIHRlbXBsYXRlIHRvIGNhc2NhZGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlcklEIFRoZSBJRCBvZiB0aGUgZm9sZGVyIHRvIGNhc2NhZGUgb3ZlclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgY2FzY2FkZSBwb2xpY3kgaWYgc3VjY2Vzc2Z1bFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY2FzY2FkZSBwb2xpY3lcblx0ICovXG5cdGNyZWF0ZUNhc2NhZGVQb2xpY3koc2NvcGUsIHRlbXBsYXRlS2V5LCBmb2xkZXJJRCwgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChDQVNDQURFX1BPTElDSUVTX1BBVEgpLFxuXHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRib2R5OiB7XG5cdFx0XHRcdFx0Zm9sZGVyX2lkOiBmb2xkZXJJRCxcblx0XHRcdFx0XHRzY29wZSxcblx0XHRcdFx0XHR0ZW1wbGF0ZUtleVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlbGV0ZSB0aGUgbWV0YWRhdGEgY2FzY2FkZSBwb2xpY3kgd2l0aCB0aGUgZ2l2ZW4gSURcblx0ICpcblx0ICogQVBJIEVuZHBvaW50OiAnL21ldGFkYXRhX2Nhc2NhZGVfcG9saWNpZXMvOnBvbGljeUlEJ1xuXHQgKiBNZXRob2Q6IERFTEVURVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcG9saWN5SUQgVGhlIElEIG9mIHRoZSBwb2xpY3kgdG8gZGVsZXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuXHQgKi9cblx0ZGVsZXRlQ2FzY2FkZVBvbGljeShwb2xpY3lJRCwgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChDQVNDQURFX1BPTElDSUVTX1BBVEgsIHBvbGljeUlEKTtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcblx0ICogSWYgYSBwb2xpY3kgYWxyZWFkeSBleGlzdHMgb24gYSBmb2xkZXIsIHRoaXMgd2lsbCBhcHBseSB0aGF0IHBvbGljeSB0byBhbGwgZXhpc3RpbmcgZmlsZXMgYW5kXG5cdCAqIHN1Yi1mb2xkZXJzIHdpdGhpbiB0aGUgdGFyZ2V0IGZvbGRlci5cblx0ICpcblx0ICogQVBJIEVuZHBvaW50OiAnL21ldGFkYXRhX2Nhc2NhZGVfcG9saWNpZXMvOnBvbGljeUlEL2FwcGx5J1xuXHQgKiBNZXRob2Q6IFBPU1Rcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBvbGljeUlEIFRoZSBJRCBvZiB0aGUgcG9saWN5IHRvIGRlbGV0ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmVzb2x1dGlvbk1ldGhvZCBIb3cgdG8gcmVzb2x2ZSBjb25mbGljdHMsIGVpdGhlciBcIm5vbmVcIiBvciBcIm92ZXJ3cml0ZVwiXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gbm90aGluZ1xuXHQgKi9cblx0Zm9yY2VBcHBseUNhc2NhZGVQb2xpY3kocG9saWN5SUQsIHJlc29sdXRpb25NZXRob2QsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQ0FTQ0FERV9QT0xJQ0lFU19QQVRILCBwb2xpY3lJRCwgJ2FwcGx5JyksXG5cdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdGJvZHk6IHtcblx0XHRcdFx0XHRjb25mbGljdF9yZXNvbHV0aW9uOiByZXNvbHV0aW9uTWV0aG9kXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcblx0ICogUXVlcnkgQm94IGl0ZW1zIGJ5IHRoZWlyIG1ldGFkYXRhXG5cdCAqXG5cdCAqIEFQSSBFbmRwb2ludDogJy9tZXRhZGF0YV9xdWVyaWVzL2V4ZWN1dGVfcmVhZCdcblx0ICogTWV0aG9kOiBQT1NUXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tIC0gVGhlIHRlbXBsYXRlIHVzZWQgaW4gdGhlIHF1ZXJ5LiBNdXN0IGJlIGluIHRoZSBmb3JtIHNjb3BlLnRlbXBsYXRlS2V5XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvckZvbGRlcklkIC0gVGhlIGZvbGRlcl9pZCB0byB3aGljaCB0byByZXN0cmFpbiB0aGUgcXVlcnlcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5xdWVyeV0gLSBUaGUgbG9naWNhbCBleHByZXNzaW9uIG9mIHRoZSBxdWVyeVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucXVlcnlfcGFyYW1ldGVyc10gLSBSZXF1aXJlZCBpZiBxdWVyeSBwcmVzZW50LiBUaGUgYXJndW1lbnRzIGZvciB0aGUgcXVlcnlcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmluZGV4X25hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIEluZGV4IHRvIHVzZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3JkZXJfYnldIC0gVGhlIGZpZWxkX2tleShzKSB0byBvcmRlciBvbiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgZGlyZWN0aW9uKHMpXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmZpZWxkc10gLSBBbiBhcnJheSBvZiBmaWVsZHMgdG8gcmV0dXJuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGFuZCB0aGVpciBhc3NvY2lhdGVkIG1ldGFkYXRhXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBQcm9taXNlIHJlc29sdmluZyB0byBhIGNvbGxlY3Rpb24gb2YgaXRlbXMgYW5kIHRoZWlyIGFzc29jaWF0ZWQgbWV0YWRhdGFcblx0ICovXG5cdHF1ZXJ5KGZyb20sIGFuY2VzdG9yRm9sZGVySWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGJvZHkgPSB7XG5cdFx0XHRmcm9tLFxuXHRcdFx0YW5jZXN0b3JfZm9sZGVyX2lkOiBhbmNlc3RvckZvbGRlcklkXG5cdFx0fTtcblxuXHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiBtZXJnZShib2R5LCBvcHRpb25zKVxuXHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShRVUVSWV9QQVRILCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNZXRhZGF0YTtcbiJdLCJuYW1lcyI6WyJ1cmxQYXRoIiwicmVxdWlyZSIsIm1lcmdlIiwiUFJPUEVSVElFU19URU1QTEFURSIsIkJBU0VfUEFUSCIsIlNDSEVNQV9TVUJSRVNPVVJDRSIsIkVOVEVSUFJJU0VfU0NPUEUiLCJHTE9CQUxfU0NPUEUiLCJDQVNDQURFX1BPTElDSUVTX1BBVEgiLCJRVUVSWV9QQVRIIiwiTWV0YWRhdGEiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJ0ZW1wbGF0ZXMiLCJQUk9QRVJUSUVTIiwic2NvcGVzIiwiRU5URVJQUklTRSIsIkdMT0JBTCIsImNhc2NhZGVSZXNvbHV0aW9uIiwiT2JqZWN0IiwiZnJlZXplIiwiUFJFU0VSVkVfRVhJU1RJTkciLCJPVkVSV1JJVEUiLCJmaWVsZFR5cGVzIiwiU1RSSU5HIiwiRU5VTSIsIk5VTUJFUiIsIkRBVEUiLCJNVUxUSV9TRUxFQ1QiLCJnZXRUZW1wbGF0ZVNjaGVtYSIsInNjb3BlIiwidGVtcGxhdGUiLCJjYWxsYmFjayIsImFwaVBhdGgiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwiZ2V0IiwiZ2V0VGVtcGxhdGVCeUlEIiwidGVtcGxhdGVJRCIsImdldFRlbXBsYXRlcyIsImNyZWF0ZVRlbXBsYXRlIiwidGVtcGxhdGVOYW1lIiwiZmllbGRzIiwib3B0aW9ucyIsInBhcmFtcyIsImJvZHkiLCJkaXNwbGF5TmFtZSIsImFzc2lnbiIsInBvc3QiLCJ1cGRhdGVUZW1wbGF0ZSIsIm9wZXJhdGlvbnMiLCJwdXQiLCJkZWxldGVUZW1wbGF0ZSIsImRlbCIsImdldENhc2NhZGVQb2xpY2llcyIsImZvbGRlcklEIiwicXMiLCJmb2xkZXJfaWQiLCJnZXRDYXNjYWRlUG9saWN5IiwicG9saWN5SUQiLCJjcmVhdGVDYXNjYWRlUG9saWN5IiwidGVtcGxhdGVLZXkiLCJkZWxldGVDYXNjYWRlUG9saWN5IiwiZm9yY2VBcHBseUNhc2NhZGVQb2xpY3kiLCJyZXNvbHV0aW9uTWV0aG9kIiwiY29uZmxpY3RfcmVzb2x1dGlvbiIsInF1ZXJ5IiwiZnJvbSIsImFuY2VzdG9yRm9sZGVySWQiLCJhbmNlc3Rvcl9mb2xkZXJfaWQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/metadata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/recent-items.js":
/*!****************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/recent-items.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box RecentItem Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/recent_items\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'RecentItem' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function RecentItems(client) {\n    this.client = client;\n}\n/**\n * Requests all items that have been accessed by a user in the last 90 days or the last 1000 items accessed.\n *\n * API Endpoint: '/recent_items'\n * Method: GET\n *\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {int} [options.limit] Maximum number of items to return\n * @param {string} [options.marker] The position marker for marker-based paging\n * @param {string} [options.fields] Comma-separated list of fields to include in the response\n * @param {Function} [callback] - Passed the items information if they were acquired successfully\n * @returns {Promise<Object>} A promise resolving to the collection of items in the collection\n */ RecentItems.prototype.get = function(options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * @module box-node-sdk/lib/managers/recent-items\n * @see {@Link RecentItems}\n */ module.exports = RecentItems;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9yZWNlbnQtaXRlbXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBQ2pGLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXRCLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBQ2pGLElBQUlDLFlBQVk7QUFFaEIsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsWUFBWUMsTUFBTTtJQUMxQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNERCxZQUFZRSxTQUFTLENBQUNDLEdBQUcsR0FBRyxTQUFTQyxPQUFPLEVBQUVDLFFBQVE7SUFDckQsSUFBSUMsU0FBUztRQUNaQyxJQUFJSDtJQUNMO0lBQ0EsSUFBSUksVUFBVVgsUUFBUUU7SUFDdEIsT0FBTyxJQUFJLENBQUNFLE1BQU0sQ0FBQ1Esc0JBQXNCLENBQUMsSUFBSSxDQUFDUixNQUFNLENBQUNFLEdBQUcsRUFBRUssU0FBU0YsUUFBUUQ7QUFDN0U7QUFFQTs7O0NBR0MsR0FDREssT0FBT0MsT0FBTyxHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvcmVjZW50LWl0ZW1zLmpzP2RmZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBCb3ggUmVjZW50SXRlbSBSZXNvdXJjZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy9yZWNlbnRfaXRlbXMnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsICdSZWNlbnRJdGVtJyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gUmVjZW50SXRlbXMoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG4vKipcbiAqIFJlcXVlc3RzIGFsbCBpdGVtcyB0aGF0IGhhdmUgYmVlbiBhY2Nlc3NlZCBieSBhIHVzZXIgaW4gdGhlIGxhc3QgOTAgZGF5cyBvciB0aGUgbGFzdCAxMDAwIGl0ZW1zIGFjY2Vzc2VkLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZWNlbnRfaXRlbXMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMubGltaXRdIE1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVyblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtlcl0gVGhlIHBvc2l0aW9uIG1hcmtlciBmb3IgbWFya2VyLWJhc2VkIHBhZ2luZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpZWxkc10gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIHRvIGluY2x1ZGUgaW4gdGhlIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBpdGVtcyBpbmZvcm1hdGlvbiBpZiB0aGV5IHdlcmUgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uXG4gKi9cblJlY2VudEl0ZW1zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvcmVjZW50LWl0ZW1zXG4gKiBAc2VlIHtATGluayBSZWNlbnRJdGVtc31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBSZWNlbnRJdGVtcztcbiJdLCJuYW1lcyI6WyJ1cmxQYXRoIiwicmVxdWlyZSIsIkJBU0VfUEFUSCIsIlJlY2VudEl0ZW1zIiwiY2xpZW50IiwicHJvdG90eXBlIiwiZ2V0Iiwib3B0aW9ucyIsImNhbGxiYWNrIiwicGFyYW1zIiwicXMiLCJhcGlQYXRoIiwid3JhcFdpdGhEZWZhdWx0SGFuZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/recent-items.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/retention-policies.js":
/*!**********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/retention-policies.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Retention Policies Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Retention policy type, which specifies how long the policy should\n * remain in effect\n * @typedef {string} RetentionPolicyType\n */ /**\n * Retention policy disposition action, which specifies what should\n * be done when the retention period is over\n * @typedef {string} RetentionPolicyDispositionAction\n */ /**\n * Policy assignment types, which specify what type of object the policy applies to\n * @typedef {string} RetentionPolicyAssignmentType\n */ /**\n * Metadata template fields to filter on for assigning a retention policy\n * @typedef {Object} MetadataFilterField\n * @property {string} field The field to filter on\n * @property {string|int} value The value to filter against\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar BASE_PATH = \"/retention_policies\", ASSIGNMENTS_PATH = \"/retention_policy_assignments\", FILE_VERSION_RETENTIONS_PATH = \"/file_version_retentions\", ASSIGNMENTS_SUBRESOURCE = \"assignments\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all Retention Policies endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function RetentionPolicies(client) {\n    this.client = client;\n}\n/**\n * Enum of valid retention policy types, which specify how long the policy should\n * remain in effect.\n * @readonly\n * @enum {RetentionPolicyType}\n */ RetentionPolicies.prototype.policyTypes = Object.freeze({\n    FINITE: \"finite\",\n    INDEFINITE: \"indefinite\"\n});\n/**\n * Enum of valid retention policy disposition actions, which specify what should\n * be done when the retention period is over\n * @readonly\n * @enum {RetentionPolicyDispositionAction}\n */ RetentionPolicies.prototype.dispositionActions = Object.freeze({\n    PERMANENTLY_DELETE: \"permanently_delete\",\n    REMOVE_RETENTION: \"remove_retention\"\n});\n/**\n * Enum of valid policy assignment types, which specify what object the policy applies to\n * @readonly\n * @enum {RetentionPolicyAssignmentType}\n */ RetentionPolicies.prototype.assignmentTypes = Object.freeze({\n    FOLDER: \"folder\",\n    ENTERPRISE: \"enterprise\",\n    METADATA: \"metadata_template\"\n});\n/**\n * Used to create a single retention policy for an enterprise\n *\n * API Endpoint: '/retention_policies'\n * Method: POST\n *\n * @param {string} name - The name of the retention policy to be created\n * @param {RetentionPolicyType} type - The type of policy to create\n * @param {RetentionPolicyDispositionAction} action - The disposition action for the new policy\n * @param {Object} [options] - Additional parameters\n * @param {int} [options.retention_length] - For finite policies, the number of days to retain the content\n * @param {Function} [callback] - Passed the new policy information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the new policy object\n */ RetentionPolicies.prototype.create = function(name, type, action, options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        body: {\n            policy_name: name,\n            policy_type: type,\n            disposition_action: action\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Fetches details about a specific retention policy\n *\n * API Endpoint: '/retention_policies/:policyID'\n * Method: GET\n *\n * @param {string} policyID - The Box ID of the retention policy being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the policy information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the policy object\n */ RetentionPolicies.prototype.get = function(policyID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, policyID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Update or modify a retention policy.\n *\n * API Endpoint: '/retention_policies/:policyID'\n * Method: PUT\n *\n * @param {string} policyID - The Box ID of the retention policy to update\n * @param {Object} updates - The information to be updated\n * @param {string} [updates.policy_name] - The name of the retention policy\n * @param {RetentionPolicyDispositionAction} [updates.disposition_action] - The disposition action for the updated policy\n * @param {string} [updates.status] - Used to retire a retention policy if status is set to retired\n * @param {Function} [callback] - Passed the updated policy information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated policy object\n */ RetentionPolicies.prototype.update = function(policyID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, policyID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Fetches a list of retention policies for the enterprise\n *\n * API Endpoint: '/retention_policies\n * Method: GET\n *\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {string} [options.policy_name] - A full or partial name to filter the retention policies by\n * @param {RetentionPolicyType} [options.policy_type] - A policy type to filter the retention policies by\n * @param {string} [options.created_by_user_id] - A user id to filter the retention policies by\n * @param {Function} [callback] - Passed the policy objects if they were acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of policies\n */ RetentionPolicies.prototype.getAll = function(options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Fetch a list of assignments for a given retention policy\n *\n * API Endpoint: '/retention_policies/:policyID/assignments'\n * Method: GET\n *\n * @param {string} policyID - The Box ID of the retention policy to get assignments for\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {RetentionPolicyAssignmentType} [options.type] - The type of the retention policy assignment to retrieve\n * @param {Function} [callback] - Passed the assignment objects if they were acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of policy assignments\n */ RetentionPolicies.prototype.getAssignments = function(policyID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, policyID, ASSIGNMENTS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Assign a retention policy to a folder or the entire enterprise.\n *\n * API Endpoint: '/retention_policy_assignments\n * Method: POST\n *\n * @param {string} policyID - The ID of the policy to assign\n * @param {RetentionPolicyAssignmentType} assignType - The type of object the policy will be assigned to\n * @param {string} assignID - The Box ID of the object to assign the retention policy to\n * @param {Object} [options] - Optional parameters for the request\n * @param {MetadataFilterField[]} [options.filter_fields] - Metadata fields to filter against, if assigning to a metadata template\n * @param {Function} [callback] - Passed the new assignment object if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created assignment object\n */ RetentionPolicies.prototype.assign = function(policyID, assignType, assignID, options, callback) {\n    // Shuffle optional arguments\n    if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n    }\n    var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n        body: {\n            policy_id: policyID,\n            assign_to: {\n                type: assignType,\n                id: assignID\n            }\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Fetch a specific policy assignment\n *\n * API Endpoint: '/retention_policy_assignments/:assignmentID'\n * Method: GET\n *\n * @param {string} assignmentID - The Box ID of the policy assignment object to fetch\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the assignment object if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the assignment object\n */ RetentionPolicies.prototype.getAssignment = function(assignmentID, options, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Get the specific retention record for a retained file version. To use this feature,\n * you must have the manage retention policies scope enabled for your API key\n * via your application management console.\n *\n * API Endpoint: '/file_version_retentions/:retentionID'\n * Method: GET\n *\n * @param {string} retentionID - The ID for the file retention record to retrieve\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Pass the file version retention record if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the retention record\n */ RetentionPolicies.prototype.getFileVersionRetention = function(retentionID, options, callback) {\n    var apiPath = urlPath(FILE_VERSION_RETENTIONS_PATH, retentionID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Get a list of retention records for a retained file versions in an enterprise.\n * To use this feature, you must have the manage retention policies scope enabled\n * for your API key via your application management console.\n *\n * API Endpoint: '/file_version_retentions'\n * Method: GET\n *\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {string} [options.file_id] - A file id to filter the file version retentions by\n * @param {string} [options.file_version_id] - A file version id to filter the file version retentions by\n * @param {string} [options.policy_id] - A policy id to filter the file version retentions by\n * @param {RetentionPolicyDispositionAction} [options.disposition_action] - The disposition action of the retention policy to filter by\n * @param {string} [options.disposition_before] - Filter by retention policies which will complete before a certain time\n * @param {string} [options.disposition_after] - Filter by retention policies which will complete after a certain time\n * @param {int} [options.limit] - The maximum number of items to return in a page\n * @param {string} [options.marker] - Paging marker, left blank to begin paging from the beginning\n * @param {Function} [callback] - Pass the file version retention record if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of retention records\n */ RetentionPolicies.prototype.getAllFileVersionRetentions = function(options, callback) {\n    var apiPath = urlPath(FILE_VERSION_RETENTIONS_PATH), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\nmodule.exports = RetentionPolicies;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9yZXRlbnRpb24tcG9saWNpZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGdGQUFnRjtBQUNoRixXQUFXO0FBQ1gsZ0ZBQWdGO0FBRWhGOzs7O0NBSUMsR0FFRDs7OztDQUlDLEdBRUQ7OztDQUdDLEdBRUQ7Ozs7O0NBS0MsR0FFRCxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUNoRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV0QixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUNoRixJQUFJQyxZQUFZLHVCQUNmQyxtQkFBbUIsaUNBQ25CQywrQkFBK0IsNEJBQy9CQywwQkFBMEI7QUFFM0IsZ0ZBQWdGO0FBQ2hGLFNBQVM7QUFDVCxnRkFBZ0Y7QUFFaEY7Ozs7OztDQU1DLEdBQ0QsU0FBU0Msa0JBQWtCQyxNQUFNO0lBQ2hDLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUE7Ozs7O0NBS0MsR0FDREQsa0JBQWtCRSxTQUFTLENBQUNDLFdBQVcsR0FBR0MsT0FBT0MsTUFBTSxDQUFDO0lBQ3ZEQyxRQUFRO0lBQ1JDLFlBQVk7QUFDYjtBQUVBOzs7OztDQUtDLEdBQ0RQLGtCQUFrQkUsU0FBUyxDQUFDTSxrQkFBa0IsR0FBR0osT0FBT0MsTUFBTSxDQUFDO0lBQzlESSxvQkFBb0I7SUFDcEJDLGtCQUFrQjtBQUNuQjtBQUVBOzs7O0NBSUMsR0FDRFYsa0JBQWtCRSxTQUFTLENBQUNTLGVBQWUsR0FBR1AsT0FBT0MsTUFBTSxDQUFDO0lBQzNETyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsVUFBVTtBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNEZCxrQkFBa0JFLFNBQVMsQ0FBQ2EsTUFBTSxHQUFHLFNBQVNDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUNsRixJQUFJ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QVM7UUFDUlUsSUFBSWI7SUFDTDtJQUVELE9BQU8sSUFBSSxDQUFDbEIsTUFBTSxDQUFDMkIsc0JBQXNCLENBQUMsSUFBSSxDQUFDM0IsTUFBTSxDQUFDNkIsR0FBRyxFQUFFVCxTQUFTQyxRQUFRRjtBQUM3RTtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEcEIsa0JBQWtCRSxTQUFTLENBQUMyQyx1QkFBdUIsR0FBRyxTQUFTQyxXQUFXLEVBQUUzQixPQUFPLEVBQUVDLFFBQVE7SUFFNUYsSUFBSUMsVUFBVTNCLFFBQVFJLDhCQUE4QmdELGNBQ25EeEIsU0FBUztRQUNSVSxJQUFJYjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNsQixNQUFNLENBQUMyQixzQkFBc0IsQ0FBQyxJQUFJLENBQUMzQixNQUFNLENBQUM2QixHQUFHLEVBQUVULFNBQVNDLFFBQVFGO0FBQzdFO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDRHBCLGtCQUFrQkUsU0FBUyxDQUFDNkMsMkJBQTJCLEdBQUcsU0FBUzVCLE9BQU8sRUFBRUMsUUFBUTtJQUVuRixJQUFJQyxVQUFVM0IsUUFBUUksK0JBQ3JCd0IsU0FBUztRQUNSVSxJQUFJYjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNsQixNQUFNLENBQUMyQixzQkFBc0IsQ0FBQyxJQUFJLENBQUMzQixNQUFNLENBQUM2QixHQUFHLEVBQUVULFNBQVNDLFFBQVFGO0FBQzdFO0FBRUE0QixPQUFPQyxPQUFPLEdBQUdqRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvcmV0ZW50aW9uLXBvbGljaWVzLmpzP2IwODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBSZXRlbnRpb24gUG9saWNpZXMgUmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlZGVmc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSZXRlbnRpb24gcG9saWN5IHR5cGUsIHdoaWNoIHNwZWNpZmllcyBob3cgbG9uZyB0aGUgcG9saWN5IHNob3VsZFxuICogcmVtYWluIGluIGVmZmVjdFxuICogQHR5cGVkZWYge3N0cmluZ30gUmV0ZW50aW9uUG9saWN5VHlwZVxuICovXG5cbi8qKlxuICogUmV0ZW50aW9uIHBvbGljeSBkaXNwb3NpdGlvbiBhY3Rpb24sIHdoaWNoIHNwZWNpZmllcyB3aGF0IHNob3VsZFxuICogYmUgZG9uZSB3aGVuIHRoZSByZXRlbnRpb24gcGVyaW9kIGlzIG92ZXJcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFJldGVudGlvblBvbGljeURpc3Bvc2l0aW9uQWN0aW9uXG4gKi9cblxuLyoqXG4gKiBQb2xpY3kgYXNzaWdubWVudCB0eXBlcywgd2hpY2ggc3BlY2lmeSB3aGF0IHR5cGUgb2Ygb2JqZWN0IHRoZSBwb2xpY3kgYXBwbGllcyB0b1xuICogQHR5cGVkZWYge3N0cmluZ30gUmV0ZW50aW9uUG9saWN5QXNzaWdubWVudFR5cGVcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIHRlbXBsYXRlIGZpZWxkcyB0byBmaWx0ZXIgb24gZm9yIGFzc2lnbmluZyBhIHJldGVudGlvbiBwb2xpY3lcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFkYXRhRmlsdGVyRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWVsZCBUaGUgZmllbGQgdG8gZmlsdGVyIG9uXG4gKiBAcHJvcGVydHkge3N0cmluZ3xpbnR9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWx0ZXIgYWdhaW5zdFxuICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy9yZXRlbnRpb25fcG9saWNpZXMnLFxuXHRBU1NJR05NRU5UU19QQVRIID0gJy9yZXRlbnRpb25fcG9saWN5X2Fzc2lnbm1lbnRzJyxcblx0RklMRV9WRVJTSU9OX1JFVEVOVElPTlNfUEFUSCA9ICcvZmlsZV92ZXJzaW9uX3JldGVudGlvbnMnLFxuXHRBU1NJR05NRU5UU19TVUJSRVNPVVJDRSA9ICdhc3NpZ25tZW50cyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsIFJldGVudGlvbiBQb2xpY2llcyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gUmV0ZW50aW9uUG9saWNpZXMoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG4vKipcbiAqIEVudW0gb2YgdmFsaWQgcmV0ZW50aW9uIHBvbGljeSB0eXBlcywgd2hpY2ggc3BlY2lmeSBob3cgbG9uZyB0aGUgcG9saWN5IHNob3VsZFxuICogcmVtYWluIGluIGVmZmVjdC5cbiAqIEByZWFkb25seVxuICogQGVudW0ge1JldGVudGlvblBvbGljeVR5cGV9XG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5wb2xpY3lUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuXHRGSU5JVEU6ICdmaW5pdGUnLFxuXHRJTkRFRklOSVRFOiAnaW5kZWZpbml0ZSdcbn0pO1xuXG4vKipcbiAqIEVudW0gb2YgdmFsaWQgcmV0ZW50aW9uIHBvbGljeSBkaXNwb3NpdGlvbiBhY3Rpb25zLCB3aGljaCBzcGVjaWZ5IHdoYXQgc2hvdWxkXG4gKiBiZSBkb25lIHdoZW4gdGhlIHJldGVudGlvbiBwZXJpb2QgaXMgb3ZlclxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7UmV0ZW50aW9uUG9saWN5RGlzcG9zaXRpb25BY3Rpb259XG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5kaXNwb3NpdGlvbkFjdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcblx0UEVSTUFORU5UTFlfREVMRVRFOiAncGVybWFuZW50bHlfZGVsZXRlJyxcblx0UkVNT1ZFX1JFVEVOVElPTjogJ3JlbW92ZV9yZXRlbnRpb24nXG59KTtcblxuLyoqXG4gKiBFbnVtIG9mIHZhbGlkIHBvbGljeSBhc3NpZ25tZW50IHR5cGVzLCB3aGljaCBzcGVjaWZ5IHdoYXQgb2JqZWN0IHRoZSBwb2xpY3kgYXBwbGllcyB0b1xuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7UmV0ZW50aW9uUG9saWN5QXNzaWdubWVudFR5cGV9XG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5hc3NpZ25tZW50VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcblx0Rk9MREVSOiAnZm9sZGVyJyxcblx0RU5URVJQUklTRTogJ2VudGVycHJpc2UnLFxuXHRNRVRBREFUQTogJ21ldGFkYXRhX3RlbXBsYXRlJ1xufSk7XG5cbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBzaW5nbGUgcmV0ZW50aW9uIHBvbGljeSBmb3IgYW4gZW50ZXJwcmlzZVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWNpZXMnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSByZXRlbnRpb24gcG9saWN5IHRvIGJlIGNyZWF0ZWRcbiAqIEBwYXJhbSB7UmV0ZW50aW9uUG9saWN5VHlwZX0gdHlwZSAtIFRoZSB0eXBlIG9mIHBvbGljeSB0byBjcmVhdGVcbiAqIEBwYXJhbSB7UmV0ZW50aW9uUG9saWN5RGlzcG9zaXRpb25BY3Rpb259IGFjdGlvbiAtIFRoZSBkaXNwb3NpdGlvbiBhY3Rpb24gZm9yIHRoZSBuZXcgcG9saWN5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMucmV0ZW50aW9uX2xlbmd0aF0gLSBGb3IgZmluaXRlIHBvbGljaWVzLCB0aGUgbnVtYmVyIG9mIGRheXMgdG8gcmV0YWluIHRoZSBjb250ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBuZXcgcG9saWN5IGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHksIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IHBvbGljeSBvYmplY3RcbiAqL1xuUmV0ZW50aW9uUG9saWNpZXMucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGFjdGlvbiwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRwb2xpY3lfbmFtZTogbmFtZSxcblx0XHRcdFx0cG9saWN5X3R5cGU6IHR5cGUsXG5cdFx0XHRcdGRpc3Bvc2l0aW9uX2FjdGlvbjogYWN0aW9uXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRPYmplY3QuYXNzaWduKHBhcmFtcy5ib2R5LCBvcHRpb25zKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2hlcyBkZXRhaWxzIGFib3V0IGEgc3BlY2lmaWMgcmV0ZW50aW9uIHBvbGljeVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWNpZXMvOnBvbGljeUlEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9saWN5SUQgLSBUaGUgQm94IElEIG9mIHRoZSByZXRlbnRpb24gcG9saWN5IGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHBvbGljeSBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHBvbGljeSBvYmplY3RcbiAqL1xuUmV0ZW50aW9uUG9saWNpZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHBvbGljeUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBwb2xpY3lJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBvciBtb2RpZnkgYSByZXRlbnRpb24gcG9saWN5LlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWNpZXMvOnBvbGljeUlEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9saWN5SUQgLSBUaGUgQm94IElEIG9mIHRoZSByZXRlbnRpb24gcG9saWN5IHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXMgLSBUaGUgaW5mb3JtYXRpb24gdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFt1cGRhdGVzLnBvbGljeV9uYW1lXSAtIFRoZSBuYW1lIG9mIHRoZSByZXRlbnRpb24gcG9saWN5XG4gKiBAcGFyYW0ge1JldGVudGlvblBvbGljeURpc3Bvc2l0aW9uQWN0aW9ufSBbdXBkYXRlcy5kaXNwb3NpdGlvbl9hY3Rpb25dIC0gVGhlIGRpc3Bvc2l0aW9uIGFjdGlvbiBmb3IgdGhlIHVwZGF0ZWQgcG9saWN5XG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMuc3RhdHVzXSAtIFVzZWQgdG8gcmV0aXJlIGEgcmV0ZW50aW9uIHBvbGljeSBpZiBzdGF0dXMgaXMgc2V0IHRvIHJldGlyZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgcG9saWN5IGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHksIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCBwb2xpY3kgb2JqZWN0XG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihwb2xpY3lJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCBwb2xpY3lJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keTogdXBkYXRlc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2hlcyBhIGxpc3Qgb2YgcmV0ZW50aW9uIHBvbGljaWVzIGZvciB0aGUgZW50ZXJwcmlzZVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWNpZXNcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb2xpY3lfbmFtZV0gLSBBIGZ1bGwgb3IgcGFydGlhbCBuYW1lIHRvIGZpbHRlciB0aGUgcmV0ZW50aW9uIHBvbGljaWVzIGJ5XG4gKiBAcGFyYW0ge1JldGVudGlvblBvbGljeVR5cGV9IFtvcHRpb25zLnBvbGljeV90eXBlXSAtIEEgcG9saWN5IHR5cGUgdG8gZmlsdGVyIHRoZSByZXRlbnRpb24gcG9saWNpZXMgYnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jcmVhdGVkX2J5X3VzZXJfaWRdIC0gQSB1c2VyIGlkIHRvIGZpbHRlciB0aGUgcmV0ZW50aW9uIHBvbGljaWVzIGJ5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBwb2xpY3kgb2JqZWN0cyBpZiB0aGV5IHdlcmUgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgcG9saWNpZXNcbiAqL1xuUmV0ZW50aW9uUG9saWNpZXMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIGxpc3Qgb2YgYXNzaWdubWVudHMgZm9yIGEgZ2l2ZW4gcmV0ZW50aW9uIHBvbGljeVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWNpZXMvOnBvbGljeUlEL2Fzc2lnbm1lbnRzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9saWN5SUQgLSBUaGUgQm94IElEIG9mIHRoZSByZXRlbnRpb24gcG9saWN5IHRvIGdldCBhc3NpZ25tZW50cyBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge1JldGVudGlvblBvbGljeUFzc2lnbm1lbnRUeXBlfSBbb3B0aW9ucy50eXBlXSAtIFRoZSB0eXBlIG9mIHRoZSByZXRlbnRpb24gcG9saWN5IGFzc2lnbm1lbnQgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIGFzc2lnbm1lbnQgb2JqZWN0cyBpZiB0aGV5IHdlcmUgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgcG9saWN5IGFzc2lnbm1lbnRzXG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5nZXRBc3NpZ25tZW50cyA9IGZ1bmN0aW9uKHBvbGljeUlELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHBvbGljeUlELCBBU1NJR05NRU5UU19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEFzc2lnbiBhIHJldGVudGlvbiBwb2xpY3kgdG8gYSBmb2xkZXIgb3IgdGhlIGVudGlyZSBlbnRlcnByaXNlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWN5X2Fzc2lnbm1lbnRzXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9saWN5SUQgLSBUaGUgSUQgb2YgdGhlIHBvbGljeSB0byBhc3NpZ25cbiAqIEBwYXJhbSB7UmV0ZW50aW9uUG9saWN5QXNzaWdubWVudFR5cGV9IGFzc2lnblR5cGUgLSBUaGUgdHlwZSBvZiBvYmplY3QgdGhlIHBvbGljeSB3aWxsIGJlIGFzc2lnbmVkIHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gYXNzaWduSUQgLSBUaGUgQm94IElEIG9mIHRoZSBvYmplY3QgdG8gYXNzaWduIHRoZSByZXRlbnRpb24gcG9saWN5IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TWV0YWRhdGFGaWx0ZXJGaWVsZFtdfSBbb3B0aW9ucy5maWx0ZXJfZmllbGRzXSAtIE1ldGFkYXRhIGZpZWxkcyB0byBmaWx0ZXIgYWdhaW5zdCwgaWYgYXNzaWduaW5nIHRvIGEgbWV0YWRhdGEgdGVtcGxhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIG5ldyBhc3NpZ25tZW50IG9iamVjdCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNyZWF0ZWQgYXNzaWdubWVudCBvYmplY3RcbiAqL1xuUmV0ZW50aW9uUG9saWNpZXMucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHBvbGljeUlELCBhc3NpZ25UeXBlLCBhc3NpZ25JRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHQvLyBTaHVmZmxlIG9wdGlvbmFsIGFyZ3VtZW50c1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IG51bGw7XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVNTSUdOTUVOVFNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRwb2xpY3lfaWQ6IHBvbGljeUlELFxuXHRcdFx0XHRhc3NpZ25fdG86IHtcblx0XHRcdFx0XHR0eXBlOiBhc3NpZ25UeXBlLFxuXHRcdFx0XHRcdGlkOiBhc3NpZ25JRFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRPYmplY3QuYXNzaWduKHBhcmFtcy5ib2R5LCBvcHRpb25zKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2ggYSBzcGVjaWZpYyBwb2xpY3kgYXNzaWdubWVudFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9yZXRlbnRpb25fcG9saWN5X2Fzc2lnbm1lbnRzLzphc3NpZ25tZW50SUQnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhc3NpZ25tZW50SUQgLSBUaGUgQm94IElEIG9mIHRoZSBwb2xpY3kgYXNzaWdubWVudCBvYmplY3QgdG8gZmV0Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBhc3NpZ25tZW50IG9iamVjdCBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGFzc2lnbm1lbnQgb2JqZWN0XG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5nZXRBc3NpZ25tZW50ID0gZnVuY3Rpb24oYXNzaWdubWVudElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChBU1NJR05NRU5UU19QQVRILCBhc3NpZ25tZW50SUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljIHJldGVudGlvbiByZWNvcmQgZm9yIGEgcmV0YWluZWQgZmlsZSB2ZXJzaW9uLiBUbyB1c2UgdGhpcyBmZWF0dXJlLFxuICogeW91IG11c3QgaGF2ZSB0aGUgbWFuYWdlIHJldGVudGlvbiBwb2xpY2llcyBzY29wZSBlbmFibGVkIGZvciB5b3VyIEFQSSBrZXlcbiAqIHZpYSB5b3VyIGFwcGxpY2F0aW9uIG1hbmFnZW1lbnQgY29uc29sZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZV92ZXJzaW9uX3JldGVudGlvbnMvOnJldGVudGlvbklEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmV0ZW50aW9uSUQgLSBUaGUgSUQgZm9yIHRoZSBmaWxlIHJldGVudGlvbiByZWNvcmQgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzcyB0aGUgZmlsZSB2ZXJzaW9uIHJldGVudGlvbiByZWNvcmQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXRlbnRpb24gcmVjb3JkXG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5nZXRGaWxlVmVyc2lvblJldGVudGlvbiA9IGZ1bmN0aW9uKHJldGVudGlvbklELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChGSUxFX1ZFUlNJT05fUkVURU5USU9OU19QQVRILCByZXRlbnRpb25JRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgcmV0ZW50aW9uIHJlY29yZHMgZm9yIGEgcmV0YWluZWQgZmlsZSB2ZXJzaW9ucyBpbiBhbiBlbnRlcnByaXNlLlxuICogVG8gdXNlIHRoaXMgZmVhdHVyZSwgeW91IG11c3QgaGF2ZSB0aGUgbWFuYWdlIHJldGVudGlvbiBwb2xpY2llcyBzY29wZSBlbmFibGVkXG4gKiBmb3IgeW91ciBBUEkga2V5IHZpYSB5b3VyIGFwcGxpY2F0aW9uIG1hbmFnZW1lbnQgY29uc29sZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvZmlsZV92ZXJzaW9uX3JldGVudGlvbnMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmlsZV9pZF0gLSBBIGZpbGUgaWQgdG8gZmlsdGVyIHRoZSBmaWxlIHZlcnNpb24gcmV0ZW50aW9ucyBieVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpbGVfdmVyc2lvbl9pZF0gLSBBIGZpbGUgdmVyc2lvbiBpZCB0byBmaWx0ZXIgdGhlIGZpbGUgdmVyc2lvbiByZXRlbnRpb25zIGJ5XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucG9saWN5X2lkXSAtIEEgcG9saWN5IGlkIHRvIGZpbHRlciB0aGUgZmlsZSB2ZXJzaW9uIHJldGVudGlvbnMgYnlcbiAqIEBwYXJhbSB7UmV0ZW50aW9uUG9saWN5RGlzcG9zaXRpb25BY3Rpb259IFtvcHRpb25zLmRpc3Bvc2l0aW9uX2FjdGlvbl0gLSBUaGUgZGlzcG9zaXRpb24gYWN0aW9uIG9mIHRoZSByZXRlbnRpb24gcG9saWN5IHRvIGZpbHRlciBieVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmRpc3Bvc2l0aW9uX2JlZm9yZV0gLSBGaWx0ZXIgYnkgcmV0ZW50aW9uIHBvbGljaWVzIHdoaWNoIHdpbGwgY29tcGxldGUgYmVmb3JlIGEgY2VydGFpbiB0aW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGlzcG9zaXRpb25fYWZ0ZXJdIC0gRmlsdGVyIGJ5IHJldGVudGlvbiBwb2xpY2llcyB3aGljaCB3aWxsIGNvbXBsZXRlIGFmdGVyIGEgY2VydGFpbiB0aW1lXG4gKiBAcGFyYW0ge2ludH0gW29wdGlvbnMubGltaXRdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRvIHJldHVybiBpbiBhIHBhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXJrZXJdIC0gUGFnaW5nIG1hcmtlciwgbGVmdCBibGFuayB0byBiZWdpbiBwYWdpbmcgZnJvbSB0aGUgYmVnaW5uaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzcyB0aGUgZmlsZSB2ZXJzaW9uIHJldGVudGlvbiByZWNvcmQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHJldGVudGlvbiByZWNvcmRzXG4gKi9cblJldGVudGlvblBvbGljaWVzLnByb3RvdHlwZS5nZXRBbGxGaWxlVmVyc2lvblJldGVudGlvbnMgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChGSUxFX1ZFUlNJT05fUkVURU5USU9OU19QQVRIKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmV0ZW50aW9uUG9saWNpZXM7XG4iXSwibmFtZXMiOlsidXJsUGF0aCIsInJlcXVpcmUiLCJCQVNFX1BBVEgiLCJBU1NJR05NRU5UU19QQVRIIiwiRklMRV9WRVJTSU9OX1JFVEVOVElPTlNfUEFUSCIsIkFTU0lHTk1FTlRTX1NVQlJFU09VUkNFIiwiUmV0ZW50aW9uUG9saWNpZXMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJwb2xpY3lUeXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsIkZJTklURSIsIklOREVGSU5JVEUiLCJkaXNwb3NpdGlvbkFjdGlvbnMiLCJQRVJNQU5FTlRMWV9ERUxFVEUiLCJSRU1PVkVfUkVURU5USU9OIiwiYXNzaWdubWVudFR5cGVzIiwiRk9MREVSIiwiRU5URVJQUklTRSIsIk1FVEFEQVRBIiwiY3JlYXRlIiwibmFtZSIsInR5cGUiLCJhY3Rpb24iLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhcGlQYXRoIiwicGFyYW1zIiwiYm9keSIsInBvbGljeV9uYW1lIiwicG9saWN5X3R5cGUiLCJkaXNwb3NpdGlvbl9hY3Rpb24iLCJhc3NpZ24iLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwicG9zdCIsImdldCIsInBvbGljeUlEIiwicXMiLCJ1cGRhdGUiLCJ1cGRhdGVzIiwicHV0IiwiZ2V0QWxsIiwiZ2V0QXNzaWdubWVudHMiLCJhc3NpZ25UeXBlIiwiYXNzaWduSUQiLCJwb2xpY3lfaWQiLCJhc3NpZ25fdG8iLCJpZCIsImdldEFzc2lnbm1lbnQiLCJhc3NpZ25tZW50SUQiLCJnZXRGaWxlVmVyc2lvblJldGVudGlvbiIsInJldGVudGlvbklEIiwiZ2V0QWxsRmlsZVZlcnNpb25SZXRlbnRpb25zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/retention-policies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/search.js":
/*!**********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/search.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Search Resource\n */ \n// -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Search metadata filter\n * @typedef {Object} SearchMetadataFilter\n * @property {string} templateKey The template to filter against\n * @property {string} scope The scope of the template, e.g. 'global' or 'enterprise'\n * @property {Object} filters Key/value filters against individual metadata template properties\n */ /** @typedef {string} SearchScope */ /** @typedef {string} SearchTrashContent */ // -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar API_PATHS_SEARCH = \"/search\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with the search endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Search(client) {\n    this.client = client;\n}\nSearch.prototype = {\n    /**\n\t * Valid search scopes\n\t * @readonly\n\t * @enum {SearchScope}\n\t */ scopes: Object.freeze({\n        USER: \"user_content\",\n        ENTERPRISE: \"enterprise_content\"\n    }),\n    /**\n\t * Searches Box for the given query.\n\t *\n\t * @param {string} searchString - The query string to use for search\n\t * @param {Object} [options] - Additional search filters. Can be left null in most cases.\n\t * @param {SearchScope} [options.scope] - The scope on which you want search. Can be user_content for a search limited to the current user or enterprise_content to search an entire enterprise\n\t * @param {string} [options.file_extensions] - Single or comma-delimited list of file extensions to filter against\n\t * @param {string} [options.created_at_range] - Date range for filtering on item creation time, e.g. '2014-05-15T13:35:01-07:00,2014-05-17T13:35:01-07:00'\n\t * @param {string} [options.updated_at_range] - Date range for filtering on item update time, e.g. '2014-05-15T13:35:01-07:00,2014-05-17T13:35:01-07:00'\n\t * @param {string} [options.size_range] - Range of item sizes (in bytes) to filter on, as lower_bound,upper_bound.  Either bound can be ommitted, e.g. ',100000' for <= 100KB\n\t * @param {string} [options.owner_user_ids] - Comma-delimited list of user IDs to filter item owner against\n\t * @param {string} [options.ancestor_folder_ids] - Comma-delimited list of folder IDs, search results will contain only items in these folders (and folders within them)\n\t * @param {string} [options.content_types] - Query within specified comma-delimited fields. The types can be name, description, file_content, comments, or tags\n\t * @param {string} [options.type] - The type of objects you want to include in the search results. The type can be file, folder, or web_link\n\t * @param {string} [options.trash_content=non_trashed_only] - Controls whether to search in the trash. The value can be trashed_only or non_trashed_only\n\t * @param {SearchMetadataFilter[]} [options.mdfilters] - Searches for objects with a specific metadata object association.  Searches with the this parameter do not require a query string\n\t * @param {boolean} [options.include_recent_shared_links] - Determines whether to include items accessible only via shared link in the response.\n\t * @param {string} [options.fields] - Comma-delimited list of fields to be included in the response\n\t * @param {int} [options.limit=30] - The number of search results to return, max 200\n\t * @param {int} [options.offset=0] - The search result at which to start the response, must be a multiple of limit\n\t * @param {string} [options.sort] - The field on which the results should be sorted, e.g. \"modified_at\"\n\t * @param {string} [options.direction] - The sort direction: \"ASC\" for ascending and \"DESC\" for descending\n\t * @param {APIRequest~Callback} [callback] - passed the new comment data if it was posted successfully\n\t * @returns {Promise<Object>} A promise resolving to the collection of search results\n\t */ query (searchString, options, callback) {\n        var apiPath = urlPath(API_PATHS_SEARCH), qs = options || {};\n        qs.query = searchString;\n        if (qs.mdfilters) {\n            if (Array.isArray(qs.mdfilters)) {\n                qs.mdfilters = JSON.stringify(qs.mdfilters);\n            } else {\n                return Promise.reject(new Error(\"Invalid mdfilters parameter: must be a valid array\")).asCallback(callback);\n            }\n        }\n        var params = {\n            qs\n        };\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n    }\n};\nmodule.exports = Search;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9zZWFyY2guanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGdGQUFnRjtBQUNoRixlQUFlO0FBQ2YsZ0ZBQWdGO0FBRWhGLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDLG1GQUNyQkMsVUFBVUQsbUJBQU9BLENBQUM7QUFFbkIsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEY7Ozs7OztDQU1DLEdBRUQsa0NBQWtDLEdBRWxDLHlDQUF5QyxHQUV6QyxnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUVoRixJQUFJRSxtQkFBbUI7QUFFdkIsZ0ZBQWdGO0FBQ2hGLFNBQVM7QUFDVCxnRkFBZ0Y7QUFFaEY7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsT0FBT0MsTUFBTTtJQUNyQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBRCxPQUFPRSxTQUFTLEdBQUc7SUFFbEI7Ozs7RUFJQyxHQUNEQyxRQUFRQyxPQUFPQyxNQUFNLENBQUM7UUFDckJDLE1BQU07UUFDTkMsWUFBWTtJQUNiO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXdCQyxHQUNEQyxPQUFNQyxZQUFZLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtRQUVwQyxJQUFJQyxVQUFVaEIsUUFBUUcsbUJBQ3JCYyxLQUFLSCxXQUFXLENBQUM7UUFFbEJHLEdBQUdMLEtBQUssR0FBR0M7UUFFWCxJQUFJSSxHQUFHQyxTQUFTLEVBQUU7WUFDakIsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxHQUFHQyxTQUFTLEdBQUc7Z0JBQ2hDRCxHQUFHQyxTQUFTLEdBQUdHLEtBQUtDLFNBQVMsQ0FBQ0wsR0FBR0MsU0FBUztZQUMzQyxPQUFPO2dCQUNOLE9BQU9oQixRQUFRcUIsTUFBTSxDQUFDLElBQUlDLE1BQU0sdURBQXVEQyxVQUFVLENBQUNWO1lBQ25HO1FBQ0Q7UUFFQSxJQUFJVyxTQUFTO1lBQ1pUO1FBQ0Q7UUFDQSxPQUFPLElBQUksQ0FBQ1osTUFBTSxDQUFDc0Isc0JBQXNCLENBQUMsSUFBSSxDQUFDdEIsTUFBTSxDQUFDdUIsR0FBRyxFQUFFWixTQUFTVSxRQUFRWDtJQUM3RTtBQUVEO0FBRUFjLE9BQU9DLE9BQU8sR0FBRzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9zZWFyY2guanM/YzRlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIEJveCBTZWFyY2ggUmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciB1cmxQYXRoID0gcmVxdWlyZSgnLi4vdXRpbC91cmwtcGF0aCcpLFxuXHRQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNlYXJjaCBtZXRhZGF0YSBmaWx0ZXJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlYXJjaE1ldGFkYXRhRmlsdGVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGVtcGxhdGVLZXkgVGhlIHRlbXBsYXRlIHRvIGZpbHRlciBhZ2FpbnN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2NvcGUgVGhlIHNjb3BlIG9mIHRoZSB0ZW1wbGF0ZSwgZS5nLiAnZ2xvYmFsJyBvciAnZW50ZXJwcmlzZSdcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBmaWx0ZXJzIEtleS92YWx1ZSBmaWx0ZXJzIGFnYWluc3QgaW5kaXZpZHVhbCBtZXRhZGF0YSB0ZW1wbGF0ZSBwcm9wZXJ0aWVzXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtzdHJpbmd9IFNlYXJjaFNjb3BlICovXG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBTZWFyY2hUcmFzaENvbnRlbnQgKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBBUElfUEFUSFNfU0VBUkNIID0gJy9zZWFyY2gnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBzZWFyY2ggZW5kcG9pbnRzIGFuZCBhY3Rpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCAtIFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIFNlYXJjaChjbGllbnQpIHtcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cblNlYXJjaC5wcm90b3R5cGUgPSB7XG5cblx0LyoqXG5cdCAqIFZhbGlkIHNlYXJjaCBzY29wZXNcblx0ICogQHJlYWRvbmx5XG5cdCAqIEBlbnVtIHtTZWFyY2hTY29wZX1cblx0ICovXG5cdHNjb3BlczogT2JqZWN0LmZyZWV6ZSh7XG5cdFx0VVNFUjogJ3VzZXJfY29udGVudCcsXG5cdFx0RU5URVJQUklTRTogJ2VudGVycHJpc2VfY29udGVudCdcblx0fSksXG5cblx0LyoqXG5cdCAqIFNlYXJjaGVzIEJveCBmb3IgdGhlIGdpdmVuIHF1ZXJ5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VhcmNoU3RyaW5nIC0gVGhlIHF1ZXJ5IHN0cmluZyB0byB1c2UgZm9yIHNlYXJjaFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBzZWFyY2ggZmlsdGVycy4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuXHQgKiBAcGFyYW0ge1NlYXJjaFNjb3BlfSBbb3B0aW9ucy5zY29wZV0gLSBUaGUgc2NvcGUgb24gd2hpY2ggeW91IHdhbnQgc2VhcmNoLiBDYW4gYmUgdXNlcl9jb250ZW50IGZvciBhIHNlYXJjaCBsaW1pdGVkIHRvIHRoZSBjdXJyZW50IHVzZXIgb3IgZW50ZXJwcmlzZV9jb250ZW50IHRvIHNlYXJjaCBhbiBlbnRpcmUgZW50ZXJwcmlzZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmlsZV9leHRlbnNpb25zXSAtIFNpbmdsZSBvciBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgdG8gZmlsdGVyIGFnYWluc3Rcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNyZWF0ZWRfYXRfcmFuZ2VdIC0gRGF0ZSByYW5nZSBmb3IgZmlsdGVyaW5nIG9uIGl0ZW0gY3JlYXRpb24gdGltZSwgZS5nLiAnMjAxNC0wNS0xNVQxMzozNTowMS0wNzowMCwyMDE0LTA1LTE3VDEzOjM1OjAxLTA3OjAwJ1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXBkYXRlZF9hdF9yYW5nZV0gLSBEYXRlIHJhbmdlIGZvciBmaWx0ZXJpbmcgb24gaXRlbSB1cGRhdGUgdGltZSwgZS5nLiAnMjAxNC0wNS0xNVQxMzozNTowMS0wNzowMCwyMDE0LTA1LTE3VDEzOjM1OjAxLTA3OjAwJ1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc2l6ZV9yYW5nZV0gLSBSYW5nZSBvZiBpdGVtIHNpemVzIChpbiBieXRlcykgdG8gZmlsdGVyIG9uLCBhcyBsb3dlcl9ib3VuZCx1cHBlcl9ib3VuZC4gIEVpdGhlciBib3VuZCBjYW4gYmUgb21taXR0ZWQsIGUuZy4gJywxMDAwMDAnIGZvciA8PSAxMDBLQlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub3duZXJfdXNlcl9pZHNdIC0gQ29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdXNlciBJRHMgdG8gZmlsdGVyIGl0ZW0gb3duZXIgYWdhaW5zdFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5jZXN0b3JfZm9sZGVyX2lkc10gLSBDb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBmb2xkZXIgSURzLCBzZWFyY2ggcmVzdWx0cyB3aWxsIGNvbnRhaW4gb25seSBpdGVtcyBpbiB0aGVzZSBmb2xkZXJzIChhbmQgZm9sZGVycyB3aXRoaW4gdGhlbSlcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRfdHlwZXNdIC0gUXVlcnkgd2l0aGluIHNwZWNpZmllZCBjb21tYS1kZWxpbWl0ZWQgZmllbGRzLiBUaGUgdHlwZXMgY2FuIGJlIG5hbWUsIGRlc2NyaXB0aW9uLCBmaWxlX2NvbnRlbnQsIGNvbW1lbnRzLCBvciB0YWdzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50eXBlXSAtIFRoZSB0eXBlIG9mIG9iamVjdHMgeW91IHdhbnQgdG8gaW5jbHVkZSBpbiB0aGUgc2VhcmNoIHJlc3VsdHMuIFRoZSB0eXBlIGNhbiBiZSBmaWxlLCBmb2xkZXIsIG9yIHdlYl9saW5rXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFzaF9jb250ZW50PW5vbl90cmFzaGVkX29ubHldIC0gQ29udHJvbHMgd2hldGhlciB0byBzZWFyY2ggaW4gdGhlIHRyYXNoLiBUaGUgdmFsdWUgY2FuIGJlIHRyYXNoZWRfb25seSBvciBub25fdHJhc2hlZF9vbmx5XG5cdCAqIEBwYXJhbSB7U2VhcmNoTWV0YWRhdGFGaWx0ZXJbXX0gW29wdGlvbnMubWRmaWx0ZXJzXSAtIFNlYXJjaGVzIGZvciBvYmplY3RzIHdpdGggYSBzcGVjaWZpYyBtZXRhZGF0YSBvYmplY3QgYXNzb2NpYXRpb24uICBTZWFyY2hlcyB3aXRoIHRoZSB0aGlzIHBhcmFtZXRlciBkbyBub3QgcmVxdWlyZSBhIHF1ZXJ5IHN0cmluZ1xuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVfcmVjZW50X3NoYXJlZF9saW5rc10gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gaW5jbHVkZSBpdGVtcyBhY2Nlc3NpYmxlIG9ubHkgdmlhIHNoYXJlZCBsaW5rIGluIHRoZSByZXNwb25zZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpZWxkc10gLSBDb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBmaWVsZHMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlXG5cdCAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5saW1pdD0zMF0gLSBUaGUgbnVtYmVyIG9mIHNlYXJjaCByZXN1bHRzIHRvIHJldHVybiwgbWF4IDIwMFxuXHQgKiBAcGFyYW0ge2ludH0gW29wdGlvbnMub2Zmc2V0PTBdIC0gVGhlIHNlYXJjaCByZXN1bHQgYXQgd2hpY2ggdG8gc3RhcnQgdGhlIHJlc3BvbnNlLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgbGltaXRcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvcnRdIC0gVGhlIGZpZWxkIG9uIHdoaWNoIHRoZSByZXN1bHRzIHNob3VsZCBiZSBzb3J0ZWQsIGUuZy4gXCJtb2RpZmllZF9hdFwiXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kaXJlY3Rpb25dIC0gVGhlIHNvcnQgZGlyZWN0aW9uOiBcIkFTQ1wiIGZvciBhc2NlbmRpbmcgYW5kIFwiREVTQ1wiIGZvciBkZXNjZW5kaW5nXG5cdCAqIEBwYXJhbSB7QVBJUmVxdWVzdH5DYWxsYmFja30gW2NhbGxiYWNrXSAtIHBhc3NlZCB0aGUgbmV3IGNvbW1lbnQgZGF0YSBpZiBpdCB3YXMgcG9zdGVkIHN1Y2Nlc3NmdWxseVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHNlYXJjaCByZXN1bHRzXG5cdCAqL1xuXHRxdWVyeShzZWFyY2hTdHJpbmcsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVBJX1BBVEhTX1NFQVJDSCksXG5cdFx0XHRxcyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRxcy5xdWVyeSA9IHNlYXJjaFN0cmluZztcblxuXHRcdGlmIChxcy5tZGZpbHRlcnMpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHFzLm1kZmlsdGVycykpIHtcblx0XHRcdFx0cXMubWRmaWx0ZXJzID0gSlNPTi5zdHJpbmdpZnkocXMubWRmaWx0ZXJzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgbWRmaWx0ZXJzIHBhcmFtZXRlcjogbXVzdCBiZSBhIHZhbGlkIGFycmF5JykpLmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRxc1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlYXJjaDtcbiJdLCJuYW1lcyI6WyJ1cmxQYXRoIiwicmVxdWlyZSIsIlByb21pc2UiLCJBUElfUEFUSFNfU0VBUkNIIiwiU2VhcmNoIiwiY2xpZW50IiwicHJvdG90eXBlIiwic2NvcGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiVVNFUiIsIkVOVEVSUFJJU0UiLCJxdWVyeSIsInNlYXJjaFN0cmluZyIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFwaVBhdGgiLCJxcyIsIm1kZmlsdGVycyIsIkFycmF5IiwiaXNBcnJheSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZWplY3QiLCJFcnJvciIsImFzQ2FsbGJhY2siLCJwYXJhbXMiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwiZ2V0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/search.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/shared-items.js":
/*!****************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/shared-items.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Shared Items\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/shared_items\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Shared Item' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function SharedItems(client) {\n    this.client = client;\n}\n/**\n * Requests a Box item associated with a shared link.\n *\n * API Endpoint: '/shared_items'\n * Method: GET\n *\n * @param {string} url - Shared Link URL\n * @param {string} [password] - Shared Link Password (null if no password)\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - passed the shared item if it was successfully acquired\n * @returns {Promise<Object>} A promise resolving to the shared item object\n */ SharedItems.prototype.get = function(url, password, options, callback) {\n    var params = {\n        qs: options,\n        headers: {\n            BoxApi: this.client.buildSharedItemAuthHeader(url, password)\n        }\n    };\n    // Handle the Special API Response\n    return this.client.get(BASE_PATH, params).then((response)=>{\n        switch(response.statusCode){\n            // 200 - Shared Item Recieved\n            case httpStatusCodes.OK:\n                return response.body;\n            // 403 - Incorrect or missing password\n            // Propagate an error explaining that the password is either missing or incorrect\n            case httpStatusCodes.FORBIDDEN:\n                var errMessage = password ? \"Incorrect shared link password\" : \"Shared link password missing\";\n                throw errors.buildResponseError(response, errMessage);\n            // Unexpected Response\n            default:\n                throw errors.buildUnexpectedResponseError(response);\n        }\n    }).asCallback(callback);\n};\n/**\n * @module box-node-sdk/lib/managers/shared-items\n * @see {@Link SharedItems}\n */ module.exports = SharedItems;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9zaGFyZWQtaXRlbXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBQ2pGLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDLCtFQUNwQkMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUczQixpRkFBaUY7QUFDakYsVUFBVTtBQUNWLGlGQUFpRjtBQUNqRixJQUFJRSxZQUFZO0FBR2hCLGlGQUFpRjtBQUNqRixTQUFTO0FBQ1QsaUZBQWlGO0FBRWpGOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFlBQVlDLE1BQU07SUFDMUIsSUFBSSxDQUFDQSxNQUFNLEdBQUdBO0FBQ2Y7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNERCxZQUFZRSxTQUFTLENBQUNDLEdBQUcsR0FBRyxTQUFTQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBQ3BFLElBQUlDLFNBQVM7UUFDWkMsSUFBSUg7UUFDSkksU0FBUztZQUNSQyxRQUFRLElBQUksQ0FBQ1YsTUFBTSxDQUFDVyx5QkFBeUIsQ0FBQ1IsS0FBS0M7UUFDcEQ7SUFDRDtJQUVBLGtDQUFrQztJQUNsQyxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDRSxHQUFHLENBQUNKLFdBQVdTLFFBQ2hDSyxJQUFJLENBQUNDLENBQUFBO1FBRUwsT0FBUUEsU0FBU0MsVUFBVTtZQUUzQiw2QkFBNkI7WUFDN0IsS0FBS2pCLGdCQUFnQmtCLEVBQUU7Z0JBQ3RCLE9BQU9GLFNBQVNHLElBQUk7WUFFckIsc0NBQXNDO1lBQ3RDLGlGQUFpRjtZQUNqRixLQUFLbkIsZ0JBQWdCb0IsU0FBUztnQkFDN0IsSUFBSUMsYUFBYSxXQUFhLG1DQUFtQztnQkFDakUsTUFBTXZCLE9BQU93QixrQkFBa0IsQ0FBQ04sVUFBVUs7WUFFMUMsc0JBQXNCO1lBQ3ZCO2dCQUNDLE1BQU12QixPQUFPeUIsNEJBQTRCLENBQUNQO1FBQzNDO0lBQ0QsR0FDQ1EsVUFBVSxDQUFDZjtBQUNkO0FBRUE7OztDQUdDLEdBQ0RnQixPQUFPQyxPQUFPLEdBQUd4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvc2hhcmVkLWl0ZW1zLmpzPzMzMzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBTaGFyZWQgSXRlbXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9ycycpLFxuXHRodHRwU3RhdHVzQ29kZXMgPSByZXF1aXJlKCdodHRwLXN0YXR1cycpO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy9zaGFyZWRfaXRlbXMnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgJ1NoYXJlZCBJdGVtJyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gU2hhcmVkSXRlbXMoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG4vKipcbiAqIFJlcXVlc3RzIGEgQm94IGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEgc2hhcmVkIGxpbmsuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3NoYXJlZF9pdGVtcydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFNoYXJlZCBMaW5rIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXNzd29yZF0gLSBTaGFyZWQgTGluayBQYXNzd29yZCAobnVsbCBpZiBubyBwYXNzd29yZClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gcGFzc2VkIHRoZSBzaGFyZWQgaXRlbSBpZiBpdCB3YXMgc3VjY2Vzc2Z1bGx5IGFjcXVpcmVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzaGFyZWQgaXRlbSBvYmplY3RcbiAqL1xuU2hhcmVkSXRlbXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHVybCwgcGFzc3dvcmQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnMsXG5cdFx0aGVhZGVyczoge1xuXHRcdFx0Qm94QXBpOiB0aGlzLmNsaWVudC5idWlsZFNoYXJlZEl0ZW1BdXRoSGVhZGVyKHVybCwgcGFzc3dvcmQpXG5cdFx0fVxuXHR9O1xuXG5cdC8vIEhhbmRsZSB0aGUgU3BlY2lhbCBBUEkgUmVzcG9uc2Vcblx0cmV0dXJuIHRoaXMuY2xpZW50LmdldChCQVNFX1BBVEgsIHBhcmFtcylcblx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cblx0XHRcdHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuXG5cdFx0XHQvLyAyMDAgLSBTaGFyZWQgSXRlbSBSZWNpZXZlZFxuXHRcdFx0Y2FzZSBodHRwU3RhdHVzQ29kZXMuT0s6XG5cdFx0XHRcdHJldHVybiByZXNwb25zZS5ib2R5O1xuXG5cdFx0XHQvLyA0MDMgLSBJbmNvcnJlY3Qgb3IgbWlzc2luZyBwYXNzd29yZFxuXHRcdFx0Ly8gUHJvcGFnYXRlIGFuIGVycm9yIGV4cGxhaW5pbmcgdGhhdCB0aGUgcGFzc3dvcmQgaXMgZWl0aGVyIG1pc3Npbmcgb3IgaW5jb3JyZWN0XG5cdFx0XHRjYXNlIGh0dHBTdGF0dXNDb2Rlcy5GT1JCSURERU46XG5cdFx0XHRcdHZhciBlcnJNZXNzYWdlID0gKHBhc3N3b3JkKSA/ICdJbmNvcnJlY3Qgc2hhcmVkIGxpbmsgcGFzc3dvcmQnIDogJ1NoYXJlZCBsaW5rIHBhc3N3b3JkIG1pc3NpbmcnO1xuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCBlcnJNZXNzYWdlKTtcblxuXHRcdFx0XHQvLyBVbmV4cGVjdGVkIFJlc3BvbnNlXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9zaGFyZWQtaXRlbXNcbiAqIEBzZWUge0BMaW5rIFNoYXJlZEl0ZW1zfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXJlZEl0ZW1zO1xuIl0sIm5hbWVzIjpbImVycm9ycyIsInJlcXVpcmUiLCJodHRwU3RhdHVzQ29kZXMiLCJCQVNFX1BBVEgiLCJTaGFyZWRJdGVtcyIsImNsaWVudCIsInByb3RvdHlwZSIsImdldCIsInVybCIsInBhc3N3b3JkIiwib3B0aW9ucyIsImNhbGxiYWNrIiwicGFyYW1zIiwicXMiLCJoZWFkZXJzIiwiQm94QXBpIiwiYnVpbGRTaGFyZWRJdGVtQXV0aEhlYWRlciIsInRoZW4iLCJyZXNwb25zZSIsInN0YXR1c0NvZGUiLCJPSyIsImJvZHkiLCJGT1JCSURERU4iLCJlcnJNZXNzYWdlIiwiYnVpbGRSZXNwb25zZUVycm9yIiwiYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsImFzQ2FsbGJhY2siLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/shared-items.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/storage-policies.js":
/*!********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/storage-policies.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Storage Policies resource\n */ \n// -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), httpStatus = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\"), errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar BASE_PATH = \"/storage_policies\", ASSIGNMENTS_PATH = \"/storage_policy_assignments\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all Retention Policies endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function StoragePolicies(client) {\n    this.client = client;\n}\nStoragePolicies.prototype = {\n    /**\n     * Get information about a specific storage policy\n     * @param {string} storagePolicyID The ID of the storage policy\n     * @param {Object} [options] Optional parameters\n     * @param {string} [options.fields] Comma-separated list of fields of the storage policy to retrieve\n     * @param {Function} [callback] Passed the storage policy object if successful\n     * @returns {Promise<Object>} Promise resolving to the storage policy object\n     */ get (storagePolicyID, options, callback) {\n        var apiPath = urlPath(BASE_PATH, storagePolicyID), params = {\n            qs: options\n        };\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n    },\n    /**\n     * Get all available storage policies for the enterprise\n     * @param {Object} [options] Optional parameters\n     * @param {string} [options.fields] Comma-separated list of fields of the storage policy to retrieve\n     * @param {Function} [callback] Passed a collection of storage policies if successful\n     * @returns {Promise<Object>} Promise resolving to the collection of storage policies\n     */ getAll (options, callback) {\n        var apiPath = urlPath(BASE_PATH), params = {\n            qs: options\n        };\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n    },\n    /**\n     * Assign a storage policy to a user\n     * @param {string} storagePolicyID The ID of the storage policy to assign\n     * @param {string} userID The ID of the user to assign the storage policy to\n     * @param {Function} [callback] Passed the assignment object if successful\n     * @returns {Promise<Object>} Promise resolving to the assignment object\n     */ assign (storagePolicyID, userID, callback) {\n        return this.getAssignmentForTarget(userID).then((assignment)=>{\n            // Check if the assignment is already correct\n            if (assignment.storage_policy.id === storagePolicyID) {\n                return assignment;\n            }\n            // If the assignment is to an enterprise, we need to create a new\n            // assignment for the user\n            if (assignment.assigned_to.type === \"enterprise\") {\n                return this.createAssignment(storagePolicyID, userID);\n            }\n            // Update the user's existing assignment\n            var update = {\n                storage_policy: {\n                    type: \"storage_policy\",\n                    id: storagePolicyID\n                }\n            };\n            return this.updateAssignment(assignment.id, update);\n        }).asCallback(callback);\n    },\n    /**\n     * Get information about a specific storage policy asisgnment by ID\n     * @param {string} assignmentID The ID of the assignment\n     * @param {Function} [callback] Passed the assignment object if successful\n     * @returns {Promise<Object>} Promise resolving to the assignment object\n     */ getAssignment (assignmentID, callback) {\n        var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID);\n        return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n    },\n    /**\n     * Gets the storage policy assignment for a specific user\n     * @param {string} targetID The ID of the target\n     * @param {Object} [options] Optional parameters\n     * @param {string} [options.targetType=user] The type of the assignment target to resolve for\n     * @param {Function} [callback] Passed the assignment object if successful\n     * @returns {Promise<Object>} Promise resolving to the assignment object\n     */ getAssignmentForTarget (targetID, options, callback) {\n        options = Object.assign({\n            targetType: \"user\"\n        }, options);\n        var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n            qs: {\n                resolved_for_type: options.targetType,\n                resolved_for_id: targetID\n            }\n        };\n        return this.client.get(apiPath, params).then((response)=>{\n            if (response.statusCode !== httpStatus.OK) {\n                // Unexpected status code, throw an error\n                throw errors.buildUnexpectedResponseError(response);\n            }\n            // Unwrap the collection and give back just the assignment object\n            return response.body.entries[0];\n        }).asCallback(callback);\n    },\n    /**\n     * Create a new storage policy assignment to a user\n     * @param {string} storagePolicyID The ID of the storage policy to assign\n     * @param {string} userID The ID of the user to assign the storage policy to\n     * @param {Function} [callback] Passed the assignment object if successful\n     * @returns {Promise<Object>} Promise resolving to the assignment object\n     */ createAssignment (storagePolicyID, userID, callback) {\n        var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n            body: {\n                storage_policy: {\n                    type: \"storage_policy\",\n                    id: storagePolicyID\n                },\n                assigned_to: {\n                    type: \"user\",\n                    id: userID\n                }\n            }\n        };\n        return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n    },\n    /**\n     * Update a storage policy assignment\n     * @param {string} assignmentID The ID of the storage policy assignment to update\n     * @param {Object} updates The updates fields to apply\n     * @param {Function} [callback] Passed the updated assignment object if successful\n     * @returns {Promise<Object>} Promise resolving to the updated assignment object\n     */ updateAssignment (assignmentID, updates, callback) {\n        var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID), params = {\n            body: updates\n        };\n        return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n    },\n    /**\n     * Remove a storage policy assignment, returning the user to the default policy\n     * @param {string} assignmentID The ID of the assignment to remove\n     * @param {Function} [callback] Passed nothing if successful\n     * @returns {Promise<void>} Promise resolving if the removal succeeds\n     */ removeAssignment (assignmentID, callback) {\n        var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID);\n        return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n    }\n};\nmodule.exports = StoragePolicies;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy9zdG9yYWdlLXBvbGljaWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUNoRixJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQyxtRkFDckJDLGFBQWFELG1CQUFPQSxDQUFDLHFFQUNyQkUsU0FBU0YsbUJBQU9BLENBQUM7QUFFbEIsZ0ZBQWdGO0FBQ2hGLFVBQVU7QUFDVixnRkFBZ0Y7QUFDaEYsSUFBSUcsWUFBWSxxQkFDZkMsbUJBQW1CO0FBRXBCLGdGQUFnRjtBQUNoRixTQUFTO0FBQ1QsZ0ZBQWdGO0FBRWhGOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLGdCQUFnQkMsTUFBTTtJQUM5QixJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBRCxnQkFBZ0JFLFNBQVMsR0FBRztJQUUzQjs7Ozs7OztLQU9JLEdBQ0pDLEtBQUlDLGVBQWUsRUFBRUMsT0FBTyxFQUFFQyxRQUFRO1FBRXJDLElBQUlDLFVBQVViLFFBQVFJLFdBQVdNLGtCQUNoQ0ksU0FBUztZQUNSQyxJQUFJSjtRQUNMO1FBRUQsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEdBQUcsRUFBRUksU0FBU0MsUUFBUUY7SUFDN0U7SUFFQTs7Ozs7O0tBTUksR0FDSkssUUFBT04sT0FBTyxFQUFFQyxRQUFRO1FBRXZCLElBQUlDLFVBQVViLFFBQVFJLFlBQ3JCVSxTQUFTO1lBQ1JDLElBQUlKO1FBQ0w7UUFFRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ0UsR0FBRyxFQUFFSSxTQUFTQyxRQUFRRjtJQUM3RTtJQUVBOzs7Ozs7S0FNSSxHQUNKTSxRQUFPUixlQUFlLEVBQUVTLE1BQU0sRUFBRVAsUUFBUTtRQUV2QyxPQUFP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YnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL3N0b3JhZ2UtcG9saWNpZXMuanM/ZmE4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIFN0b3JhZ2UgUG9saWNpZXMgcmVzb3VyY2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKSxcblx0aHR0cFN0YXR1cyA9IHJlcXVpcmUoJ2h0dHAtc3RhdHVzJyksXG5cdGVycm9ycyA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIEJBU0VfUEFUSCA9ICcvc3RvcmFnZV9wb2xpY2llcycsXG5cdEFTU0lHTk1FTlRTX1BBVEggPSAnL3N0b3JhZ2VfcG9saWN5X2Fzc2lnbm1lbnRzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgUmV0ZW50aW9uIFBvbGljaWVzIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgLSBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBTdG9yYWdlUG9saWNpZXMoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG5TdG9yYWdlUG9saWNpZXMucHJvdG90eXBlID0ge1xuXG5cdC8qKlxuICAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIHN0b3JhZ2UgcG9saWN5XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JhZ2VQb2xpY3lJRCBUaGUgSUQgb2YgdGhlIHN0b3JhZ2UgcG9saWN5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpZWxkc10gQ29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgZmllbGRzIG9mIHRoZSBzdG9yYWdlIHBvbGljeSB0byByZXRyaWV2ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIHRoZSBzdG9yYWdlIHBvbGljeSBvYmplY3QgaWYgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzdG9yYWdlIHBvbGljeSBvYmplY3RcbiAgICAgKi9cblx0Z2V0KHN0b3JhZ2VQb2xpY3lJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHN0b3JhZ2VQb2xpY3lJRCksXG5cdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdHFzOiBvcHRpb25zXG5cdFx0XHR9O1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcbiAgICAgKiBHZXQgYWxsIGF2YWlsYWJsZSBzdG9yYWdlIHBvbGljaWVzIGZvciB0aGUgZW50ZXJwcmlzZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5maWVsZHNdIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGUgc3RvcmFnZSBwb2xpY3kgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCBhIGNvbGxlY3Rpb24gb2Ygc3RvcmFnZSBwb2xpY2llcyBpZiBzdWNjZXNzZnVsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2Ygc3RvcmFnZSBwb2xpY2llc1xuICAgICAqL1xuXHRnZXRBbGwob3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgpLFxuXHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRxczogb3B0aW9uc1xuXHRcdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG4gICAgICogQXNzaWduIGEgc3RvcmFnZSBwb2xpY3kgdG8gYSB1c2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JhZ2VQb2xpY3lJRCBUaGUgSUQgb2YgdGhlIHN0b3JhZ2UgcG9saWN5IHRvIGFzc2lnblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySUQgVGhlIElEIG9mIHRoZSB1c2VyIHRvIGFzc2lnbiB0aGUgc3RvcmFnZSBwb2xpY3kgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgYXNzaWdubWVudCBvYmplY3QgaWYgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhc3NpZ25tZW50IG9iamVjdFxuICAgICAqL1xuXHRhc3NpZ24oc3RvcmFnZVBvbGljeUlELCB1c2VySUQsIGNhbGxiYWNrKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRBc3NpZ25tZW50Rm9yVGFyZ2V0KHVzZXJJRClcblx0XHRcdC50aGVuKGFzc2lnbm1lbnQgPT4ge1xuXHRcdFx0XHQvLyBDaGVjayBpZiB0aGUgYXNzaWdubWVudCBpcyBhbHJlYWR5IGNvcnJlY3Rcblx0XHRcdFx0aWYgKGFzc2lnbm1lbnQuc3RvcmFnZV9wb2xpY3kuaWQgPT09IHN0b3JhZ2VQb2xpY3lJRCkge1xuXHRcdFx0XHRcdHJldHVybiBhc3NpZ25tZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGFzc2lnbm1lbnQgaXMgdG8gYW4gZW50ZXJwcmlzZSwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXdcblx0XHRcdFx0Ly8gYXNzaWdubWVudCBmb3IgdGhlIHVzZXJcblx0XHRcdFx0aWYgKGFzc2lnbm1lbnQuYXNzaWduZWRfdG8udHlwZSA9PT0gJ2VudGVycHJpc2UnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlQXNzaWdubWVudChzdG9yYWdlUG9saWN5SUQsIHVzZXJJRCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBVcGRhdGUgdGhlIHVzZXIncyBleGlzdGluZyBhc3NpZ25tZW50XG5cdFx0XHRcdHZhciB1cGRhdGUgPSB7XG5cdFx0XHRcdFx0c3RvcmFnZV9wb2xpY3k6IHtcblx0XHRcdFx0XHRcdHR5cGU6ICdzdG9yYWdlX3BvbGljeScsXG5cdFx0XHRcdFx0XHRpZDogc3RvcmFnZVBvbGljeUlEXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy51cGRhdGVBc3NpZ25tZW50KGFzc2lnbm1lbnQuaWQsIHVwZGF0ZSk7XG5cdFx0XHR9KVxuXHRcdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xuXHR9LFxuXG5cdC8qKlxuICAgICAqIEdldCBpbmZvcm1hdGlvbiBhYm91dCBhIHNwZWNpZmljIHN0b3JhZ2UgcG9saWN5IGFzaXNnbm1lbnQgYnkgSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzaWdubWVudElEIFRoZSBJRCBvZiB0aGUgYXNzaWdubWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIHRoZSBhc3NpZ25tZW50IG9iamVjdCBpZiBzdWNjZXNzZnVsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGFzc2lnbm1lbnQgb2JqZWN0XG4gICAgICovXG5cdGdldEFzc2lnbm1lbnQoYXNzaWdubWVudElELCBjYWxsYmFjaykge1xuXG5cdFx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEFTU0lHTk1FTlRTX1BBVEgsIGFzc2lnbm1lbnRJRCk7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcblx0fSxcblxuXHQvKipcbiAgICAgKiBHZXRzIHRoZSBzdG9yYWdlIHBvbGljeSBhc3NpZ25tZW50IGZvciBhIHNwZWNpZmljIHVzZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgVGhlIElEIG9mIHRoZSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudGFyZ2V0VHlwZT11c2VyXSBUaGUgdHlwZSBvZiB0aGUgYXNzaWdubWVudCB0YXJnZXQgdG8gcmVzb2x2ZSBmb3JcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgYXNzaWdubWVudCBvYmplY3QgaWYgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhc3NpZ25tZW50IG9iamVjdFxuICAgICAqL1xuXHRnZXRBc3NpZ25tZW50Rm9yVGFyZ2V0KHRhcmdldElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdFx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB0YXJnZXRUeXBlOiAndXNlcicgfSwgb3B0aW9ucyk7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVNTSUdOTUVOVFNfUEFUSCksXG5cdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdHFzOiB7XG5cdFx0XHRcdFx0cmVzb2x2ZWRfZm9yX3R5cGU6IG9wdGlvbnMudGFyZ2V0VHlwZSxcblx0XHRcdFx0XHRyZXNvbHZlZF9mb3JfaWQ6IHRhcmdldElEXG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRyZXR1cm4gdGhpcy5jbGllbnQuZ2V0KGFwaVBhdGgsIHBhcmFtcylcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gaHR0cFN0YXR1cy5PSykge1xuXHRcdFx0XHRcdC8vIFVuZXhwZWN0ZWQgc3RhdHVzIGNvZGUsIHRocm93IGFuIGVycm9yXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVW53cmFwIHRoZSBjb2xsZWN0aW9uIGFuZCBnaXZlIGJhY2sganVzdCB0aGUgYXNzaWdubWVudCBvYmplY3Rcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmJvZHkuZW50cmllc1swXTtcblx0XHRcdH0pXG5cdFx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0b3JhZ2UgcG9saWN5IGFzc2lnbm1lbnQgdG8gYSB1c2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0b3JhZ2VQb2xpY3lJRCBUaGUgSUQgb2YgdGhlIHN0b3JhZ2UgcG9saWN5IHRvIGFzc2lnblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySUQgVGhlIElEIG9mIHRoZSB1c2VyIHRvIGFzc2lnbiB0aGUgc3RvcmFnZSBwb2xpY3kgdG9cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgYXNzaWdubWVudCBvYmplY3QgaWYgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhc3NpZ25tZW50IG9iamVjdFxuICAgICAqL1xuXHRjcmVhdGVBc3NpZ25tZW50KHN0b3JhZ2VQb2xpY3lJRCwgdXNlcklELCBjYWxsYmFjaykge1xuXG5cdFx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEFTU0lHTk1FTlRTX1BBVEgpLFxuXHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRib2R5OiB7XG5cdFx0XHRcdFx0c3RvcmFnZV9wb2xpY3k6IHtcblx0XHRcdFx0XHRcdHR5cGU6ICdzdG9yYWdlX3BvbGljeScsXG5cdFx0XHRcdFx0XHRpZDogc3RvcmFnZVBvbGljeUlEXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRhc3NpZ25lZF90bzoge1xuXHRcdFx0XHRcdFx0dHlwZTogJ3VzZXInLFxuXHRcdFx0XHRcdFx0aWQ6IHVzZXJJRFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xuXHR9LFxuXG5cdC8qKlxuICAgICAqIFVwZGF0ZSBhIHN0b3JhZ2UgcG9saWN5IGFzc2lnbm1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzaWdubWVudElEIFRoZSBJRCBvZiB0aGUgc3RvcmFnZSBwb2xpY3kgYXNzaWdubWVudCB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcyBUaGUgdXBkYXRlcyBmaWVsZHMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFBhc3NlZCB0aGUgdXBkYXRlZCBhc3NpZ25tZW50IG9iamVjdCBpZiBzdWNjZXNzZnVsXG4gICAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgYXNzaWdubWVudCBvYmplY3RcbiAgICAgKi9cblx0dXBkYXRlQXNzaWdubWVudChhc3NpZ25tZW50SUQsIHVwZGF0ZXMsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVNTSUdOTUVOVFNfUEFUSCwgYXNzaWdubWVudElEKSxcblx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0Ym9keTogdXBkYXRlc1xuXHRcdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0LyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmFnZSBwb2xpY3kgYXNzaWdubWVudCwgcmV0dXJuaW5nIHRoZSB1c2VyIHRvIHRoZSBkZWZhdWx0IHBvbGljeVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NpZ25tZW50SUQgVGhlIElEIG9mIHRoZSBhc3NpZ25tZW50IHRvIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIG5vdGhpbmcgaWYgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBQcm9taXNlIHJlc29sdmluZyBpZiB0aGUgcmVtb3ZhbCBzdWNjZWVkc1xuICAgICAqL1xuXHRyZW1vdmVBc3NpZ25tZW50KGFzc2lnbm1lbnRJRCwgY2FsbGJhY2spIHtcblxuXHRcdHZhciBhcGlQYXRoID0gdXJsUGF0aChBU1NJR05NRU5UU19QQVRILCBhc3NpZ25tZW50SUQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3RvcmFnZVBvbGljaWVzO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiaHR0cFN0YXR1cyIsImVycm9ycyIsIkJBU0VfUEFUSCIsIkFTU0lHTk1FTlRTX1BBVEgiLCJTdG9yYWdlUG9saWNpZXMiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJnZXQiLCJzdG9yYWdlUG9saWN5SUQiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhcGlQYXRoIiwicGFyYW1zIiwicXMiLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwiZ2V0QWxsIiwiYXNzaWduIiwidXNlcklEIiwiZ2V0QXNzaWdubWVudEZvclRhcmdldCIsInRoZW4iLCJhc3NpZ25tZW50Iiwic3RvcmFnZV9wb2xpY3kiLCJpZCIsImFzc2lnbmVkX3RvIiwidHlwZSIsImNyZWF0ZUFzc2lnbm1lbnQiLCJ1cGRhdGUiLCJ1cGRhdGVBc3NpZ25tZW50IiwiYXNDYWxsYmFjayIsImdldEFzc2lnbm1lbnQiLCJhc3NpZ25tZW50SUQiLCJ0YXJnZXRJRCIsIk9iamVjdCIsInRhcmdldFR5cGUiLCJyZXNvbHZlZF9mb3JfdHlwZSIsInJlc29sdmVkX2Zvcl9pZCIsInJlc3BvbnNlIiwic3RhdHVzQ29kZSIsIk9LIiwiYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsImJvZHkiLCJlbnRyaWVzIiwicG9zdCIsInVwZGF0ZXMiLCJwdXQiLCJyZW1vdmVBc3NpZ25tZW50IiwiZGVsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/storage-policies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/tasks.js":
/*!*********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/tasks.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Tasks Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/** @typedef {string} TaskResolutionState */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nvar BASE_PATH = \"/tasks\", ASSIGNMENTS_SUBRESOURCE = \"assignments\", ASSIGNMENTS_PATH = \"/task_assignments\", REVIEW_ACTION = \"review\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Tasks' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Tasks(client) {\n    this.client = client;\n}\n/**\n * Enum of valid task resolution states\n * @readonly\n * @enum {TaskResolutionState}\n */ Tasks.prototype.resolutionStates = Object.freeze({\n    COMPLETE: \"completed\",\n    INCOMPLETE: \"incomplete\",\n    APPROVED: \"approved\",\n    REJECTED: \"rejected\"\n});\n/**\n * Used to create a single task for single user on a single file.\n *\n * API Endpoint: '/tasks'\n * Method: POST\n *\n * @param {string} fileID - The ID of the item this task is for\n * @param {Object} [options] - Additional parameters\n * @param {string} [options.message] - An optional message to include with the task\n * @param {string} [options.due_at] - The day at which this task is due\n * @param {Function} [callback] - Passed the new task information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created task object\n */ Tasks.prototype.create = function(fileID, options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        body: {\n            item: {\n                type: \"file\",\n                id: fileID\n            },\n            action: REVIEW_ACTION\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Fetches a specific task.\n *\n * API Endpoint: '/tasks/:taskID'\n * Method: GET\n *\n * @param {string} taskID - The Box ID of the task being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the task information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the task object\n */ Tasks.prototype.get = function(taskID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, taskID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Updates a specific task.\n *\n * API Endpoint: '/tasks/:taskID'\n * Method: PUT\n *\n * @param {string} taskID - The Box ID of the task being updated\n * @param {Object} updates - Fields of the task object to update\n * @param {string} [updates.message] - An optional message to include with the task\n * @param {string} [updates.due_at] - The day at which this task is due\n * @param {Function} [callback] - Passed the updated task information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated task object\n */ Tasks.prototype.update = function(taskID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, taskID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Permanently deletes a specific task.\n *\n * API Endpoint: '/tasks/:taskID'\n * Method: DELETE\n *\n * @param {string} taskID - The Box ID of the task being deleted\n * @param {Function} [callback] - Empty body passed if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Tasks.prototype.delete = function(taskID, callback) {\n    var apiPath = urlPath(BASE_PATH, taskID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Get a list of assignments for a given task\n *\n * API Endpoint: '/tasks/:taskID/assignments'\n * Method: GET\n *\n * @param {string} taskID - The Box ID of the task to get assignments for\n * @param {Object} [options] - Additional parameters, can be left null in most cases\n * @param {Function} [callback] - Passed the list of assignments if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of assignment objects\n */ Tasks.prototype.getAssignments = function(taskID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, taskID, ASSIGNMENTS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Get a specific task assignment\n *\n * API Endpoint: '/task_assignments/:assignmentID'\n * Method: GET\n *\n * @param {string} assignmentID - The Box ID of the task assignment to retrieve\n * @param {Object} [options] - Additional parameters, can be left null in most cases\n * @param {Function} [callback] - Passed the task assignment if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the assignment object\n */ Tasks.prototype.getAssignment = function(assignmentID, options, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Assign a task to a specific user by ID\n *\n * API Endpoint: '/task_assignments'\n * Method: POST\n *\n * @param {string} taskID - The Box ID of the task to assign\n * @param {string} userID - The ID of the user to assign the task to\n * @param {Function} [callback] - Passed the task assignment if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the new assignment object\n */ Tasks.prototype.assignByUserID = function(taskID, userID, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n        body: {\n            task: {\n                type: \"task\",\n                id: taskID\n            },\n            assign_to: {\n                id: userID\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Assign a task to a specific user by email address\n *\n * API Endpoint: '/task_assignments'\n * Method: POST\n *\n * @param {string} taskID - The Box ID of the task to assign\n * @param {string} email - The email address of the user to assign the task to\n * @param {Function} [callback] - Passed the task assignment if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the new assignment object\n */ Tasks.prototype.assignByEmail = function(taskID, email, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH), params = {\n        body: {\n            task: {\n                type: \"task\",\n                id: taskID\n            },\n            assign_to: {\n                login: email\n            }\n        }\n    };\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Update a task assignment.  This is used to resolve or complete a task.\n *\n * API Endpoint: '/task_assignments/:assignmentID'\n * Method: PUT\n *\n * @param {string} assignmentID - The Box ID of the task assignment to update\n * @param {Object} options - The fields of the assignment to update\n * @param {string} [options.message] - A message from the assignee about this task\n * @param {TaskResolutionState} [options.resolution_state] - Resolution of the task\n * @param {Function} [callback] - Passed the updated task assignment if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated assignment object\n */ Tasks.prototype.updateAssignment = function(assignmentID, options, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID), params = {\n        body: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Delete a task assignment.  This unassigns a user from the related task.\n *\n * API Endpoint: '/task_assignments/:assignmentID'\n * Method: DELETE\n *\n * @param {string} assignmentID - The Box ID of the task assignment to delete\n * @param {Function} [callback] - Passed nothing if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Tasks.prototype.deleteAssignment = function(assignmentID, callback) {\n    var apiPath = urlPath(ASSIGNMENTS_PATH, assignmentID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\nmodule.exports = Tasks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy90YXNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEYsMENBQTBDLEdBRTFDLGdGQUFnRjtBQUNoRixlQUFlO0FBQ2YsZ0ZBQWdGO0FBQ2hGLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXRCLGdGQUFnRjtBQUNoRixVQUFVO0FBQ1YsZ0ZBQWdGO0FBQ2hGLElBQUlDLFlBQVksVUFDZkMsMEJBQTBCLGVBQzFCQyxtQkFBbUIscUJBQ25CQyxnQkFBZ0I7QUFFakIsZ0ZBQWdGO0FBQ2hGLFNBQVM7QUFDVCxnRkFBZ0Y7QUFFaEY7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsTUFBTUMsTUFBTTtJQUNwQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBOzs7O0NBSUMsR0FDREQsTUFBTUUsU0FBUyxDQUFDQyxnQkFBZ0IsR0FBR0MsT0FBT0MsTUFBTSxDQUFDO0lBQ2hEQyxVQUFVO0lBQ1ZDLFlBQVk7SUFDWkMsVUFBVTtJQUNWQyxVQUFVO0FBQ1g7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRFQsTUFBTUUsU0FBUyxDQUFDUSxNQUFNLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7SUFFMUQsSUFBSUMsVUFBVXBCLFFBQVFFLFlBQ3JCbUIsU0FBUztRQUNSQyxNQUFNO1lBQ0xDLE1BQU07Z0JBQ0xDLE1BQU07Z0JBQ05DLElBQUlSO1lBQ0w7WUFDQVMsUUFBUXJCO1FBQ1Q7SUFDRDtJQUVESyxPQUFPaUIsTUFBTSxDQUFDTixPQUFPQyxJQUFJLEVBQUVKO0lBRTNCLE9BQU8sSUFBSSxDQUFDWCxNQUFNLENBQUNxQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNyQixNQUFNLENBQUNzQixJQUFJLEVBQUVULFNBQVNDLFFBQVFGO0FBQzlFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNE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QUFTQyxRQUFRRjtBQUM5RTtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNEYixNQUFNRSxTQUFTLENBQUN3QyxnQkFBZ0IsR0FBRyxTQUFTUixZQUFZLEVBQUV0QixPQUFPLEVBQUVDLFFBQVE7SUFFMUUsSUFBSUMsVUFBVXBCLFFBQVFJLGtCQUFrQm9DLGVBQ3ZDbkIsU0FBUztRQUNSQyxNQUFNSjtJQUNQO0lBRUQsT0FBTyxJQUFJLENBQUNYLE1BQU0sQ0FBQ3FCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3JCLE1BQU0sQ0FBQzRCLEdBQUcsRUFBRWYsU0FBU0MsUUFBUUY7QUFDN0U7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRGIsTUFBTUUsU0FBUyxDQUFDeUMsZ0JBQWdCLEdBQUcsU0FBU1QsWUFBWSxFQUFFckIsUUFBUTtJQUVqRSxJQUFJQyxVQUFVcEIsUUFBUUksa0JBQWtCb0M7SUFFeEMsT0FBTyxJQUFJLENBQUNqQyxNQUFNLENBQUNxQixzQkFBc0IsQ0FBQyxJQUFJLENBQUNyQixNQUFNLENBQUM4QixHQUFHLEVBQUVqQixTQUFTLE1BQU1EO0FBQzNFO0FBRUErQixPQUFPQyxPQUFPLEdBQUc3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvdGFza3MuanM/MDI5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIFRhc2tzIFJlc291cmNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZWRlZnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKiBAdHlwZWRlZiB7c3RyaW5nfSBUYXNrUmVzb2x1dGlvblN0YXRlICovXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy90YXNrcycsXG5cdEFTU0lHTk1FTlRTX1NVQlJFU09VUkNFID0gJ2Fzc2lnbm1lbnRzJyxcblx0QVNTSUdOTUVOVFNfUEFUSCA9ICcvdGFza19hc3NpZ25tZW50cycsXG5cdFJFVklFV19BQ1RJT04gPSAncmV2aWV3JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgJ1Rhc2tzJyBlbmRwb2ludHMgYW5kIGFjdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gVGhlIEJveCBBUEkgQ2xpZW50IHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIG1ha2luZyBjYWxscyB0byB0aGUgQVBJXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gVGFza3MoY2xpZW50KSB7XG5cdHRoaXMuY2xpZW50ID0gY2xpZW50O1xufVxuXG4vKipcbiAqIEVudW0gb2YgdmFsaWQgdGFzayByZXNvbHV0aW9uIHN0YXRlc1xuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7VGFza1Jlc29sdXRpb25TdGF0ZX1cbiAqL1xuVGFza3MucHJvdG90eXBlLnJlc29sdXRpb25TdGF0ZXMgPSBPYmplY3QuZnJlZXplKHtcblx0Q09NUExFVEU6ICdjb21wbGV0ZWQnLFxuXHRJTkNPTVBMRVRFOiAnaW5jb21wbGV0ZScsXG5cdEFQUFJPVkVEOiAnYXBwcm92ZWQnLFxuXHRSRUpFQ1RFRDogJ3JlamVjdGVkJ1xufSk7XG5cbi8qKlxuICogVXNlZCB0byBjcmVhdGUgYSBzaW5nbGUgdGFzayBmb3Igc2luZ2xlIHVzZXIgb24gYSBzaW5nbGUgZmlsZS5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdGFza3MnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZUlEIC0gVGhlIElEIG9mIHRoZSBpdGVtIHRoaXMgdGFzayBpcyBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXSAtIEFuIG9wdGlvbmFsIG1lc3NhZ2UgdG8gaW5jbHVkZSB3aXRoIHRoZSB0YXNrXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZHVlX2F0XSAtIFRoZSBkYXkgYXQgd2hpY2ggdGhpcyB0YXNrIGlzIGR1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbmV3IHRhc2sgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseSwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjcmVhdGVkIHRhc2sgb2JqZWN0XG4gKi9cblRhc2tzLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihmaWxlSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHRpdGVtOiB7XG5cdFx0XHRcdFx0dHlwZTogJ2ZpbGUnLFxuXHRcdFx0XHRcdGlkOiBmaWxlSURcblx0XHRcdFx0fSxcblx0XHRcdFx0YWN0aW9uOiBSRVZJRVdfQUNUSU9OXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRPYmplY3QuYXNzaWduKHBhcmFtcy5ib2R5LCBvcHRpb25zKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogRmV0Y2hlcyBhIHNwZWNpZmljIHRhc2suXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3Rhc2tzLzp0YXNrSUQnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrSUQgLSBUaGUgQm94IElEIG9mIHRoZSB0YXNrIGJlaW5nIHJlcXVlc3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHRhc2sgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseSwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0YXNrIG9iamVjdFxuICovXG5UYXNrcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odGFza0lELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHRhc2tJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzcGVjaWZpYyB0YXNrLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy90YXNrcy86dGFza0lEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFza0lEIC0gVGhlIEJveCBJRCBvZiB0aGUgdGFzayBiZWluZyB1cGRhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gdXBkYXRlcyAtIEZpZWxkcyBvZiB0aGUgdGFzayBvYmplY3QgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMubWVzc2FnZV0gLSBBbiBvcHRpb25hbCBtZXNzYWdlIHRvIGluY2x1ZGUgd2l0aCB0aGUgdGFza1xuICogQHBhcmFtIHtzdHJpbmd9IFt1cGRhdGVzLmR1ZV9hdF0gLSBUaGUgZGF5IGF0IHdoaWNoIHRoaXMgdGFzayBpcyBkdWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgdGFzayBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgdGFzayBvYmplY3RcbiAqL1xuVGFza3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHRhc2tJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB0YXNrSUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHVwZGF0ZXNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFBlcm1hbmVudGx5IGRlbGV0ZXMgYSBzcGVjaWZpYyB0YXNrLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy90YXNrcy86dGFza0lEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFza0lEIC0gVGhlIEJveCBJRCBvZiB0aGUgdGFzayBiZWluZyBkZWxldGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgYm9keSBwYXNzZWQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cblRhc2tzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbih0YXNrSUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgdGFza0lEKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhc3NpZ25tZW50cyBmb3IgYSBnaXZlbiB0YXNrXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3Rhc2tzLzp0YXNrSUQvYXNzaWdubWVudHMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrSUQgLSBUaGUgQm94IElEIG9mIHRoZSB0YXNrIHRvIGdldCBhc3NpZ25tZW50cyBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMsIGNhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbGlzdCBvZiBhc3NpZ25tZW50cyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgYXNzaWdubWVudCBvYmplY3RzXG4gKi9cblRhc2tzLnByb3RvdHlwZS5nZXRBc3NpZ25tZW50cyA9IGZ1bmN0aW9uKHRhc2tJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB0YXNrSUQsIEFTU0lHTk1FTlRTX1NVQlJFU09VUkNFKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGEgc3BlY2lmaWMgdGFzayBhc3NpZ25tZW50XG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3Rhc2tfYXNzaWdubWVudHMvOmFzc2lnbm1lbnRJRCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFzc2lnbm1lbnRJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIHRhc2sgYXNzaWdubWVudCB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB0YXNrIGFzc2lnbm1lbnQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhc3NpZ25tZW50IG9iamVjdFxuICovXG5UYXNrcy5wcm90b3R5cGUuZ2V0QXNzaWdubWVudCA9IGZ1bmN0aW9uKGFzc2lnbm1lbnRJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVNTSUdOTUVOVFNfUEFUSCwgYXNzaWdubWVudElEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQXNzaWduIGEgdGFzayB0byBhIHNwZWNpZmljIHVzZXIgYnkgSURcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdGFza19hc3NpZ25tZW50cydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXNrSUQgLSBUaGUgQm94IElEIG9mIHRoZSB0YXNrIHRvIGFzc2lnblxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byBhc3NpZ24gdGhlIHRhc2sgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHRhc2sgYXNzaWdubWVudCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG5ldyBhc3NpZ25tZW50IG9iamVjdFxuICovXG5UYXNrcy5wcm90b3R5cGUuYXNzaWduQnlVc2VySUQgPSBmdW5jdGlvbih0YXNrSUQsIHVzZXJJRCwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQVNTSUdOTUVOVFNfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHR0YXNrOiB7XG5cdFx0XHRcdFx0dHlwZTogJ3Rhc2snLFxuXHRcdFx0XHRcdGlkOiB0YXNrSURcblx0XHRcdFx0fSxcblx0XHRcdFx0YXNzaWduX3RvOiB7XG5cdFx0XHRcdFx0aWQ6IHVzZXJJRFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQXNzaWduIGEgdGFzayB0byBhIHNwZWNpZmljIHVzZXIgYnkgZW1haWwgYWRkcmVzc1xuICpcbiAqIEFQSSBFbmRwb2ludDogJy90YXNrX2Fzc2lnbm1lbnRzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRhc2tJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIHRhc2sgdG8gYXNzaWduXG4gKiBAcGFyYW0ge3N0cmluZ30gZW1haWwgLSBUaGUgZW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlciB0byBhc3NpZ24gdGhlIHRhc2sgdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHRhc2sgYXNzaWdubWVudCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG5ldyBhc3NpZ25tZW50IG9iamVjdFxuICovXG5UYXNrcy5wcm90b3R5cGUuYXNzaWduQnlFbWFpbCA9IGZ1bmN0aW9uKHRhc2tJRCwgZW1haWwsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEFTU0lHTk1FTlRTX1BBVEgpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHtcblx0XHRcdFx0dGFzazoge1xuXHRcdFx0XHRcdHR5cGU6ICd0YXNrJyxcblx0XHRcdFx0XHRpZDogdGFza0lEXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFzc2lnbl90bzoge1xuXHRcdFx0XHRcdGxvZ2luOiBlbWFpbFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgdGFzayBhc3NpZ25tZW50LiAgVGhpcyBpcyB1c2VkIHRvIHJlc29sdmUgb3IgY29tcGxldGUgYSB0YXNrLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy90YXNrX2Fzc2lnbm1lbnRzLzphc3NpZ25tZW50SUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhc3NpZ25tZW50SUQgLSBUaGUgQm94IElEIG9mIHRoZSB0YXNrIGFzc2lnbm1lbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBmaWVsZHMgb2YgdGhlIGFzc2lnbm1lbnQgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWVzc2FnZV0gLSBBIG1lc3NhZ2UgZnJvbSB0aGUgYXNzaWduZWUgYWJvdXQgdGhpcyB0YXNrXG4gKiBAcGFyYW0ge1Rhc2tSZXNvbHV0aW9uU3RhdGV9IFtvcHRpb25zLnJlc29sdXRpb25fc3RhdGVdIC0gUmVzb2x1dGlvbiBvZiB0aGUgdGFza1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBkYXRlZCB0YXNrIGFzc2lnbm1lbnQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIGFzc2lnbm1lbnQgb2JqZWN0XG4gKi9cblRhc2tzLnByb3RvdHlwZS51cGRhdGVBc3NpZ25tZW50ID0gZnVuY3Rpb24oYXNzaWdubWVudElELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChBU1NJR05NRU5UU19QQVRILCBhc3NpZ25tZW50SUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIHRhc2sgYXNzaWdubWVudC4gIFRoaXMgdW5hc3NpZ25zIGEgdXNlciBmcm9tIHRoZSByZWxhdGVkIHRhc2suXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3Rhc2tfYXNzaWdubWVudHMvOmFzc2lnbm1lbnRJRCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFzc2lnbm1lbnRJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIHRhc2sgYXNzaWdubWVudCB0byBkZWxldGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgbm90aGluZyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuVGFza3MucHJvdG90eXBlLmRlbGV0ZUFzc2lnbm1lbnQgPSBmdW5jdGlvbihhc3NpZ25tZW50SUQsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEFTU0lHTk1FTlRTX1BBVEgsIGFzc2lnbm1lbnRJRCk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRhc2tzO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiQkFTRV9QQVRIIiwiQVNTSUdOTUVOVFNfU1VCUkVTT1VSQ0UiLCJBU1NJR05NRU5UU19QQVRIIiwiUkVWSUVXX0FDVElPTiIsIlRhc2tzIiwiY2xpZW50IiwicHJvdG90eXBlIiwicmVzb2x1dGlvblN0YXRlcyIsIk9iamVjdCIsImZyZWV6ZSIsIkNPTVBMRVRFIiwiSU5DT01QTEVURSIsIkFQUFJPVkVEIiwiUkVKRUNURUQiLCJjcmVhdGUiLCJmaWxlSUQiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhcGlQYXRoIiwicGFyYW1zIiwiYm9keSIsIml0ZW0iLCJ0eXBlIiwiaWQiLCJhY3Rpb24iLCJhc3NpZ24iLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwicG9zdCIsImdldCIsInRhc2tJRCIsInFzIiwidXBkYXRlIiwidXBkYXRlcyIsInB1dCIsImRlbGV0ZSIsImRlbCIsImdldEFzc2lnbm1lbnRzIiwiZ2V0QXNzaWdubWVudCIsImFzc2lnbm1lbnRJRCIsImFzc2lnbkJ5VXNlcklEIiwidXNlcklEIiwidGFzayIsImFzc2lnbl90byIsImFzc2lnbkJ5RW1haWwiLCJlbWFpbCIsImxvZ2luIiwidXBkYXRlQXNzaWdubWVudCIsImRlbGV0ZUFzc2lnbm1lbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/tasks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/terms-of-service.js":
/*!********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/terms-of-service.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the  Box Terms of Service Resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * Terms of service parameter constant\n * @typedef {string} TermsOfServicesStatus Determines whether the terms of service created is currently enabled or disabled\n * @typedef {string} TermsOfServicesType Determines whether the terms of service is for internal users or users outside of the enterprise\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\"), /* eslint-disable no-unused-vars*/ Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), /* eslint-enable no-unused-vars*/ errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\n// Base path for all terms of service endpoints\nvar BASE_PATH = \"/terms_of_services\", USER_STATUSES_PATH = \"/terms_of_service_user_statuses\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Terms of Services' and 'Terms of Service User Statuses' endpoints and actions.\n *\n * @param {BoxClient} client The Box API Client that is responsible for making calls to the API\n * @constructor\n */ function TermsOfService(client) {\n    // Attach the client, for making API calls\n    this.client = client;\n}\n/**\n * Enum value of scope of the custom terms of services set to either managed by an enterprise or enternal to an enterprise\n *\n * @readonly\n * @enum {TermsOfServicesType}\n */ TermsOfService.prototype.type = {\n    MANAGED: \"managed\",\n    EXTERNAL: \"external\"\n};\n/**\n * Enum value of status of the custom terms of services, either currently enabled or currently disabled\n *\n * @readonly\n * @enum {TermsOfServicesStatus}\n */ TermsOfService.prototype.status = {\n    ENABLED: \"enabled\",\n    DISABLED: \"disabled\"\n};\n/**\n * Creates a custom terms of services with user specified values\n *\n * API Endpoint: '/terms_of_services'\n * Method: POST\n *\n * @param {TermsOfServicesType} termsOfServicesType - Determine if the custom terms of service is scoped internall or externally to an enterprise\n * @param {TermsOfServicesStatus} termsOfServicesStatus - Determine if the custom terms of service is enabled or disabled\n * @param {string} termsOfServicesText - Text field for message associated with custom terms of services\n * @param {Function} [callback] - Passed the terms of services information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of services object\n */ TermsOfService.prototype.create = function(termsOfServicesType, termsOfServicesStatus, termsOfServicesText, callback) {\n    var params = {\n        body: {\n            status: termsOfServicesStatus,\n            tos_type: termsOfServicesType,\n            text: termsOfServicesText\n        }\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Updates a custom terms of services with new specified values\n *\n * API Endpoint: '/terms_of_services/:termsOfServicesID'\n * Method: PUT\n *\n * @param {string} termsOfServicesID - The id of the custom terms of services to update\n * @param {Object} updates - Fields ot the Terms of Service to update\n * @param {TermsOfServicesStatus} [updates.status] - Determine if the custom terms of service is scoped internall or externally to an enterprise\n * @param {string} [updates.text] - Text field for message associated with custom terms of services\n * @param {Function} [callback] - Passed the terms of services updated information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of services object\n */ TermsOfService.prototype.update = function(termsOfServicesID, updates, callback) {\n    var params = {\n        body: updates\n    };\n    var apiPath = urlPath(BASE_PATH, termsOfServicesID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Gets a specific custom terms of services with specified ID\n *\n * API Endpoint: '/terms_of_services/:termsOfServicesID'\n * Method: GET\n *\n * @param {string} termsOfServicesID - The id of the custom terms of services to retrieve\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {string} [options.fields] - Comma-separated list of fields to return on the collaboration objects\n * @param {Function} [callback] - Passed the terms of services information with specified ID if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of services object\n */ TermsOfService.prototype.get = function(termsOfServicesID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, termsOfServicesID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Gets custom terms of services for the user's enterprise\n *\n * API Endpoint: '/terms_of_services'\n * Method: GET\n *\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {TermsOfServiceType} [options.tos_type] - Optional, indicates whether the terms of service is set for external or managed under enterprise\n * @param {string} [options.fields] - Comma-separated list of fields to return on the collaboration objects\n * @param {Function} [callback] - Passed the terms of services information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of services object\n */ TermsOfService.prototype.getAll = function(options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Accepts/rejects custom terms of services for the user\n *\n * API Endpoint: '/terms_of_service_user_statuses'\n * Method: POST\n *\n * @param {string} termsOfServicesID - Terms of services ID to retrieve user statuses on\n * @param {boolean} isAccepted - Determines wehether the terms of services has been accepted or rejected\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {string} [options.user_id] - Optional, user id to retrieve terms of service status on, default is current user\n * @param {Function} [callback] - Passed the terms of service user status information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of service user status\n */ TermsOfService.prototype.createUserStatus = function(termsOfServicesID, isAccepted, options, callback) {\n    var params = {\n        body: {\n            tos: {\n                id: termsOfServicesID,\n                type: \"terms_of_service\"\n            },\n            is_accepted: isAccepted\n        }\n    };\n    if (options && options.user_id) {\n        params.body.user = {\n            id: options.user_id,\n            type: \"user\"\n        };\n    }\n    var apiPath = urlPath(USER_STATUSES_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Gets a terms os service status given the terms of services id\n *\n * API Endpoint: '/terms_of_service_user_statuses'\n * Method: GET\n *\n * @param {string} termsOfServicesID - The ID of the terms of services to retrieve status on\n * @param {Object} [options] - Additional options. Can be left null in most cases\n * @param {string} [options.user_id] - Optional, the id of the user to retrieve status of custom terms and service on\n * @param {Function} [callback] - Passed the terms of service user status information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of service user status\n */ TermsOfService.prototype.getUserStatus = function(termsOfServicesID, options, callback) {\n    var params = {\n        qs: {\n            tos_id: termsOfServicesID\n        }\n    };\n    if (options) {\n        Object.assign(params.qs, options);\n    }\n    var apiPath = urlPath(USER_STATUSES_PATH);\n    return this.client.get(apiPath, params).then((response)=>{\n        if (response.statusCode !== 200) {\n            throw errors.buildUnexpectedResponseError(response);\n        }\n        return response.body.entries[0];\n    }).asCallback(callback);\n};\n/**\n * Accepts/rejects custom terms of services for the user\n *\n * API Endpoint: '/terms_of_service_user_statuses'\n * Method: PUT\n *\n * @param {string} termsOfServiceUserStatusID - Terms of service user status object ID\n * @param {boolean} isAccepted - Determines wehether the terms of services has been accepted or rejected\n * @param {Function} [callback] - Passed the terms of service user status updated information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated terms of service user status\n */ TermsOfService.prototype.updateUserStatus = function(termsOfServiceUserStatusID, isAccepted, callback) {\n    var params = {\n        body: {\n            is_accepted: isAccepted\n        }\n    };\n    var apiPath = urlPath(USER_STATUSES_PATH, termsOfServiceUserStatusID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Creates a user status for terms of service, if already exists then update existing user status for terms of service\n *\n * API Endpoint: '/terms_of_service_user_statuses'\n * Method: POST/PUT\n *\n * @param {string} termsOfServicesID - Terms of services ID to retrieve user statuses on\n * @param {boolean} isAccepted - Determines wehether the terms of services has been accepted or rejected\n * @param {Object} [options] - Additional options. Can be left null in most cases.\n * @param {string} [options.user_id] - Optional, user id to retrieve terms of service status on, default is current user\n * @param {Function} [callback] - Passed the terms of service user status information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the terms of service user status\n */ TermsOfService.prototype.setUserStatus = function(termsOfServicesID, isAccepted, options, callback) {\n    var params = {\n        body: {\n            tos: {\n                id: termsOfServicesID,\n                type: \"terms_of_service\"\n            },\n            is_accepted: isAccepted\n        }\n    };\n    if (options && options.user_id) {\n        params.body.user = {\n            id: options.user_id,\n            type: \"user\"\n        };\n    }\n    var apiPath = urlPath(USER_STATUSES_PATH);\n    return this.client.post(apiPath, params).then((response)=>{\n        switch(response.statusCode){\n            // 200 - A user status has been successfully created on terms of service\n            // return the terms of service user status object\n            case httpStatusCodes.OK:\n                return response.body;\n            // 409 - Conflict\n            // Terms of Service already exists. Update the existing terms of service object\n            case httpStatusCodes.CONFLICT:\n                var getOptions = Object.assign({\n                    fields: \"id\"\n                }, options);\n                return this.getUserStatus(termsOfServicesID, getOptions).then((userStatus)=>this.updateUserStatus(userStatus.id, isAccepted));\n            default:\n                throw errors.buildUnexpectedResponseError(response);\n        }\n    }).asCallback(callback);\n};\n/**\n * @module box-node-sdk/lib/managers/terms-of-service\n * @see {@Link TermsOfService}\n */ module.exports = TermsOfService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy90ZXJtcy1vZi1zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFDQSxnRkFBZ0Y7QUFDaEYsV0FBVztBQUNYLGdGQUFnRjtBQUVoRjs7OztDQUlDLEdBRUQsZ0ZBQWdGO0FBQ2hGLGVBQWU7QUFDZixnRkFBZ0Y7QUFFaEYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUMsbUZBQ3JCLGdDQUFnQyxHQUNoQ0MsVUFBVUQsbUJBQU9BLENBQUMseUVBQ2xCLCtCQUErQixHQUMvQkUsU0FBU0YsbUJBQU9BLENBQUMsK0VBQ2pCRyxrQkFBa0JILG1CQUFPQSxDQUFDO0FBRTNCLGdGQUFnRjtBQUNoRixVQUFVO0FBQ1YsZ0ZBQWdGO0FBRWhGLCtDQUErQztBQUMvQyxJQUFJSSxZQUFZLHNCQUNmQyxxQkFBcUI7QUFFdEIsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7O0NBS0MsR0FDRCxTQUFTQyxlQUFlQyxNQUFNO0lBQzdCLDBDQUEwQztJQUMxQyxJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBOzs7OztDQUtDLEdBQ0RELGVBQWVFLFNBQVMsQ0FBQ0MsSUFBSSxHQUFHO0lBQy9CQyxTQUFTO0lBQ1RDLFVBQVU7QUFDWDtBQUVBOzs7OztDQUtDLEdBQ0RMLGVBQWVFLFNBQVMsQ0FBQ0ksTUFBTSxHQUFHO0lBQ2pDQyxTQUFTO0lBQ1RDLFVBQVU7QUFDWDtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBQ0RSLGVBQWVFLFNBQVMsQ0FBQ08sTUFBTSxHQUFHLFNBQVNDLG1CQUFtQixFQUFFQyxxQkFBcUIsRUFBRUMsbUJBQW1CLEVBQUVDLFFBQVE7SUFDbkgsSUFBSUMsU0FBUztRQUNaQyxNQUFNO1lBQ0xULFFBQVFLO1lBQ1JLLFVBQVVOO1lBQ1ZPLE1BQU1MO1FBQ1A7SUFDRDtJQUVBLElBQUlNLFVBQVV6QixRQUFRSztJQUN0QixPQUFPLElB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Q0FBQ08sV0FBV3JCLEVBQUUsRUFBRUY7WUFFM0Q7Z0JBQ0MsTUFBTWxDLE9BQU8rQyw0QkFBNEIsQ0FBQ0Y7UUFDM0M7SUFDRCxHQUNDSSxVQUFVLENBQUNoQztBQUNkO0FBRUE7OztDQUdDLEdBQ0R5QyxPQUFPQyxPQUFPLEdBQUd2RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvdGVybXMtb2Ytc2VydmljZS5qcz83OTc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBNYW5hZ2VyIGZvciB0aGUgIEJveCBUZXJtcyBvZiBTZXJ2aWNlIFJlc291cmNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRlcm1zIG9mIHNlcnZpY2UgcGFyYW1ldGVyIGNvbnN0YW50XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBUZXJtc09mU2VydmljZXNTdGF0dXMgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlIGNyZWF0ZWQgaXMgY3VycmVudGx5IGVuYWJsZWQgb3IgZGlzYWJsZWRcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IFRlcm1zT2ZTZXJ2aWNlc1R5cGUgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlIGlzIGZvciBpbnRlcm5hbCB1c2VycyBvciB1c2VycyBvdXRzaWRlIG9mIHRoZSBlbnRlcnByaXNlXG4gKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyksXG5cdC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzKi9cblx0UHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyksXG5cdC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMqL1xuXHRlcnJvcnMgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9ycycpLFxuXHRodHRwU3RhdHVzQ29kZXMgPSByZXF1aXJlKCdodHRwLXN0YXR1cycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQmFzZSBwYXRoIGZvciBhbGwgdGVybXMgb2Ygc2VydmljZSBlbmRwb2ludHNcbnZhciBCQVNFX1BBVEggPSAnL3Rlcm1zX29mX3NlcnZpY2VzJyxcblx0VVNFUl9TVEFUVVNFU19QQVRIID0gJy90ZXJtc19vZl9zZXJ2aWNlX3VzZXJfc3RhdHVzZXMnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsICdUZXJtcyBvZiBTZXJ2aWNlcycgYW5kICdUZXJtcyBvZiBTZXJ2aWNlIFVzZXIgU3RhdHVzZXMnIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRlcm1zT2ZTZXJ2aWNlKGNsaWVudCkge1xuXHQvLyBBdHRhY2ggdGhlIGNsaWVudCwgZm9yIG1ha2luZyBBUEkgY2FsbHNcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogRW51bSB2YWx1ZSBvZiBzY29wZSBvZiB0aGUgY3VzdG9tIHRlcm1zIG9mIHNlcnZpY2VzIHNldCB0byBlaXRoZXIgbWFuYWdlZCBieSBhbiBlbnRlcnByaXNlIG9yIGVudGVybmFsIHRvIGFuIGVudGVycHJpc2VcbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtUZXJtc09mU2VydmljZXNUeXBlfVxuICovXG5UZXJtc09mU2VydmljZS5wcm90b3R5cGUudHlwZSA9IHtcblx0TUFOQUdFRDogJ21hbmFnZWQnLFxuXHRFWFRFUk5BTDogJ2V4dGVybmFsJ1xufTtcblxuLyoqXG4gKiBFbnVtIHZhbHVlIG9mIHN0YXR1cyBvZiB0aGUgY3VzdG9tIHRlcm1zIG9mIHNlcnZpY2VzLCBlaXRoZXIgY3VycmVudGx5IGVuYWJsZWQgb3IgY3VycmVudGx5IGRpc2FibGVkXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7VGVybXNPZlNlcnZpY2VzU3RhdHVzfVxuICovXG5UZXJtc09mU2VydmljZS5wcm90b3R5cGUuc3RhdHVzID0ge1xuXHRFTkFCTEVEOiAnZW5hYmxlZCcsXG5cdERJU0FCTEVEOiAnZGlzYWJsZWQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gdGVybXMgb2Ygc2VydmljZXMgd2l0aCB1c2VyIHNwZWNpZmllZCB2YWx1ZXNcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdGVybXNfb2Zfc2VydmljZXMnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge1Rlcm1zT2ZTZXJ2aWNlc1R5cGV9IHRlcm1zT2ZTZXJ2aWNlc1R5cGUgLSBEZXRlcm1pbmUgaWYgdGhlIGN1c3RvbSB0ZXJtcyBvZiBzZXJ2aWNlIGlzIHNjb3BlZCBpbnRlcm5hbGwgb3IgZXh0ZXJuYWxseSB0byBhbiBlbnRlcnByaXNlXG4gKiBAcGFyYW0ge1Rlcm1zT2ZTZXJ2aWNlc1N0YXR1c30gdGVybXNPZlNlcnZpY2VzU3RhdHVzIC0gRGV0ZXJtaW5lIGlmIHRoZSBjdXN0b20gdGVybXMgb2Ygc2VydmljZSBpcyBlbmFibGVkIG9yIGRpc2FibGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybXNPZlNlcnZpY2VzVGV4dCAtIFRleHQgZmllbGQgZm9yIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIGN1c3RvbSB0ZXJtcyBvZiBzZXJ2aWNlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGVybXMgb2Ygc2VydmljZXMgaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlcyBvYmplY3RcbiAqL1xuVGVybXNPZlNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHRlcm1zT2ZTZXJ2aWNlc1R5cGUsIHRlcm1zT2ZTZXJ2aWNlc1N0YXR1cywgdGVybXNPZlNlcnZpY2VzVGV4dCwgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHRzdGF0dXM6IHRlcm1zT2ZTZXJ2aWNlc1N0YXR1cyxcblx0XHRcdHRvc190eXBlOiB0ZXJtc09mU2VydmljZXNUeXBlLFxuXHRcdFx0dGV4dDogdGVybXNPZlNlcnZpY2VzVGV4dFxuXHRcdH1cblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBjdXN0b20gdGVybXMgb2Ygc2VydmljZXMgd2l0aCBuZXcgc3BlY2lmaWVkIHZhbHVlc1xuICpcbiAqIEFQSSBFbmRwb2ludDogJy90ZXJtc19vZl9zZXJ2aWNlcy86dGVybXNPZlNlcnZpY2VzSUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtc09mU2VydmljZXNJRCAtIFRoZSBpZCBvZiB0aGUgY3VzdG9tIHRlcm1zIG9mIHNlcnZpY2VzIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXMgLSBGaWVsZHMgb3QgdGhlIFRlcm1zIG9mIFNlcnZpY2UgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge1Rlcm1zT2ZTZXJ2aWNlc1N0YXR1c30gW3VwZGF0ZXMuc3RhdHVzXSAtIERldGVybWluZSBpZiB0aGUgY3VzdG9tIHRlcm1zIG9mIHNlcnZpY2UgaXMgc2NvcGVkIGludGVybmFsbCBvciBleHRlcm5hbGx5IHRvIGFuIGVudGVycHJpc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdXBkYXRlcy50ZXh0XSAtIFRleHQgZmllbGQgZm9yIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIGN1c3RvbSB0ZXJtcyBvZiBzZXJ2aWNlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGVybXMgb2Ygc2VydmljZXMgdXBkYXRlZCBpbmZvcm1hdGlvbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRlcm1zIG9mIHNlcnZpY2VzIG9iamVjdFxuICovXG5UZXJtc09mU2VydmljZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odGVybXNPZlNlcnZpY2VzSUQsIHVwZGF0ZXMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keTogdXBkYXRlc1xuXHR9O1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHRlcm1zT2ZTZXJ2aWNlc0lEKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucHV0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0cyBhIHNwZWNpZmljIGN1c3RvbSB0ZXJtcyBvZiBzZXJ2aWNlcyB3aXRoIHNwZWNpZmllZCBJRFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy90ZXJtc19vZl9zZXJ2aWNlcy86dGVybXNPZlNlcnZpY2VzSUQnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtc09mU2VydmljZXNJRCAtIFRoZSBpZCBvZiB0aGUgY3VzdG9tIHRlcm1zIG9mIHNlcnZpY2VzIHRvIHJldHJpZXZlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmllbGRzXSAtIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkcyB0byByZXR1cm4gb24gdGhlIGNvbGxhYm9yYXRpb24gb2JqZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGVybXMgb2Ygc2VydmljZXMgaW5mb3JtYXRpb24gd2l0aCBzcGVjaWZpZWQgSUQgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlcyBvYmplY3RcbiAqL1xuVGVybXNPZlNlcnZpY2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHRlcm1zT2ZTZXJ2aWNlc0lELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdHFzOiBvcHRpb25zXG5cdH07XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgdGVybXNPZlNlcnZpY2VzSUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXRzIGN1c3RvbSB0ZXJtcyBvZiBzZXJ2aWNlcyBmb3IgdGhlIHVzZXIncyBlbnRlcnByaXNlXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3Rlcm1zX29mX3NlcnZpY2VzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zLiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge1Rlcm1zT2ZTZXJ2aWNlVHlwZX0gW29wdGlvbnMudG9zX3R5cGVdIC0gT3B0aW9uYWwsIGluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlIGlzIHNldCBmb3IgZXh0ZXJuYWwgb3IgbWFuYWdlZCB1bmRlciBlbnRlcnByaXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmllbGRzXSAtIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkcyB0byByZXR1cm4gb24gdGhlIGNvbGxhYm9yYXRpb24gb2JqZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGVybXMgb2Ygc2VydmljZXMgaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlcyBvYmplY3RcbiAqL1xuVGVybXNPZlNlcnZpY2UucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnNcblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQWNjZXB0cy9yZWplY3RzIGN1c3RvbSB0ZXJtcyBvZiBzZXJ2aWNlcyBmb3IgdGhlIHVzZXJcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdGVybXNfb2Zfc2VydmljZV91c2VyX3N0YXR1c2VzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRlcm1zT2ZTZXJ2aWNlc0lEIC0gVGVybXMgb2Ygc2VydmljZXMgSUQgdG8gcmV0cmlldmUgdXNlciBzdGF0dXNlcyBvblxuICogQHBhcmFtIHtib29sZWFufSBpc0FjY2VwdGVkIC0gRGV0ZXJtaW5lcyB3ZWhldGhlciB0aGUgdGVybXMgb2Ygc2VydmljZXMgaGFzIGJlZW4gYWNjZXB0ZWQgb3IgcmVqZWN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51c2VyX2lkXSAtIE9wdGlvbmFsLCB1c2VyIGlkIHRvIHJldHJpZXZlIHRlcm1zIG9mIHNlcnZpY2Ugc3RhdHVzIG9uLCBkZWZhdWx0IGlzIGN1cnJlbnQgdXNlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGVybXMgb2Ygc2VydmljZSB1c2VyIHN0YXR1cyBpbmZvcm1hdGlvbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHRlcm1zIG9mIHNlcnZpY2UgdXNlciBzdGF0dXNcbiAqL1xuVGVybXNPZlNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZVVzZXJTdGF0dXMgPSBmdW5jdGlvbih0ZXJtc09mU2VydmljZXNJRCwgaXNBY2NlcHRlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHR0b3M6IHtcblx0XHRcdFx0aWQ6IHRlcm1zT2ZTZXJ2aWNlc0lELFxuXHRcdFx0XHR0eXBlOiAndGVybXNfb2Zfc2VydmljZSdcblx0XHRcdH0sXG5cdFx0XHRpc19hY2NlcHRlZDogaXNBY2NlcHRlZFxuXHRcdH1cblx0fTtcblxuXHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVzZXJfaWQpIHtcblx0XHRwYXJhbXMuYm9keS51c2VyID0ge2lkOiBvcHRpb25zLnVzZXJfaWQsIHR5cGU6ICd1c2VyJ307XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoVVNFUl9TVEFUVVNFU19QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEdldHMgYSB0ZXJtcyBvcyBzZXJ2aWNlIHN0YXR1cyBnaXZlbiB0aGUgdGVybXMgb2Ygc2VydmljZXMgaWRcbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdGVybXNfb2Zfc2VydmljZV91c2VyX3N0YXR1c2VzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybXNPZlNlcnZpY2VzSUQgLSBUaGUgSUQgb2YgdGhlIHRlcm1zIG9mIHNlcnZpY2VzIHRvIHJldHJpZXZlIHN0YXR1cyBvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucy4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudXNlcl9pZF0gLSBPcHRpb25hbCwgdGhlIGlkIG9mIHRoZSB1c2VyIHRvIHJldHJpZXZlIHN0YXR1cyBvZiBjdXN0b20gdGVybXMgYW5kIHNlcnZpY2Ugb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHRlcm1zIG9mIHNlcnZpY2UgdXNlciBzdGF0dXMgaW5mb3JtYXRpb24gaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlIHVzZXIgc3RhdHVzXG4gKi9cblRlcm1zT2ZTZXJ2aWNlLnByb3RvdHlwZS5nZXRVc2VyU3RhdHVzID0gZnVuY3Rpb24odGVybXNPZlNlcnZpY2VzSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IHtcblx0XHRcdHRvc19pZDogdGVybXNPZlNlcnZpY2VzSURcblx0XHR9XG5cdH07XG5cblx0aWYgKG9wdGlvbnMpIHtcblx0XHRPYmplY3QuYXNzaWduKHBhcmFtcy5xcywgb3B0aW9ucyk7XG5cdH1cblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoVVNFUl9TVEFUVVNFU19QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LmdldChhcGlQYXRoLCBwYXJhbXMpXG5cdFx0LnRoZW4ocmVzcG9uc2UgPT4ge1xuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2UuYm9keS5lbnRyaWVzWzBdO1xuXHRcdH0pXG5cdFx0LmFzQ2FsbGJhY2soY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBY2NlcHRzL3JlamVjdHMgY3VzdG9tIHRlcm1zIG9mIHNlcnZpY2VzIGZvciB0aGUgdXNlclxuICpcbiAqIEFQSSBFbmRwb2ludDogJy90ZXJtc19vZl9zZXJ2aWNlX3VzZXJfc3RhdHVzZXMnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtc09mU2VydmljZVVzZXJTdGF0dXNJRCAtIFRlcm1zIG9mIHNlcnZpY2UgdXNlciBzdGF0dXMgb2JqZWN0IElEXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWNjZXB0ZWQgLSBEZXRlcm1pbmVzIHdlaGV0aGVyIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlcyBoYXMgYmVlbiBhY2NlcHRlZCBvciByZWplY3RlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdGVybXMgb2Ygc2VydmljZSB1c2VyIHN0YXR1cyB1cGRhdGVkIGluZm9ybWF0aW9uIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCB0ZXJtcyBvZiBzZXJ2aWNlIHVzZXIgc3RhdHVzXG4gKi9cblRlcm1zT2ZTZXJ2aWNlLnByb3RvdHlwZS51cGRhdGVVc2VyU3RhdHVzID0gZnVuY3Rpb24odGVybXNPZlNlcnZpY2VVc2VyU3RhdHVzSUQsIGlzQWNjZXB0ZWQsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0Ym9keToge1xuXHRcdFx0aXNfYWNjZXB0ZWQ6IGlzQWNjZXB0ZWRcblx0XHR9XG5cdH07XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKFVTRVJfU1RBVFVTRVNfUEFUSCwgdGVybXNPZlNlcnZpY2VVc2VyU3RhdHVzSUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdXNlciBzdGF0dXMgZm9yIHRlcm1zIG9mIHNlcnZpY2UsIGlmIGFscmVhZHkgZXhpc3RzIHRoZW4gdXBkYXRlIGV4aXN0aW5nIHVzZXIgc3RhdHVzIGZvciB0ZXJtcyBvZiBzZXJ2aWNlXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3Rlcm1zX29mX3NlcnZpY2VfdXNlcl9zdGF0dXNlcydcbiAqIE1ldGhvZDogUE9TVC9QVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybXNPZlNlcnZpY2VzSUQgLSBUZXJtcyBvZiBzZXJ2aWNlcyBJRCB0byByZXRyaWV2ZSB1c2VyIHN0YXR1c2VzIG9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWNjZXB0ZWQgLSBEZXRlcm1pbmVzIHdlaGV0aGVyIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlcyBoYXMgYmVlbiBhY2NlcHRlZCBvciByZWplY3RlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucy4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVzZXJfaWRdIC0gT3B0aW9uYWwsIHVzZXIgaWQgdG8gcmV0cmlldmUgdGVybXMgb2Ygc2VydmljZSBzdGF0dXMgb24sIGRlZmF1bHQgaXMgY3VycmVudCB1c2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB0ZXJtcyBvZiBzZXJ2aWNlIHVzZXIgc3RhdHVzIGluZm9ybWF0aW9uIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdGVybXMgb2Ygc2VydmljZSB1c2VyIHN0YXR1c1xuICovXG5UZXJtc09mU2VydmljZS5wcm90b3R5cGUuc2V0VXNlclN0YXR1cyA9IGZ1bmN0aW9uKHRlcm1zT2ZTZXJ2aWNlc0lELCBpc0FjY2VwdGVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IHtcblx0XHRcdHRvczoge1xuXHRcdFx0XHRpZDogdGVybXNPZlNlcnZpY2VzSUQsXG5cdFx0XHRcdHR5cGU6ICd0ZXJtc19vZl9zZXJ2aWNlJ1xuXHRcdFx0fSxcblx0XHRcdGlzX2FjY2VwdGVkOiBpc0FjY2VwdGVkXG5cdFx0fVxuXHR9O1xuXG5cdGlmIChvcHRpb25zICYmIG9wdGlvbnMudXNlcl9pZCkge1xuXHRcdHBhcmFtcy5ib2R5LnVzZXIgPSB7aWQ6IG9wdGlvbnMudXNlcl9pZCwgdHlwZTogJ3VzZXInfTtcblx0fVxuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChVU0VSX1NUQVRVU0VTX1BBVEgpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC5wb3N0KGFwaVBhdGgsIHBhcmFtcylcblx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1c0NvZGUpIHtcblxuXHRcdFx0Ly8gMjAwIC0gQSB1c2VyIHN0YXR1cyBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY3JlYXRlZCBvbiB0ZXJtcyBvZiBzZXJ2aWNlXG5cdFx0XHQvLyByZXR1cm4gdGhlIHRlcm1zIG9mIHNlcnZpY2UgdXNlciBzdGF0dXMgb2JqZWN0XG5cdFx0XHRjYXNlIGh0dHBTdGF0dXNDb2Rlcy5PSzpcblx0XHRcdFx0cmV0dXJuIHJlc3BvbnNlLmJvZHk7XG5cblx0XHRcdFx0Ly8gNDA5IC0gQ29uZmxpY3Rcblx0XHRcdFx0Ly8gVGVybXMgb2YgU2VydmljZSBhbHJlYWR5IGV4aXN0cy4gVXBkYXRlIHRoZSBleGlzdGluZyB0ZXJtcyBvZiBzZXJ2aWNlIG9iamVjdFxuXHRcdFx0Y2FzZSBodHRwU3RhdHVzQ29kZXMuQ09ORkxJQ1Q6XG5cdFx0XHRcdHZhciBnZXRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7ZmllbGRzOiAnaWQnfSwgb3B0aW9ucyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFVzZXJTdGF0dXModGVybXNPZlNlcnZpY2VzSUQsIGdldE9wdGlvbnMpXG5cdFx0XHRcdFx0LnRoZW4odXNlclN0YXR1cyA9PiB0aGlzLnVwZGF0ZVVzZXJTdGF0dXModXNlclN0YXR1cy5pZCwgaXNBY2NlcHRlZCkpO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHR9XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy90ZXJtcy1vZi1zZXJ2aWNlXG4gKiBAc2VlIHtATGluayBUZXJtc09mU2VydmljZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBUZXJtc09mU2VydmljZTtcblxuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiUHJvbWlzZSIsImVycm9ycyIsImh0dHBTdGF0dXNDb2RlcyIsIkJBU0VfUEFUSCIsIlVTRVJfU1RBVFVTRVNfUEFUSCIsIlRlcm1zT2ZTZXJ2aWNlIiwiY2xpZW50IiwicHJvdG90eXBlIiwidHlwZSIsIk1BTkFHRUQiLCJFWFRFUk5BTCIsInN0YXR1cyIsIkVOQUJMRUQiLCJESVNBQkxFRCIsImNyZWF0ZSIsInRlcm1zT2ZTZXJ2aWNlc1R5cGUiLCJ0ZXJtc09mU2VydmljZXNTdGF0dXMiLCJ0ZXJtc09mU2VydmljZXNUZXh0IiwiY2FsbGJhY2siLCJwYXJhbXMiLCJib2R5IiwidG9zX3R5cGUiLCJ0ZXh0IiwiYXBpUGF0aCIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJwb3N0IiwidXBkYXRlIiwidGVybXNPZlNlcnZpY2VzSUQiLCJ1cGRhdGVzIiwicHV0IiwiZ2V0Iiwib3B0aW9ucyIsInFzIiwiZ2V0QWxsIiwiY3JlYXRlVXNlclN0YXR1cyIsImlzQWNjZXB0ZWQiLCJ0b3MiLCJpZCIsImlzX2FjY2VwdGVkIiwidXNlcl9pZCIsInVzZXIiLCJnZXRVc2VyU3RhdHVzIiwidG9zX2lkIiwiT2JqZWN0IiwiYXNzaWduIiwidGhlbiIsInJlc3BvbnNlIiwic3RhdHVzQ29kZSIsImJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IiLCJlbnRyaWVzIiwiYXNDYWxsYmFjayIsInVwZGF0ZVVzZXJTdGF0dXMiLCJ0ZXJtc09mU2VydmljZVVzZXJTdGF0dXNJRCIsInNldFVzZXJTdGF0dXMiLCJPSyIsIkNPTkZMSUNUIiwiZ2V0T3B0aW9ucyIsImZpZWxkcyIsInVzZXJTdGF0dXMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/terms-of-service.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/trash.js":
/*!*********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/trash.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Trash Resource\n */ \n// -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\n// Trash is technically a folder, so it uses the folders endpoint\nvar BASE_PATH = \"/folders\", TRASH_ID = \"trash\", ITEMS_SUBRESOURCE = \"items\";\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all Trash endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Trash(client) {\n    this.client = client;\n}\n/**\n * Get items in the user's trash\n *\n * API Endpoint: '/folders/trash/items'\n * Method: GET\n *\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {string} [options.fields] - Comma-delimited list of item fields to return\n * @param {Function} [callback] - Passed the list of trashed items if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of trashed items\n */ Trash.prototype.get = function(options, callback) {\n    var apiPath = urlPath(BASE_PATH, TRASH_ID, ITEMS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\nmodule.exports = Trash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy90cmFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsZ0ZBQWdGO0FBQ2hGLGVBQWU7QUFDZixnRkFBZ0Y7QUFFaEYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFdEIsZ0ZBQWdGO0FBQ2hGLFVBQVU7QUFDVixnRkFBZ0Y7QUFFaEYsaUVBQWlFO0FBQ2pFLElBQUlDLFlBQVksWUFDZkMsV0FBVyxTQUNYQyxvQkFBb0I7QUFHckIsZ0ZBQWdGO0FBQ2hGLFNBQVM7QUFDVCxnRkFBZ0Y7QUFFaEY7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsTUFBTUMsTUFBTTtJQUNwQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDREQsTUFBTUUsU0FBUyxDQUFDQyxHQUFHLEdBQUcsU0FBU0MsT0FBTyxFQUFFQyxRQUFRO0lBRS9DLElBQUlDLFVBQVVYLFFBQVFFLFdBQVdDLFVBQVVDLG9CQUMxQ1EsU0FBUztRQUNSQyxJQUFJSjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNILE1BQU0sQ0FBQ1Esc0JBQXNCLENBQUMsSUFBSSxDQUFDUixNQUFNLENBQUNFLEdBQUcsRUFBRUcsU0FBU0MsUUFBUUY7QUFDN0U7QUFFQUssT0FBT0MsT0FBTyxHQUFHWCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvdHJhc2guanM/MzlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIFRyYXNoIFJlc291cmNlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFRyYXNoIGlzIHRlY2huaWNhbGx5IGEgZm9sZGVyLCBzbyBpdCB1c2VzIHRoZSBmb2xkZXJzIGVuZHBvaW50XG52YXIgQkFTRV9QQVRIID0gJy9mb2xkZXJzJyxcblx0VFJBU0hfSUQgPSAndHJhc2gnLFxuXHRJVEVNU19TVUJSRVNPVVJDRSA9ICdpdGVtcyc7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgVHJhc2ggZW5kcG9pbnRzIGFuZCBhY3Rpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCAtIFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIFRyYXNoKGNsaWVudCkge1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuLyoqXG4gKiBHZXQgaXRlbXMgaW4gdGhlIHVzZXIncyB0cmFzaFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy9mb2xkZXJzL3RyYXNoL2l0ZW1zJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVycywgY2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmllbGRzXSAtIENvbW1hLWRlbGltaXRlZCBsaXN0IG9mIGl0ZW0gZmllbGRzIHRvIHJldHVyblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbGlzdCBvZiB0cmFzaGVkIGl0ZW1zIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY29sbGVjdGlvbiBvZiB0cmFzaGVkIGl0ZW1zXG4gKi9cblRyYXNoLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIFRSQVNIX0lELCBJVEVNU19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYXNoO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiQkFTRV9QQVRIIiwiVFJBU0hfSUQiLCJJVEVNU19TVUJSRVNPVVJDRSIsIlRyYXNoIiwiY2xpZW50IiwicHJvdG90eXBlIiwiZ2V0Iiwib3B0aW9ucyIsImNhbGxiYWNrIiwiYXBpUGF0aCIsInBhcmFtcyIsInFzIiwid3JhcFdpdGhEZWZhdWx0SGFuZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/trash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/users.js":
/*!*********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/users.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box User Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/users\", EMAIL_ALIASES_SUBRESOURCE = \"email_aliases\", GROUP_MEMBERSHIPS_SUBRESOURCE = \"memberships\", CURRENT_USER_ID = \"me\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'User' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function Users(client) {\n    this.client = client;\n}\n/** @const {string} */ Users.prototype.CURRENT_USER_ID = CURRENT_USER_ID;\n/**\n * Requests information for the Box user info associated with a given ID\n *\n * API Endpoint: '/users/:id'\n * Method: GET\n *\n * @param {string} userID - The ID of the user to retrieve\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - passed the user info if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the user object\n */ Users.prototype.get = function(userID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, userID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Update some information about a user.\n *\n * API Endpoint: '/users/:id'\n * Method: PUT\n *\n * @param {string} userID - The ID of the user to update\n * @param {Object} updates - User fields to update\n * @param {Function} [callback] - Passed the updated user information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated user object\n */ Users.prototype.update = function(userID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, userID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Deletes a user in an enterprise account.\n *\n * API Endpoint: '/users/:userID'\n * Method: DELETE\n *\n * @param {string} userID - The ID of the user to delete\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {boolean} [options.notify] - Determines if the destination user should receive email notification of the transfer.\n * @param {boolean} [options.force] - Whether or not the user should be deleted even if this user still own files.\n * @param {Function} [callback] - Empty response body passed if successful, error otherwise\n * @returns {Promise<void>} A promise resolving to nothing\n */ Users.prototype.delete = function(userID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, userID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, params, callback);\n};\n/**\n * Get all linked email addresses for a user.\n * @NOTE(mwiller) 2014-06-10: This does not include their primary email address!\n *\n * API Endpoint: '/users/:id/email_aliases'\n * Method: GET\n *\n * @param {string} userID - The ID of the user to retrieve email alises for\n * @param {Function} [callback] - Passed the email aliases if successful\n * @returns {Promise<Object>} A promise resolving to the collection of email aliases\n */ Users.prototype.getEmailAliases = function(userID, callback) {\n    var apiPath = urlPath(BASE_PATH, userID, EMAIL_ALIASES_SUBRESOURCE);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, null, callback);\n};\n/**\n * Add a linked email address to a user's account.\n *\n * API Endpoint: '/users/:id/email_aliases'\n * Method: POST\n *\n * @param {string} userID - The ID of the user to add an email alias to\n * @param {string} email - The email address to add\n * @param {Object} [options] - Optional parameters\n * @param {boolean} [options.is_confirmed=false] Whether or not to attempt to auto-confirm the alias (for admins)\n * @param {Function} [callback] - Passed the new alias if successful\n * @returns {Promise<Object>} A promise resolving to the new email alias\n */ Users.prototype.addEmailAlias = function(userID, email, options, callback) {\n    options = options || {};\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    var apiPath = urlPath(BASE_PATH, userID, EMAIL_ALIASES_SUBRESOURCE), params = {\n        body: {\n            email,\n            is_confirmed: false // don't attempt to autoconfirm aliases for admins by default\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Remove a linked email address from the current user by alias ID.\n *\n * API Endpoint: '/users/:id/email_aliases/:aliasID'\n * Method: DELETE\n *\n * @param {string} userID - The ID of the user to remove the email alias from\n * @param {string} aliasID - The ID of the linked email alias to remove\n * @param {Function} [callback] - Passed nothing on success\n * @returns {Promise<void>} A promise resolving to nothing\n */ Users.prototype.removeEmailAlias = function(userID, aliasID, callback) {\n    var apiPath = urlPath(BASE_PATH, userID, EMAIL_ALIASES_SUBRESOURCE, aliasID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Retrieve a list of group memberships for the user, which show which groups\n * the user belongs to.  This ability is restricted to group admins.\n *\n * API Endpoint: '/users/:userID/memberships'\n * Method: GET\n *\n * @param {string} userID - The ID of the user to get group memberships for\n * @param {Object} [options] - Optional parameters, can be left null in most cases\n * @param {int} [options.limit] - The number of memberships to retrieve\n * @param {int} [options.offset] - Paging marker, retrieve records starting at this position in the list\n * @param {Function} [callback] - Passed a list of memberships if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of group memberships\n */ Users.prototype.getGroupMemberships = function(userID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, userID, GROUP_MEMBERSHIPS_SUBRESOURCE), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Retrieve the user's avatar image.\n *\n * API Endpoint: '/users/:userID/avatar'\n * Method: GET\n *\n * @param {string} userID The ID of the user whose avatar should be retrieved\n * @param {Function} [callback] Passed a stream over the bytes of the avatar image if successful\n * @returns {Promise<Readable>} A promise resolving to the image stream\n */ Users.prototype.getAvatar = function(userID, callback) {\n    var apiPath = urlPath(BASE_PATH, userID, \"avatar\"), params = {\n        streaming: true\n    };\n    return this.client.get(apiPath, params).asCallback(callback);\n};\n// @NOTE(fschott) 2014-05-06: Still need to implement get, edit, create, etc.\n//  The problem is that they are only available to enterprise admins, so we'll\n//  first need to figure out how we want to handle access to those methods.\n//  Remove this comment once we have.\n/**\n * @module box-node-sdk/lib/managers/users\n * @see {@Link Users}\n */ module.exports = Users;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy91c2Vycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFHdEIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFDakYsSUFBSUMsWUFBWSxVQUNmQyw0QkFBNEIsaUJBQzVCQyxnQ0FBZ0MsZUFDaENDLGtCQUFrQjtBQUduQixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxNQUFNQyxNQUFNO0lBQ3BCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtBQUNmO0FBRUEsb0JBQW9CLEdBQ3BCRCxNQUFNRSxTQUFTLENBQUNILGVBQWUsR0FBR0E7QUFFbEM7Ozs7Ozs7Ozs7Q0FVQyxHQUNEQyxNQUFNRSxTQUFTLENBQUNDLEdBQUcsR0FBRyxTQUFTQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUN2RCxJQUFJQyxVQUFVYixRQUFRRSxXQUFXUSxTQUNoQ0ksU0FBUztRQUNSQyxJQUFJSjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEdBQUcsRUFBRUksU0FBU0MsUUFBUUY7QUFDN0U7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0ROLE1BQU1FLFNBQVMsQ0FBQ1MsTUFBTSxHQUFHLFNBQVNQLE1BQU0sRUFBRVEsT0FBTyxFQUFFTixRQUFRO0lBQzFELElBQUlDLFVBQVViLFFBQVFFLFdBQVdRLFNBQ2hDSSxTQUFTO1FBQ1JLLE1BQU1EO0lBQ1A7SUFFRCxPQUFPLElBQUksQ0FBQ1gsTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ2EsR0FBRyxFQUFFUCxTQUFTQyxRQUFRRjtBQUM3RTtBQUVBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNETixNQUFNRSxTQUFTLENBQUNhLE1BQU0sR0FBRyxTQUFTWCxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUMxRCxJQUFJQyxVQUFVYixRQUFRRSxXQUFXUSxTQUNoQ0ksU0FBUztRQUNSQyxJQUFJSjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNlLEdBQUcsRUFBRVQsU0FBU0MsUUFBUUY7QUFDN0U7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0ROLE1BQU1FLFNBQVMsQ0FBQ2UsZUFBZSxHQUFHLFNBQVNiLE1BQU0sRUFBRUUsUUFBUTtJQUMxRCxJQUFJQyxVQUFVYixRQUFRRSxXQUFXUSxRQUFRUDtJQUN6QyxPQUFPLElBQUksQ0FBQ0ksTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ0UsR0FBRyxFQUFFSSxTQUFTLE1BQU1EO0FBQzNFO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0ROLE1BQU1FLFNBQVMsQ0FBQ2dCLGFBQWEsR0FBRyxTQUFTZCxNQUFNLEVBQUVlLEtBQUssRUFBRWQsT0FBTyxFQUFFQyxRQUFRO0lBRXhFRCxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFBSSxPQUFPQSxZQUFZLFlBQVk7UUFDbENDLFdBQVdEO1FBQ1hBLFVBQVUsQ0FBQztJQUNaO0lBRUEsSUFBSUUsVUFBVWIsUUFBUUUsV0FBV1EsUUFBUVAsNEJBQ3hDVyxTQUFTO1FBQ1JLLE1BQU07WUFDTE07WUFDQUMsY0FBYyxNQUFNLDZEQUE2RDtRQUNsRjtJQUNEO0lBRURDLE9BQU9DLE1BQU0sQ0FBQ2QsT0FBT0ssSUFBSSxFQUFFUjtJQUUzQixPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDUyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNULE1BQU0sQ0FBQ3NCLElBQUksRUFBRWhCLFNBQVNDLFFBQVFGO0FBQzlFO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNETixNQUFNRSxTQUFTLENBQUNzQixnQkFBZ0IsR0FBRyxTQUFTcEIsTUFBTSxFQUFFcUIsT0FBTyxFQUFFbkIsUUFBUTtJQUNwRSxJQUFJQyxVQUFVYixRQUFRRSxXQUFXUSxRQUFRUCwyQkFBMkI0QjtJQUNwRSxPQUFPLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNlLEdBQUcsRUFBRVQsU0FBUyxNQUFNRDtBQUMzRTtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRE4sTUFBTUUsU0FBUyxDQUFDd0IsbUJBQW1CLEdBQUcsU0FBU3RCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBRXZFLElBQUlDLFVBQVViLFFBQVFFLFdBQVdRLFFBQVFOLGdDQUN4Q1UsU0FBUztRQUNSQyxJQUFJSjtJQUNMO0lBRUQsT0FBTyxJQUFJLENBQUNKLE1BQU0sQ0FBQ1Msc0JBQXNCLENBQUMsSUFBSSxDQUFDVCxNQUFNLENBQUNFLEdBQUcsRUFBRUksU0FBU0MsUUFBUUY7QUFDN0U7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRE4sTUFBTUUsU0FBUyxDQUFDeUIsU0FBUyxHQUFHLFNBQVN2QixNQUFNLEVBQUVFLFFBQVE7SUFFcEQsSUFBSUMsVUFBVWIsUUFBUUUsV0FBV1EsUUFBUSxXQUN4Q0ksU0FBUztRQUNSb0IsV0FBVztJQUNaO0lBRUQsT0FBTyxJQUFJLENBQUMzQixNQUFNLENBQUNFLEdBQUcsQ0FBQ0ksU0FBU0MsUUFDOUJxQixVQUFVLENBQUN2QjtBQUNkO0FBRUEsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RSwyRUFBMkU7QUFDM0UscUNBQXFDO0FBRXJDOzs7Q0FHQyxHQUNEd0IsT0FBT0MsT0FBTyxHQUFHL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL21hbmFnZXJzL3VzZXJzLmpzPzJmYTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1hbmFnZXIgZm9yIHRoZSBCb3ggVXNlciBSZXNvdXJjZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyk7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBCQVNFX1BBVEggPSAnL3VzZXJzJyxcblx0RU1BSUxfQUxJQVNFU19TVUJSRVNPVVJDRSA9ICdlbWFpbF9hbGlhc2VzJyxcblx0R1JPVVBfTUVNQkVSU0hJUFNfU1VCUkVTT1VSQ0UgPSAnbWVtYmVyc2hpcHMnLFxuXHRDVVJSRU5UX1VTRVJfSUQgPSAnbWUnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTaW1wbGUgbWFuYWdlciBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBhbGwgJ1VzZXInIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm94Q2xpZW50fSBjbGllbnQgLSBUaGUgQm94IEFQSSBDbGllbnQgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgbWFraW5nIGNhbGxzIHRvIHRoZSBBUElcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBVc2VycyhjbGllbnQpIHtcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cblVzZXJzLnByb3RvdHlwZS5DVVJSRU5UX1VTRVJfSUQgPSBDVVJSRU5UX1VTRVJfSUQ7XG5cbi8qKlxuICogUmVxdWVzdHMgaW5mb3JtYXRpb24gZm9yIHRoZSBCb3ggdXNlciBpbmZvIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIElEXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3VzZXJzLzppZCdcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHJlcXVlc3QuIENhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBwYXNzZWQgdGhlIHVzZXIgaW5mbyBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1c2VyIG9iamVjdFxuICovXG5Vc2Vycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24odXNlcklELCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB1c2VySUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdHFzOiBvcHRpb25zXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgc29tZSBpbmZvcm1hdGlvbiBhYm91dCBhIHVzZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3VzZXJzLzppZCdcbiAqIE1ldGhvZDogUFVUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byB1cGRhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIC0gVXNlciBmaWVsZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIHVzZXIgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCB1c2VyIG9iamVjdFxuICovXG5Vc2Vycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24odXNlcklELCB1cGRhdGVzLCBjYWxsYmFjaykge1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB1c2VySUQpLFxuXHRcdHBhcmFtcyA9IHtcblx0XHRcdGJvZHk6IHVwZGF0ZXNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgYSB1c2VyIGluIGFuIGVudGVycHJpc2UgYWNjb3VudC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdXNlcnMvOnVzZXJJRCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byBkZWxldGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm5vdGlmeV0gLSBEZXRlcm1pbmVzIGlmIHRoZSBkZXN0aW5hdGlvbiB1c2VyIHNob3VsZCByZWNlaXZlIGVtYWlsIG5vdGlmaWNhdGlvbiBvZiB0aGUgdHJhbnNmZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlXSAtIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIHNob3VsZCBiZSBkZWxldGVkIGV2ZW4gaWYgdGhpcyB1c2VyIHN0aWxsIG93biBmaWxlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBFbXB0eSByZXNwb25zZSBib2R5IHBhc3NlZCBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuVXNlcnMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKHVzZXJJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgdXNlcklEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRxczogb3B0aW9uc1xuXHRcdH07XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogR2V0IGFsbCBsaW5rZWQgZW1haWwgYWRkcmVzc2VzIGZvciBhIHVzZXIuXG4gKiBATk9URShtd2lsbGVyKSAyMDE0LTA2LTEwOiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlaXIgcHJpbWFyeSBlbWFpbCBhZGRyZXNzIVxuICpcbiAqIEFQSSBFbmRwb2ludDogJy91c2Vycy86aWQvZW1haWxfYWxpYXNlcydcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCAtIFRoZSBJRCBvZiB0aGUgdXNlciB0byByZXRyaWV2ZSBlbWFpbCBhbGlzZXMgZm9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBlbWFpbCBhbGlhc2VzIGlmIHN1Y2Nlc3NmdWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgZW1haWwgYWxpYXNlc1xuICovXG5Vc2Vycy5wcm90b3R5cGUuZ2V0RW1haWxBbGlhc2VzID0gZnVuY3Rpb24odXNlcklELCBjYWxsYmFjaykge1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB1c2VySUQsIEVNQUlMX0FMSUFTRVNfU1VCUkVTT1VSQ0UpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlua2VkIGVtYWlsIGFkZHJlc3MgdG8gYSB1c2VyJ3MgYWNjb3VudC5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvdXNlcnMvOmlkL2VtYWlsX2FsaWFzZXMnXG4gKiBNZXRob2Q6IFBPU1RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklEIC0gVGhlIElEIG9mIHRoZSB1c2VyIHRvIGFkZCBhbiBlbWFpbCBhbGlhcyB0b1xuICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsIC0gVGhlIGVtYWlsIGFkZHJlc3MgdG8gYWRkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc19jb25maXJtZWQ9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gYXV0by1jb25maXJtIHRoZSBhbGlhcyAoZm9yIGFkbWlucylcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIG5ldyBhbGlhcyBpZiBzdWNjZXNzZnVsXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXcgZW1haWwgYWxpYXNcbiAqL1xuVXNlcnMucHJvdG90eXBlLmFkZEVtYWlsQWxpYXMgPSBmdW5jdGlvbih1c2VySUQsIGVtYWlsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRjYWxsYmFjayA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgdXNlcklELCBFTUFJTF9BTElBU0VTX1NVQlJFU09VUkNFKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB7XG5cdFx0XHRcdGVtYWlsLFxuXHRcdFx0XHRpc19jb25maXJtZWQ6IGZhbHNlIC8vIGRvbid0IGF0dGVtcHQgdG8gYXV0b2NvbmZpcm0gYWxpYXNlcyBmb3IgYWRtaW5zIGJ5IGRlZmF1bHRcblx0XHRcdH1cblx0XHR9O1xuXG5cdE9iamVjdC5hc3NpZ24ocGFyYW1zLmJvZHksIG9wdGlvbnMpO1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYSBsaW5rZWQgZW1haWwgYWRkcmVzcyBmcm9tIHRoZSBjdXJyZW50IHVzZXIgYnkgYWxpYXMgSUQuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3VzZXJzLzppZC9lbWFpbF9hbGlhc2VzLzphbGlhc0lEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXNlcklEIC0gVGhlIElEIG9mIHRoZSB1c2VyIHRvIHJlbW92ZSB0aGUgZW1haWwgYWxpYXMgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzSUQgLSBUaGUgSUQgb2YgdGhlIGxpbmtlZCBlbWFpbCBhbGlhcyB0byByZW1vdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgbm90aGluZyBvbiBzdWNjZXNzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cblVzZXJzLnByb3RvdHlwZS5yZW1vdmVFbWFpbEFsaWFzID0gZnVuY3Rpb24odXNlcklELCBhbGlhc0lELCBjYWxsYmFjaykge1xuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB1c2VySUQsIEVNQUlMX0FMSUFTRVNfU1VCUkVTT1VSQ0UsIGFsaWFzSUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5kZWwpKGFwaVBhdGgsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSBsaXN0IG9mIGdyb3VwIG1lbWJlcnNoaXBzIGZvciB0aGUgdXNlciwgd2hpY2ggc2hvdyB3aGljaCBncm91cHNcbiAqIHRoZSB1c2VyIGJlbG9uZ3MgdG8uICBUaGlzIGFiaWxpdHkgaXMgcmVzdHJpY3RlZCB0byBncm91cCBhZG1pbnMuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3VzZXJzLzp1c2VySUQvbWVtYmVyc2hpcHMnXG4gKiBNZXRob2Q6IEdFVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1c2VySUQgLSBUaGUgSUQgb2YgdGhlIHVzZXIgdG8gZ2V0IGdyb3VwIG1lbWJlcnNoaXBzIGZvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMsIGNhbiBiZSBsZWZ0IG51bGwgaW4gbW9zdCBjYXNlc1xuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmxpbWl0XSAtIFRoZSBudW1iZXIgb2YgbWVtYmVyc2hpcHMgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7aW50fSBbb3B0aW9ucy5vZmZzZXRdIC0gUGFnaW5nIG1hcmtlciwgcmV0cmlldmUgcmVjb3JkcyBzdGFydGluZyBhdCB0aGlzIHBvc2l0aW9uIGluIHRoZSBsaXN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIGEgbGlzdCBvZiBtZW1iZXJzaGlwcyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2YgZ3JvdXAgbWVtYmVyc2hpcHNcbiAqL1xuVXNlcnMucHJvdG90eXBlLmdldEdyb3VwTWVtYmVyc2hpcHMgPSBmdW5jdGlvbih1c2VySUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgdXNlcklELCBHUk9VUF9NRU1CRVJTSElQU19TVUJSRVNPVVJDRSksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB1c2VyJ3MgYXZhdGFyIGltYWdlLlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy91c2Vycy86dXNlcklEL2F2YXRhcidcbiAqIE1ldGhvZDogR0VUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJRCBUaGUgSUQgb2YgdGhlIHVzZXIgd2hvc2UgYXZhdGFyIHNob3VsZCBiZSByZXRyaWV2ZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUGFzc2VkIGEgc3RyZWFtIG92ZXIgdGhlIGJ5dGVzIG9mIHRoZSBhdmF0YXIgaW1hZ2UgaWYgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8UmVhZGFibGU+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBpbWFnZSBzdHJlYW1cbiAqL1xuVXNlcnMucHJvdG90eXBlLmdldEF2YXRhciA9IGZ1bmN0aW9uKHVzZXJJRCwgY2FsbGJhY2spIHtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB1c2VySUQsICdhdmF0YXInKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRzdHJlYW1pbmc6IHRydWVcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC5nZXQoYXBpUGF0aCwgcGFyYW1zKVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8vIEBOT1RFKGZzY2hvdHQpIDIwMTQtMDUtMDY6IFN0aWxsIG5lZWQgdG8gaW1wbGVtZW50IGdldCwgZWRpdCwgY3JlYXRlLCBldGMuXG4vLyAgVGhlIHByb2JsZW0gaXMgdGhhdCB0aGV5IGFyZSBvbmx5IGF2YWlsYWJsZSB0byBlbnRlcnByaXNlIGFkbWlucywgc28gd2UnbGxcbi8vICBmaXJzdCBuZWVkIHRvIGZpZ3VyZSBvdXQgaG93IHdlIHdhbnQgdG8gaGFuZGxlIGFjY2VzcyB0byB0aG9zZSBtZXRob2RzLlxuLy8gIFJlbW92ZSB0aGlzIGNvbW1lbnQgb25jZSB3ZSBoYXZlLlxuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy91c2Vyc1xuICogQHNlZSB7QExpbmsgVXNlcnN9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gVXNlcnM7XG4iXSwibmFtZXMiOlsidXJsUGF0aCIsInJlcXVpcmUiLCJCQVNFX1BBVEgiLCJFTUFJTF9BTElBU0VTX1NVQlJFU09VUkNFIiwiR1JPVVBfTUVNQkVSU0hJUFNfU1VCUkVTT1VSQ0UiLCJDVVJSRU5UX1VTRVJfSUQiLCJVc2VycyIsImNsaWVudCIsInByb3RvdHlwZSIsImdldCIsInVzZXJJRCIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFwaVBhdGgiLCJwYXJhbXMiLCJxcyIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJ1cGRhdGUiLCJ1cGRhdGVzIiwiYm9keSIsInB1dCIsImRlbGV0ZSIsImRlbCIsImdldEVtYWlsQWxpYXNlcyIsImFkZEVtYWlsQWxpYXMiLCJlbWFpbCIsImlzX2NvbmZpcm1lZCIsIk9iamVjdCIsImFzc2lnbiIsInBvc3QiLCJyZW1vdmVFbWFpbEFsaWFzIiwiYWxpYXNJRCIsImdldEdyb3VwTWVtYmVyc2hpcHMiLCJnZXRBdmF0YXIiLCJzdHJlYW1pbmciLCJhc0NhbGxiYWNrIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/users.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/web-links.js":
/*!*************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/web-links.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Web Links Resource\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar BASE_PATH = \"/web_links\";\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Weblinks' endpoints and actions.\n *\n * @constructor\n * @param {BoxClient} client - The Box API Client that is responsible for making calls to the API\n * @returns {void}\n */ function WebLinks(client) {\n    this.client = client;\n}\n/**\n * Creates a web link object within a given folder.\n *\n * API Endpoint: '/web_links'\n * Method: POST\n *\n * @param {string} url - URL you want the web link to point to. Must include http:// or https://\n * @param {string} parentID - The ID of the parent folder where you're creating the web link\n * @param {Object} [options] - Additional parameters\n * @param {string} [options.name] - Name for the web link. Will default to the URL if empty.\n * @param {string} [options.description] - Description of the web link. Will provide more context to users about the web link.\n * @param {Function} [callback] - Passed the new web link information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the created weblink object\n */ WebLinks.prototype.create = function(url, parentID, options, callback) {\n    var apiPath = urlPath(BASE_PATH), params = {\n        body: {\n            url,\n            parent: {\n                id: parentID\n            }\n        }\n    };\n    Object.assign(params.body, options);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Use to get information about the web link.\n *\n * API Endpoint: '/web_links/:weblinkID'\n * Method: GET\n *\n * @param {string} weblinkID - The Box ID of web link being requested\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the web-link information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the weblink object\n */ WebLinks.prototype.get = function(weblinkID, options, callback) {\n    var apiPath = urlPath(BASE_PATH, weblinkID), params = {\n        qs: options\n    };\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Updates information for a web link.\n *\n * API Endpoint: '/web_links/:weblinkID'\n * Method: PUT\n *\n * @param {string} weblinkID - The Box ID of the web link being updated\n * @param {Object} updates - Fields of the weblink to update\n * @param {string} [updates.name] - Name for the web link. Will default to the URL if empty.\n * @param {string} [updates.description] - Description of the web link. Will provide more context to users about the web link.\n * @param {Function} [callback] - Passed the updated web link information if it was acquired successfully, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated web link object\n */ WebLinks.prototype.update = function(weblinkID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, weblinkID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Deletes a web link and moves it to the trash\n *\n * API Endpoint: '/web_links/:weblinkID'\n * Method: DELETE\n *\n * @param {string} weblinkID - The Box ID of the web link being moved to the trash\n * @param {Function} [callback] - Empty body passed if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to nothing\n */ WebLinks.prototype.delete = function(weblinkID, callback) {\n    var apiPath = urlPath(BASE_PATH, weblinkID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Move a web link into a new parent folder.\n *\n * API Endpoint: '/web_links/:webLinkID'\n * Method: PUT\n *\n * @param {string} webLinkID - The Box ID of the web link being requested\n * @param {string} newParentID - The Box ID for the new parent folder. '0' to move to All Files.\n * @param {Function} [callback] - Passed the updated web link information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the updated web link object\n */ WebLinks.prototype.move = function(webLinkID, newParentID, callback) {\n    var params = {\n        body: {\n            parent: {\n                id: newParentID\n            }\n        }\n    };\n    var apiPath = urlPath(BASE_PATH, webLinkID);\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Copy a web link into a new, different folder\n *\n * API Endpoint: '/web_links/:webLinkID/copy\n * Method: POST\n *\n * @param {string} webLinkID - The Box ID of the web link being requested\n * @param {string} newParentID - The Box ID for the new parent folder. '0' to copy to All Files.\n * @param {Object} [options] - Optional parameters for the copy operation, can be left null in most cases\n * @param {string} [options.name] - A new name to use if there is an identically-named item in the new parent folder\n * @param {Function} [callback] - passed the new web link info if call was successful\n * @returns {Promise<Object>} A promise resolving to the new web link object\n */ WebLinks.prototype.copy = function(webLinkID, newParentID, options, callback) {\n    options = options || {};\n    options.parent = {\n        id: newParentID\n    };\n    var params = {\n        body: options\n    };\n    var apiPath = urlPath(BASE_PATH, webLinkID, \"/copy\");\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Add a web link to a given collection\n *\n * API Endpoint: '/web_links/:webLinkID'\n * Method: PUT\n *\n * @param {string} webLinkID - The web link to add to the collection\n * @param {string} collectionID - The collection to add the web link to\n * @param {Function} [callback] - Passed the updated web link if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated web link object\n */ WebLinks.prototype.addToCollection = function(webLinkID, collectionID, callback) {\n    return this.get(webLinkID, {\n        fields: \"collections\"\n    }).then((data)=>{\n        var collections = data.collections || [];\n        // Convert to correct format\n        collections = collections.map((c)=>({\n                id: c.id\n            }));\n        if (!collections.find((c)=>c.id === collectionID)) {\n            collections.push({\n                id: collectionID\n            });\n        }\n        return this.update(webLinkID, {\n            collections\n        });\n    }).asCallback(callback);\n};\n/**\n * Remove a web link from a given collection\n *\n * API Endpoint: '/web_links/:webLinkID'\n * Method: PUT\n *\n * @param {string} webLinkID - The web link to remove from the collection\n * @param {string} collectionID - The collection to remove the web link from\n * @param {Function} [callback] - Passed the updated web link if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated web link object\n */ WebLinks.prototype.removeFromCollection = function(webLinkID, collectionID, callback) {\n    return this.get(webLinkID, {\n        fields: \"collections\"\n    }).then((data)=>{\n        var collections = data.collections || [];\n        // Convert to correct object format and remove the specified collection\n        collections = collections.map((c)=>({\n                id: c.id\n            })).filter((c)=>c.id !== collectionID);\n        return this.update(webLinkID, {\n            collections\n        });\n    }).asCallback(callback);\n};\nmodule.exports = WebLinks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy93ZWItbGlua3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBQ2pGLElBQUlBLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXRCLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBQ2pGLElBQUlDLFlBQVk7QUFFaEIsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsU0FBU0MsTUFBTTtJQUN2QixJQUFJLENBQUNBLE1BQU0sR0FBR0E7QUFDZjtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDREQsU0FBU0UsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0MsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsUUFBUTtJQUNwRSxJQUFJQyxVQUFVWCxRQUFRRSxZQUNyQlUsU0FBUztRQUNSQyxNQUFNO1lBQ0xOO1lBQ0FPLFFBQVE7Z0JBQ1BDLElBQUlQO1lBQ0w7UUFDRDtJQUNEO0lBRURRLE9BQU9DLE1BQU0sQ0FBQ0wsT0FBT0MsSUFBSSxFQUFFSjtJQUUzQixPQUFPLElBQUksQ0FBQ0wsTUFBTSxDQUFDYyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsSUFBSSxFQUFFUixTQUFTQyxRQUFRRjtBQUM5RTtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRFAsU0FBU0UsU0FBUyxDQUFDZSxHQUFHLEdBQUcsU0FBU0MsU0FBUyxFQUFFWixPQUFPLEVBQUVDLFFBQVE7SUFDN0QsSUFBSUMsVUFBVVgsUUFBUUUsV0FBV21CLFlBQ2hDVCxTQUFTO1FBQ1JVLElBQUliO0lBQ0w7SUFFRCxPQUFPLElBQUksQ0FBQ0wsTUFBTSxDQUFDYyxzQkFBc0IsQ0FBQyxJQUFJLENBQUNkLE1BQU0sQ0FBQ2dCLEdBQUcsRUFBRVQsU0FBU0MsUUFBUUY7QUFD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QUFBLElBQU07Z0JBQUN4QixJQUFJd0IsRUFBRXhCLEVBQUU7WUFBQSxJQUFJNkIsTUFBTSxDQUFDTCxDQUFBQSxJQUFLQSxFQUFFeEIsRUFBRSxLQUFLa0I7UUFFdEUsT0FBTyxJQUFJLENBQUNWLE1BQU0sQ0FBQ00sV0FBVztZQUFDUTtRQUFXO0lBQzNDLEdBQ0NLLFVBQVUsQ0FBQ2hDO0FBQ2Q7QUFFQW1DLE9BQU9DLE9BQU8sR0FBRzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy93ZWItbGlua3MuanM/MjFiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIFdlYiBMaW5rcyBSZXNvdXJjZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHVybFBhdGggPSByZXF1aXJlKCcuLi91dGlsL3VybC1wYXRoJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQkFTRV9QQVRIID0gJy93ZWJfbGlua3MnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2ltcGxlIG1hbmFnZXIgZm9yIGludGVyYWN0aW5nIHdpdGggYWxsICdXZWJsaW5rcycgZW5kcG9pbnRzIGFuZCBhY3Rpb25zLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb3hDbGllbnR9IGNsaWVudCAtIFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIFdlYkxpbmtzKGNsaWVudCkge1xuXHR0aGlzLmNsaWVudCA9IGNsaWVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgd2ViIGxpbmsgb2JqZWN0IHdpdGhpbiBhIGdpdmVuIGZvbGRlci5cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvd2ViX2xpbmtzJ1xuICogTWV0aG9kOiBQT1NUXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFVSTCB5b3Ugd2FudCB0aGUgd2ViIGxpbmsgdG8gcG9pbnQgdG8uIE11c3QgaW5jbHVkZSBodHRwOi8vIG9yIGh0dHBzOi8vXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgLSBUaGUgSUQgb2YgdGhlIHBhcmVudCBmb2xkZXIgd2hlcmUgeW91J3JlIGNyZWF0aW5nIHRoZSB3ZWIgbGlua1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm5hbWVdIC0gTmFtZSBmb3IgdGhlIHdlYiBsaW5rLiBXaWxsIGRlZmF1bHQgdG8gdGhlIFVSTCBpZiBlbXB0eS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kZXNjcmlwdGlvbl0gLSBEZXNjcmlwdGlvbiBvZiB0aGUgd2ViIGxpbmsuIFdpbGwgcHJvdmlkZSBtb3JlIGNvbnRleHQgdG8gdXNlcnMgYWJvdXQgdGhlIHdlYiBsaW5rLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbmV3IHdlYiBsaW5rIGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHksIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3JlYXRlZCB3ZWJsaW5rIG9iamVjdFxuICovXG5XZWJMaW5rcy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24odXJsLCBwYXJlbnRJRCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0Ym9keToge1xuXHRcdFx0XHR1cmwsXG5cdFx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRcdGlkOiBwYXJlbnRJRFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRPYmplY3QuYXNzaWduKHBhcmFtcy5ib2R5LCBvcHRpb25zKTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wb3N0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXNlIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgd2ViIGxpbmsuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3dlYl9saW5rcy86d2VibGlua0lEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2VibGlua0lEIC0gVGhlIEJveCBJRCBvZiB3ZWIgbGluayBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB3ZWItbGluayBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5LCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHdlYmxpbmsgb2JqZWN0XG4gKi9cbldlYkxpbmtzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih3ZWJsaW5rSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHdlYmxpbmtJRCksXG5cdFx0cGFyYW1zID0ge1xuXHRcdFx0cXM6IG9wdGlvbnNcblx0XHR9O1xuXG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LmdldCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgaW5mb3JtYXRpb24gZm9yIGEgd2ViIGxpbmsuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3dlYl9saW5rcy86d2VibGlua0lEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2VibGlua0lEIC0gVGhlIEJveCBJRCBvZiB0aGUgd2ViIGxpbmsgYmVpbmcgdXBkYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZXMgLSBGaWVsZHMgb2YgdGhlIHdlYmxpbmsgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMubmFtZV0gLSBOYW1lIGZvciB0aGUgd2ViIGxpbmsuIFdpbGwgZGVmYXVsdCB0byB0aGUgVVJMIGlmIGVtcHR5LlxuICogQHBhcmFtIHtzdHJpbmd9IFt1cGRhdGVzLmRlc2NyaXB0aW9uXSAtIERlc2NyaXB0aW9uIG9mIHRoZSB3ZWIgbGluay4gV2lsbCBwcm92aWRlIG1vcmUgY29udGV4dCB0byB1c2VycyBhYm91dCB0aGUgd2ViIGxpbmsuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB1cGRhdGVkIHdlYiBsaW5rIGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHksIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCB3ZWIgbGluayBvYmplY3RcbiAqL1xuV2ViTGlua3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHdlYmxpbmtJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgd2VibGlua0lEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB1cGRhdGVzXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgd2ViIGxpbmsgYW5kIG1vdmVzIGl0IHRvIHRoZSB0cmFzaFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy93ZWJfbGlua3MvOndlYmxpbmtJRCdcbiAqIE1ldGhvZDogREVMRVRFXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHdlYmxpbmtJRCAtIFRoZSBCb3ggSUQgb2YgdGhlIHdlYiBsaW5rIGJlaW5nIG1vdmVkIHRvIHRoZSB0cmFzaFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEVtcHR5IGJvZHkgcGFzc2VkIGlmIHN1Y2Nlc3NmdWwsIGVycm9yIG90aGVyd2lzZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byBub3RoaW5nXG4gKi9cbldlYkxpbmtzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbih3ZWJsaW5rSUQsIGNhbGxiYWNrKSB7XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHdlYmxpbmtJRCk7XG5cblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIE1vdmUgYSB3ZWIgbGluayBpbnRvIGEgbmV3IHBhcmVudCBmb2xkZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3dlYl9saW5rcy86d2ViTGlua0lEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViTGlua0lEIC0gVGhlIEJveCBJRCBvZiB0aGUgd2ViIGxpbmsgYmVpbmcgcmVxdWVzdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3UGFyZW50SUQgLSBUaGUgQm94IElEIGZvciB0aGUgbmV3IHBhcmVudCBmb2xkZXIuICcwJyB0byBtb3ZlIHRvIEFsbCBGaWxlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgd2ViIGxpbmsgaW5mb3JtYXRpb24gaWYgaXQgd2FzIGFjcXVpcmVkIHN1Y2Nlc3NmdWxseVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgdXBkYXRlZCB3ZWIgbGluayBvYmplY3RcbiAqL1xuV2ViTGlua3MucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbih3ZWJMaW5rSUQsIG5ld1BhcmVudElELCBjYWxsYmFjaykge1xuXHR2YXIgcGFyYW1zID0ge1xuXHRcdGJvZHk6IHtcblx0XHRcdHBhcmVudDoge1xuXHRcdFx0XHRpZDogbmV3UGFyZW50SURcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHdlYkxpbmtJRCk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnB1dCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIENvcHkgYSB3ZWIgbGluayBpbnRvIGEgbmV3LCBkaWZmZXJlbnQgZm9sZGVyXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3dlYl9saW5rcy86d2ViTGlua0lEL2NvcHlcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJMaW5rSUQgLSBUaGUgQm94IElEIG9mIHRoZSB3ZWIgbGluayBiZWluZyByZXF1ZXN0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXJlbnRJRCAtIFRoZSBCb3ggSUQgZm9yIHRoZSBuZXcgcGFyZW50IGZvbGRlci4gJzAnIHRvIGNvcHkgdG8gQWxsIEZpbGVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjb3B5IG9wZXJhdGlvbiwgY2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV0gLSBBIG5ldyBuYW1lIHRvIHVzZSBpZiB0aGVyZSBpcyBhbiBpZGVudGljYWxseS1uYW1lZCBpdGVtIGluIHRoZSBuZXcgcGFyZW50IGZvbGRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHBhc3NlZCB0aGUgbmV3IHdlYiBsaW5rIGluZm8gaWYgY2FsbCB3YXMgc3VjY2Vzc2Z1bFxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IHdlYiBsaW5rIG9iamVjdFxuICovXG5XZWJMaW5rcy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHdlYkxpbmtJRCwgbmV3UGFyZW50SUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5wYXJlbnQgPSB7XG5cdFx0aWQ6IG5ld1BhcmVudElEXG5cdH07XG5cblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiBvcHRpb25zXG5cdH07XG5cdHZhciBhcGlQYXRoID0gdXJsUGF0aChCQVNFX1BBVEgsIHdlYkxpbmtJRCwgJy9jb3B5Jyk7XG5cdHJldHVybiB0aGlzLmNsaWVudC53cmFwV2l0aERlZmF1bHRIYW5kbGVyKHRoaXMuY2xpZW50LnBvc3QpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBBZGQgYSB3ZWIgbGluayB0byBhIGdpdmVuIGNvbGxlY3Rpb25cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvd2ViX2xpbmtzLzp3ZWJMaW5rSUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJMaW5rSUQgLSBUaGUgd2ViIGxpbmsgdG8gYWRkIHRvIHRoZSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbklEIC0gVGhlIGNvbGxlY3Rpb24gdG8gYWRkIHRoZSB3ZWIgbGluayB0b1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgdXBkYXRlZCB3ZWIgbGluayBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgd2ViIGxpbmsgb2JqZWN0XG4gKi9cbldlYkxpbmtzLnByb3RvdHlwZS5hZGRUb0NvbGxlY3Rpb24gPSBmdW5jdGlvbih3ZWJMaW5rSUQsIGNvbGxlY3Rpb25JRCwgY2FsbGJhY2spIHtcblxuXHRyZXR1cm4gdGhpcy5nZXQod2ViTGlua0lELCB7ZmllbGRzOiAnY29sbGVjdGlvbnMnfSlcblx0XHQudGhlbihkYXRhID0+IHtcblxuXHRcdFx0dmFyIGNvbGxlY3Rpb25zID0gZGF0YS5jb2xsZWN0aW9ucyB8fCBbXTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBjb3JyZWN0IGZvcm1hdFxuXHRcdFx0Y29sbGVjdGlvbnMgPSBjb2xsZWN0aW9ucy5tYXAoYyA9PiAoe2lkOiBjLmlkfSkpO1xuXG5cdFx0XHRpZiAoIWNvbGxlY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBjb2xsZWN0aW9uSUQpKSB7XG5cblx0XHRcdFx0Y29sbGVjdGlvbnMucHVzaCh7aWQ6IGNvbGxlY3Rpb25JRH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcy51cGRhdGUod2ViTGlua0lELCB7Y29sbGVjdGlvbnN9KTtcblx0XHR9KVxuXHRcdC5hc0NhbGxiYWNrKGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgd2ViIGxpbmsgZnJvbSBhIGdpdmVuIGNvbGxlY3Rpb25cbiAqXG4gKiBBUEkgRW5kcG9pbnQ6ICcvd2ViX2xpbmtzLzp3ZWJMaW5rSUQnXG4gKiBNZXRob2Q6IFBVVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJMaW5rSUQgLSBUaGUgd2ViIGxpbmsgdG8gcmVtb3ZlIGZyb20gdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uSUQgLSBUaGUgY29sbGVjdGlvbiB0byByZW1vdmUgdGhlIHdlYiBsaW5rIGZyb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgd2ViIGxpbmsgaWYgc3VjY2Vzc2Z1bCwgZXJyb3Igb3RoZXJ3aXNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB1cGRhdGVkIHdlYiBsaW5rIG9iamVjdFxuICovXG5XZWJMaW5rcy5wcm90b3R5cGUucmVtb3ZlRnJvbUNvbGxlY3Rpb24gPSBmdW5jdGlvbih3ZWJMaW5rSUQsIGNvbGxlY3Rpb25JRCwgY2FsbGJhY2spIHtcblxuXHRyZXR1cm4gdGhpcy5nZXQod2ViTGlua0lELCB7ZmllbGRzOiAnY29sbGVjdGlvbnMnfSlcblx0XHQudGhlbihkYXRhID0+IHtcblxuXHRcdFx0dmFyIGNvbGxlY3Rpb25zID0gZGF0YS5jb2xsZWN0aW9ucyB8fCBbXTtcblx0XHRcdC8vIENvbnZlcnQgdG8gY29ycmVjdCBvYmplY3QgZm9ybWF0IGFuZCByZW1vdmUgdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uXG5cdFx0XHRjb2xsZWN0aW9ucyA9IGNvbGxlY3Rpb25zLm1hcChjID0+ICh7aWQ6IGMuaWR9KSkuZmlsdGVyKGMgPT4gYy5pZCAhPT0gY29sbGVjdGlvbklEKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMudXBkYXRlKHdlYkxpbmtJRCwge2NvbGxlY3Rpb25zfSk7XG5cdFx0fSlcblx0XHQuYXNDYWxsYmFjayhjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYkxpbmtzO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiQkFTRV9QQVRIIiwiV2ViTGlua3MiLCJjbGllbnQiLCJwcm90b3R5cGUiLCJjcmVhdGUiLCJ1cmwiLCJwYXJlbnRJRCIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFwaVBhdGgiLCJwYXJhbXMiLCJib2R5IiwicGFyZW50IiwiaWQiLCJPYmplY3QiLCJhc3NpZ24iLCJ3cmFwV2l0aERlZmF1bHRIYW5kbGVyIiwicG9zdCIsImdldCIsIndlYmxpbmtJRCIsInFzIiwidXBkYXRlIiwidXBkYXRlcyIsInB1dCIsImRlbGV0ZSIsImRlbCIsIm1vdmUiLCJ3ZWJMaW5rSUQiLCJuZXdQYXJlbnRJRCIsImNvcHkiLCJhZGRUb0NvbGxlY3Rpb24iLCJjb2xsZWN0aW9uSUQiLCJmaWVsZHMiLCJ0aGVuIiwiZGF0YSIsImNvbGxlY3Rpb25zIiwibWFwIiwiYyIsImZpbmQiLCJwdXNoIiwiYXNDYWxsYmFjayIsInJlbW92ZUZyb21Db2xsZWN0aW9uIiwiZmlsdGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/web-links.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/managers/webhooks.js":
/*!************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/managers/webhooks.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Manager for the Box Webhooks resource\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * A webhook trigger type constant\n * @typedef {string} WebhookTriggerType\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar urlPath = __webpack_require__(/*! ../util/url-path */ \"(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\n// Base path for all webhooks endpoints\nvar BASE_PATH = \"/webhooks\";\n// This prevents replay attacks\nconst MAX_MESSAGE_AGE = 10 * 60; // 10 minutes\n/**\n * Compute the message signature\n * @see {@Link https://developer.box.com/en/guides/webhooks/handle/setup-signatures/}\n *\n * @param {string} body - The request body of the webhook message\n * @param {Object} headers - The request headers of the webhook message\n * @param {?string} signatureKey - The signature to verify the message with\n * @returns {?string} - The message signature (or null, if it can't be computed)\n * @private\n */ function computeSignature(body, headers, signatureKey) {\n    if (!signatureKey) {\n        return null;\n    }\n    if (headers[\"box-signature-version\"] !== \"1\") {\n        return null;\n    }\n    if (headers[\"box-signature-algorithm\"] !== \"HmacSHA256\") {\n        return null;\n    }\n    let hmac = crypto.createHmac(\"sha256\", signatureKey);\n    hmac.update(body);\n    hmac.update(headers[\"box-delivery-timestamp\"]);\n    const signature = hmac.digest(\"base64\");\n    return signature;\n}\n/**\n * Validate the message signature\n * @see {@Link https://developer.box.com/en/guides/webhooks/handle/verify-signatures/}\n *\n * @param {string} body - The request body of the webhook message\n * @param {Object} headers - The request headers of the webhook message\n * @param {string} primarySignatureKey - The primary signature to verify the message with\n * @param {string} [secondarySignatureKey] - The secondary signature to verify the message with\n * @returns {boolean} - True or false\n * @private\n */ function validateSignature(body, headers, primarySignatureKey, secondarySignatureKey) {\n    // Either the primary or secondary signature must match the corresponding signature from Box\n    // (The use of two signatures allows the signing keys to be rotated one at a time)\n    const primarySignature = computeSignature(body, headers, primarySignatureKey);\n    if (primarySignature && primarySignature === headers[\"box-signature-primary\"]) {\n        return true;\n    }\n    const secondarySignature = computeSignature(body, headers, secondarySignatureKey);\n    if (secondarySignature && secondarySignature === headers[\"box-signature-secondary\"]) {\n        return true;\n    }\n    return false;\n}\n/**\n * Validate that the delivery timestamp is not too far in the past (to prevent replay attacks)\n *\n * @param {Object} headers - The request headers of the webhook message\n * @param {int} maxMessageAge - The maximum message age (in seconds)\n * @returns {boolean} - True or false\n * @private\n */ function validateDeliveryTimestamp(headers, maxMessageAge) {\n    const deliveryTime = Date.parse(headers[\"box-delivery-timestamp\"]);\n    const currentTime = Date.now();\n    const messageAge = (currentTime - deliveryTime) / 1000;\n    if (messageAge > maxMessageAge) {\n        return false;\n    }\n    return true;\n}\n/**\n * Stringify JSON with escaped multibyte Unicode characters to ensure computed signatures match PHP's default behavior\n *\n * @param {Object} body - The parsed JSON object\n * @returns {string} - Stringified JSON with escaped multibyte Unicode characters\n * @private\n */ function jsonStringifyWithEscapedUnicode(body) {\n    return JSON.stringify(body).replace(/[\\u007f-\\uffff]/g, (char)=>`\\\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);\n}\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Simple manager for interacting with all 'Webhooks' endpoints and actions.\n *\n * @param {BoxClient} client The Box API Client that is responsible for making calls to the API\n * @constructor\n */ function Webhooks(client) {\n    // Attach the client, for making API calls\n    this.client = client;\n}\n/**\n * Primary signature key to protect webhooks against attacks.\n * @static\n * @type {?string}\n */ Webhooks.primarySignatureKey = null;\n/**\n * Secondary signature key to protect webhooks against attacks.\n * @static\n * @type {?string}\n */ Webhooks.secondarySignatureKey = null;\n/**\n * Enum of valid webhooks event triggers\n *\n * @readonly\n * @enum {WebhookTriggerType}\n */ Webhooks.prototype.triggerTypes = {\n    FILE: {\n        UPLOADED: \"FILE.UPLOADED\",\n        PREVIEWED: \"FILE.PREVIEWED\",\n        DOWNLOADED: \"FILE.DOWNLOADED\",\n        TRASHED: \"FILE.TRASHED\",\n        DELETED: \"FILE.DELETED\",\n        RESTORED: \"FILE.RESTORED\",\n        COPIED: \"FILE.COPIED\",\n        MOVED: \"FILE.MOVED\",\n        LOCKED: \"FILE.LOCKED\",\n        UNLOCKED: \"FILE.UNLOCKED\",\n        RENAMED: \"FILE.RENAMED\"\n    },\n    COMMENT: {\n        CREATED: \"COMMENT.CREATED\",\n        UPDATED: \"COMMENT.UPDATED\",\n        DELETED: \"COMMENT.DELETED\"\n    },\n    TASK_ASSIGNMENT: {\n        CREATED: \"TASK_ASSIGNMENT.CREATED\",\n        UPDATED: \"TASK_ASSIGNMENT.UPDATED\"\n    },\n    METADATA_INSTANCE: {\n        CREATED: \"METADATA_INSTANCE.CREATED\",\n        UPDATED: \"METADATA_INSTANCE.UPDATED\",\n        DELETED: \"METADATA_INSTANCE.DELETED\"\n    },\n    FOLDER: {\n        CREATED: \"FOLDER.CREATED\",\n        DOWNLOADED: \"FOLDER.DOWNLOADED\",\n        RESTORED: \"FOLDER.RESTORED\",\n        DELETED: \"FOLDER.DELETED\",\n        COPIED: \"FOLDER.COPIED\",\n        MOVED: \"FOLDER.MOVED\",\n        TRASHED: \"FOLDER.TRASHED\",\n        RENAMED: \"FOLDER.RENAMED\"\n    },\n    WEBHOOK: {\n        DELETED: \"WEBHOOK.DELETED\"\n    },\n    COLLABORATION: {\n        CREATED: \"COLLABORATION.CREATED\",\n        ACCEPTED: \"COLLABORATION.ACCEPTED\",\n        REJECTED: \"COLLABORATION.REJECTED\",\n        REMOVED: \"COLLABORATION.REMOVED\",\n        UPDATED: \"COLLABORATION.UPDATED\"\n    },\n    SHARED_LINK: {\n        DELETED: \"SHARED_LINK.DELETED\",\n        CREATED: \"SHARED_LINK.CREATED\",\n        UPDATED: \"SHARED_LINK.UPDATED\"\n    }\n};\n/**\n * Create a new webhook on a given Box object, specified by type and ID.\n *\n * API Endpoint: '/webhooks'\n * Method: POST\n *\n * @param {string} targetID - Box ID  of the item to create webhook on\n * @param {ItemType} targetType - Type of item the webhook will be created on\n * @param {string} notificationURL - The URL of your application where Box will notify you of events triggers\n * @param {WebhookTriggerType[]} triggerTypes - Array of event types that trigger notification for the target\n * @param {Function} [callback] - Passed the new webhook information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the new webhook object\n */ Webhooks.prototype.create = function(targetID, targetType, notificationURL, triggerTypes, callback) {\n    var params = {\n        body: {\n            target: {\n                id: targetID,\n                type: targetType\n            },\n            address: notificationURL,\n            triggers: triggerTypes\n        }\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.post)(apiPath, params, callback);\n};\n/**\n * Returns a webhook object with the specified Webhook ID\n *\n * API Endpoint: '/webhooks/:webhookID'\n * Method: GET\n *\n * @param {string} webhookID - ID of the webhook to retrieve\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {Function} [callback] - Passed the webhook information if it was acquired successfully\n * @returns {Promise<Object>} A promise resolving to the webhook object\n */ Webhooks.prototype.get = function(webhookID, options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH, webhookID);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Get a list of webhooks that are active for the current application and user.\n *\n * API Endpoint: '/webhooks'\n * Method: GET\n *\n * @param {Object} [options] - Additional options for the request. Can be left null in most cases.\n * @param {int} [options.limit=100] - The number of webhooks to return\n * @param {string} [options.marker] - Pagination marker\n * @param {Function} [callback] - Passed the list of webhooks if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the collection of webhooks\n */ Webhooks.prototype.getAll = function(options, callback) {\n    var params = {\n        qs: options\n    };\n    var apiPath = urlPath(BASE_PATH);\n    return this.client.wrapWithDefaultHandler(this.client.get)(apiPath, params, callback);\n};\n/**\n * Update a webhook\n *\n * API Endpoint: '/webhooks/:webhookID'\n * Method: PUT\n *\n * @param {string} webhookID - The ID of the webhook to be updated\n * @param {Object} updates - Webhook fields to update\n * @param {string} [updates.address] - The new URL used by Box to send a notification when webhook is triggered\n * @param {WebhookTriggerType[]} [updates.triggers] - The new events that triggers a notification\n * @param {Function} [callback] - Passed the updated webhook information if successful, error otherwise\n * @returns {Promise<Object>} A promise resolving to the updated webhook object\n */ Webhooks.prototype.update = function(webhookID, updates, callback) {\n    var apiPath = urlPath(BASE_PATH, webhookID), params = {\n        body: updates\n    };\n    return this.client.wrapWithDefaultHandler(this.client.put)(apiPath, params, callback);\n};\n/**\n * Delete a specified webhook by ID\n *\n * API Endpoint: '/webhooks/:webhookID'\n * Method: DELETE\n *\n * @param {string} webhookID - ID of webhook to be deleted\n * @param {Function} [callback] - Empty response body passed if successful.\n * @returns {Promise<void>} A promise resolving to nothing\n */ Webhooks.prototype.delete = function(webhookID, callback) {\n    var apiPath = urlPath(BASE_PATH, webhookID);\n    return this.client.wrapWithDefaultHandler(this.client.del)(apiPath, null, callback);\n};\n/**\n * Sets primary and secondary signatures that are used to verify the Webhooks messages\n *\n * @param {string} primaryKey - The primary signature to verify the message with\n * @param {string} [secondaryKey] - The secondary signature to verify the message with\n * @returns {void}\n */ Webhooks.setSignatureKeys = function(primaryKey, secondaryKey) {\n    Webhooks.primarySignatureKey = primaryKey;\n    if (typeof secondaryKey === \"string\") {\n        Webhooks.secondarySignatureKey = secondaryKey;\n    }\n};\n/**\n * Validate a webhook message by verifying the signature and the delivery timestamp\n *\n * @param {string|Object} body - The request body of the webhook message\n * @param {Object} headers - The request headers of the webhook message\n * @param {string} [primaryKey] - The primary signature to verify the message with. If it is sent as a parameter,\n     it overrides the static variable primarySignatureKey\n * @param {string} [secondaryKey] - The secondary signature to verify the message with. If it is sent as a parameter,\n     it overrides the static variable primarySignatureKey\n * @param {int} [maxMessageAge] - The maximum message age (in seconds).  Defaults to 10 minutes\n * @returns {boolean} - True or false\n */ Webhooks.validateMessage = function(body, headers, primaryKey, secondaryKey, maxMessageAge) {\n    if (!primaryKey && Webhooks.primarySignatureKey) {\n        primaryKey = Webhooks.primarySignatureKey;\n    }\n    if (!secondaryKey && Webhooks.secondarySignatureKey) {\n        secondaryKey = Webhooks.secondarySignatureKey;\n    }\n    if (typeof maxMessageAge !== \"number\") {\n        maxMessageAge = MAX_MESSAGE_AGE;\n    }\n    // For frameworks like Express that automatically parse JSON\n    // bodies into Objects, re-stringify for signature testing\n    if (typeof body === \"object\") {\n        // Escape forward slashes to ensure a matching signature\n        body = jsonStringifyWithEscapedUnicode(body).replace(/\\//g, \"\\\\/\");\n    }\n    if (!validateSignature(body, headers, primaryKey, secondaryKey)) {\n        return false;\n    }\n    if (!validateDeliveryTimestamp(headers, maxMessageAge)) {\n        return false;\n    }\n    return true;\n};\nWebhooks.prototype.validateMessage = Webhooks.validateMessage;\n/**\n * @module box-node-sdk/lib/managers/webhooks\n * @see {@Link Webhooks}\n */ module.exports = Webhooks;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9tYW5hZ2Vycy93ZWJob29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUNEO0FBRUEsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEY7OztDQUdDLEdBRUQsZ0ZBQWdGO0FBQ2hGLGVBQWU7QUFDZixnRkFBZ0Y7QUFFaEYsSUFBSUEsVUFBVUMsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUMsU0FBU0QsbUJBQU9BLENBQUM7QUFFdkIsZ0ZBQWdGO0FBQ2hGLFVBQVU7QUFDVixnRkFBZ0Y7QUFFaEYsdUNBQXVDO0FBQ3ZDLElBQUlFLFlBQVk7QUFFaEIsK0JBQStCO0FBQy9CLE1BQU1DLGtCQUFrQixLQUFLLElBQUksYUFBYTtBQUU5Qzs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQyxpQkFBaUJDLElBQUksRUFBRUMsT0FBTyxFQUFFQyxZQUFZO0lBQ3BELElBQUksQ0FBQ0EsY0FBYztRQUNsQixPQUFPO0lBQ1I7SUFFQSxJQUFJRCxPQUFPLENBQUMsd0JBQXdCLEtBQUssS0FBSztRQUM3QyxPQUFPO0lBQ1I7SUFFQSxJQUFJQSxPQUFPLENBQUMsMEJBQTBCLEtBQUssY0FBYztRQUN4RCxPQUFPO0lBQ1I7SUFFQSxJQUFJRSxPQUFPUCxPQUFPUSxVQUFVLENBQUMsVUFBVUY7SUFDdkNDLEtBQUtFLE1BQU0sQ0FBQ0w7SUFDWkcsS0FBS0UsTUFBTSxDQUFDSixPQUFPLENBQUMseUJBQXlCO0lBRTdDLE1BQU1LLFlBQVlILEtBQUtJLE1BQU0sQ0FBQztJQUU5QixPQUFPRDtBQUNSO0FBRUE7Ozs7Ozs7Ozs7Q0FVQyxHQUNELFNBQVNFLGtCQUFrQlIsSUFBSSxFQUFFQyxPQUFPLEVBQUVRLG1CQUFtQixFQUFFQyxxQkFBcUI7SUFDbkYsNEZBQTRGO0lBQzVGLGtGQUFrRjtJQUNsRixNQUFNQyxtQkFBbUJaLGlCQUFpQkMsTUFBTUMsU0FBU1E7SUFFekQsSUFBSUUsb0JBQW9CQSxxQkFB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U0FBU21ELGdCQUFnQixHQUFHLFNBQVNDLFVBQVUsRUFBRUMsWUFBWTtJQUM1RHJELFNBQVNwQixtQkFBbUIsR0FBR3dFO0lBRS9CLElBQUksT0FBT0MsaUJBQWlCLFVBQVU7UUFDckNyRCxTQUFTbkIscUJBQXFCLEdBQUd3RTtJQUNsQztBQUNEO0FBRUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDRHJELFNBQVNzRCxlQUFlLEdBQUcsU0FBU25GLElBQUksRUFBRUMsT0FBTyxFQUFFZ0YsVUFBVSxFQUFFQyxZQUFZLEVBQUVwRSxhQUFhO0lBQ3pGLElBQUksQ0FBQ21FLGNBQWNwRCxTQUFTcEIsbUJBQW1CLEVBQUU7UUFDaER3RSxhQUFhcEQsU0FBU3BCLG1CQUFtQjtJQUMxQztJQUVBLElBQUksQ0FBQ3lFLGdCQUFnQnJELFNBQVNuQixxQkFBcUIsRUFBRTtRQUNwRHdFLGVBQWVyRCxTQUFTbkIscUJBQXFCO0lBQzlDO0lBRUEsSUFBSSxPQUFPSSxrQkFBa0IsVUFBVTtRQUN0Q0EsZ0JBQWdCaEI7SUFDakI7SUFFQSw0REFBNEQ7SUFDNUQsMERBQTBEO0lBQzFELElBQUksT0FBT0UsU0FBUyxVQUFVO1FBQzdCLHdEQUF3RDtRQUN4REEsT0FBT3FCLGdDQUFnQ3JCLE1BQU13QixPQUFPLENBQUMsT0FBTztJQUM3RDtJQUVBLElBQUksQ0FBQ2hCLGtCQUFrQlIsTUFBTUMsU0FBU2dGLFlBQVlDLGVBQWU7UUFDaEUsT0FBTztJQUNSO0lBRUEsSUFBSSxDQUFDckUsMEJBQTBCWixTQUFTYSxnQkFBZ0I7UUFDdkQsT0FBTztJQUNSO0lBRUEsT0FBTztBQUNSO0FBRUFlLFNBQVNFLFNBQVMsQ0FBQ29ELGVBQWUsR0FBR3RELFNBQVNzRCxlQUFlO0FBRTdEOzs7Q0FHQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUd4RCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvd2ViaG9va3MuanM/NDI2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgTWFuYWdlciBmb3IgdGhlIEJveCBXZWJob29rcyByZXNvdXJjZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlZGVmc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIHdlYmhvb2sgdHJpZ2dlciB0eXBlIGNvbnN0YW50XG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBXZWJob29rVHJpZ2dlclR5cGVcbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgdXJsUGF0aCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsLXBhdGgnKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gQmFzZSBwYXRoIGZvciBhbGwgd2ViaG9va3MgZW5kcG9pbnRzXG52YXIgQkFTRV9QQVRIID0gJy93ZWJob29rcyc7XG5cbi8vIFRoaXMgcHJldmVudHMgcmVwbGF5IGF0dGFja3NcbmNvbnN0IE1BWF9NRVNTQUdFX0FHRSA9IDEwICogNjA7IC8vIDEwIG1pbnV0ZXNcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBtZXNzYWdlIHNpZ25hdHVyZVxuICogQHNlZSB7QExpbmsgaHR0cHM6Ly9kZXZlbG9wZXIuYm94LmNvbS9lbi9ndWlkZXMvd2ViaG9va3MvaGFuZGxlL3NldHVwLXNpZ25hdHVyZXMvfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBib2R5IC0gVGhlIHJlcXVlc3QgYm9keSBvZiB0aGUgd2ViaG9vayBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVycyAtIFRoZSByZXF1ZXN0IGhlYWRlcnMgb2YgdGhlIHdlYmhvb2sgbWVzc2FnZVxuICogQHBhcmFtIHs/c3RyaW5nfSBzaWduYXR1cmVLZXkgLSBUaGUgc2lnbmF0dXJlIHRvIHZlcmlmeSB0aGUgbWVzc2FnZSB3aXRoXG4gKiBAcmV0dXJucyB7P3N0cmluZ30gLSBUaGUgbWVzc2FnZSBzaWduYXR1cmUgKG9yIG51bGwsIGlmIGl0IGNhbid0IGJlIGNvbXB1dGVkKVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNpZ25hdHVyZShib2R5LCBoZWFkZXJzLCBzaWduYXR1cmVLZXkpIHtcblx0aWYgKCFzaWduYXR1cmVLZXkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGlmIChoZWFkZXJzWydib3gtc2lnbmF0dXJlLXZlcnNpb24nXSAhPT0gJzEnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoaGVhZGVyc1snYm94LXNpZ25hdHVyZS1hbGdvcml0aG0nXSAhPT0gJ0htYWNTSEEyNTYnKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRsZXQgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGEyNTYnLCBzaWduYXR1cmVLZXkpO1xuXHRobWFjLnVwZGF0ZShib2R5KTtcblx0aG1hYy51cGRhdGUoaGVhZGVyc1snYm94LWRlbGl2ZXJ5LXRpbWVzdGFtcCddKTtcblxuXHRjb25zdCBzaWduYXR1cmUgPSBobWFjLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cblx0cmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgbWVzc2FnZSBzaWduYXR1cmVcbiAqIEBzZWUge0BMaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLmJveC5jb20vZW4vZ3VpZGVzL3dlYmhvb2tzL2hhbmRsZS92ZXJpZnktc2lnbmF0dXJlcy99XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJvZHkgLSBUaGUgcmVxdWVzdCBib2R5IG9mIHRoZSB3ZWJob29rIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIC0gVGhlIHJlcXVlc3QgaGVhZGVycyBvZiB0aGUgd2ViaG9vayBtZXNzYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJpbWFyeVNpZ25hdHVyZUtleSAtIFRoZSBwcmltYXJ5IHNpZ25hdHVyZSB0byB2ZXJpZnkgdGhlIG1lc3NhZ2Ugd2l0aFxuICogQHBhcmFtIHtzdHJpbmd9IFtzZWNvbmRhcnlTaWduYXR1cmVLZXldIC0gVGhlIHNlY29uZGFyeSBzaWduYXR1cmUgdG8gdmVyaWZ5IHRoZSBtZXNzYWdlIHdpdGhcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgb3IgZmFsc2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbmF0dXJlKGJvZHksIGhlYWRlcnMsIHByaW1hcnlTaWduYXR1cmVLZXksIHNlY29uZGFyeVNpZ25hdHVyZUtleSkge1xuXHQvLyBFaXRoZXIgdGhlIHByaW1hcnkgb3Igc2Vjb25kYXJ5IHNpZ25hdHVyZSBtdXN0IG1hdGNoIHRoZSBjb3JyZXNwb25kaW5nIHNpZ25hdHVyZSBmcm9tIEJveFxuXHQvLyAoVGhlIHVzZSBvZiB0d28gc2lnbmF0dXJlcyBhbGxvd3MgdGhlIHNpZ25pbmcga2V5cyB0byBiZSByb3RhdGVkIG9uZSBhdCBhIHRpbWUpXG5cdGNvbnN0IHByaW1hcnlTaWduYXR1cmUgPSBjb21wdXRlU2lnbmF0dXJlKGJvZHksIGhlYWRlcnMsIHByaW1hcnlTaWduYXR1cmVLZXkpO1xuXG5cdGlmIChwcmltYXJ5U2lnbmF0dXJlICYmIHByaW1hcnlTaWduYXR1cmUgPT09IGhlYWRlcnNbJ2JveC1zaWduYXR1cmUtcHJpbWFyeSddKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRjb25zdCBzZWNvbmRhcnlTaWduYXR1cmUgPSBjb21wdXRlU2lnbmF0dXJlKGJvZHksIGhlYWRlcnMsIHNlY29uZGFyeVNpZ25hdHVyZUtleSk7XG5cblx0aWYgKHNlY29uZGFyeVNpZ25hdHVyZSAmJiBzZWNvbmRhcnlTaWduYXR1cmUgPT09IGhlYWRlcnNbJ2JveC1zaWduYXR1cmUtc2Vjb25kYXJ5J10pIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBkZWxpdmVyeSB0aW1lc3RhbXAgaXMgbm90IHRvbyBmYXIgaW4gdGhlIHBhc3QgKHRvIHByZXZlbnQgcmVwbGF5IGF0dGFja3MpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgLSBUaGUgcmVxdWVzdCBoZWFkZXJzIG9mIHRoZSB3ZWJob29rIG1lc3NhZ2VcbiAqIEBwYXJhbSB7aW50fSBtYXhNZXNzYWdlQWdlIC0gVGhlIG1heGltdW0gbWVzc2FnZSBhZ2UgKGluIHNlY29uZHMpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIG9yIGZhbHNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURlbGl2ZXJ5VGltZXN0YW1wKGhlYWRlcnMsIG1heE1lc3NhZ2VBZ2UpIHtcblx0Y29uc3QgZGVsaXZlcnlUaW1lID0gRGF0ZS5wYXJzZShoZWFkZXJzWydib3gtZGVsaXZlcnktdGltZXN0YW1wJ10pO1xuXHRjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG5cdGNvbnN0IG1lc3NhZ2VBZ2UgPSAoY3VycmVudFRpbWUgLSBkZWxpdmVyeVRpbWUpIC8gMTAwMDtcblxuXHRpZiAobWVzc2FnZUFnZSA+IG1heE1lc3NhZ2VBZ2UpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTdHJpbmdpZnkgSlNPTiB3aXRoIGVzY2FwZWQgbXVsdGlieXRlIFVuaWNvZGUgY2hhcmFjdGVycyB0byBlbnN1cmUgY29tcHV0ZWQgc2lnbmF0dXJlcyBtYXRjaCBQSFAncyBkZWZhdWx0IGJlaGF2aW9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGJvZHkgLSBUaGUgcGFyc2VkIEpTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFN0cmluZ2lmaWVkIEpTT04gd2l0aCBlc2NhcGVkIG11bHRpYnl0ZSBVbmljb2RlIGNoYXJhY3RlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGpzb25TdHJpbmdpZnlXaXRoRXNjYXBlZFVuaWNvZGUoYm9keSkge1xuXHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSkucmVwbGFjZSgvW1xcdTAwN2YtXFx1ZmZmZl0vZywgY2hhciA9PiBgXFxcXHUke2AwMDAwJHtjaGFyLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTQpfWApO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNpbXBsZSBtYW5hZ2VyIGZvciBpbnRlcmFjdGluZyB3aXRoIGFsbCAnV2ViaG9va3MnIGVuZHBvaW50cyBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IFRoZSBCb3ggQVBJIENsaWVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBtYWtpbmcgY2FsbHMgdG8gdGhlIEFQSVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdlYmhvb2tzKGNsaWVudCkge1xuXHQvLyBBdHRhY2ggdGhlIGNsaWVudCwgZm9yIG1ha2luZyBBUEkgY2FsbHNcblx0dGhpcy5jbGllbnQgPSBjbGllbnQ7XG59XG5cbi8qKlxuICogUHJpbWFyeSBzaWduYXR1cmUga2V5IHRvIHByb3RlY3Qgd2ViaG9va3MgYWdhaW5zdCBhdHRhY2tzLlxuICogQHN0YXRpY1xuICogQHR5cGUgez9zdHJpbmd9XG4gKi9cbldlYmhvb2tzLnByaW1hcnlTaWduYXR1cmVLZXkgPSBudWxsO1xuXG4vKipcbiAqIFNlY29uZGFyeSBzaWduYXR1cmUga2V5IHRvIHByb3RlY3Qgd2ViaG9va3MgYWdhaW5zdCBhdHRhY2tzLlxuICogQHN0YXRpY1xuICogQHR5cGUgez9zdHJpbmd9XG4gKi9cbldlYmhvb2tzLnNlY29uZGFyeVNpZ25hdHVyZUtleSA9IG51bGw7XG5cblxuLyoqXG4gKiBFbnVtIG9mIHZhbGlkIHdlYmhvb2tzIGV2ZW50IHRyaWdnZXJzXG4gKlxuICogQHJlYWRvbmx5XG4gKiBAZW51bSB7V2ViaG9va1RyaWdnZXJUeXBlfVxuICovXG5XZWJob29rcy5wcm90b3R5cGUudHJpZ2dlclR5cGVzID0ge1xuXHRGSUxFOiB7XG5cdFx0VVBMT0FERUQ6ICdGSUxFLlVQTE9BREVEJyxcblx0XHRQUkVWSUVXRUQ6ICdGSUxFLlBSRVZJRVdFRCcsXG5cdFx0RE9XTkxPQURFRDogJ0ZJTEUuRE9XTkxPQURFRCcsXG5cdFx0VFJBU0hFRDogJ0ZJTEUuVFJBU0hFRCcsXG5cdFx0REVMRVRFRDogJ0ZJTEUuREVMRVRFRCcsXG5cdFx0UkVTVE9SRUQ6ICdGSUxFLlJFU1RPUkVEJyxcblx0XHRDT1BJRUQ6ICdGSUxFLkNPUElFRCcsXG5cdFx0TU9WRUQ6ICdGSUxFLk1PVkVEJyxcblx0XHRMT0NLRUQ6ICdGSUxFLkxPQ0tFRCcsXG5cdFx0VU5MT0NLRUQ6ICdGSUxFLlVOTE9DS0VEJyxcblx0XHRSRU5BTUVEOiAnRklMRS5SRU5BTUVEJ1xuXHR9LFxuXHRDT01NRU5UOiB7XG5cdFx0Q1JFQVRFRDogJ0NPTU1FTlQuQ1JFQVRFRCcsXG5cdFx0VVBEQVRFRDogJ0NPTU1FTlQuVVBEQVRFRCcsXG5cdFx0REVMRVRFRDogJ0NPTU1FTlQuREVMRVRFRCdcblx0fSxcblx0VEFTS19BU1NJR05NRU5UOiB7XG5cdFx0Q1JFQVRFRDogJ1RBU0tfQVNTSUdOTUVOVC5DUkVBVEVEJyxcblx0XHRVUERBVEVEOiAnVEFTS19BU1NJR05NRU5ULlVQREFURUQnXG5cdH0sXG5cdE1FVEFEQVRBX0lOU1RBTkNFOiB7XG5cdFx0Q1JFQVRFRDogJ01FVEFEQVRBX0lOU1RBTkNFLkNSRUFURUQnLFxuXHRcdFVQREFURUQ6ICdNRVRBREFUQV9JTlNUQU5DRS5VUERBVEVEJyxcblx0XHRERUxFVEVEOiAnTUVUQURBVEFfSU5TVEFOQ0UuREVMRVRFRCdcblx0fSxcblx0Rk9MREVSOiB7XG5cdFx0Q1JFQVRFRDogJ0ZPTERFUi5DUkVBVEVEJyxcblx0XHRET1dOTE9BREVEOiAnRk9MREVSLkRPV05MT0FERUQnLFxuXHRcdFJFU1RPUkVEOiAnRk9MREVSLlJFU1RPUkVEJyxcblx0XHRERUxFVEVEOiAnRk9MREVSLkRFTEVURUQnLFxuXHRcdENPUElFRDogJ0ZPTERFUi5DT1BJRUQnLFxuXHRcdE1PVkVEOiAnRk9MREVSLk1PVkVEJyxcblx0XHRUUkFTSEVEOiAnRk9MREVSLlRSQVNIRUQnLFxuXHRcdFJFTkFNRUQ6ICdGT0xERVIuUkVOQU1FRCdcblx0fSxcblx0V0VCSE9PSzoge1xuXHRcdERFTEVURUQ6ICdXRUJIT09LLkRFTEVURUQnXG5cdH0sXG5cdENPTExBQk9SQVRJT046IHtcblx0XHRDUkVBVEVEOiAnQ09MTEFCT1JBVElPTi5DUkVBVEVEJyxcblx0XHRBQ0NFUFRFRDogJ0NPTExBQk9SQVRJT04uQUNDRVBURUQnLFxuXHRcdFJFSkVDVEVEOiAnQ09MTEFCT1JBVElPTi5SRUpFQ1RFRCcsXG5cdFx0UkVNT1ZFRDogJ0NPTExBQk9SQVRJT04uUkVNT1ZFRCcsXG5cdFx0VVBEQVRFRDogJ0NPTExBQk9SQVRJT04uVVBEQVRFRCdcblx0fSxcblx0U0hBUkVEX0xJTks6IHtcblx0XHRERUxFVEVEOiAnU0hBUkVEX0xJTksuREVMRVRFRCcsXG5cdFx0Q1JFQVRFRDogJ1NIQVJFRF9MSU5LLkNSRUFURUQnLFxuXHRcdFVQREFURUQ6ICdTSEFSRURfTElOSy5VUERBVEVEJ1xuXHR9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB3ZWJob29rIG9uIGEgZ2l2ZW4gQm94IG9iamVjdCwgc3BlY2lmaWVkIGJ5IHR5cGUgYW5kIElELlxuICpcbiAqIEFQSSBFbmRwb2ludDogJy93ZWJob29rcydcbiAqIE1ldGhvZDogUE9TVFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCAtIEJveCBJRCAgb2YgdGhlIGl0ZW0gdG8gY3JlYXRlIHdlYmhvb2sgb25cbiAqIEBwYXJhbSB7SXRlbVR5cGV9IHRhcmdldFR5cGUgLSBUeXBlIG9mIGl0ZW0gdGhlIHdlYmhvb2sgd2lsbCBiZSBjcmVhdGVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbm90aWZpY2F0aW9uVVJMIC0gVGhlIFVSTCBvZiB5b3VyIGFwcGxpY2F0aW9uIHdoZXJlIEJveCB3aWxsIG5vdGlmeSB5b3Ugb2YgZXZlbnRzIHRyaWdnZXJzXG4gKiBAcGFyYW0ge1dlYmhvb2tUcmlnZ2VyVHlwZVtdfSB0cmlnZ2VyVHlwZXMgLSBBcnJheSBvZiBldmVudCB0eXBlcyB0aGF0IHRyaWdnZXIgbm90aWZpY2F0aW9uIGZvciB0aGUgdGFyZ2V0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSBuZXcgd2ViaG9vayBpbmZvcm1hdGlvbiBpZiBpdCB3YXMgYWNxdWlyZWQgc3VjY2Vzc2Z1bGx5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXcgd2ViaG9vayBvYmplY3RcbiAqL1xuV2ViaG9va3MucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHRhcmdldElELCB0YXJnZXRUeXBlLCBub3RpZmljYXRpb25VUkwsIHRyaWdnZXJUeXBlcywgY2FsbGJhY2spIHtcblx0dmFyIHBhcmFtcyA9IHtcblx0XHRib2R5OiB7XG5cdFx0XHR0YXJnZXQ6IHtcblx0XHRcdFx0aWQ6IHRhcmdldElELFxuXHRcdFx0XHR0eXBlOiB0YXJnZXRUeXBlXG5cdFx0XHR9LFxuXHRcdFx0YWRkcmVzczogbm90aWZpY2F0aW9uVVJMLFxuXHRcdFx0dHJpZ2dlcnM6IHRyaWdnZXJUeXBlc1xuXHRcdH1cblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQucG9zdCkoYXBpUGF0aCwgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB3ZWJob29rIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgV2ViaG9vayBJRFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy93ZWJob29rcy86d2ViaG9va0lEJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lEIC0gSUQgb2YgdGhlIHdlYmhvb2sgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByZXF1ZXN0LiBDYW4gYmUgbGVmdCBudWxsIGluIG1vc3QgY2FzZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gUGFzc2VkIHRoZSB3ZWJob29rIGluZm9ybWF0aW9uIGlmIGl0IHdhcyBhY3F1aXJlZCBzdWNjZXNzZnVsbHlcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHdlYmhvb2sgb2JqZWN0XG4gKi9cbldlYmhvb2tzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbih3ZWJob29rSUQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnNcblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRILCB3ZWJob29rSUQpO1xuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5nZXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBHZXQgYSBsaXN0IG9mIHdlYmhvb2tzIHRoYXQgYXJlIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnQgYXBwbGljYXRpb24gYW5kIHVzZXIuXG4gKlxuICogQVBJIEVuZHBvaW50OiAnL3dlYmhvb2tzJ1xuICogTWV0aG9kOiBHRVRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgcmVxdWVzdC4gQ2FuIGJlIGxlZnQgbnVsbCBpbiBtb3N0IGNhc2VzLlxuICogQHBhcmFtIHtpbnR9IFtvcHRpb25zLmxpbWl0PTEwMF0gLSBUaGUgbnVtYmVyIG9mIHdlYmhvb2tzIHRvIHJldHVyblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1hcmtlcl0gLSBQYWdpbmF0aW9uIG1hcmtlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIFBhc3NlZCB0aGUgbGlzdCBvZiB3ZWJob29rcyBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNvbGxlY3Rpb24gb2Ygd2ViaG9va3NcbiAqL1xuV2ViaG9va3MucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdHZhciBwYXJhbXMgPSB7XG5cdFx0cXM6IG9wdGlvbnNcblx0fTtcblxuXHR2YXIgYXBpUGF0aCA9IHVybFBhdGgoQkFTRV9QQVRIKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZ2V0KShhcGlQYXRoLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIGEgd2ViaG9va1xuICpcbiAqIEFQSSBFbmRwb2ludDogJy93ZWJob29rcy86d2ViaG9va0lEJ1xuICogTWV0aG9kOiBQVVRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lEIC0gVGhlIElEIG9mIHRoZSB3ZWJob29rIHRvIGJlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVzIC0gV2ViaG9vayBmaWVsZHMgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VwZGF0ZXMuYWRkcmVzc10gLSBUaGUgbmV3IFVSTCB1c2VkIGJ5IEJveCB0byBzZW5kIGEgbm90aWZpY2F0aW9uIHdoZW4gd2ViaG9vayBpcyB0cmlnZ2VyZWRcbiAqIEBwYXJhbSB7V2ViaG9va1RyaWdnZXJUeXBlW119IFt1cGRhdGVzLnRyaWdnZXJzXSAtIFRoZSBuZXcgZXZlbnRzIHRoYXQgdHJpZ2dlcnMgYSBub3RpZmljYXRpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBQYXNzZWQgdGhlIHVwZGF0ZWQgd2ViaG9vayBpbmZvcm1hdGlvbiBpZiBzdWNjZXNzZnVsLCBlcnJvciBvdGhlcndpc2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHVwZGF0ZWQgd2ViaG9vayBvYmplY3RcbiAqL1xuV2ViaG9va3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKHdlYmhvb2tJRCwgdXBkYXRlcywgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgd2ViaG9va0lEKSxcblx0XHRwYXJhbXMgPSB7XG5cdFx0XHRib2R5OiB1cGRhdGVzXG5cdFx0fTtcblxuXHRyZXR1cm4gdGhpcy5jbGllbnQud3JhcFdpdGhEZWZhdWx0SGFuZGxlcih0aGlzLmNsaWVudC5wdXQpKGFwaVBhdGgsIHBhcmFtcywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYSBzcGVjaWZpZWQgd2ViaG9vayBieSBJRFxuICpcbiAqIEFQSSBFbmRwb2ludDogJy93ZWJob29rcy86d2ViaG9va0lEJ1xuICogTWV0aG9kOiBERUxFVEVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lEIC0gSUQgb2Ygd2ViaG9vayB0byBiZSBkZWxldGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRW1wdHkgcmVzcG9uc2UgYm9keSBwYXNzZWQgaWYgc3VjY2Vzc2Z1bC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgcmVzb2x2aW5nIHRvIG5vdGhpbmdcbiAqL1xuV2ViaG9va3MucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uKHdlYmhvb2tJRCwgY2FsbGJhY2spIHtcblx0dmFyIGFwaVBhdGggPSB1cmxQYXRoKEJBU0VfUEFUSCwgd2ViaG9va0lEKTtcblx0cmV0dXJuIHRoaXMuY2xpZW50LndyYXBXaXRoRGVmYXVsdEhhbmRsZXIodGhpcy5jbGllbnQuZGVsKShhcGlQYXRoLCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFNldHMgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IHNpZ25hdHVyZXMgdGhhdCBhcmUgdXNlZCB0byB2ZXJpZnkgdGhlIFdlYmhvb2tzIG1lc3NhZ2VzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlLZXkgLSBUaGUgcHJpbWFyeSBzaWduYXR1cmUgdG8gdmVyaWZ5IHRoZSBtZXNzYWdlIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2Vjb25kYXJ5S2V5XSAtIFRoZSBzZWNvbmRhcnkgc2lnbmF0dXJlIHRvIHZlcmlmeSB0aGUgbWVzc2FnZSB3aXRoXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuV2ViaG9va3Muc2V0U2lnbmF0dXJlS2V5cyA9IGZ1bmN0aW9uKHByaW1hcnlLZXksIHNlY29uZGFyeUtleSkge1xuXHRXZWJob29rcy5wcmltYXJ5U2lnbmF0dXJlS2V5ID0gcHJpbWFyeUtleTtcblxuXHRpZiAodHlwZW9mIHNlY29uZGFyeUtleSA9PT0gJ3N0cmluZycpIHtcblx0XHRXZWJob29rcy5zZWNvbmRhcnlTaWduYXR1cmVLZXkgPSBzZWNvbmRhcnlLZXk7XG5cdH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGUgYSB3ZWJob29rIG1lc3NhZ2UgYnkgdmVyaWZ5aW5nIHRoZSBzaWduYXR1cmUgYW5kIHRoZSBkZWxpdmVyeSB0aW1lc3RhbXBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGJvZHkgLSBUaGUgcmVxdWVzdCBib2R5IG9mIHRoZSB3ZWJob29rIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIC0gVGhlIHJlcXVlc3QgaGVhZGVycyBvZiB0aGUgd2ViaG9vayBtZXNzYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByaW1hcnlLZXldIC0gVGhlIHByaW1hcnkgc2lnbmF0dXJlIHRvIHZlcmlmeSB0aGUgbWVzc2FnZSB3aXRoLiBJZiBpdCBpcyBzZW50IGFzIGEgcGFyYW1ldGVyLFxuICAgICBpdCBvdmVycmlkZXMgdGhlIHN0YXRpYyB2YXJpYWJsZSBwcmltYXJ5U2lnbmF0dXJlS2V5XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NlY29uZGFyeUtleV0gLSBUaGUgc2Vjb25kYXJ5IHNpZ25hdHVyZSB0byB2ZXJpZnkgdGhlIG1lc3NhZ2Ugd2l0aC4gSWYgaXQgaXMgc2VudCBhcyBhIHBhcmFtZXRlcixcbiAgICAgaXQgb3ZlcnJpZGVzIHRoZSBzdGF0aWMgdmFyaWFibGUgcHJpbWFyeVNpZ25hdHVyZUtleVxuICogQHBhcmFtIHtpbnR9IFttYXhNZXNzYWdlQWdlXSAtIFRoZSBtYXhpbXVtIG1lc3NhZ2UgYWdlIChpbiBzZWNvbmRzKS4gIERlZmF1bHRzIHRvIDEwIG1pbnV0ZXNcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgb3IgZmFsc2VcbiAqL1xuV2ViaG9va3MudmFsaWRhdGVNZXNzYWdlID0gZnVuY3Rpb24oYm9keSwgaGVhZGVycywgcHJpbWFyeUtleSwgc2Vjb25kYXJ5S2V5LCBtYXhNZXNzYWdlQWdlKSB7XG5cdGlmICghcHJpbWFyeUtleSAmJiBXZWJob29rcy5wcmltYXJ5U2lnbmF0dXJlS2V5KSB7XG5cdFx0cHJpbWFyeUtleSA9IFdlYmhvb2tzLnByaW1hcnlTaWduYXR1cmVLZXk7XG5cdH1cblxuXHRpZiAoIXNlY29uZGFyeUtleSAmJiBXZWJob29rcy5zZWNvbmRhcnlTaWduYXR1cmVLZXkpIHtcblx0XHRzZWNvbmRhcnlLZXkgPSBXZWJob29rcy5zZWNvbmRhcnlTaWduYXR1cmVLZXk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1heE1lc3NhZ2VBZ2UgIT09ICdudW1iZXInKSB7XG5cdFx0bWF4TWVzc2FnZUFnZSA9IE1BWF9NRVNTQUdFX0FHRTtcblx0fVxuXG5cdC8vIEZvciBmcmFtZXdvcmtzIGxpa2UgRXhwcmVzcyB0aGF0IGF1dG9tYXRpY2FsbHkgcGFyc2UgSlNPTlxuXHQvLyBib2RpZXMgaW50byBPYmplY3RzLCByZS1zdHJpbmdpZnkgZm9yIHNpZ25hdHVyZSB0ZXN0aW5nXG5cdGlmICh0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcpIHtcblx0XHQvLyBFc2NhcGUgZm9yd2FyZCBzbGFzaGVzIHRvIGVuc3VyZSBhIG1hdGNoaW5nIHNpZ25hdHVyZVxuXHRcdGJvZHkgPSBqc29uU3RyaW5naWZ5V2l0aEVzY2FwZWRVbmljb2RlKGJvZHkpLnJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKTtcblx0fVxuXG5cdGlmICghdmFsaWRhdGVTaWduYXR1cmUoYm9keSwgaGVhZGVycywgcHJpbWFyeUtleSwgc2Vjb25kYXJ5S2V5KSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICghdmFsaWRhdGVEZWxpdmVyeVRpbWVzdGFtcChoZWFkZXJzLCBtYXhNZXNzYWdlQWdlKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcblxuV2ViaG9va3MucHJvdG90eXBlLnZhbGlkYXRlTWVzc2FnZSA9IFdlYmhvb2tzLnZhbGlkYXRlTWVzc2FnZTtcblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvbWFuYWdlcnMvd2ViaG9va3NcbiAqIEBzZWUge0BMaW5rIFdlYmhvb2tzfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFdlYmhvb2tzO1xuIl0sIm5hbWVzIjpbInVybFBhdGgiLCJyZXF1aXJlIiwiY3J5cHRvIiwiQkFTRV9QQVRIIiwiTUFYX01FU1NBR0VfQUdFIiwiY29tcHV0ZVNpZ25hdHVyZSIsImJvZHkiLCJoZWFkZXJzIiwic2lnbmF0dXJlS2V5IiwiaG1hYyIsImNyZWF0ZUhtYWMiLCJ1cGRhdGUiLCJzaWduYXR1cmUiLCJkaWdlc3QiLCJ2YWxpZGF0ZVNpZ25hdHVyZSIsInByaW1hcnlTaWduYXR1cmVLZXkiLCJzZWNvbmRhcnlTaWduYXR1cmVLZXkiLCJwcmltYXJ5U2lnbmF0dXJlIiwic2Vjb25kYXJ5U2lnbmF0dXJlIiwidmFsaWRhdGVEZWxpdmVyeVRpbWVzdGFtcCIsIm1heE1lc3NhZ2VBZ2UiLCJkZWxpdmVyeVRpbWUiLCJEYXRlIiwicGFyc2UiLCJjdXJyZW50VGltZSIsIm5vdyIsIm1lc3NhZ2VBZ2UiLCJqc29uU3RyaW5naWZ5V2l0aEVzY2FwZWRVbmljb2RlIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcGxhY2UiLCJjaGFyIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwic2xpY2UiLCJXZWJob29rcyIsImNsaWVudCIsInByb3RvdHlwZSIsInRyaWdnZXJUeXBlcyIsIkZJTEUiLCJVUExPQURFRCIsIlBSRVZJRVdFRCIsIkRPV05MT0FERUQiLCJUUkFTSEVEIiwiREVMRVRFRCIsIlJFU1RPUkVEIiwiQ09QSUVEIiwiTU9WRUQiLCJMT0NLRUQiLCJVTkxPQ0tFRCIsIlJFTkFNRUQiLCJDT01NRU5UIiwiQ1JFQVRFRCIsIlVQREFURUQiLCJUQVNLX0FTU0lHTk1FTlQiLCJNRVRBREFUQV9JTlNUQU5DRSIsIkZPTERFUiIsIldFQkhPT0siLCJDT0xMQUJPUkFUSU9OIiwiQUNDRVBURUQiLCJSRUpFQ1RFRCIsIlJFTU9WRUQiLCJTSEFSRURfTElOSyIsImNyZWF0ZSIsInRhcmdldElEIiwidGFyZ2V0VHlwZSIsIm5vdGlmaWNhdGlvblVSTCIsImNhbGxiYWNrIiwicGFyYW1zIiwidGFyZ2V0IiwiaWQiLCJ0eXBlIiwiYWRkcmVzcyIsInRyaWdnZXJzIiwiYXBpUGF0aCIsIndyYXBXaXRoRGVmYXVsdEhhbmRsZXIiLCJwb3N0IiwiZ2V0Iiwid2ViaG9va0lEIiwib3B0aW9ucyIsInFzIiwiZ2V0QWxsIiwidXBkYXRlcyIsInB1dCIsImRlbGV0ZSIsImRlbCIsInNldFNpZ25hdHVyZUtleXMiLCJwcmltYXJ5S2V5Iiwic2Vjb25kYXJ5S2V5IiwidmFsaWRhdGVNZXNzYWdlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/managers/webhooks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/sessions/anonymous-session.js":
/*!*********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/sessions/anonymous-session.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview An Anonymous Box API Session.\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nconst Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * An Anonymous Box API Session.\n *\n * The Anonymous API Session holds a Client Credentials accessToken, which it\n * returns to the client so that it may make calls on behalf of anonymous users.\n *\n * Anonymous tokens will be refreshed in the background if a request is made within the\n * \"stale buffer\" (defaults to 10 minutes before the token is set to expire).\n * If the token is also expired, all incoming requests will be held until a fresh token\n * is retrieved.\n *\n * @param {Config} config The SDK configuration options\n * @param {TokenManager} tokenManager The TokenManager\n * @constructor\n */ function AnonymousSession(config, tokenManager) {\n    this._config = config;\n    this._tokenManager = tokenManager;\n    // The TokenInfo object for this anonymous session\n    this._tokenInfo = null;\n    this._refreshPromise = null;\n}\n/**\n * Initiate a refresh of the anonymous access tokens. New tokens should be passed to the\n * caller, and then cached for later use.\n *\n * @param {?TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<string>} Promise resolving to the access token\n * @private\n */ AnonymousSession.prototype._refreshAnonymousAccessToken = function(options) {\n    // If tokens aren't already being refreshed, start the refresh\n    if (!this._refreshPromise) {\n        // Initiate a refresh\n        this._refreshPromise = this._tokenManager.getTokensClientCredentialsGrant(options).then((tokenInfo)=>{\n            // Set new token info and propagate the new access token\n            this._tokenInfo = tokenInfo;\n            return tokenInfo.accessToken;\n        }).finally(()=>{\n            // Refresh complete, clear promise\n            this._refreshPromise = null;\n        });\n    }\n    return this._refreshPromise;\n};\n/**\n * Produces a valid, anonymous access token.\n * Performs a refresh before returning if the current token is expired. If the current\n * token is considered stale but still valid, return the current token but initiate a\n * new refresh in the background.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<string>} Promise resolving to the access token\n */ AnonymousSession.prototype.getAccessToken = function(options) {\n    // If the current token is no longer fresh, get a new token. All incoming\n    // requests will be held until a fresh token is retrieved.\n    var expirationBuffer = Math.max(this._config.expiredBufferMS, this._config.staleBufferMS);\n    if (!this._tokenInfo || !this._tokenManager.isAccessTokenValid(this._tokenInfo, expirationBuffer)) {\n        return this._refreshAnonymousAccessToken(options);\n    }\n    // Your token is not currently stale! Return the current access token.\n    return Promise.resolve(this._tokenInfo.accessToken);\n};\n/**\n * Revokes the anonymous token used by this anonymous session, and clears the saved tokenInfo.\n *\n * @param {TokenRequestOptions} options] - Sets optional behavior for the token grant\n * @returns {Promise} Promise resolving if the revoke succeeds\n */ AnonymousSession.prototype.revokeTokens = function(options) {\n    // The current anonymous token is revoked (but a new one will be created automatically as needed).\n    var tokenInfo = this._tokenInfo || {}, accessToken = tokenInfo.accessToken;\n    this._tokenInfo = null;\n    return this._tokenManager.revokeTokens(accessToken, options);\n};\n/**\n * Return the anonymous session token, since there is no need to downscope a\n * token that does not have any associated user credentials.\n * @param {string|string[]} scopes The scope(s) requested for the new token\n * @param {string} [resource] The absolute URL of an API resource to scope the new token to\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<TokenInfo>} Promise resolving to the new token info\n */ AnonymousSession.prototype.exchangeToken = function(scopes, resource, options) {\n    // We need to get the access token, in case it hasn't been generated yet\n    return this.getAccessToken(options)// Pass back the entire token info object, not just the acces token,\n    // to maintain parity with the other session classes\n    .then(()=>this._tokenInfo);\n};\n/**\n * @module box-node-sdk/lib/sessions/anonymous-session\n * @see {@Link AnonymousSession}\n */ module.exports = AnonymousSession;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9hbm9ueW1vdXMtc2Vzc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFFakYsTUFBTUEsVUFBVUMsbUJBQU9BLENBQUM7QUFFeEIsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFFakYsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDRCxTQUFTQyxpQkFBaUJDLE1BQU0sRUFBRUMsWUFBWTtJQUM3QyxJQUFJLENBQUNDLE9BQU8sR0FBR0Y7SUFDZixJQUFJLENBQUNHLGFBQWEsR0FBR0Y7SUFFckIsa0RBQWtEO0lBQ2xELElBQUksQ0FBQ0csVUFBVSxHQUFHO0lBRWxCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO0FBQ3hCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNETixpQkFBaUJPLFNBQVMsQ0FBQ0MsNEJBQTRCLEdBQUcsU0FBU0MsT0FBTztJQUV6RSw4REFBOEQ7SUFDOUQsSUFBSSxDQUFDLElBQUksQ0FBQ0gsZUFBZSxFQUFFO1FBQzFCLHFCQUFxQjtRQUNyQixJQUFJLENBQUNBLGVBQWUsR0FBRyxJQUFJLENBQUNGLGFBQWEsQ0FBQ00sK0JBQStCLENBQUNELFNBQ3hFRSxJQUFJLENBQUNDLENBQUFBO1lBQ0wsd0RBQXdEO1lBQ3hELElBQUksQ0FBQ1AsVUFBVSxHQUFHTztZQUNsQixPQUFPQSxVQUFVQyxXQUFXO1FBQzdCLEdBQ0NDLE9BQU8sQ0FBQztZQUNSLGtDQUFrQztZQUNsQyxJQUFJLENBQUNSLGVBQWUsR0FBRztRQUN4QjtJQUNGO0lBRUEsT0FBTyxJQUFJLENBQUNBLGVBQWU7QUFDNUI7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNETixpQkFBaUJPLFNBQVMsQ0FBQ1EsY0FBYyxHQUFHLFNBQVNOLE9BQU87SUFDM0QseUVBQXlFO0lBQ3pFLDBEQUEwRDtJQUMxRCxJQUFJTyxtQkFBbUJDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNmLE9BQU8sQ0FBQ2dCLGVBQWUsRUFBRSxJQUFJLENBQUNoQixPQUFPLENBQUNpQixhQUFhO0lBQ3hGLElBQUksQ0FBQyxJQUFJLENBQUNmLFVBQVUsSUFBSSxDQUFDLElBQUksQ0FBQ0QsYUFBYSxDQUFDaUIsa0JBQWtCLENBQUMsSUFBSSxDQUFDaEIsVUFBVSxFQUFFVyxtQkFBbUI7UUFDbEcsT0FBTyxJQUFJLENBQUNSLDRCQUE0QixDQUFDQztJQUMxQztJQUVBLHNFQUFzRTtJQUN0RSxPQUFPWCxRQUFRd0IsT0FBTyxDQUFDLElBQUksQ0FBQ2pCLFVBQVUsQ0FBQ1EsV0FBVztBQUNuRDtBQUVBOzs7OztDQUtDLEdBQ0RiLGlCQUFpQk8sU0FBUyxDQUFDZ0IsWUFBWSxHQUFHLFNBQVNkLE9BQU87SUFDekQsa0dBQWtHO0lBQ2xHLElBQUlHLFlBQVksSUFBSSxDQUFDUCxVQUFVLElBQUksQ0FBQyxHQUNuQ1EsY0FBY0QsVUFBVUMsV0FBVztJQUNwQyxJQUFJLENBQUNSLFVBQVUsR0FBRztJQUNsQixPQUFPLElBQUksQ0FBQ0QsYUFBYSxDQUFDbUIsWUFBWSxDQUFDVixhQUFhSjtBQUNyRDtBQUVBOzs7Ozs7O0NBT0MsR0FDRFQsaUJBQWlCTyxTQUFTLENBQUNpQixhQUFhLEdBQUcsU0FBU0MsTUFBTSxFQUFFQyxRQUFRLEVBQUVqQixPQUFPO0lBRTVFLHdFQUF3RTtJQUN4RSxPQUFPLElBQUksQ0FBQ00sY0FBYyxDQUFDTixRQUMxQixvRUFBb0U7SUFDcEUsb0RBQW9EO0tBQ25ERSxJQUFJLENBQUMsSUFBTSxJQUFJLENBQUNOLFVBQVU7QUFDN0I7QUFFQTs7O0NBR0MsR0FDRHNCLE9BQU9DLE9BQU8sR0FBRzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9hbm9ueW1vdXMtc2Vzc2lvbi5qcz81YWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBBbiBBbm9ueW1vdXMgQm94IEFQSSBTZXNzaW9uLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFuIEFub255bW91cyBCb3ggQVBJIFNlc3Npb24uXG4gKlxuICogVGhlIEFub255bW91cyBBUEkgU2Vzc2lvbiBob2xkcyBhIENsaWVudCBDcmVkZW50aWFscyBhY2Nlc3NUb2tlbiwgd2hpY2ggaXRcbiAqIHJldHVybnMgdG8gdGhlIGNsaWVudCBzbyB0aGF0IGl0IG1heSBtYWtlIGNhbGxzIG9uIGJlaGFsZiBvZiBhbm9ueW1vdXMgdXNlcnMuXG4gKlxuICogQW5vbnltb3VzIHRva2VucyB3aWxsIGJlIHJlZnJlc2hlZCBpbiB0aGUgYmFja2dyb3VuZCBpZiBhIHJlcXVlc3QgaXMgbWFkZSB3aXRoaW4gdGhlXG4gKiBcInN0YWxlIGJ1ZmZlclwiIChkZWZhdWx0cyB0byAxMCBtaW51dGVzIGJlZm9yZSB0aGUgdG9rZW4gaXMgc2V0IHRvIGV4cGlyZSkuXG4gKiBJZiB0aGUgdG9rZW4gaXMgYWxzbyBleHBpcmVkLCBhbGwgaW5jb21pbmcgcmVxdWVzdHMgd2lsbCBiZSBoZWxkIHVudGlsIGEgZnJlc2ggdG9rZW5cbiAqIGlzIHJldHJpZXZlZC5cbiAqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFRoZSBTREsgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge1Rva2VuTWFuYWdlcn0gdG9rZW5NYW5hZ2VyIFRoZSBUb2tlbk1hbmFnZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBbm9ueW1vdXNTZXNzaW9uKGNvbmZpZywgdG9rZW5NYW5hZ2VyKSB7XG5cdHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcblx0dGhpcy5fdG9rZW5NYW5hZ2VyID0gdG9rZW5NYW5hZ2VyO1xuXG5cdC8vIFRoZSBUb2tlbkluZm8gb2JqZWN0IGZvciB0aGlzIGFub255bW91cyBzZXNzaW9uXG5cdHRoaXMuX3Rva2VuSW5mbyA9IG51bGw7XG5cblx0dGhpcy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIGEgcmVmcmVzaCBvZiB0aGUgYW5vbnltb3VzIGFjY2VzcyB0b2tlbnMuIE5ldyB0b2tlbnMgc2hvdWxkIGJlIHBhc3NlZCB0byB0aGVcbiAqIGNhbGxlciwgYW5kIHRoZW4gY2FjaGVkIGZvciBsYXRlciB1c2UuXG4gKlxuICogQHBhcmFtIHs/VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgYWNjZXNzIHRva2VuXG4gKiBAcHJpdmF0ZVxuICovXG5Bbm9ueW1vdXNTZXNzaW9uLnByb3RvdHlwZS5fcmVmcmVzaEFub255bW91c0FjY2Vzc1Rva2VuID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXG5cdC8vIElmIHRva2VucyBhcmVuJ3QgYWxyZWFkeSBiZWluZyByZWZyZXNoZWQsIHN0YXJ0IHRoZSByZWZyZXNoXG5cdGlmICghdGhpcy5fcmVmcmVzaFByb21pc2UpIHtcblx0XHQvLyBJbml0aWF0ZSBhIHJlZnJlc2hcblx0XHR0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IHRoaXMuX3Rva2VuTWFuYWdlci5nZXRUb2tlbnNDbGllbnRDcmVkZW50aWFsc0dyYW50KG9wdGlvbnMpXG5cdFx0XHQudGhlbih0b2tlbkluZm8gPT4ge1xuXHRcdFx0XHQvLyBTZXQgbmV3IHRva2VuIGluZm8gYW5kIHByb3BhZ2F0ZSB0aGUgbmV3IGFjY2VzcyB0b2tlblxuXHRcdFx0XHR0aGlzLl90b2tlbkluZm8gPSB0b2tlbkluZm87XG5cdFx0XHRcdHJldHVybiB0b2tlbkluZm8uYWNjZXNzVG9rZW47XG5cdFx0XHR9KVxuXHRcdFx0LmZpbmFsbHkoKCkgPT4ge1xuXHRcdFx0XHQvLyBSZWZyZXNoIGNvbXBsZXRlLCBjbGVhciBwcm9taXNlXG5cdFx0XHRcdHRoaXMuX3JlZnJlc2hQcm9taXNlID0gbnVsbDtcblx0XHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuX3JlZnJlc2hQcm9taXNlO1xufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhIHZhbGlkLCBhbm9ueW1vdXMgYWNjZXNzIHRva2VuLlxuICogUGVyZm9ybXMgYSByZWZyZXNoIGJlZm9yZSByZXR1cm5pbmcgaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgZXhwaXJlZC4gSWYgdGhlIGN1cnJlbnRcbiAqIHRva2VuIGlzIGNvbnNpZGVyZWQgc3RhbGUgYnV0IHN0aWxsIHZhbGlkLCByZXR1cm4gdGhlIGN1cnJlbnQgdG9rZW4gYnV0IGluaXRpYXRlIGFcbiAqIG5ldyByZWZyZXNoIGluIHRoZSBiYWNrZ3JvdW5kLlxuICpcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgYWNjZXNzIHRva2VuXG4gKi9cbkFub255bW91c1Nlc3Npb24ucHJvdG90eXBlLmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvLyBJZiB0aGUgY3VycmVudCB0b2tlbiBpcyBubyBsb25nZXIgZnJlc2gsIGdldCBhIG5ldyB0b2tlbi4gQWxsIGluY29taW5nXG5cdC8vIHJlcXVlc3RzIHdpbGwgYmUgaGVsZCB1bnRpbCBhIGZyZXNoIHRva2VuIGlzIHJldHJpZXZlZC5cblx0dmFyIGV4cGlyYXRpb25CdWZmZXIgPSBNYXRoLm1heCh0aGlzLl9jb25maWcuZXhwaXJlZEJ1ZmZlck1TLCB0aGlzLl9jb25maWcuc3RhbGVCdWZmZXJNUyk7XG5cdGlmICghdGhpcy5fdG9rZW5JbmZvIHx8ICF0aGlzLl90b2tlbk1hbmFnZXIuaXNBY2Nlc3NUb2tlblZhbGlkKHRoaXMuX3Rva2VuSW5mbywgZXhwaXJhdGlvbkJ1ZmZlcikpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVmcmVzaEFub255bW91c0FjY2Vzc1Rva2VuKG9wdGlvbnMpO1xuXHR9XG5cblx0Ly8gWW91ciB0b2tlbiBpcyBub3QgY3VycmVudGx5IHN0YWxlISBSZXR1cm4gdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuLlxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Rva2VuSW5mby5hY2Nlc3NUb2tlbik7XG59O1xuXG4vKipcbiAqIFJldm9rZXMgdGhlIGFub255bW91cyB0b2tlbiB1c2VkIGJ5IHRoaXMgYW5vbnltb3VzIHNlc3Npb24sIGFuZCBjbGVhcnMgdGhlIHNhdmVkIHRva2VuSW5mby5cbiAqXG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IG9wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZpbmcgaWYgdGhlIHJldm9rZSBzdWNjZWVkc1xuICovXG5Bbm9ueW1vdXNTZXNzaW9uLnByb3RvdHlwZS5yZXZva2VUb2tlbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdC8vIFRoZSBjdXJyZW50IGFub255bW91cyB0b2tlbiBpcyByZXZva2VkIChidXQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IGFzIG5lZWRlZCkuXG5cdHZhciB0b2tlbkluZm8gPSB0aGlzLl90b2tlbkluZm8gfHwge30sXG5cdFx0YWNjZXNzVG9rZW4gPSB0b2tlbkluZm8uYWNjZXNzVG9rZW47XG5cdHRoaXMuX3Rva2VuSW5mbyA9IG51bGw7XG5cdHJldHVybiB0aGlzLl90b2tlbk1hbmFnZXIucmV2b2tlVG9rZW5zKGFjY2Vzc1Rva2VuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBhbm9ueW1vdXMgc2Vzc2lvbiB0b2tlbiwgc2luY2UgdGhlcmUgaXMgbm8gbmVlZCB0byBkb3duc2NvcGUgYVxuICogdG9rZW4gdGhhdCBkb2VzIG5vdCBoYXZlIGFueSBhc3NvY2lhdGVkIHVzZXIgY3JlZGVudGlhbHMuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gc2NvcGVzIFRoZSBzY29wZShzKSByZXF1ZXN0ZWQgZm9yIHRoZSBuZXcgdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzb3VyY2VdIFRoZSBhYnNvbHV0ZSBVUkwgb2YgYW4gQVBJIHJlc291cmNlIHRvIHNjb3BlIHRoZSBuZXcgdG9rZW4gdG9cbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkluZm8+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IHRva2VuIGluZm9cbiAqL1xuQW5vbnltb3VzU2Vzc2lvbi5wcm90b3R5cGUuZXhjaGFuZ2VUb2tlbiA9IGZ1bmN0aW9uKHNjb3BlcywgcmVzb3VyY2UsIG9wdGlvbnMpIHtcblxuXHQvLyBXZSBuZWVkIHRvIGdldCB0aGUgYWNjZXNzIHRva2VuLCBpbiBjYXNlIGl0IGhhc24ndCBiZWVuIGdlbmVyYXRlZCB5ZXRcblx0cmV0dXJuIHRoaXMuZ2V0QWNjZXNzVG9rZW4ob3B0aW9ucylcblx0XHQvLyBQYXNzIGJhY2sgdGhlIGVudGlyZSB0b2tlbiBpbmZvIG9iamVjdCwgbm90IGp1c3QgdGhlIGFjY2VzIHRva2VuLFxuXHRcdC8vIHRvIG1haW50YWluIHBhcml0eSB3aXRoIHRoZSBvdGhlciBzZXNzaW9uIGNsYXNzZXNcblx0XHQudGhlbigoKSA9PiB0aGlzLl90b2tlbkluZm8pO1xufTtcblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvc2Vzc2lvbnMvYW5vbnltb3VzLXNlc3Npb25cbiAqIEBzZWUge0BMaW5rIEFub255bW91c1Nlc3Npb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQW5vbnltb3VzU2Vzc2lvbjtcbiJdLCJuYW1lcyI6WyJQcm9taXNlIiwicmVxdWlyZSIsIkFub255bW91c1Nlc3Npb24iLCJjb25maWciLCJ0b2tlbk1hbmFnZXIiLCJfY29uZmlnIiwiX3Rva2VuTWFuYWdlciIsIl90b2tlbkluZm8iLCJfcmVmcmVzaFByb21pc2UiLCJwcm90b3R5cGUiLCJfcmVmcmVzaEFub255bW91c0FjY2Vzc1Rva2VuIiwib3B0aW9ucyIsImdldFRva2Vuc0NsaWVudENyZWRlbnRpYWxzR3JhbnQiLCJ0aGVuIiwidG9rZW5JbmZvIiwiYWNjZXNzVG9rZW4iLCJmaW5hbGx5IiwiZ2V0QWNjZXNzVG9rZW4iLCJleHBpcmF0aW9uQnVmZmVyIiwiTWF0aCIsIm1heCIsImV4cGlyZWRCdWZmZXJNUyIsInN0YWxlQnVmZmVyTVMiLCJpc0FjY2Vzc1Rva2VuVmFsaWQiLCJyZXNvbHZlIiwicmV2b2tlVG9rZW5zIiwiZXhjaGFuZ2VUb2tlbiIsInNjb3BlcyIsInJlc291cmNlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/sessions/anonymous-session.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/sessions/app-auth-session.js":
/*!********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/sessions/app-auth-session.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview App Auth Box API Session.\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nconst Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n/**\n * Validate that an object is a valid TokenStore object\n *\n * @param {Object} obj the object to validate\n * @returns {boolean} returns true if the passed in object is a valid TokenStore object that\n * has all the expected properties. false otherwise.\n * @private\n */ function isObjectValidTokenStore(obj) {\n    return Boolean(obj && obj.read && obj.write && obj.clear);\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * App Auth Box API Session.\n *\n * The App Auth API Session holds an accessToken for an app user or enterprise,\n * which it returns to the client so that it may make calls on behalf of\n * these entities.\n *\n * These access tokens will be refreshed in the background if a request is made within the\n * \"stale buffer\" (defaults to 10 minutes before the token is set to expire).\n * If the token is also expired, all incoming requests will be held until a fresh token\n * is retrieved.\n *\n * @param {string} type The type of the entity to authenticate the app auth session as, \"user\" or \"enterprise\"\n * @param {string} id The Box ID of the entity to authenticate as\n * @param {Config} config The SDK configuration options\n * @param {TokenManager} tokenManager The TokenManager\n * @param {TokenStore} [tokenStore] The token store instance to use for caching token info\n * @constructor\n */ function AppAuthSession(type, id, config, tokenManager, tokenStore) {\n    this._type = type;\n    this._id = id;\n    this._config = config;\n    this._tokenManager = tokenManager;\n    // If tokenStore was provided, set the persistent data & current store operations\n    if (tokenStore) {\n        assert(isObjectValidTokenStore(tokenStore), \"Token store provided is improperly formatted. Methods required: read(), write(), clear().\");\n        this._tokenStore = Promise.promisifyAll(tokenStore);\n    }\n    // The TokenInfo object for this app auth session\n    this._tokenInfo = null;\n    // Indicates if tokens are currently being refreshed\n    this._refreshPromise = null;\n}\n/**\n * Initiate a refresh of the app auth access tokens. New tokens should be passed\n * to the caller, and then cached for later use.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<string>} Promise resolving to the access token\n * @private\n */ AppAuthSession.prototype._refreshAppAuthAccessToken = function(options) {\n    // If tokens aren't already being refreshed, start the refresh\n    if (!this._refreshPromise) {\n        this._refreshPromise = this._tokenManager.getTokensJWTGrant(this._type, this._id, options).then((tokenInfo)=>{\n            // Set new token info and propagate the new access token\n            this._tokenInfo = tokenInfo;\n            if (this._tokenStore) {\n                return this._tokenStore.writeAsync(tokenInfo).then(()=>tokenInfo.accessToken);\n            }\n            return tokenInfo.accessToken;\n        }).finally(()=>{\n            // Refresh complete, clear promise\n            this._refreshPromise = null;\n        });\n    }\n    return this._refreshPromise;\n};\n/**\n * Produces a valid, app auth access token.\n * Performs a refresh before returning if the current token is expired. If the current\n * token is considered stale but still valid, return the current token but initiate a\n * new refresh in the background.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<string>} Promise resolving to the access token\n */ AppAuthSession.prototype.getAccessToken = function(options) {\n    var expirationBuffer = Math.max(this._config.expiredBufferMS, this._config.staleBufferMS);\n    // If we're initializing the client and have a token store, try reading from it\n    if (!this._tokenInfo && this._tokenStore) {\n        return this._tokenStore.readAsync().then((tokenInfo)=>{\n            if (!this._tokenManager.isAccessTokenValid(tokenInfo, expirationBuffer)) {\n                // Token store contains expired tokens, refresh\n                return this._refreshAppAuthAccessToken(options);\n            }\n            this._tokenInfo = tokenInfo;\n            return tokenInfo.accessToken;\n        });\n    }\n    // If the current token is not fresh, get a new token. All incoming\n    // requests will be held until a fresh token is retrieved.\n    if (!this._tokenInfo || !this._tokenManager.isAccessTokenValid(this._tokenInfo, expirationBuffer)) {\n        return this._refreshAppAuthAccessToken(options);\n    }\n    // Your token is not currently stale! Return the current access token.\n    return Promise.resolve(this._tokenInfo.accessToken);\n};\n/**\n * Revokes the app auth token used by this session, and clears the saved tokenInfo.\n *\n * @param {TokenRequestOptions} [options]- Sets optional behavior for the token grant\n * @returns {Promise} Promise resolving if the revoke succeeds\n */ AppAuthSession.prototype.revokeTokens = function(options) {\n    // The current app auth token is revoked (but a new one will be created automatically as needed).\n    var tokenInfo = this._tokenInfo || {}, accessToken = tokenInfo.accessToken;\n    this._tokenInfo = null;\n    return this._tokenManager.revokeTokens(accessToken, options);\n};\n/**\n * Exchange the client access token for one with lower scope\n * @param {string|string[]} scopes The scope(s) requested for the new token\n * @param {string} [resource] The absolute URL of an API resource to scope the new token to\n * @param {Object} [options] - Optional parameters\n * @param {TokenRequestOptions} [options.tokenRequestOptions] - Sets optional behavior for the token grant\n * @param {ActorParams} [options.actor] - Optional actor parameters for creating annotator tokens\n * @returns {Promise<TokenInfo>} Promise resolving to the new token info\n */ AppAuthSession.prototype.exchangeToken = function(scopes, resource, options) {\n    return this.getAccessToken(options).then((accessToken)=>this._tokenManager.exchangeToken(accessToken, scopes, resource, options));\n};\n/**\n * Handle an an \"Expired Tokens\" Error. If our tokens are expired, we need to clear the token\n * store (if present) before continuing.\n *\n * @param {Errors~ExpiredTokensError} err An \"expired tokens\" error including information\n *  about the request/response.\n * @returns {Promise<Error>} Promise resolving to an error.  This will\n *  usually be the original response error, but could an error from trying to access the\n *  token store as well.\n */ AppAuthSession.prototype.handleExpiredTokensError = function(err) {\n    if (!this._tokenStore) {\n        return Promise.resolve(err);\n    }\n    // If a token store is available, clear the store and throw either error\n    // eslint-disable-next-line promise/no-promise-in-callback\n    return this._tokenStore.clearAsync().catch((e)=>errors.unwrapAndThrow(e)).then(()=>{\n        throw err;\n    });\n};\n/**\n * @module box-node-sdk/lib/sessions/app-auth-session\n * @see {@Link AppAuthSession}\n */ module.exports = AppAuthSession;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9hcHAtYXV0aC1zZXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxpRkFBaUY7QUFDakYsZUFBZTtBQUNmLGlGQUFpRjtBQUVqRixNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUN4QixNQUFNQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUN2QixNQUFNRSxTQUFTRixtQkFBT0EsQ0FBQztBQUV2QixpRkFBaUY7QUFDakYsVUFBVTtBQUNWLGlGQUFpRjtBQUVqRjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csd0JBQXdCQyxHQUFHO0lBQ25DLE9BQU9DLFFBQVFELE9BQU9BLElBQUlFLElBQUksSUFBSUYsSUFBSUcsS0FBSyxJQUFJSCxJQUFJSSxLQUFLO0FBQ3pEO0FBRUEsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNDLGVBQWVDLElBQUksRUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQUVDLFlBQVksRUFBRUMsVUFBVTtJQUNqRSxJQUFJLENBQUNDLEtBQUssR0FBR0w7SUFDYixJQUFJLENBQUNNLEdBQUcsR0FBR0w7SUFDWCxJQUFJLENBQUNNLE9BQU8sR0FBR0w7SUFDZixJQUFJLENBQUNNLGFBQWEsR0FBR0w7SUFFckIsaUZBQWlGO0lBQ2pGLElBQUlDLFlBQVk7UUFDZmIsT0FBT0Usd0JBQXdCVyxhQUFhO1FBQzVDLElBQUksQ0FBQ0ssV0FBVyxHQUFHcEIsUUFBUXFCLFlBQVksQ0FBQ047SUFDekM7SUFFQSxpREFBaUQ7SUFDakQsSUFBSSxDQUFDTyxVQUFVLEdBQUc7SUFFbEIsb0RBQW9EO0lBQ3BELElBQUksQ0FBQ0MsZUFBZSxHQUFHO0FBQ3hCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNEYixlQUFlYyxTQUFTLENBQUNDLDBCQUEwQixHQUFHLFNBQVNDLE9BQU87SUFFckUsOERBQThE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Q0FBQzRCLFVBQVUsR0FDaENDLEtBQUssQ0FBQ0MsQ0FBQUEsSUFBSy9DLE9BQU9nRCxjQUFjLENBQUNELElBQ2pDdEIsSUFBSSxDQUFDO1FBQ0wsTUFBTW1CO0lBQ1A7QUFDRjtBQUVBOzs7Q0FHQyxHQUNESyxPQUFPQyxPQUFPLEdBQUczQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvc2Vzc2lvbnMvYXBwLWF1dGgtc2Vzc2lvbi5qcz9lMzFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBBcHAgQXV0aCBCb3ggQVBJIFNlc3Npb24uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9ycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgYW4gb2JqZWN0IGlzIGEgdmFsaWQgVG9rZW5TdG9yZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBvYmplY3QgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSByZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCBpbiBvYmplY3QgaXMgYSB2YWxpZCBUb2tlblN0b3JlIG9iamVjdCB0aGF0XG4gKiBoYXMgYWxsIHRoZSBleHBlY3RlZCBwcm9wZXJ0aWVzLiBmYWxzZSBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc09iamVjdFZhbGlkVG9rZW5TdG9yZShvYmopIHtcblx0cmV0dXJuIEJvb2xlYW4ob2JqICYmIG9iai5yZWFkICYmIG9iai53cml0ZSAmJiBvYmouY2xlYXIpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQXBwIEF1dGggQm94IEFQSSBTZXNzaW9uLlxuICpcbiAqIFRoZSBBcHAgQXV0aCBBUEkgU2Vzc2lvbiBob2xkcyBhbiBhY2Nlc3NUb2tlbiBmb3IgYW4gYXBwIHVzZXIgb3IgZW50ZXJwcmlzZSxcbiAqIHdoaWNoIGl0IHJldHVybnMgdG8gdGhlIGNsaWVudCBzbyB0aGF0IGl0IG1heSBtYWtlIGNhbGxzIG9uIGJlaGFsZiBvZlxuICogdGhlc2UgZW50aXRpZXMuXG4gKlxuICogVGhlc2UgYWNjZXNzIHRva2VucyB3aWxsIGJlIHJlZnJlc2hlZCBpbiB0aGUgYmFja2dyb3VuZCBpZiBhIHJlcXVlc3QgaXMgbWFkZSB3aXRoaW4gdGhlXG4gKiBcInN0YWxlIGJ1ZmZlclwiIChkZWZhdWx0cyB0byAxMCBtaW51dGVzIGJlZm9yZSB0aGUgdG9rZW4gaXMgc2V0IHRvIGV4cGlyZSkuXG4gKiBJZiB0aGUgdG9rZW4gaXMgYWxzbyBleHBpcmVkLCBhbGwgaW5jb21pbmcgcmVxdWVzdHMgd2lsbCBiZSBoZWxkIHVudGlsIGEgZnJlc2ggdG9rZW5cbiAqIGlzIHJldHJpZXZlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiB0aGUgZW50aXR5IHRvIGF1dGhlbnRpY2F0ZSB0aGUgYXBwIGF1dGggc2Vzc2lvbiBhcywgXCJ1c2VyXCIgb3IgXCJlbnRlcnByaXNlXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgQm94IElEIG9mIHRoZSBlbnRpdHkgdG8gYXV0aGVudGljYXRlIGFzXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFRoZSBTREsgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge1Rva2VuTWFuYWdlcn0gdG9rZW5NYW5hZ2VyIFRoZSBUb2tlbk1hbmFnZXJcbiAqIEBwYXJhbSB7VG9rZW5TdG9yZX0gW3Rva2VuU3RvcmVdIFRoZSB0b2tlbiBzdG9yZSBpbnN0YW5jZSB0byB1c2UgZm9yIGNhY2hpbmcgdG9rZW4gaW5mb1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEFwcEF1dGhTZXNzaW9uKHR5cGUsIGlkLCBjb25maWcsIHRva2VuTWFuYWdlciwgdG9rZW5TdG9yZSkge1xuXHR0aGlzLl90eXBlID0gdHlwZTtcblx0dGhpcy5faWQgPSBpZDtcblx0dGhpcy5fY29uZmlnID0gY29uZmlnO1xuXHR0aGlzLl90b2tlbk1hbmFnZXIgPSB0b2tlbk1hbmFnZXI7XG5cblx0Ly8gSWYgdG9rZW5TdG9yZSB3YXMgcHJvdmlkZWQsIHNldCB0aGUgcGVyc2lzdGVudCBkYXRhICYgY3VycmVudCBzdG9yZSBvcGVyYXRpb25zXG5cdGlmICh0b2tlblN0b3JlKSB7XG5cdFx0YXNzZXJ0KGlzT2JqZWN0VmFsaWRUb2tlblN0b3JlKHRva2VuU3RvcmUpLCAnVG9rZW4gc3RvcmUgcHJvdmlkZWQgaXMgaW1wcm9wZXJseSBmb3JtYXR0ZWQuIE1ldGhvZHMgcmVxdWlyZWQ6IHJlYWQoKSwgd3JpdGUoKSwgY2xlYXIoKS4nKTtcblx0XHR0aGlzLl90b2tlblN0b3JlID0gUHJvbWlzZS5wcm9taXNpZnlBbGwodG9rZW5TdG9yZSk7XG5cdH1cblxuXHQvLyBUaGUgVG9rZW5JbmZvIG9iamVjdCBmb3IgdGhpcyBhcHAgYXV0aCBzZXNzaW9uXG5cdHRoaXMuX3Rva2VuSW5mbyA9IG51bGw7XG5cblx0Ly8gSW5kaWNhdGVzIGlmIHRva2VucyBhcmUgY3VycmVudGx5IGJlaW5nIHJlZnJlc2hlZFxuXHR0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG59XG5cbi8qKlxuICogSW5pdGlhdGUgYSByZWZyZXNoIG9mIHRoZSBhcHAgYXV0aCBhY2Nlc3MgdG9rZW5zLiBOZXcgdG9rZW5zIHNob3VsZCBiZSBwYXNzZWRcbiAqIHRvIHRoZSBjYWxsZXIsIGFuZCB0aGVuIGNhY2hlZCBmb3IgbGF0ZXIgdXNlLlxuICpcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgYWNjZXNzIHRva2VuXG4gKiBAcHJpdmF0ZVxuICovXG5BcHBBdXRoU2Vzc2lvbi5wcm90b3R5cGUuX3JlZnJlc2hBcHBBdXRoQWNjZXNzVG9rZW4gPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cblx0Ly8gSWYgdG9rZW5zIGFyZW4ndCBhbHJlYWR5IGJlaW5nIHJlZnJlc2hlZCwgc3RhcnQgdGhlIHJlZnJlc2hcblx0aWYgKCF0aGlzLl9yZWZyZXNoUHJvbWlzZSkge1xuXG5cdFx0dGhpcy5fcmVmcmVzaFByb21pc2UgPSB0aGlzLl90b2tlbk1hbmFnZXIuZ2V0VG9rZW5zSldUR3JhbnQodGhpcy5fdHlwZSwgdGhpcy5faWQsIG9wdGlvbnMpXG5cdFx0XHQudGhlbih0b2tlbkluZm8gPT4ge1xuXHRcdFx0XHQvLyBTZXQgbmV3IHRva2VuIGluZm8gYW5kIHByb3BhZ2F0ZSB0aGUgbmV3IGFjY2VzcyB0b2tlblxuXHRcdFx0XHR0aGlzLl90b2tlbkluZm8gPSB0b2tlbkluZm87XG5cblx0XHRcdFx0aWYgKHRoaXMuX3Rva2VuU3RvcmUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdG9rZW5TdG9yZS53cml0ZUFzeW5jKHRva2VuSW5mbylcblx0XHRcdFx0XHRcdC50aGVuKCgpID0+IHRva2VuSW5mby5hY2Nlc3NUb2tlbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG9rZW5JbmZvLmFjY2Vzc1Rva2VuO1xuXHRcdFx0fSlcblx0XHRcdC5maW5hbGx5KCgpID0+IHtcblx0XHRcdFx0Ly8gUmVmcmVzaCBjb21wbGV0ZSwgY2xlYXIgcHJvbWlzZVxuXHRcdFx0XHR0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzLl9yZWZyZXNoUHJvbWlzZTtcbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYSB2YWxpZCwgYXBwIGF1dGggYWNjZXNzIHRva2VuLlxuICogUGVyZm9ybXMgYSByZWZyZXNoIGJlZm9yZSByZXR1cm5pbmcgaWYgdGhlIGN1cnJlbnQgdG9rZW4gaXMgZXhwaXJlZC4gSWYgdGhlIGN1cnJlbnRcbiAqIHRva2VuIGlzIGNvbnNpZGVyZWQgc3RhbGUgYnV0IHN0aWxsIHZhbGlkLCByZXR1cm4gdGhlIGN1cnJlbnQgdG9rZW4gYnV0IGluaXRpYXRlIGFcbiAqIG5ldyByZWZyZXNoIGluIHRoZSBiYWNrZ3JvdW5kLlxuICpcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgYWNjZXNzIHRva2VuXG4gKi9cbkFwcEF1dGhTZXNzaW9uLnByb3RvdHlwZS5nZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuXHR2YXIgZXhwaXJhdGlvbkJ1ZmZlciA9IE1hdGgubWF4KHRoaXMuX2NvbmZpZy5leHBpcmVkQnVmZmVyTVMsIHRoaXMuX2NvbmZpZy5zdGFsZUJ1ZmZlck1TKTtcblxuXHQvLyBJZiB3ZSdyZSBpbml0aWFsaXppbmcgdGhlIGNsaWVudCBhbmQgaGF2ZSBhIHRva2VuIHN0b3JlLCB0cnkgcmVhZGluZyBmcm9tIGl0XG5cdGlmICghdGhpcy5fdG9rZW5JbmZvICYmIHRoaXMuX3Rva2VuU3RvcmUpIHtcblxuXHRcdHJldHVybiB0aGlzLl90b2tlblN0b3JlLnJlYWRBc3luYygpXG5cdFx0XHQudGhlbih0b2tlbkluZm8gPT4ge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3Rva2VuTWFuYWdlci5pc0FjY2Vzc1Rva2VuVmFsaWQodG9rZW5JbmZvLCBleHBpcmF0aW9uQnVmZmVyKSkge1xuXHRcdFx0XHRcdC8vIFRva2VuIHN0b3JlIGNvbnRhaW5zIGV4cGlyZWQgdG9rZW5zLCByZWZyZXNoXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3JlZnJlc2hBcHBBdXRoQWNjZXNzVG9rZW4ob3B0aW9ucyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl90b2tlbkluZm8gPSB0b2tlbkluZm87XG5cdFx0XHRcdHJldHVybiB0b2tlbkluZm8uYWNjZXNzVG9rZW47XG5cdFx0XHR9KTtcblx0fVxuXG5cdC8vIElmIHRoZSBjdXJyZW50IHRva2VuIGlzIG5vdCBmcmVzaCwgZ2V0IGEgbmV3IHRva2VuLiBBbGwgaW5jb21pbmdcblx0Ly8gcmVxdWVzdHMgd2lsbCBiZSBoZWxkIHVudGlsIGEgZnJlc2ggdG9rZW4gaXMgcmV0cmlldmVkLlxuXHRpZiAoIXRoaXMuX3Rva2VuSW5mbyB8fCAhdGhpcy5fdG9rZW5NYW5hZ2VyLmlzQWNjZXNzVG9rZW5WYWxpZCh0aGlzLl90b2tlbkluZm8sIGV4cGlyYXRpb25CdWZmZXIpKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlZnJlc2hBcHBBdXRoQWNjZXNzVG9rZW4ob3B0aW9ucyk7XG5cdH1cblxuXHQvLyBZb3VyIHRva2VuIGlzIG5vdCBjdXJyZW50bHkgc3RhbGUhIFJldHVybiB0aGUgY3VycmVudCBhY2Nlc3MgdG9rZW4uXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fdG9rZW5JbmZvLmFjY2Vzc1Rva2VuKTtcbn07XG5cbi8qKlxuICogUmV2b2tlcyB0aGUgYXBwIGF1dGggdG9rZW4gdXNlZCBieSB0aGlzIHNlc3Npb24sIGFuZCBjbGVhcnMgdGhlIHNhdmVkIHRva2VuSW5mby5cbiAqXG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXS0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZpbmcgaWYgdGhlIHJldm9rZSBzdWNjZWVkc1xuICovXG5BcHBBdXRoU2Vzc2lvbi5wcm90b3R5cGUucmV2b2tlVG9rZW5zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvLyBUaGUgY3VycmVudCBhcHAgYXV0aCB0b2tlbiBpcyByZXZva2VkIChidXQgYSBuZXcgb25lIHdpbGwgYmUgY3JlYXRlZCBhdXRvbWF0aWNhbGx5IGFzIG5lZWRlZCkuXG5cdHZhciB0b2tlbkluZm8gPSB0aGlzLl90b2tlbkluZm8gfHwge30sXG5cdFx0YWNjZXNzVG9rZW4gPSB0b2tlbkluZm8uYWNjZXNzVG9rZW47XG5cdHRoaXMuX3Rva2VuSW5mbyA9IG51bGw7XG5cdHJldHVybiB0aGlzLl90b2tlbk1hbmFnZXIucmV2b2tlVG9rZW5zKGFjY2Vzc1Rva2VuLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRXhjaGFuZ2UgdGhlIGNsaWVudCBhY2Nlc3MgdG9rZW4gZm9yIG9uZSB3aXRoIGxvd2VyIHNjb3BlXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gc2NvcGVzIFRoZSBzY29wZShzKSByZXF1ZXN0ZWQgZm9yIHRoZSBuZXcgdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzb3VyY2VdIFRoZSBhYnNvbHV0ZSBVUkwgb2YgYW4gQVBJIHJlc291cmNlIHRvIHNjb3BlIHRoZSBuZXcgdG9rZW4gdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zLnRva2VuUmVxdWVzdE9wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcGFyYW0ge0FjdG9yUGFyYW1zfSBbb3B0aW9ucy5hY3Rvcl0gLSBPcHRpb25hbCBhY3RvciBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhbm5vdGF0b3IgdG9rZW5zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkluZm8+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbmV3IHRva2VuIGluZm9cbiAqL1xuQXBwQXV0aFNlc3Npb24ucHJvdG90eXBlLmV4Y2hhbmdlVG9rZW4gPSBmdW5jdGlvbihzY29wZXMsIHJlc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0aGlzLmdldEFjY2Vzc1Rva2VuKG9wdGlvbnMpXG5cdFx0LnRoZW4oYWNjZXNzVG9rZW4gPT4gdGhpcy5fdG9rZW5NYW5hZ2VyLmV4Y2hhbmdlVG9rZW4oYWNjZXNzVG9rZW4sIHNjb3BlcywgcmVzb3VyY2UsIG9wdGlvbnMpKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIGFuIGFuIFwiRXhwaXJlZCBUb2tlbnNcIiBFcnJvci4gSWYgb3VyIHRva2VucyBhcmUgZXhwaXJlZCwgd2UgbmVlZCB0byBjbGVhciB0aGUgdG9rZW5cbiAqIHN0b3JlIChpZiBwcmVzZW50KSBiZWZvcmUgY29udGludWluZy5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yc35FeHBpcmVkVG9rZW5zRXJyb3J9IGVyciBBbiBcImV4cGlyZWQgdG9rZW5zXCIgZXJyb3IgaW5jbHVkaW5nIGluZm9ybWF0aW9uXG4gKiAgYWJvdXQgdGhlIHJlcXVlc3QvcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxFcnJvcj59IFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGVycm9yLiAgVGhpcyB3aWxsXG4gKiAgdXN1YWxseSBiZSB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgZXJyb3IsIGJ1dCBjb3VsZCBhbiBlcnJvciBmcm9tIHRyeWluZyB0byBhY2Nlc3MgdGhlXG4gKiAgdG9rZW4gc3RvcmUgYXMgd2VsbC5cbiAqL1xuQXBwQXV0aFNlc3Npb24ucHJvdG90eXBlLmhhbmRsZUV4cGlyZWRUb2tlbnNFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXG5cdGlmICghdGhpcy5fdG9rZW5TdG9yZSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZXJyKTtcblx0fVxuXG5cdC8vIElmIGEgdG9rZW4gc3RvcmUgaXMgYXZhaWxhYmxlLCBjbGVhciB0aGUgc3RvcmUgYW5kIHRocm93IGVpdGhlciBlcnJvclxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJvbWlzZS9uby1wcm9taXNlLWluLWNhbGxiYWNrXG5cdHJldHVybiB0aGlzLl90b2tlblN0b3JlLmNsZWFyQXN5bmMoKVxuXHRcdC5jYXRjaChlID0+IGVycm9ycy51bndyYXBBbmRUaHJvdyhlKSlcblx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHR0aHJvdyBlcnI7XG5cdFx0fSk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9hcHAtYXV0aC1zZXNzaW9uXG4gKiBAc2VlIHtATGluayBBcHBBdXRoU2Vzc2lvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBBcHBBdXRoU2Vzc2lvbjtcbiJdLCJuYW1lcyI6WyJQcm9taXNlIiwicmVxdWlyZSIsImFzc2VydCIsImVycm9ycyIsImlzT2JqZWN0VmFsaWRUb2tlblN0b3JlIiwib2JqIiwiQm9vbGVhbiIsInJlYWQiLCJ3cml0ZSIsImNsZWFyIiwiQXBwQXV0aFNlc3Npb24iLCJ0eXBlIiwiaWQiLCJjb25maWciLCJ0b2tlbk1hbmFnZXIiLCJ0b2tlblN0b3JlIiwiX3R5cGUiLCJfaWQiLCJfY29uZmlnIiwiX3Rva2VuTWFuYWdlciIsIl90b2tlblN0b3JlIiwicHJvbWlzaWZ5QWxsIiwiX3Rva2VuSW5mbyIsIl9yZWZyZXNoUHJvbWlzZSIsInByb3RvdHlwZSIsIl9yZWZyZXNoQXBwQXV0aEFjY2Vzc1Rva2VuIiwib3B0aW9ucyIsImdldFRva2Vuc0pXVEdyYW50IiwidGhlbiIsInRva2VuSW5mbyIsIndyaXRlQXN5bmMiLCJhY2Nlc3NUb2tlbiIsImZpbmFsbHkiLCJnZXRBY2Nlc3NUb2tlbiIsImV4cGlyYXRpb25CdWZmZXIiLCJNYXRoIiwibWF4IiwiZXhwaXJlZEJ1ZmZlck1TIiwic3RhbGVCdWZmZXJNUyIsInJlYWRBc3luYyIsImlzQWNjZXNzVG9rZW5WYWxpZCIsInJlc29sdmUiLCJyZXZva2VUb2tlbnMiLCJleGNoYW5nZVRva2VuIiwic2NvcGVzIiwicmVzb3VyY2UiLCJoYW5kbGVFeHBpcmVkVG9rZW5zRXJyb3IiLCJlcnIiLCJjbGVhckFzeW5jIiwiY2F0Y2giLCJlIiwidW53cmFwQW5kVGhyb3ciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/sessions/app-auth-session.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/sessions/basic-session.js":
/*!*****************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/sessions/basic-session.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview A Basic Box API Session.\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nconst Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\");\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * A BasicSession holds only a single accessToken. It has no idea how to authenticate,\n * refresh, or persist its token information. When that token expires, the session\n * and any clients using it will become useless.\n *\n * Basic API Session is the most simple API Session to use, which makes it a good choice\n * for simple applications, developers who are just getting started, and applications\n * that wish to manage tokens themselves.\n *\n * @param {string} accessToken The existing access token for a user\n * @param {TokenManager} tokenManager The token manager\n * @constructor\n */ function BasicSession(accessToken, tokenManager) {\n    this._accessToken = accessToken;\n    this._tokenManager = tokenManager;\n}\n/**\n * Returns the clients access token. BasicSession never returns an error, since it doesn't\n * know the status of its own token.\n *\n * @returns {Promise<string>} Promise resolving to the access token\n */ BasicSession.prototype.getAccessToken = function() {\n    return Promise.resolve(this._accessToken);\n};\n/**\n * Revokes the session's access token.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise} Promise resolving if the revoke succeeds\n */ BasicSession.prototype.revokeTokens = function(options) {\n    return this._tokenManager.revokeTokens(this._accessToken, options);\n};\n/**\n * Exchange the client access token for one with lower scope\n * @param {string|string[]} scopes The scope(s) requested for the new token\n * @param {string} [resource] The absolute URL of an API resource to scope the new token to\n * @param {Object} [options] - Optional parameters\n * @param {TokenRequestOptions} [options.tokenRequestOptions] - Sets optional behavior for the token grant\n * @param {ActorParams} [options.actor] - Optional actor parameters for creating annotator tokens\n * @returns {Promise<TokenInfo>} Promise resolving to the new token info\n */ BasicSession.prototype.exchangeToken = function(scopes, resource, options) {\n    return this._tokenManager.exchangeToken(this._accessToken, scopes, resource, options);\n};\n/**\n * @module box-node-sdk/lib/sessions/basic-session\n * @see {@Link BasicSession}\n */ module.exports = BasicSession;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9iYXNpYy1zZXNzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFHQSxpRkFBaUY7QUFDakYsZUFBZTtBQUNmLGlGQUFpRjtBQUVqRixNQUFNQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV4QixpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxTQUFTQyxhQUFhQyxXQUFXLEVBQUVDLFlBQVk7SUFDOUMsSUFBSSxDQUFDQyxZQUFZLEdBQUdGO0lBQ3BCLElBQUksQ0FBQ0csYUFBYSxHQUFHRjtBQUN0QjtBQUVBOzs7OztDQUtDLEdBQ0RGLGFBQWFLLFNBQVMsQ0FBQ0MsY0FBYyxHQUFHO0lBQ3ZDLE9BQU9SLFFBQVFTLE9BQU8sQ0FBQyxJQUFJLENBQUNKLFlBQVk7QUFDekM7QUFFQTs7Ozs7Q0FLQyxHQUNESCxhQUFhSyxTQUFTLENBQUNHLFlBQVksR0FBRyxTQUFTQyxPQUFPO0lBQ3JELE9BQU8sSUFBSSxDQUFDTCxhQUFhLENBQUNJLFlBQVksQ0FBQyxJQUFJLENBQUNMLFlBQVksRUFBRU07QUFDM0Q7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNEVCxhQUFhSyxTQUFTLENBQUNLLGFBQWEsR0FBRyxTQUFTQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUgsT0FBTztJQUN4RSxPQUFPLElBQUksQ0FBQ0wsYUFBYSxDQUFDTSxhQUFhLENBQUMsSUFBSSxDQUFDUCxZQUFZLEVBQUVRLFFBQVFDLFVBQVVIO0FBQzlFO0FBRUE7OztDQUdDLEdBQ0RJLE9BQU9DLE9BQU8sR0FBR2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL3Nlc3Npb25zL2Jhc2ljLXNlc3Npb24uanM/MzIwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBCYXNpYyBCb3ggQVBJIFNlc3Npb24uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIEJhc2ljU2Vzc2lvbiBob2xkcyBvbmx5IGEgc2luZ2xlIGFjY2Vzc1Rva2VuLiBJdCBoYXMgbm8gaWRlYSBob3cgdG8gYXV0aGVudGljYXRlLFxuICogcmVmcmVzaCwgb3IgcGVyc2lzdCBpdHMgdG9rZW4gaW5mb3JtYXRpb24uIFdoZW4gdGhhdCB0b2tlbiBleHBpcmVzLCB0aGUgc2Vzc2lvblxuICogYW5kIGFueSBjbGllbnRzIHVzaW5nIGl0IHdpbGwgYmVjb21lIHVzZWxlc3MuXG4gKlxuICogQmFzaWMgQVBJIFNlc3Npb24gaXMgdGhlIG1vc3Qgc2ltcGxlIEFQSSBTZXNzaW9uIHRvIHVzZSwgd2hpY2ggbWFrZXMgaXQgYSBnb29kIGNob2ljZVxuICogZm9yIHNpbXBsZSBhcHBsaWNhdGlvbnMsIGRldmVsb3BlcnMgd2hvIGFyZSBqdXN0IGdldHRpbmcgc3RhcnRlZCwgYW5kIGFwcGxpY2F0aW9uc1xuICogdGhhdCB3aXNoIHRvIG1hbmFnZSB0b2tlbnMgdGhlbXNlbHZlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjZXNzVG9rZW4gVGhlIGV4aXN0aW5nIGFjY2VzcyB0b2tlbiBmb3IgYSB1c2VyXG4gKiBAcGFyYW0ge1Rva2VuTWFuYWdlcn0gdG9rZW5NYW5hZ2VyIFRoZSB0b2tlbiBtYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmFzaWNTZXNzaW9uKGFjY2Vzc1Rva2VuLCB0b2tlbk1hbmFnZXIpIHtcblx0dGhpcy5fYWNjZXNzVG9rZW4gPSBhY2Nlc3NUb2tlbjtcblx0dGhpcy5fdG9rZW5NYW5hZ2VyID0gdG9rZW5NYW5hZ2VyO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNsaWVudHMgYWNjZXNzIHRva2VuLiBCYXNpY1Nlc3Npb24gbmV2ZXIgcmV0dXJucyBhbiBlcnJvciwgc2luY2UgaXQgZG9lc24ndFxuICoga25vdyB0aGUgc3RhdHVzIG9mIGl0cyBvd24gdG9rZW4uXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGFjY2VzcyB0b2tlblxuICovXG5CYXNpY1Nlc3Npb24ucHJvdG90eXBlLmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYWNjZXNzVG9rZW4pO1xufTtcblxuLyoqXG4gKiBSZXZva2VzIHRoZSBzZXNzaW9uJ3MgYWNjZXNzIHRva2VuLlxuICpcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZpbmcgaWYgdGhlIHJldm9rZSBzdWNjZWVkc1xuICovXG5CYXNpY1Nlc3Npb24ucHJvdG90eXBlLnJldm9rZVRva2VucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0cmV0dXJuIHRoaXMuX3Rva2VuTWFuYWdlci5yZXZva2VUb2tlbnModGhpcy5fYWNjZXNzVG9rZW4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGNoYW5nZSB0aGUgY2xpZW50IGFjY2VzcyB0b2tlbiBmb3Igb25lIHdpdGggbG93ZXIgc2NvcGVcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBzY29wZXMgVGhlIHNjb3BlKHMpIHJlcXVlc3RlZCBmb3IgdGhlIG5ldyB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IFtyZXNvdXJjZV0gVGhlIGFic29sdXRlIFVSTCBvZiBhbiBBUEkgcmVzb3VyY2UgdG8gc2NvcGUgdGhlIG5ldyB0b2tlbiB0b1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnMudG9rZW5SZXF1ZXN0T3B0aW9uc10gLSBTZXRzIG9wdGlvbmFsIGJlaGF2aW9yIGZvciB0aGUgdG9rZW4gZ3JhbnRcbiAqIEBwYXJhbSB7QWN0b3JQYXJhbXN9IFtvcHRpb25zLmFjdG9yXSAtIE9wdGlvbmFsIGFjdG9yIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGFubm90YXRvciB0b2tlbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXcgdG9rZW4gaW5mb1xuICovXG5CYXNpY1Nlc3Npb24ucHJvdG90eXBlLmV4Y2hhbmdlVG9rZW4gPSBmdW5jdGlvbihzY29wZXMsIHJlc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0aGlzLl90b2tlbk1hbmFnZXIuZXhjaGFuZ2VUb2tlbih0aGlzLl9hY2Nlc3NUb2tlbiwgc2NvcGVzLCByZXNvdXJjZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9iYXNpYy1zZXNzaW9uXG4gKiBAc2VlIHtATGluayBCYXNpY1Nlc3Npb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gQmFzaWNTZXNzaW9uO1xuIl0sIm5hbWVzIjpbIlByb21pc2UiLCJyZXF1aXJlIiwiQmFzaWNTZXNzaW9uIiwiYWNjZXNzVG9rZW4iLCJ0b2tlbk1hbmFnZXIiLCJfYWNjZXNzVG9rZW4iLCJfdG9rZW5NYW5hZ2VyIiwicHJvdG90eXBlIiwiZ2V0QWNjZXNzVG9rZW4iLCJyZXNvbHZlIiwicmV2b2tlVG9rZW5zIiwib3B0aW9ucyIsImV4Y2hhbmdlVG9rZW4iLCJzY29wZXMiLCJyZXNvdXJjZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/sessions/basic-session.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/sessions/persistent-session.js":
/*!**********************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/sessions/persistent-session.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview A Persistent Box API Session.\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nconst assert = __webpack_require__(/*! assert */ \"assert\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), errors = __webpack_require__(/*! ../util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n/**\n * Validate that an object is a valid TokenInfo object\n *\n * @param {Object} obj The object to validate\n * @returns {boolean} True if the passed in object is a valid TokenInfo object that\n *  has all the expected properties, false otherwise\n * @private\n */ function isObjectValidTokenInfo(obj) {\n    return Boolean(obj && obj.accessToken && obj.refreshToken && obj.accessTokenTTLMS && obj.acquiredAtMS);\n}\n/**\n * Validate that an object is a valid TokenStore object\n *\n * @param {Object} obj the object to validate\n * @returns {boolean} returns true if the passed in object is a valid TokenStore object that\n * has all the expected properties. false otherwise.\n * @private\n */ function isObjectValidTokenStore(obj) {\n    return Boolean(obj && obj.read && obj.write && obj.clear);\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * A Persistent API Session has the ability to refresh its access token once it becomes expired.\n * It takes in a full tokenInfo object for authentication. It can detect when its tokens have\n * expired and will request new, valid tokens if needed. It can also interface with a token\n * data-store if one is provided.\n *\n * Persistent API Session a good choice for long-running applications or web servers that\n * must remember users across sessions.\n *\n * @param {TokenInfo} tokenInfo A valid TokenInfo object. Will throw if improperly formatted.\n * @param {TokenStore} [tokenStore] A valid TokenStore object. Will throw if improperly formatted.\n * @param {Config} config The SDK configuration options\n * @param {TokenManager} tokenManager The token manager\n * @constructor\n */ function PersistentSession(tokenInfo, tokenStore, config, tokenManager) {\n    this._config = config;\n    this._tokenManager = tokenManager;\n    // Keeps track of if tokens are currently being refreshed\n    this._refreshPromise = null;\n    // Set valid PersistentSession credentials. Throw if expected credentials are invalid or not given.\n    assert(isObjectValidTokenInfo(tokenInfo), \"tokenInfo is improperly formatted. Properties required: accessToken, refreshToken, accessTokenTTLMS and acquiredAtMS.\");\n    this._setTokenInfo(tokenInfo);\n    // If tokenStore was provided, set the persistent data & current store operations\n    if (tokenStore) {\n        assert(isObjectValidTokenStore(tokenStore), \"Token store provided but is improperly formatted. Methods required: read(), write(), clear().\");\n        this._tokenStore = Promise.promisifyAll(tokenStore);\n    }\n}\n/**\n * Sets all relevant token info for this client.\n *\n * @param {TokenInfo} tokenInfo A valid TokenInfo object.\n * @returns {void}\n * @private\n */ PersistentSession.prototype._setTokenInfo = function(tokenInfo) {\n    this._tokenInfo = {\n        accessToken: tokenInfo.accessToken,\n        refreshToken: tokenInfo.refreshToken,\n        accessTokenTTLMS: tokenInfo.accessTokenTTLMS,\n        acquiredAtMS: tokenInfo.acquiredAtMS\n    };\n};\n/**\n * Attempts to refresh tokens for the client.\n * Will use the Box refresh token grant to complete the refresh. On refresh failure, we'll\n * check the token store for more recently updated tokens and load them if found. Otherwise\n * an error will be propagated.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<string>} Promise resolving to the access token\n * @private\n */ PersistentSession.prototype._refreshTokens = function(options) {\n    // If not already refreshing, kick off a token refresh request and set a lock so that additional\n    // client requests don't try as well\n    if (!this._refreshPromise) {\n        this._refreshPromise = this._tokenManager.getTokensRefreshGrant(this._tokenInfo.refreshToken, options).catch((err)=>{\n            // If we got an error response from Box API, but it was 400 invalid_grant, it indicates we may have just\n            // made the request with an invalidated refresh token. Since only a max of 2 refresh tokens can be valid\n            // at any point in time, and a horizontally scaled app could have multiple Node instances running in parallel,\n            // it is possible to hit cases where too many servers all refresh a user's tokens at once\n            // and cause this server's token to become invalidated. However, the user should still be alive, but\n            // we'll need to check the central data store for the latest valid tokens that some other server in the app\n            // cluster would have received. So, instead pull tokens from the central store and attempt to use them.\n            if (err.statusCode === httpStatusCodes.BAD_REQUEST && this._tokenStore) {\n                var invalidGrantError = err;\n                // Check the tokenStore to see if tokens have been updated recently. If they have, then another\n                // instance of the session may have already refreshed the user tokens, which would explain why\n                // we couldn't refresh.\n                return this._tokenStore.readAsync().catch((e)=>errors.unwrapAndThrow(e)).then((storeTokenInfo)=>{\n                    // if the tokens we got from the central store are the same as the tokens we made the failed request with\n                    // already, then we can be sure that no other servers have valid tokens for this server either.\n                    // Thus, this user truly has an expired refresh token. So, propagate an \"Expired Tokens\" error.\n                    if (!storeTokenInfo || storeTokenInfo.refreshToken === this._tokenInfo.refreshToken) {\n                        throw errors.buildAuthError(invalidGrantError.response);\n                    }\n                    // Propagate the fresh tokens that we found in the session\n                    return storeTokenInfo;\n                });\n            }\n            // Box API returned a permanent error that is not retryable and we can't recover.\n            // We have no usable tokens for the user and no way to refresh them - propagate a permanent error.\n            throw err;\n        }).then((tokenInfo)=>{\n            // Success! We got back a TokenInfo object from the API.\n            // If we have a token store, we'll write it there now before finishing up the request.\n            if (this._tokenStore) {\n                return this._tokenStore.writeAsync(tokenInfo).catch((e)=>errors.unwrapAndThrow(e)).then(()=>tokenInfo);\n            }\n            // If no token store, Set and propagate the access token immediately\n            return tokenInfo;\n        }).then((tokenInfo)=>{\n            // Set and propagate the new access token\n            this._setTokenInfo(tokenInfo);\n            return tokenInfo.accessToken;\n        }).catch((err)=>this.handleExpiredTokensError(err)).finally(()=>{\n            // Refresh complete, clear promise\n            this._refreshPromise = null;\n        });\n    }\n    return this._refreshPromise;\n};\n// ------------------------------------------------------------------------------\n// Public Instance\n// ------------------------------------------------------------------------------\n/**\n * Returns the clients access token.\n *\n * If tokens don't yet exist, first attempt to retrieve them.\n * If tokens are expired, first attempt to refresh them.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise<string>} Promise resolving to the access token\n */ PersistentSession.prototype.getAccessToken = function(options) {\n    // If our tokens are not fresh, we need to refresh them\n    var expirationBuffer = Math.max(this._config.expiredBufferMS, this._config.staleBufferMS);\n    if (!this._tokenManager.isAccessTokenValid(this._tokenInfo, expirationBuffer)) {\n        return this._refreshTokens(options);\n    }\n    // Current access token is still valid. Return it.\n    return Promise.resolve(this._tokenInfo.accessToken);\n};\n/**\n * Revokes the session's tokens. If the session has a refresh token we'll use that,\n * since it is more likely to be up to date. Otherwise, we'll revoke the accessToken.\n * Revoking either one will disable the other as well.\n *\n * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n * @returns {Promise} Promise that resolves when the revoke succeeds\n */ PersistentSession.prototype.revokeTokens = function(options) {\n    return this._tokenManager.revokeTokens(this._tokenInfo.refreshToken, options);\n};\n/**\n * Exchange the client access token for one with lower scope\n * @param {string|string[]} scopes The scope(s) requested for the new token\n * @param {string} [resource] The absolute URL of an API resource to scope the new token to\n * @param {Object} [options] - Optional parameters\n * @param {TokenRequestOptions} [options.tokenRequestOptions] - Sets optional behavior for the token grant\n * @returns {void}\n */ PersistentSession.prototype.exchangeToken = function(scopes, resource, options) {\n    return this.getAccessToken(options).then((accessToken)=>this._tokenManager.exchangeToken(accessToken, scopes, resource, options));\n};\n/**\n * Handle an an \"Expired Tokens\" Error. If our tokens are expired, we need to clear the token\n * store (if present) before continuing.\n *\n * @param {Errors~ExpiredTokensError} err An \"expired tokens\" error including information\n *  about the request/response.\n * @returns {Promise<Error>} Promise resolving to an error.  This will\n *  usually be the original response error, but could an error from trying to access the\n *  token store as well.\n */ PersistentSession.prototype.handleExpiredTokensError = function(err) {\n    if (!this._tokenStore) {\n        return Promise.resolve(err);\n    }\n    // If a token store is available, clear the store and throw either error\n    // eslint-disable-next-line promise/no-promise-in-callback\n    return this._tokenStore.clearAsync().catch((e)=>errors.unwrapAndThrow(e)).then(()=>{\n        throw err;\n    });\n};\n/**\n * @module box-node-sdk/lib/sessions/persistent-session\n * @see {@Link PersistentSession}\n */ module.exports = PersistentSession;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi9zZXNzaW9ucy9wZXJzaXN0ZW50LXNlc3Npb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUdBLGlGQUFpRjtBQUNqRixlQUFlO0FBQ2YsaUZBQWlGO0FBQ2pGLE1BQU1BLFNBQVNDLG1CQUFPQSxDQUFDLHlCQUN0QkMsVUFBVUQsbUJBQU9BLENBQUMseUVBQ2xCRSxTQUFTRixtQkFBT0EsQ0FBQywrRUFDakJHLGtCQUFrQkgsbUJBQU9BLENBQUM7QUFHM0IsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFFakY7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNJLHVCQUF1QkMsR0FBRztJQUNsQyxPQUFPQyxRQUFRRCxPQUNkQSxJQUFJRSxXQUFXLElBQ2ZGLElBQUlHLFlBQVksSUFDaEJILElBQUlJLGdCQUFnQixJQUNwQkosSUFBSUssWUFBWTtBQUNsQjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyx3QkFBd0JOLEdBQUc7SUFDbkMsT0FBT0MsUUFBUUQsT0FBT0EsSUFBSU8sSUFBSSxJQUFJUCxJQUFJUSxLQUFLLElBQUlSLElBQUlTLEtBQUs7QUFDekQ7QUFHQSxpRkFBaUY7QUFDakYsU0FBUztBQUNULGlGQUFpRjtBQUVqRjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNELFNBQVNDLGtCQUFrQkMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRUMsWUFBWTtJQUNyRSxJQUFJLENBQUNDLE9BQU8sR0FBR0Y7SUFDZixJQUFJLENBQUNHLGFBQWEsR0FBR0Y7SUFFckIseURBQXlEO0lBQ3pELElBQUksQ0FBQ0csZUFBZSxHQUFHO0lBRXZCLG1HQUFtRztJQUNuR3ZCLE9BQU9LLHVCQUF1QlksWUFBWTtJQUMxQyxJQUFJLENBQUNPLGFBQWEsQ0FBQ1A7SUFFbkIsaUZBQWlGO0lBQ2pGLElBQUlDLFlBQVk7UUFDZmxCLE9BQU9ZLHdCQUF3Qk0sYUFBYTtRQUM1QyxJQUFJLENB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bmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL3Nlc3Npb25zL3BlcnNpc3RlbnQtc2Vzc2lvbi5qcz8zODIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBBIFBlcnNpc3RlbnQgQm94IEFQSSBTZXNzaW9uLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKSxcblx0UHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyksXG5cdGVycm9ycyA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JzJyksXG5cdGh0dHBTdGF0dXNDb2RlcyA9IHJlcXVpcmUoJ2h0dHAtc3RhdHVzJyk7XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGFuIG9iamVjdCBpcyBhIHZhbGlkIFRva2VuSW5mbyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXNzZWQgaW4gb2JqZWN0IGlzIGEgdmFsaWQgVG9rZW5JbmZvIG9iamVjdCB0aGF0XG4gKiAgaGFzIGFsbCB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcywgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc09iamVjdFZhbGlkVG9rZW5JbmZvKG9iaikge1xuXHRyZXR1cm4gQm9vbGVhbihvYmogJiZcblx0XHRvYmouYWNjZXNzVG9rZW4gJiZcblx0XHRvYmoucmVmcmVzaFRva2VuICYmXG5cdFx0b2JqLmFjY2Vzc1Rva2VuVFRMTVMgJiZcblx0XHRvYmouYWNxdWlyZWRBdE1TKTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGFuIG9iamVjdCBpcyBhIHZhbGlkIFRva2VuU3RvcmUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgaW4gb2JqZWN0IGlzIGEgdmFsaWQgVG9rZW5TdG9yZSBvYmplY3QgdGhhdFxuICogaGFzIGFsbCB0aGUgZXhwZWN0ZWQgcHJvcGVydGllcy4gZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RWYWxpZFRva2VuU3RvcmUob2JqKSB7XG5cdHJldHVybiBCb29sZWFuKG9iaiAmJiBvYmoucmVhZCAmJiBvYmoud3JpdGUgJiYgb2JqLmNsZWFyKTtcbn1cblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQSBQZXJzaXN0ZW50IEFQSSBTZXNzaW9uIGhhcyB0aGUgYWJpbGl0eSB0byByZWZyZXNoIGl0cyBhY2Nlc3MgdG9rZW4gb25jZSBpdCBiZWNvbWVzIGV4cGlyZWQuXG4gKiBJdCB0YWtlcyBpbiBhIGZ1bGwgdG9rZW5JbmZvIG9iamVjdCBmb3IgYXV0aGVudGljYXRpb24uIEl0IGNhbiBkZXRlY3Qgd2hlbiBpdHMgdG9rZW5zIGhhdmVcbiAqIGV4cGlyZWQgYW5kIHdpbGwgcmVxdWVzdCBuZXcsIHZhbGlkIHRva2VucyBpZiBuZWVkZWQuIEl0IGNhbiBhbHNvIGludGVyZmFjZSB3aXRoIGEgdG9rZW5cbiAqIGRhdGEtc3RvcmUgaWYgb25lIGlzIHByb3ZpZGVkLlxuICpcbiAqIFBlcnNpc3RlbnQgQVBJIFNlc3Npb24gYSBnb29kIGNob2ljZSBmb3IgbG9uZy1ydW5uaW5nIGFwcGxpY2F0aW9ucyBvciB3ZWIgc2VydmVycyB0aGF0XG4gKiBtdXN0IHJlbWVtYmVyIHVzZXJzIGFjcm9zcyBzZXNzaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1Rva2VuSW5mb30gdG9rZW5JbmZvIEEgdmFsaWQgVG9rZW5JbmZvIG9iamVjdC4gV2lsbCB0aHJvdyBpZiBpbXByb3Blcmx5IGZvcm1hdHRlZC5cbiAqIEBwYXJhbSB7VG9rZW5TdG9yZX0gW3Rva2VuU3RvcmVdIEEgdmFsaWQgVG9rZW5TdG9yZSBvYmplY3QuIFdpbGwgdGhyb3cgaWYgaW1wcm9wZXJseSBmb3JtYXR0ZWQuXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFRoZSBTREsgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge1Rva2VuTWFuYWdlcn0gdG9rZW5NYW5hZ2VyIFRoZSB0b2tlbiBtYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGVyc2lzdGVudFNlc3Npb24odG9rZW5JbmZvLCB0b2tlblN0b3JlLCBjb25maWcsIHRva2VuTWFuYWdlcikge1xuXHR0aGlzLl9jb25maWcgPSBjb25maWc7XG5cdHRoaXMuX3Rva2VuTWFuYWdlciA9IHRva2VuTWFuYWdlcjtcblxuXHQvLyBLZWVwcyB0cmFjayBvZiBpZiB0b2tlbnMgYXJlIGN1cnJlbnRseSBiZWluZyByZWZyZXNoZWRcblx0dGhpcy5fcmVmcmVzaFByb21pc2UgPSBudWxsO1xuXG5cdC8vIFNldCB2YWxpZCBQZXJzaXN0ZW50U2Vzc2lvbiBjcmVkZW50aWFscy4gVGhyb3cgaWYgZXhwZWN0ZWQgY3JlZGVudGlhbHMgYXJlIGludmFsaWQgb3Igbm90IGdpdmVuLlxuXHRhc3NlcnQoaXNPYmplY3RWYWxpZFRva2VuSW5mbyh0b2tlbkluZm8pLCAndG9rZW5JbmZvIGlzIGltcHJvcGVybHkgZm9ybWF0dGVkLiBQcm9wZXJ0aWVzIHJlcXVpcmVkOiBhY2Nlc3NUb2tlbiwgcmVmcmVzaFRva2VuLCBhY2Nlc3NUb2tlblRUTE1TIGFuZCBhY3F1aXJlZEF0TVMuJyk7XG5cdHRoaXMuX3NldFRva2VuSW5mbyh0b2tlbkluZm8pO1xuXG5cdC8vIElmIHRva2VuU3RvcmUgd2FzIHByb3ZpZGVkLCBzZXQgdGhlIHBlcnNpc3RlbnQgZGF0YSAmIGN1cnJlbnQgc3RvcmUgb3BlcmF0aW9uc1xuXHRpZiAodG9rZW5TdG9yZSkge1xuXHRcdGFzc2VydChpc09iamVjdFZhbGlkVG9rZW5TdG9yZSh0b2tlblN0b3JlKSwgJ1Rva2VuIHN0b3JlIHByb3ZpZGVkIGJ1dCBpcyBpbXByb3Blcmx5IGZvcm1hdHRlZC4gTWV0aG9kcyByZXF1aXJlZDogcmVhZCgpLCB3cml0ZSgpLCBjbGVhcigpLicpO1xuXHRcdHRoaXMuX3Rva2VuU3RvcmUgPSBQcm9taXNlLnByb21pc2lmeUFsbCh0b2tlblN0b3JlKTtcblx0fVxufVxuXG4vKipcbiAqIFNldHMgYWxsIHJlbGV2YW50IHRva2VuIGluZm8gZm9yIHRoaXMgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7VG9rZW5JbmZvfSB0b2tlbkluZm8gQSB2YWxpZCBUb2tlbkluZm8gb2JqZWN0LlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5QZXJzaXN0ZW50U2Vzc2lvbi5wcm90b3R5cGUuX3NldFRva2VuSW5mbyA9IGZ1bmN0aW9uKHRva2VuSW5mbykge1xuXHR0aGlzLl90b2tlbkluZm8gPSB7XG5cdFx0YWNjZXNzVG9rZW46IHRva2VuSW5mby5hY2Nlc3NUb2tlbixcblx0XHRyZWZyZXNoVG9rZW46IHRva2VuSW5mby5yZWZyZXNoVG9rZW4sXG5cdFx0YWNjZXNzVG9rZW5UVExNUzogdG9rZW5JbmZvLmFjY2Vzc1Rva2VuVFRMTVMsXG5cdFx0YWNxdWlyZWRBdE1TOiB0b2tlbkluZm8uYWNxdWlyZWRBdE1TXG5cdH07XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlZnJlc2ggdG9rZW5zIGZvciB0aGUgY2xpZW50LlxuICogV2lsbCB1c2UgdGhlIEJveCByZWZyZXNoIHRva2VuIGdyYW50IHRvIGNvbXBsZXRlIHRoZSByZWZyZXNoLiBPbiByZWZyZXNoIGZhaWx1cmUsIHdlJ2xsXG4gKiBjaGVjayB0aGUgdG9rZW4gc3RvcmUgZm9yIG1vcmUgcmVjZW50bHkgdXBkYXRlZCB0b2tlbnMgYW5kIGxvYWQgdGhlbSBpZiBmb3VuZC4gT3RoZXJ3aXNlXG4gKiBhbiBlcnJvciB3aWxsIGJlIHByb3BhZ2F0ZWQuXG4gKlxuICogQHBhcmFtIHtUb2tlblJlcXVlc3RPcHRpb25zfSBbb3B0aW9uc10gLSBTZXRzIG9wdGlvbmFsIGJlaGF2aW9yIGZvciB0aGUgdG9rZW4gZ3JhbnRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhY2Nlc3MgdG9rZW5cbiAqIEBwcml2YXRlXG4gKi9cblBlcnNpc3RlbnRTZXNzaW9uLnByb3RvdHlwZS5fcmVmcmVzaFRva2VucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0Ly8gSWYgbm90IGFscmVhZHkgcmVmcmVzaGluZywga2ljayBvZmYgYSB0b2tlbiByZWZyZXNoIHJlcXVlc3QgYW5kIHNldCBhIGxvY2sgc28gdGhhdCBhZGRpdGlvbmFsXG5cdC8vIGNsaWVudCByZXF1ZXN0cyBkb24ndCB0cnkgYXMgd2VsbFxuXHRpZiAoIXRoaXMuX3JlZnJlc2hQcm9taXNlKSB7XG5cblx0XHR0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IHRoaXMuX3Rva2VuTWFuYWdlci5nZXRUb2tlbnNSZWZyZXNoR3JhbnQodGhpcy5fdG9rZW5JbmZvLnJlZnJlc2hUb2tlbiwgb3B0aW9ucylcblx0XHRcdC5jYXRjaChlcnIgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBnb3QgYW4gZXJyb3IgcmVzcG9uc2UgZnJvbSBCb3ggQVBJLCBidXQgaXQgd2FzIDQwMCBpbnZhbGlkX2dyYW50LCBpdCBpbmRpY2F0ZXMgd2UgbWF5IGhhdmUganVzdFxuXHRcdFx0XHQvLyBtYWRlIHRoZSByZXF1ZXN0IHdpdGggYW4gaW52YWxpZGF0ZWQgcmVmcmVzaCB0b2tlbi4gU2luY2Ugb25seSBhIG1heCBvZiAyIHJlZnJlc2ggdG9rZW5zIGNhbiBiZSB2YWxpZFxuXHRcdFx0XHQvLyBhdCBhbnkgcG9pbnQgaW4gdGltZSwgYW5kIGEgaG9yaXpvbnRhbGx5IHNjYWxlZCBhcHAgY291bGQgaGF2ZSBtdWx0aXBsZSBOb2RlIGluc3RhbmNlcyBydW5uaW5nIGluIHBhcmFsbGVsLFxuXHRcdFx0XHQvLyBpdCBpcyBwb3NzaWJsZSB0byBoaXQgY2FzZXMgd2hlcmUgdG9vIG1hbnkgc2VydmVycyBhbGwgcmVmcmVzaCBhIHVzZXIncyB0b2tlbnMgYXQgb25jZVxuXHRcdFx0XHQvLyBhbmQgY2F1c2UgdGhpcyBzZXJ2ZXIncyB0b2tlbiB0byBiZWNvbWUgaW52YWxpZGF0ZWQuIEhvd2V2ZXIsIHRoZSB1c2VyIHNob3VsZCBzdGlsbCBiZSBhbGl2ZSwgYnV0XG5cdFx0XHRcdC8vIHdlJ2xsIG5lZWQgdG8gY2hlY2sgdGhlIGNlbnRyYWwgZGF0YSBzdG9yZSBmb3IgdGhlIGxhdGVzdCB2YWxpZCB0b2tlbnMgdGhhdCBzb21lIG90aGVyIHNlcnZlciBpbiB0aGUgYXBwXG5cdFx0XHRcdC8vIGNsdXN0ZXIgd291bGQgaGF2ZSByZWNlaXZlZC4gU28sIGluc3RlYWQgcHVsbCB0b2tlbnMgZnJvbSB0aGUgY2VudHJhbCBzdG9yZSBhbmQgYXR0ZW1wdCB0byB1c2UgdGhlbS5cblx0XHRcdFx0aWYgKGVyci5zdGF0dXNDb2RlID09PSBodHRwU3RhdHVzQ29kZXMuQkFEX1JFUVVFU1QgJiYgdGhpcy5fdG9rZW5TdG9yZSkge1xuXHRcdFx0XHRcdHZhciBpbnZhbGlkR3JhbnRFcnJvciA9IGVycjtcblxuXHRcdFx0XHRcdC8vIENoZWNrIHRoZSB0b2tlblN0b3JlIHRvIHNlZSBpZiB0b2tlbnMgaGF2ZSBiZWVuIHVwZGF0ZWQgcmVjZW50bHkuIElmIHRoZXkgaGF2ZSwgdGhlbiBhbm90aGVyXG5cdFx0XHRcdFx0Ly8gaW5zdGFuY2Ugb2YgdGhlIHNlc3Npb24gbWF5IGhhdmUgYWxyZWFkeSByZWZyZXNoZWQgdGhlIHVzZXIgdG9rZW5zLCB3aGljaCB3b3VsZCBleHBsYWluIHdoeVxuXHRcdFx0XHRcdC8vIHdlIGNvdWxkbid0IHJlZnJlc2guXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX3Rva2VuU3RvcmUucmVhZEFzeW5jKClcblx0XHRcdFx0XHRcdC5jYXRjaChlID0+IGVycm9ycy51bndyYXBBbmRUaHJvdyhlKSlcblx0XHRcdFx0XHRcdC50aGVuKHN0b3JlVG9rZW5JbmZvID0+IHtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIHRva2VucyB3ZSBnb3QgZnJvbSB0aGUgY2VudHJhbCBzdG9yZSBhcmUgdGhlIHNhbWUgYXMgdGhlIHRva2VucyB3ZSBtYWRlIHRoZSBmYWlsZWQgcmVxdWVzdCB3aXRoXG5cdFx0XHRcdFx0XHRcdC8vIGFscmVhZHksIHRoZW4gd2UgY2FuIGJlIHN1cmUgdGhhdCBubyBvdGhlciBzZXJ2ZXJzIGhhdmUgdmFsaWQgdG9rZW5zIGZvciB0aGlzIHNlcnZlciBlaXRoZXIuXG5cdFx0XHRcdFx0XHRcdC8vIFRodXMsIHRoaXMgdXNlciB0cnVseSBoYXMgYW4gZXhwaXJlZCByZWZyZXNoIHRva2VuLiBTbywgcHJvcGFnYXRlIGFuIFwiRXhwaXJlZCBUb2tlbnNcIiBlcnJvci5cblx0XHRcdFx0XHRcdFx0aWYgKCFzdG9yZVRva2VuSW5mbyB8fCBzdG9yZVRva2VuSW5mby5yZWZyZXNoVG9rZW4gPT09IHRoaXMuX3Rva2VuSW5mby5yZWZyZXNoVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRBdXRoRXJyb3IoaW52YWxpZEdyYW50RXJyb3IucmVzcG9uc2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGFnYXRlIHRoZSBmcmVzaCB0b2tlbnMgdGhhdCB3ZSBmb3VuZCBpbiB0aGUgc2Vzc2lvblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc3RvcmVUb2tlbkluZm87XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEJveCBBUEkgcmV0dXJuZWQgYSBwZXJtYW5lbnQgZXJyb3IgdGhhdCBpcyBub3QgcmV0cnlhYmxlIGFuZCB3ZSBjYW4ndCByZWNvdmVyLlxuXHRcdFx0XHQvLyBXZSBoYXZlIG5vIHVzYWJsZSB0b2tlbnMgZm9yIHRoZSB1c2VyIGFuZCBubyB3YXkgdG8gcmVmcmVzaCB0aGVtIC0gcHJvcGFnYXRlIGEgcGVybWFuZW50IGVycm9yLlxuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4odG9rZW5JbmZvID0+IHtcblx0XHRcdFx0Ly8gU3VjY2VzcyEgV2UgZ290IGJhY2sgYSBUb2tlbkluZm8gb2JqZWN0IGZyb20gdGhlIEFQSS5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHRva2VuIHN0b3JlLCB3ZSdsbCB3cml0ZSBpdCB0aGVyZSBub3cgYmVmb3JlIGZpbmlzaGluZyB1cCB0aGUgcmVxdWVzdC5cblx0XHRcdFx0aWYgKHRoaXMuX3Rva2VuU3RvcmUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fdG9rZW5TdG9yZS53cml0ZUFzeW5jKHRva2VuSW5mbylcblx0XHRcdFx0XHRcdC5jYXRjaChlID0+IGVycm9ycy51bndyYXBBbmRUaHJvdyhlKSlcblx0XHRcdFx0XHRcdC50aGVuKCgpID0+IHRva2VuSW5mbyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBubyB0b2tlbiBzdG9yZSwgU2V0IGFuZCBwcm9wYWdhdGUgdGhlIGFjY2VzcyB0b2tlbiBpbW1lZGlhdGVseVxuXHRcdFx0XHRyZXR1cm4gdG9rZW5JbmZvO1xuXHRcdFx0fSlcblx0XHRcdC50aGVuKHRva2VuSW5mbyA9PiB7XG5cdFx0XHRcdC8vIFNldCBhbmQgcHJvcGFnYXRlIHRoZSBuZXcgYWNjZXNzIHRva2VuXG5cdFx0XHRcdHRoaXMuX3NldFRva2VuSW5mbyh0b2tlbkluZm8pO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5JbmZvLmFjY2Vzc1Rva2VuO1xuXHRcdFx0fSlcblx0XHRcdC5jYXRjaChlcnIgPT4gdGhpcy5oYW5kbGVFeHBpcmVkVG9rZW5zRXJyb3IoZXJyKSlcblx0XHRcdC5maW5hbGx5KCgpID0+IHtcblx0XHRcdFx0Ly8gUmVmcmVzaCBjb21wbGV0ZSwgY2xlYXIgcHJvbWlzZVxuXHRcdFx0XHR0aGlzLl9yZWZyZXNoUHJvbWlzZSA9IG51bGw7XG5cdFx0XHR9KTtcblx0fVxuXG5cdHJldHVybiB0aGlzLl9yZWZyZXNoUHJvbWlzZTtcbn07XG5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWMgSW5zdGFuY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNsaWVudHMgYWNjZXNzIHRva2VuLlxuICpcbiAqIElmIHRva2VucyBkb24ndCB5ZXQgZXhpc3QsIGZpcnN0IGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlbS5cbiAqIElmIHRva2VucyBhcmUgZXhwaXJlZCwgZmlyc3QgYXR0ZW1wdCB0byByZWZyZXNoIHRoZW0uXG4gKlxuICogQHBhcmFtIHtUb2tlblJlcXVlc3RPcHRpb25zfSBbb3B0aW9uc10gLSBTZXRzIG9wdGlvbmFsIGJlaGF2aW9yIGZvciB0aGUgdG9rZW4gZ3JhbnRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBhY2Nlc3MgdG9rZW5cbiAqL1xuUGVyc2lzdGVudFNlc3Npb24ucHJvdG90eXBlLmdldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvLyBJZiBvdXIgdG9rZW5zIGFyZSBub3QgZnJlc2gsIHdlIG5lZWQgdG8gcmVmcmVzaCB0aGVtXG5cdHZhciBleHBpcmF0aW9uQnVmZmVyID0gTWF0aC5tYXgodGhpcy5fY29uZmlnLmV4cGlyZWRCdWZmZXJNUywgdGhpcy5fY29uZmlnLnN0YWxlQnVmZmVyTVMpO1xuXHRpZiAoIXRoaXMuX3Rva2VuTWFuYWdlci5pc0FjY2Vzc1Rva2VuVmFsaWQodGhpcy5fdG9rZW5JbmZvLCBleHBpcmF0aW9uQnVmZmVyKSkge1xuXHRcdHJldHVybiB0aGlzLl9yZWZyZXNoVG9rZW5zKG9wdGlvbnMpO1xuXHR9XG5cblx0Ly8gQ3VycmVudCBhY2Nlc3MgdG9rZW4gaXMgc3RpbGwgdmFsaWQuIFJldHVybiBpdC5cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl90b2tlbkluZm8uYWNjZXNzVG9rZW4pO1xufTtcblxuLyoqXG4gKiBSZXZva2VzIHRoZSBzZXNzaW9uJ3MgdG9rZW5zLiBJZiB0aGUgc2Vzc2lvbiBoYXMgYSByZWZyZXNoIHRva2VuIHdlJ2xsIHVzZSB0aGF0LFxuICogc2luY2UgaXQgaXMgbW9yZSBsaWtlbHkgdG8gYmUgdXAgdG8gZGF0ZS4gT3RoZXJ3aXNlLCB3ZSdsbCByZXZva2UgdGhlIGFjY2Vzc1Rva2VuLlxuICogUmV2b2tpbmcgZWl0aGVyIG9uZSB3aWxsIGRpc2FibGUgdGhlIG90aGVyIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtUb2tlblJlcXVlc3RPcHRpb25zfSBbb3B0aW9uc10gLSBTZXRzIG9wdGlvbmFsIGJlaGF2aW9yIGZvciB0aGUgdG9rZW4gZ3JhbnRcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgcmV2b2tlIHN1Y2NlZWRzXG4gKi9cblBlcnNpc3RlbnRTZXNzaW9uLnByb3RvdHlwZS5yZXZva2VUb2tlbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHJldHVybiB0aGlzLl90b2tlbk1hbmFnZXIucmV2b2tlVG9rZW5zKHRoaXMuX3Rva2VuSW5mby5yZWZyZXNoVG9rZW4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeGNoYW5nZSB0aGUgY2xpZW50IGFjY2VzcyB0b2tlbiBmb3Igb25lIHdpdGggbG93ZXIgc2NvcGVcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBzY29wZXMgVGhlIHNjb3BlKHMpIHJlcXVlc3RlZCBmb3IgdGhlIG5ldyB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IFtyZXNvdXJjZV0gVGhlIGFic29sdXRlIFVSTCBvZiBhbiBBUEkgcmVzb3VyY2UgdG8gc2NvcGUgdGhlIG5ldyB0b2tlbiB0b1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnMudG9rZW5SZXF1ZXN0T3B0aW9uc10gLSBTZXRzIG9wdGlvbmFsIGJlaGF2aW9yIGZvciB0aGUgdG9rZW4gZ3JhbnRcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5QZXJzaXN0ZW50U2Vzc2lvbi5wcm90b3R5cGUuZXhjaGFuZ2VUb2tlbiA9IGZ1bmN0aW9uKHNjb3BlcywgcmVzb3VyY2UsIG9wdGlvbnMpIHtcblxuXHRyZXR1cm4gdGhpcy5nZXRBY2Nlc3NUb2tlbihvcHRpb25zKVxuXHRcdC50aGVuKGFjY2Vzc1Rva2VuID0+IHRoaXMuX3Rva2VuTWFuYWdlci5leGNoYW5nZVRva2VuKGFjY2Vzc1Rva2VuLCBzY29wZXMsIHJlc291cmNlLCBvcHRpb25zKSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhbiBhbiBcIkV4cGlyZWQgVG9rZW5zXCIgRXJyb3IuIElmIG91ciB0b2tlbnMgYXJlIGV4cGlyZWQsIHdlIG5lZWQgdG8gY2xlYXIgdGhlIHRva2VuXG4gKiBzdG9yZSAoaWYgcHJlc2VudCkgYmVmb3JlIGNvbnRpbnVpbmcuXG4gKlxuICogQHBhcmFtIHtFcnJvcnN+RXhwaXJlZFRva2Vuc0Vycm9yfSBlcnIgQW4gXCJleHBpcmVkIHRva2Vuc1wiIGVycm9yIGluY2x1ZGluZyBpbmZvcm1hdGlvblxuICogIGFib3V0IHRoZSByZXF1ZXN0L3Jlc3BvbnNlLlxuICogQHJldHVybnMge1Byb21pc2U8RXJyb3I+fSBQcm9taXNlIHJlc29sdmluZyB0byBhbiBlcnJvci4gIFRoaXMgd2lsbFxuICogIHVzdWFsbHkgYmUgdGhlIG9yaWdpbmFsIHJlc3BvbnNlIGVycm9yLCBidXQgY291bGQgYW4gZXJyb3IgZnJvbSB0cnlpbmcgdG8gYWNjZXNzIHRoZVxuICogIHRva2VuIHN0b3JlIGFzIHdlbGwuXG4gKi9cblBlcnNpc3RlbnRTZXNzaW9uLnByb3RvdHlwZS5oYW5kbGVFeHBpcmVkVG9rZW5zRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblxuXHRpZiAoIXRoaXMuX3Rva2VuU3RvcmUpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVycik7XG5cdH1cblxuXHQvLyBJZiBhIHRva2VuIHN0b3JlIGlzIGF2YWlsYWJsZSwgY2xlYXIgdGhlIHN0b3JlIGFuZCB0aHJvdyBlaXRoZXIgZXJyb3Jcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByb21pc2Uvbm8tcHJvbWlzZS1pbi1jYWxsYmFja1xuXHRyZXR1cm4gdGhpcy5fdG9rZW5TdG9yZS5jbGVhckFzeW5jKClcblx0XHQuY2F0Y2goZSA9PiBlcnJvcnMudW53cmFwQW5kVGhyb3coZSkpXG5cdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0dGhyb3cgZXJyO1xuXHRcdH0pO1xufTtcblxuLyoqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvc2Vzc2lvbnMvcGVyc2lzdGVudC1zZXNzaW9uXG4gKiBAc2VlIHtATGluayBQZXJzaXN0ZW50U2Vzc2lvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBQZXJzaXN0ZW50U2Vzc2lvbjtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiUHJvbWlzZSIsImVycm9ycyIsImh0dHBTdGF0dXNDb2RlcyIsImlzT2JqZWN0VmFsaWRUb2tlbkluZm8iLCJvYmoiLCJCb29sZWFuIiwiYWNjZXNzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJhY2Nlc3NUb2tlblRUTE1TIiwiYWNxdWlyZWRBdE1TIiwiaXNPYmplY3RWYWxpZFRva2VuU3RvcmUiLCJyZWFkIiwid3JpdGUiLCJjbGVhciIsIlBlcnNpc3RlbnRTZXNzaW9uIiwidG9rZW5JbmZvIiwidG9rZW5TdG9yZSIsImNvbmZpZyIsInRva2VuTWFuYWdlciIsIl9jb25maWciLCJfdG9rZW5NYW5hZ2VyIiwiX3JlZnJlc2hQcm9taXNlIiwiX3NldFRva2VuSW5mbyIsIl90b2tlblN0b3JlIiwicHJvbWlzaWZ5QWxsIiwicHJvdG90eXBlIiwiX3Rva2VuSW5mbyIsIl9yZWZyZXNoVG9rZW5zIiwib3B0aW9ucyIsImdldFRva2Vuc1JlZnJlc2hHcmFudCIsImNhdGNoIiwiZXJyIiwic3RhdHVzQ29kZSIsIkJBRF9SRVFVRVNUIiwiaW52YWxpZEdyYW50RXJyb3IiLCJyZWFkQXN5bmMiLCJlIiwidW53cmFwQW5kVGhyb3ciLCJ0aGVuIiwic3RvcmVUb2tlbkluZm8iLCJidWlsZEF1dGhFcnJvciIsInJlc3BvbnNlIiwid3JpdGVBc3luYyIsImhhbmRsZUV4cGlyZWRUb2tlbnNFcnJvciIsImZpbmFsbHkiLCJnZXRBY2Nlc3NUb2tlbiIsImV4cGlyYXRpb25CdWZmZXIiLCJNYXRoIiwibWF4IiwiZXhwaXJlZEJ1ZmZlck1TIiwic3RhbGVCdWZmZXJNUyIsImlzQWNjZXNzVG9rZW5WYWxpZCIsInJlc29sdmUiLCJyZXZva2VUb2tlbnMiLCJleGNoYW5nZVRva2VuIiwic2NvcGVzIiwicmVzb3VyY2UiLCJjbGVhckFzeW5jIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/sessions/persistent-session.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/token-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/token-manager.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Token Manager\n */ \n// ------------------------------------------------------------------------------\n// Typedefs and Callbacks\n// ------------------------------------------------------------------------------\n/**\n * Token request options. Set by the consumer to add/modify the params sent to the\n * request.\n *\n * @typedef {Object} TokenRequestOptions\n * @property {string} [ip] The IP Address of the requesting user. This IP will be reflected in authentication\n *                         notification emails sent to your users on login. Defaults to the IP address of the\n *                         server requesting the tokens.\n */ /**\n * Parameters for creating a token using a Box shared link via token exchange\n * @typedef {Object} SharedLinkParams\n * @property {string} url Shared link URL\n */ /**\n * Parameters for creating an actor token via token exchange\n * @typedef {Object} ActorParams\n * @property {string} id The external identifier for the actor\n * @property {string} name The display name of the actor\n */ /**\n * An object representing all token information for a single Box user.\n *\n * @typedef {Object} TokenInfo\n * @property {string} accessToken    The API access token. Used to authenticate API requests to a certain\n *                                   user and/or application.\n * @property {int} acquiredAtMS      The time that the tokens were acquired.\n * @property {int} accessTokenTTLMS  The TTL of the access token. Can be used with acquiredAtMS to\n *                                   calculate if the current access token has expired.\n * @property {string} [refreshToken] The API refresh token is a Longer-lasting than an access token, and can\n *                                   be used to gain a new access token if the current access token becomes\n *                                   expired. Grants like the 'client credentials' grant don't return a\n *                                   refresh token, and have no refresh capabilities.\n */ /**\n  *\tDetermines whether a JWT auth error can be retried\n  * @param {Error} err The JWT auth error\n  * @returns {boolean} True if the error is retryable\n  */ function isJWTAuthErrorRetryable(err) {\n    if (err.authExpired && err.response.headers.date && (err.response.body.error_description.indexOf(\"exp\") > -1 || err.response.body.error_description.indexOf(\"jti\") > -1)) {\n        return true;\n    } else if (err.statusCode === 429 || err.statusCode >= 500) {\n        return true;\n    }\n    return false;\n}\n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar errors = __webpack_require__(/*! ./util/errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\"), jwt = __webpack_require__(/*! jsonwebtoken */ \"(rsc)/./node_modules/jsonwebtoken/index.js\"), uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/index.js\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), getRetryTimeout = __webpack_require__(/*! ./util/exponential-backoff */ \"(rsc)/./node_modules/box-node-sdk/lib/util/exponential-backoff.js\");\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n/**\n * Collection of grant types that can be used to acquire tokens via OAuth2\n *\n * @readonly\n * @enum {string}\n */ var grantTypes = {\n    AUTHORIZATION_CODE: \"authorization_code\",\n    REFRESH_TOKEN: \"refresh_token\",\n    CLIENT_CREDENTIALS: \"client_credentials\",\n    JWT: \"urn:ietf:params:oauth:grant-type:jwt-bearer\",\n    TOKEN_EXCHANGE: \"urn:ietf:params:oauth:grant-type:token-exchange\"\n};\n/**\n * Collection of paths to interact with Box OAuth2 tokening system\n *\n * @readonly\n * @enum {string}\n */ var tokenPaths = {\n    ROOT: \"/oauth2\",\n    GET: \"/token\",\n    REVOKE: \"/revoke\"\n};\n// Timer used to track elapsed time starting with executing an async request and ending with emitting the response.\nvar asyncRequestTimer;\n// The XFF header label - Used to give the API better information for uploads, rate-limiting, etc.\nconst HEADER_XFF = \"X-Forwarded-For\";\nconst ACCESS_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\";\nconst ACTOR_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:id_token\";\nconst BOX_JWT_AUDIENCE = \"https://api.box.com/oauth2/token\";\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n/**\n * Parse the response body to create a new TokenInfo object.\n *\n * @param {Object} grantResponseBody - (Request lib) response body containing granted token info from API\n * @returns {TokenInfo} A TokenInfo object.\n * @private\n */ function getTokensFromGrantResponse(grantResponseBody) {\n    return {\n        // Set the access token & refresh token (if passed)\n        accessToken: grantResponseBody.access_token,\n        refreshToken: grantResponseBody.refresh_token,\n        // Box API sends back expires_in in seconds, we convert to ms for consistency of keeping all time in ms\n        accessTokenTTLMS: parseInt(grantResponseBody.expires_in, 10) * 1000,\n        acquiredAtMS: Date.now()\n    };\n}\n/**\n * Determines if a given string could represent an authorization code or token.\n *\n * @param {string} codeOrToken The code or token to check.\n * @returns {boolean} True if codeOrToken is valid, false if not.\n * @private\n */ function isValidCodeOrToken(codeOrToken) {\n    return typeof codeOrToken === \"string\" && codeOrToken.length > 0;\n}\n/**\n * Determines if a token grant response is valid\n *\n * @param {string} grantType the type of token grant\n * @param {Object} responseBody the body of the response to check\n * @returns {boolean} True if response body has expected fields, false if not.\n * @private\n */ function isValidTokenResponse(grantType, responseBody) {\n    if (!isValidCodeOrToken(responseBody.access_token)) {\n        return false;\n    }\n    if (typeof responseBody.expires_in !== \"number\") {\n        return false;\n    }\n    // Check the refresh_token for certain types of grants\n    if (grantType === \"authorization_code\" || grantType === \"refresh_token\") {\n        if (!isValidCodeOrToken(responseBody.refresh_token)) {\n            return false;\n        }\n    }\n    return true;\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * Manager for API access abd refresh tokens\n *\n * @param {Config} config The config object\n * @param {APIRequestManager} requestManager The API Request Manager\n * @constructor\n */ function TokenManager(config, requestManager) {\n    this.config = config;\n    this.oauthBaseURL = config.apiRootURL + tokenPaths.ROOT;\n    this.requestManager = requestManager;\n}\nTokenManager.prototype = {\n    /**\n\t * Given a TokenInfo object, returns whether its access token is expired. An access token is considered\n\t * expired once its TTL surpasses the current time outside of the given buffer. This is a public method so\n\t * that other modules may check the validity of their tokens.\n\t *\n\t * @param {TokenInfo} tokenInfo the token info to be written\n\t * @param {int} [bufferMS] An optional buffer we'd like to test against. The greater this buffer, the more aggressively\n\t * we'll call a token invalid.\n\t * @returns {boolean} True if token is valid outside of buffer, otherwise false\n\t */ isAccessTokenValid (tokenInfo, bufferMS) {\n        if (typeof tokenInfo.acquiredAtMS === \"undefined\" || typeof tokenInfo.accessTokenTTLMS === \"undefined\") {\n            return false;\n        }\n        bufferMS = bufferMS || 0;\n        var expireTime = tokenInfo.acquiredAtMS + tokenInfo.accessTokenTTLMS - bufferMS;\n        return expireTime > Date.now();\n    },\n    /**\n\t * Acquires OAuth2 tokens using a grant type (authorization_code, password, refresh_token)\n\t *\n\t * @param {Object} formParams - should contain all params expected by Box OAuth2 token endpoint\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant, null for default behavior\n\t * @returns {Promise<TokenInfo>} Promise resolving to the token info\n\t * @private\n\t */ getTokens (formParams, options) {\n        var params = {\n            method: \"POST\",\n            url: this.oauthBaseURL + tokenPaths.GET,\n            headers: {},\n            form: formParams\n        };\n        options = options || {};\n        // add in app-specific id and secret to auth with Box\n        params.form.client_id = this.config.clientID;\n        params.form.client_secret = this.config.clientSecret;\n        if (options.ip) {\n            params.headers[HEADER_XFF] = options.ip;\n        }\n        return this.requestManager.makeRequest(params).then((response)=>{\n            // Response Error: The API is telling us that we attempted an invalid token grant. This\n            // means that our refresh token or auth code has exipred, so propagate an \"Expired Tokens\"\n            // error.\n            if (response.body && response.body.error && response.body.error === \"invalid_grant\") {\n                var errDescription = response.body.error_description;\n                var message = errDescription ? `Auth Error: ${errDescription}` : undefined;\n                throw errors.buildAuthError(response, message);\n            }\n            // Unexpected Response: If the token request couldn't get a valid response, then we're\n            // out of options. Build an \"Unexpected Response\" error and propagate it out for the\n            // consumer to handle.\n            if (response.statusCode !== httpStatusCodes.OK || response.body instanceof Buffer) {\n                throw errors.buildUnexpectedResponseError(response);\n            }\n            // Check to see if token response is valid in case the API returns us a 200 with a malformed token\n            if (!isValidTokenResponse(formParams.grant_type, response.body)) {\n                throw errors.buildResponseError(response, \"Token format from response invalid\");\n            }\n            // Got valid token response. Parse out the TokenInfo and propagate it back.\n            return getTokensFromGrantResponse(response.body);\n        });\n    },\n    /**\n\t * Acquires token info using an authorization code\n\t *\n\t * @param {string} authorizationCode - authorization code issued by Box\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n\t * @returns {Promise<TokenInfo>} Promise resolving to the token info\n\t */ getTokensAuthorizationCodeGrant (authorizationCode, options) {\n        if (!isValidCodeOrToken(authorizationCode)) {\n            return Promise.reject(new Error(\"Invalid authorization code.\"));\n        }\n        var params = {\n            grant_type: grantTypes.AUTHORIZATION_CODE,\n            code: authorizationCode\n        };\n        return this.getTokens(params, options);\n    },\n    /**\n\t * Acquires token info using the client credentials grant.\n\t *\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n\t * @returns {Promise<TokenInfo>} Promise resolving to the token info\n\t */ getTokensClientCredentialsGrant (options) {\n        var params = {\n            grant_type: grantTypes.CLIENT_CREDENTIALS\n        };\n        return this.getTokens(params, options);\n    },\n    /**\n\t * Refreshes the access and refresh tokens for a given refresh token.\n\t *\n\t * @param {string} refreshToken - A valid OAuth refresh token\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n\t * @returns {Promise<TokenInfo>} Promise resolving to the token info\n\t */ getTokensRefreshGrant (refreshToken, options) {\n        if (!isValidCodeOrToken(refreshToken)) {\n            return Promise.reject(new Error(\"Invalid refresh token.\"));\n        }\n        var params = {\n            grant_type: grantTypes.REFRESH_TOKEN,\n            refresh_token: refreshToken\n        };\n        return this.getTokens(params, options);\n    },\n    /**\n\t * Gets tokens for enterprise administration of app users\n\t * @param {string} type The type of token to create, \"user\" or \"enterprise\"\n\t * @param {string} id The ID of the enterprise to generate a token for\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n\t * @returns {Promise<TokenInfo>} Promise resolving to the token info\n\t */ getTokensJWTGrant (type, id, options) {\n        if (!this.config.appAuth.keyID) {\n            return Promise.reject(new Error(\"Must provide app auth configuration to use JWT Grant\"));\n        }\n        var claims = {\n            exp: Math.floor(Date.now() / 1000) + this.config.appAuth.expirationTime,\n            box_sub_type: type\n        };\n        var jwtOptions = {\n            algorithm: this.config.appAuth.algorithm,\n            audience: BOX_JWT_AUDIENCE,\n            subject: id,\n            issuer: this.config.clientID,\n            jwtid: uuid.v4(),\n            noTimestamp: !this.config.appAuth.verifyTimestamp,\n            keyid: this.config.appAuth.keyID\n        };\n        var keyParams = {\n            key: this.config.appAuth.privateKey,\n            passphrase: this.config.appAuth.passphrase\n        };\n        var assertion;\n        try {\n            assertion = jwt.sign(claims, keyParams, jwtOptions);\n        } catch (jwtErr) {\n            return Promise.reject(jwtErr);\n        }\n        var params = {\n            grant_type: grantTypes.JWT,\n            assertion\n        };\n        // Start the request timer immediately before executing the async request\n        asyncRequestTimer = process.hrtime();\n        return this.getTokens(params, options).catch((err)=>this.retryJWTGrant(claims, jwtOptions, keyParams, params, options, err, 0));\n    },\n    /**\n\t * Attempt a retry if possible and create a new JTI claim. If the request hasn't exceeded it's maximum number of retries,\n\t * re-execute the request (after the retry interval). Otherwise, propagate a new error.\n\t *\n\t * @param {Object} claims - JTI claims object\n\t * @param {Object} [jwtOptions] - JWT options for the signature\n\t * @param {Object} keyParams - Key JWT parameters object that contains the private key and the passphrase\n\t * @param {Object} params - Should contain all params expected by Box OAuth2 token endpoint\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n\t * @param {Error} error - Error from the previous JWT request\n\t * @param {int} numRetries - Number of retries attempted\n\t * @returns {Promise<TokenInfo>} Promise resolving to the token info\n\t */ // eslint-disable-next-line max-params\n    retryJWTGrant (claims, jwtOptions, keyParams, params, options, error, numRetries) {\n        if (numRetries < this.config.numMaxRetries && isJWTAuthErrorRetryable(error)) {\n            var retryTimeout;\n            numRetries += 1;\n            // If the retry strategy is defined, then use it to determine the time (in ms) until the next retry or to\n            // propagate an error to the user.\n            if (this.config.retryStrategy) {\n                // Get the total elapsed time so far since the request was executed\n                var totalElapsedTime = process.hrtime(asyncRequestTimer);\n                var totalElapsedTimeMS = totalElapsedTime[0] * 1000 + totalElapsedTime[1] / 1000000;\n                var retryOptions = {\n                    error,\n                    numRetryAttempts: numRetries,\n                    numMaxRetries: this.config.numMaxRetries,\n                    retryIntervalMS: this.config.retryIntervalMS,\n                    totalElapsedTimeMS\n                };\n                retryTimeout = this.config.retryStrategy(retryOptions);\n                // If the retry strategy doesn't return a number/time in ms, then propagate the response error to the user.\n                // However, if the retry strategy returns its own error, this will be propagated to the user instead.\n                if (typeof retryTimeout !== \"number\") {\n                    if (retryTimeout instanceof Error) {\n                        error = retryTimeout;\n                    }\n                    throw error;\n                }\n            } else if (error.hasOwnProperty(\"response\") && error.response.hasOwnProperty(\"headers\") && error.response.headers.hasOwnProperty(\"retry-after\")) {\n                retryTimeout = error.response.headers[\"retry-after\"] * 1000;\n            } else {\n                retryTimeout = getRetryTimeout(numRetries, this.config.retryIntervalMS);\n            }\n            var time = Math.floor(Date.now() / 1000);\n            if (error.response.headers.date) {\n                time = Math.floor(Date.parse(error.response.headers.date) / 1000);\n            }\n            // Add length of retry timeout to current expiration time to calculate the expiration time for the JTI claim.\n            claims.exp = time + this.config.appAuth.expirationTime + retryTimeout / 1000;\n            jwtOptions.jwtid = uuid.v4();\n            try {\n                params.assertion = jwt.sign(claims, keyParams, jwtOptions);\n            } catch (jwtErr) {\n                throw jwtErr;\n            }\n            return Promise.delay(retryTimeout).then(()=>{\n                // Start the request timer immediately before executing the async request\n                asyncRequestTimer = process.hrtime();\n                return this.getTokens(params, options).catch((err)=>this.retryJWTGrant(claims, jwtOptions, keyParams, params, options, err, numRetries));\n            });\n        } else if (numRetries >= this.config.numMaxRetries) {\n            error.maxRetriesExceeded = true;\n        }\n        throw error;\n    },\n    /**\n\t * Exchange a valid access token for one with a lower scope, or delegated to\n\t * an external user identifier.\n\t *\n\t * @param {string} accessToken - The valid access token to exchange\n\t * @param {string|string[]} scopes - The scope(s) of the new access token\n\t * @param {string} [resource] - The absolute URL of an API resource to restrict the new token to\n\t * @param {Object} [options] - Optional parameters\n\t * @param {TokenRequestOptions} [options.tokenRequestOptions] - Sets optional behavior for the token grant\n\t * @param {ActorParams} [options.actor] - Optional actor parameters for creating annotator tokens\n\t * @param {SharedLinkParams} [options.sharedLink] - Optional shared link parameters for creating tokens using shared links\n\t * @returns {Promise<TokenInfo>} Promise resolving to the new token info\n\t */ exchangeToken (accessToken, scopes, resource, options) {\n        var params = {\n            grant_type: grantTypes.TOKEN_EXCHANGE,\n            subject_token_type: ACCESS_TOKEN_TYPE,\n            subject_token: accessToken,\n            scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \")\n        };\n        if (resource) {\n            params.resource = resource;\n        }\n        if (options && options.sharedLink) {\n            params.box_shared_link = options.sharedLink.url;\n        }\n        if (options && options.actor) {\n            var payload = {\n                iss: this.config.clientID,\n                sub: options.actor.id,\n                aud: BOX_JWT_AUDIENCE,\n                box_sub_type: \"external\",\n                name: options.actor.name\n            };\n            var jwtOptions = {\n                algorithm: \"none\",\n                expiresIn: \"1m\",\n                noTimestamp: true,\n                jwtid: uuid.v4()\n            };\n            var token;\n            try {\n                token = jwt.sign(payload, \"UNUSED\", jwtOptions);\n            } catch (jwtError) {\n                return Promise.reject(jwtError);\n            }\n            params.actor_token = token;\n            params.actor_token_type = ACTOR_TOKEN_TYPE;\n        }\n        return this.getTokens(params, options && options.tokenRequestOptions ? options.tokenRequestOptions : null);\n    },\n    /**\n\t * Revokes a token pair associated with a given access or refresh token.\n\t *\n\t * @param {string} token - A valid access or refresh token to revoke\n\t * @param {TokenRequestOptions} [options] - Sets optional behavior for the token grant\n\t * @returns {Promise} Promise resolving if the revoke succeeds\n\t */ revokeTokens (token, options) {\n        var params = {\n            method: \"POST\",\n            url: this.oauthBaseURL + tokenPaths.REVOKE,\n            form: {\n                token,\n                client_id: this.config.clientID,\n                client_secret: this.config.clientSecret\n            }\n        };\n        if (options && options.ip) {\n            params.headers = {};\n            params.headers[HEADER_XFF] = options.ip;\n        }\n        return this.requestManager.makeRequest(params);\n    }\n};\n/**\n * Provides interactions with Box OAuth2 tokening system.\n *\n * @module box-node-sdk/lib/token-manager\n */ module.exports = TokenManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi90b2tlbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxpRkFBaUY7QUFDakYseUJBQXlCO0FBQ3pCLGlGQUFpRjtBQUVqRjs7Ozs7Ozs7Q0FRQyxHQUVEOzs7O0NBSUMsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FFRDs7OztFQUlFLEdBQ0YsU0FBU0Esd0JBQXdCQyxHQUFHO0lBRW5DLElBQUlBLElBQUlDLFdBQVcsSUFBSUQsSUFBSUUsUUFBUSxDQUFDQyxPQUFPLENBQUNDLElBQUksSUFBS0osQ0FBQUEsSUFBSUUsUUFBUSxDQUFDRyxJQUFJLENBQUNDLGlCQUFpQixDQUFDQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUtQLElBQUlFLFFBQVEsQ0FBQ0csSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ0MsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJO1FBQ3pLLE9BQU87SUFDUixPQUFPLElBQUlQLElBQUlRLFVBQVUsS0FBSyxPQUFPUixJQUFJUSxVQUFVLElBQUksS0FBSztRQUMzRCxPQUFPO0lBQ1I7SUFDQSxPQUFPO0FBQ1I7QUFFQSxpRkFBaUY7QUFDakYsZUFBZTtBQUNmLGlGQUFpRjtBQUNqRixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQyw4RUFDcEJDLE1BQU1ELG1CQUFPQSxDQUFDLG1FQUNkRSxPQUFPRixtQkFBT0EsQ0FBQyxtREFDZkcsa0JBQWtCSCxtQkFBT0EsQ0FBQyxxRUFDMUJJLFVBQVVKLG1CQUFPQSxDQUFDLHlFQUNsQkssa0JBQWtCTCxtQkFBT0EsQ0FBQztBQUUzQixpRkFBaUY7QUFDakYsWUFBWTtBQUNaLGlGQUFpRjtBQUVqRjs7Ozs7Q0FLQyxHQUNELElBQUlNLGFBQWE7SUFDaEJDLG9CQUFvQjtJQUNwQkMsZUFBZTtJQUNmQyxvQkFBb0I7SUFDcEJDLEtBQUs7SUFDTEMsZ0JBQWdCO0FBQ2pCO0FBRUE7Ozs7O0NB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LElBQUlqRCxhQUFhO2dCQUNoQkMsV0FBVztnQkFDWGlELFdBQVc7Z0JBQ1gzQyxhQUFhO2dCQUNiRixPQUFPOUYsS0FBSytGLEVBQUU7WUFDZjtZQUVBLElBQUk2QztZQUNKLElBQUk7Z0JBQ0hBLFFBQVE3SSxJQUFJeUcsSUFBSSxDQUFDOEIsU0FBUyxVQUFVN0M7WUFDckMsRUFBRSxPQUFPb0QsVUFBVTtnQkFDbEIsT0FBTzNJLFFBQVF1RSxNQUFNLENBQUNvRTtZQUN2QjtZQUVBM0YsT0FBTzRGLFdBQVcsR0FBR0Y7WUFDckIxRixPQUFPNkYsZ0JBQWdCLEdBQUc5SDtRQUMzQjtRQUVBLE9BQU8sSUFBSSxDQUFDOEIsU0FBUyxDQUFDRyxRQUFRRCxXQUFXQSxRQUFRK0YsbUJBQW1CLEdBQUcvRixRQUFRK0YsbUJBQW1CLEdBQUc7SUFDdEc7SUFFQTs7Ozs7O0VBTUMsR0FDREMsY0FBYUwsS0FBSyxFQUFFM0YsT0FBTztRQUMxQixJQUFJQyxTQUFTO1lBQ1pDLFFBQVE7WUFDUkMsS0FBSyxJQUFJLENBQUNaLFlBQVksR0FBRzlCLFdBQVdHLE1BQU07WUFDMUN3QyxNQUFNO2dCQUNMdUY7Z0JBQ0F0RixXQUFXLElBQUksQ0FBQ2hCLE1BQU0sQ0FBQ2lCLFFBQVE7Z0JBQy9CQyxlQUFlLElBQUksQ0FBQ2xCLE1BQU0sQ0FBQ21CLFlBQVk7WUFDeEM7UUFDRDtRQUVBLElBQUlSLFdBQVdBLFFBQVFTLEVBQUUsRUFBRTtZQUMxQlIsT0FBTzNELE9BQU8sR0FBRyxDQUFDO1lBQ2xCMkQsT0FBTzNELE9BQU8sQ0FBQ3dCLFdBQVcsR0FBR2tDLFFBQVFTLEVBQUU7UUFDeEM7UUFFQSxPQUFPLElBQUksQ0FBQ25CLGNBQWMsQ0FBQ29CLFdBQVcsQ0FBQ1Q7SUFDeEM7QUFDRDtBQUVBOzs7O0NBSUMsR0FDRGdHLE9BQU9DLE9BQU8sR0FBRzlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi90b2tlbi1tYW5hZ2VyLmpzPzQzMDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRva2VuIE1hbmFnZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVHlwZWRlZnMgYW5kIENhbGxiYWNrc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVG9rZW4gcmVxdWVzdCBvcHRpb25zLiBTZXQgYnkgdGhlIGNvbnN1bWVyIHRvIGFkZC9tb2RpZnkgdGhlIHBhcmFtcyBzZW50IHRvIHRoZVxuICogcmVxdWVzdC5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUb2tlblJlcXVlc3RPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2lwXSBUaGUgSVAgQWRkcmVzcyBvZiB0aGUgcmVxdWVzdGluZyB1c2VyLiBUaGlzIElQIHdpbGwgYmUgcmVmbGVjdGVkIGluIGF1dGhlbnRpY2F0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24gZW1haWxzIHNlbnQgdG8geW91ciB1c2VycyBvbiBsb2dpbi4gRGVmYXVsdHMgdG8gdGhlIElQIGFkZHJlc3Mgb2YgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIgcmVxdWVzdGluZyB0aGUgdG9rZW5zLlxuICovXG5cbi8qKlxuICogUGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSB0b2tlbiB1c2luZyBhIEJveCBzaGFyZWQgbGluayB2aWEgdG9rZW4gZXhjaGFuZ2VcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNoYXJlZExpbmtQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1cmwgU2hhcmVkIGxpbmsgVVJMXG4gKi9cblxuLyoqXG4gKiBQYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhbiBhY3RvciB0b2tlbiB2aWEgdG9rZW4gZXhjaGFuZ2VcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEFjdG9yUGFyYW1zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gaWQgVGhlIGV4dGVybmFsIGlkZW50aWZpZXIgZm9yIHRoZSBhY3RvclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgVGhlIGRpc3BsYXkgbmFtZSBvZiB0aGUgYWN0b3JcbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgYWxsIHRva2VuIGluZm9ybWF0aW9uIGZvciBhIHNpbmdsZSBCb3ggdXNlci5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBUb2tlbkluZm9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhY2Nlc3NUb2tlbiAgICBUaGUgQVBJIGFjY2VzcyB0b2tlbi4gVXNlZCB0byBhdXRoZW50aWNhdGUgQVBJIHJlcXVlc3RzIHRvIGEgY2VydGFpblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIgYW5kL29yIGFwcGxpY2F0aW9uLlxuICogQHByb3BlcnR5IHtpbnR9IGFjcXVpcmVkQXRNUyAgICAgIFRoZSB0aW1lIHRoYXQgdGhlIHRva2VucyB3ZXJlIGFjcXVpcmVkLlxuICogQHByb3BlcnR5IHtpbnR9IGFjY2Vzc1Rva2VuVFRMTVMgIFRoZSBUVEwgb2YgdGhlIGFjY2VzcyB0b2tlbi4gQ2FuIGJlIHVzZWQgd2l0aCBhY3F1aXJlZEF0TVMgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGUgaWYgdGhlIGN1cnJlbnQgYWNjZXNzIHRva2VuIGhhcyBleHBpcmVkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtyZWZyZXNoVG9rZW5dIFRoZSBBUEkgcmVmcmVzaCB0b2tlbiBpcyBhIExvbmdlci1sYXN0aW5nIHRoYW4gYW4gYWNjZXNzIHRva2VuLCBhbmQgY2FuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgdXNlZCB0byBnYWluIGEgbmV3IGFjY2VzcyB0b2tlbiBpZiB0aGUgY3VycmVudCBhY2Nlc3MgdG9rZW4gYmVjb21lc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZWQuIEdyYW50cyBsaWtlIHRoZSAnY2xpZW50IGNyZWRlbnRpYWxzJyBncmFudCBkb24ndCByZXR1cm4gYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2ggdG9rZW4sIGFuZCBoYXZlIG5vIHJlZnJlc2ggY2FwYWJpbGl0aWVzLlxuICovXG5cbi8qKlxuICAqXHREZXRlcm1pbmVzIHdoZXRoZXIgYSBKV1QgYXV0aCBlcnJvciBjYW4gYmUgcmV0cmllZFxuICAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgSldUIGF1dGggZXJyb3JcbiAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgcmV0cnlhYmxlXG4gICovXG5mdW5jdGlvbiBpc0pXVEF1dGhFcnJvclJldHJ5YWJsZShlcnIpIHtcblxuXHRpZiAoZXJyLmF1dGhFeHBpcmVkICYmIGVyci5yZXNwb25zZS5oZWFkZXJzLmRhdGUgJiYgKGVyci5yZXNwb25zZS5ib2R5LmVycm9yX2Rlc2NyaXB0aW9uLmluZGV4T2YoJ2V4cCcpID4gLTEgfHwgZXJyLnJlc3BvbnNlLmJvZHkuZXJyb3JfZGVzY3JpcHRpb24uaW5kZXhPZignanRpJykgPiAtMSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBlbHNlIGlmIChlcnIuc3RhdHVzQ29kZSA9PT0gNDI5IHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vdXRpbC9lcnJvcnMnKSxcblx0and0ID0gcmVxdWlyZSgnanNvbndlYnRva2VuJyksXG5cdHV1aWQgPSByZXF1aXJlKCd1dWlkJyksXG5cdGh0dHBTdGF0dXNDb2RlcyA9IHJlcXVpcmUoJ2h0dHAtc3RhdHVzJyksXG5cdFByb21pc2UgPSByZXF1aXJlKCdibHVlYmlyZCcpLFxuXHRnZXRSZXRyeVRpbWVvdXQgPSByZXF1aXJlKCcuL3V0aWwvZXhwb25lbnRpYWwtYmFja29mZicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENvbnN0YW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBncmFudCB0eXBlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGFjcXVpcmUgdG9rZW5zIHZpYSBPQXV0aDJcbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciBncmFudFR5cGVzID0ge1xuXHRBVVRIT1JJWkFUSU9OX0NPREU6ICdhdXRob3JpemF0aW9uX2NvZGUnLFxuXHRSRUZSRVNIX1RPS0VOOiAncmVmcmVzaF90b2tlbicsXG5cdENMSUVOVF9DUkVERU5USUFMUzogJ2NsaWVudF9jcmVkZW50aWFscycsXG5cdEpXVDogJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOmp3dC1iZWFyZXInLFxuXHRUT0tFTl9FWENIQU5HRTogJ3VybjppZXRmOnBhcmFtczpvYXV0aDpncmFudC10eXBlOnRva2VuLWV4Y2hhbmdlJ1xufTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIHBhdGhzIHRvIGludGVyYWN0IHdpdGggQm94IE9BdXRoMiB0b2tlbmluZyBzeXN0ZW1cbiAqXG4gKiBAcmVhZG9ubHlcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbnZhciB0b2tlblBhdGhzID0ge1xuXHRST09UOiAnL29hdXRoMicsXG5cdEdFVDogJy90b2tlbicsXG5cdFJFVk9LRTogJy9yZXZva2UnXG59O1xuXG4vLyBUaW1lciB1c2VkIHRvIHRyYWNrIGVsYXBzZWQgdGltZSBzdGFydGluZyB3aXRoIGV4ZWN1dGluZyBhbiBhc3luYyByZXF1ZXN0IGFuZCBlbmRpbmcgd2l0aCBlbWl0dGluZyB0aGUgcmVzcG9uc2UuXG52YXIgYXN5bmNSZXF1ZXN0VGltZXI7XG5cbi8vIFRoZSBYRkYgaGVhZGVyIGxhYmVsIC0gVXNlZCB0byBnaXZlIHRoZSBBUEkgYmV0dGVyIGluZm9ybWF0aW9uIGZvciB1cGxvYWRzLCByYXRlLWxpbWl0aW5nLCBldGMuXG5jb25zdCBIRUFERVJfWEZGID0gJ1gtRm9yd2FyZGVkLUZvcic7XG5jb25zdCBBQ0NFU1NfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTphY2Nlc3NfdG9rZW4nO1xuY29uc3QgQUNUT1JfVE9LRU5fVFlQRSA9ICd1cm46aWV0ZjpwYXJhbXM6b2F1dGg6dG9rZW4tdHlwZTppZF90b2tlbic7XG5jb25zdCBCT1hfSldUX0FVRElFTkNFID0gJ2h0dHBzOi8vYXBpLmJveC5jb20vb2F1dGgyL3Rva2VuJztcblxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFByaXZhdGVcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFBhcnNlIHRoZSByZXNwb25zZSBib2R5IHRvIGNyZWF0ZSBhIG5ldyBUb2tlbkluZm8gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBncmFudFJlc3BvbnNlQm9keSAtIChSZXF1ZXN0IGxpYikgcmVzcG9uc2UgYm9keSBjb250YWluaW5nIGdyYW50ZWQgdG9rZW4gaW5mbyBmcm9tIEFQSVxuICogQHJldHVybnMge1Rva2VuSW5mb30gQSBUb2tlbkluZm8gb2JqZWN0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VG9rZW5zRnJvbUdyYW50UmVzcG9uc2UoZ3JhbnRSZXNwb25zZUJvZHkpIHtcblx0cmV0dXJuIHtcblx0XHQvLyBTZXQgdGhlIGFjY2VzcyB0b2tlbiAmIHJlZnJlc2ggdG9rZW4gKGlmIHBhc3NlZClcblx0XHRhY2Nlc3NUb2tlbjogZ3JhbnRSZXNwb25zZUJvZHkuYWNjZXNzX3Rva2VuLFxuXHRcdHJlZnJlc2hUb2tlbjogZ3JhbnRSZXNwb25zZUJvZHkucmVmcmVzaF90b2tlbixcblx0XHQvLyBCb3ggQVBJIHNlbmRzIGJhY2sgZXhwaXJlc19pbiBpbiBzZWNvbmRzLCB3ZSBjb252ZXJ0IHRvIG1zIGZvciBjb25zaXN0ZW5jeSBvZiBrZWVwaW5nIGFsbCB0aW1lIGluIG1zXG5cdFx0YWNjZXNzVG9rZW5UVExNUzogcGFyc2VJbnQoZ3JhbnRSZXNwb25zZUJvZHkuZXhwaXJlc19pbiwgMTApICogMTAwMCxcblx0XHRhY3F1aXJlZEF0TVM6IERhdGUubm93KClcblx0fTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gc3RyaW5nIGNvdWxkIHJlcHJlc2VudCBhbiBhdXRob3JpemF0aW9uIGNvZGUgb3IgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVPclRva2VuIFRoZSBjb2RlIG9yIHRva2VuIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgY29kZU9yVG9rZW4gaXMgdmFsaWQsIGZhbHNlIGlmIG5vdC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb2RlT3JUb2tlbihjb2RlT3JUb2tlbikge1xuXHRyZXR1cm4gKHR5cGVvZiBjb2RlT3JUb2tlbiA9PT0gJ3N0cmluZycgJiYgY29kZU9yVG9rZW4ubGVuZ3RoID4gMCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHRva2VuIGdyYW50IHJlc3BvbnNlIGlzIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGdyYW50VHlwZSB0aGUgdHlwZSBvZiB0b2tlbiBncmFudFxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlQm9keSB0aGUgYm9keSBvZiB0aGUgcmVzcG9uc2UgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHJlc3BvbnNlIGJvZHkgaGFzIGV4cGVjdGVkIGZpZWxkcywgZmFsc2UgaWYgbm90LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFRva2VuUmVzcG9uc2UoZ3JhbnRUeXBlLCByZXNwb25zZUJvZHkpIHtcblx0aWYgKCFpc1ZhbGlkQ29kZU9yVG9rZW4ocmVzcG9uc2VCb2R5LmFjY2Vzc190b2tlbikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiByZXNwb25zZUJvZHkuZXhwaXJlc19pbiAhPT0gJ251bWJlcicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0Ly8gQ2hlY2sgdGhlIHJlZnJlc2hfdG9rZW4gZm9yIGNlcnRhaW4gdHlwZXMgb2YgZ3JhbnRzXG5cdGlmIChncmFudFR5cGUgPT09ICdhdXRob3JpemF0aW9uX2NvZGUnIHx8IGdyYW50VHlwZSA9PT0gJ3JlZnJlc2hfdG9rZW4nKSB7XG5cdFx0aWYgKCFpc1ZhbGlkQ29kZU9yVG9rZW4ocmVzcG9uc2VCb2R5LnJlZnJlc2hfdG9rZW4pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogTWFuYWdlciBmb3IgQVBJIGFjY2VzcyBhYmQgcmVmcmVzaCB0b2tlbnNcbiAqXG4gKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0XG4gKiBAcGFyYW0ge0FQSVJlcXVlc3RNYW5hZ2VyfSByZXF1ZXN0TWFuYWdlciBUaGUgQVBJIFJlcXVlc3QgTWFuYWdlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRva2VuTWFuYWdlcihjb25maWcsIHJlcXVlc3RNYW5hZ2VyKSB7XG5cblx0dGhpcy5jb25maWcgPSBjb25maWc7XG5cdHRoaXMub2F1dGhCYXNlVVJMID0gY29uZmlnLmFwaVJvb3RVUkwgKyB0b2tlblBhdGhzLlJPT1Q7XG5cdHRoaXMucmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbn1cblxuVG9rZW5NYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuXHQvKipcblx0ICogR2l2ZW4gYSBUb2tlbkluZm8gb2JqZWN0LCByZXR1cm5zIHdoZXRoZXIgaXRzIGFjY2VzcyB0b2tlbiBpcyBleHBpcmVkLiBBbiBhY2Nlc3MgdG9rZW4gaXMgY29uc2lkZXJlZFxuXHQgKiBleHBpcmVkIG9uY2UgaXRzIFRUTCBzdXJwYXNzZXMgdGhlIGN1cnJlbnQgdGltZSBvdXRzaWRlIG9mIHRoZSBnaXZlbiBidWZmZXIuIFRoaXMgaXMgYSBwdWJsaWMgbWV0aG9kIHNvXG5cdCAqIHRoYXQgb3RoZXIgbW9kdWxlcyBtYXkgY2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZWlyIHRva2Vucy5cblx0ICpcblx0ICogQHBhcmFtIHtUb2tlbkluZm99IHRva2VuSW5mbyB0aGUgdG9rZW4gaW5mbyB0byBiZSB3cml0dGVuXG5cdCAqIEBwYXJhbSB7aW50fSBbYnVmZmVyTVNdIEFuIG9wdGlvbmFsIGJ1ZmZlciB3ZSdkIGxpa2UgdG8gdGVzdCBhZ2FpbnN0LiBUaGUgZ3JlYXRlciB0aGlzIGJ1ZmZlciwgdGhlIG1vcmUgYWdncmVzc2l2ZWx5XG5cdCAqIHdlJ2xsIGNhbGwgYSB0b2tlbiBpbnZhbGlkLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0b2tlbiBpcyB2YWxpZCBvdXRzaWRlIG9mIGJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG5cdCAqL1xuXHRpc0FjY2Vzc1Rva2VuVmFsaWQodG9rZW5JbmZvLCBidWZmZXJNUykge1xuXHRcdGlmICh0eXBlb2YgdG9rZW5JbmZvLmFjcXVpcmVkQXRNUyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHRva2VuSW5mby5hY2Nlc3NUb2tlblRUTE1TID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRidWZmZXJNUyA9IGJ1ZmZlck1TIHx8IDA7XG5cdFx0dmFyIGV4cGlyZVRpbWUgPSB0b2tlbkluZm8uYWNxdWlyZWRBdE1TICsgdG9rZW5JbmZvLmFjY2Vzc1Rva2VuVFRMTVMgLSBidWZmZXJNUztcblx0XHRyZXR1cm4gKGV4cGlyZVRpbWUgPiBEYXRlLm5vdygpKTtcblx0fSxcblxuXHQvKipcblx0ICogQWNxdWlyZXMgT0F1dGgyIHRva2VucyB1c2luZyBhIGdyYW50IHR5cGUgKGF1dGhvcml6YXRpb25fY29kZSwgcGFzc3dvcmQsIHJlZnJlc2hfdG9rZW4pXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtUGFyYW1zIC0gc2hvdWxkIGNvbnRhaW4gYWxsIHBhcmFtcyBleHBlY3RlZCBieSBCb3ggT0F1dGgyIHRva2VuIGVuZHBvaW50XG5cdCAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50LCBudWxsIGZvciBkZWZhdWx0IGJlaGF2aW9yXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZvXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRnZXRUb2tlbnMoZm9ybVBhcmFtcywgb3B0aW9ucykge1xuXHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRtZXRob2Q6ICdQT1NUJyxcblx0XHRcdHVybDogdGhpcy5vYXV0aEJhc2VVUkwgKyB0b2tlblBhdGhzLkdFVCxcblx0XHRcdGhlYWRlcnM6IHt9LFxuXHRcdFx0Zm9ybTogZm9ybVBhcmFtc1xuXHRcdH07XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBhZGQgaW4gYXBwLXNwZWNpZmljIGlkIGFuZCBzZWNyZXQgdG8gYXV0aCB3aXRoIEJveFxuXHRcdHBhcmFtcy5mb3JtLmNsaWVudF9pZCA9IHRoaXMuY29uZmlnLmNsaWVudElEO1xuXHRcdHBhcmFtcy5mb3JtLmNsaWVudF9zZWNyZXQgPSB0aGlzLmNvbmZpZy5jbGllbnRTZWNyZXQ7XG5cblx0XHRpZiAob3B0aW9ucy5pcCkge1xuXHRcdFx0cGFyYW1zLmhlYWRlcnNbSEVBREVSX1hGRl0gPSBvcHRpb25zLmlwO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnJlcXVlc3RNYW5hZ2VyLm1ha2VSZXF1ZXN0KHBhcmFtcylcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0XHQvLyBSZXNwb25zZSBFcnJvcjogVGhlIEFQSSBpcyB0ZWxsaW5nIHVzIHRoYXQgd2UgYXR0ZW1wdGVkIGFuIGludmFsaWQgdG9rZW4gZ3JhbnQuIFRoaXNcblx0XHRcdFx0Ly8gbWVhbnMgdGhhdCBvdXIgcmVmcmVzaCB0b2tlbiBvciBhdXRoIGNvZGUgaGFzIGV4aXByZWQsIHNvIHByb3BhZ2F0ZSBhbiBcIkV4cGlyZWQgVG9rZW5zXCJcblx0XHRcdFx0Ly8gZXJyb3IuXG5cdFx0XHRcdGlmIChyZXNwb25zZS5ib2R5ICYmIHJlc3BvbnNlLmJvZHkuZXJyb3IgJiYgcmVzcG9uc2UuYm9keS5lcnJvciA9PT0gJ2ludmFsaWRfZ3JhbnQnKSB7XG5cdFx0XHRcdFx0dmFyIGVyckRlc2NyaXB0aW9uID0gcmVzcG9uc2UuYm9keS5lcnJvcl9kZXNjcmlwdGlvbjtcblx0XHRcdFx0XHR2YXIgbWVzc2FnZSA9IGVyckRlc2NyaXB0aW9uID8gYEF1dGggRXJyb3I6ICR7ZXJyRGVzY3JpcHRpb259YCA6IHVuZGVmaW5lZDtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRBdXRoRXJyb3IocmVzcG9uc2UsIG1lc3NhZ2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVW5leHBlY3RlZCBSZXNwb25zZTogSWYgdGhlIHRva2VuIHJlcXVlc3QgY291bGRuJ3QgZ2V0IGEgdmFsaWQgcmVzcG9uc2UsIHRoZW4gd2UncmVcblx0XHRcdFx0Ly8gb3V0IG9mIG9wdGlvbnMuIEJ1aWxkIGFuIFwiVW5leHBlY3RlZCBSZXNwb25zZVwiIGVycm9yIGFuZCBwcm9wYWdhdGUgaXQgb3V0IGZvciB0aGVcblx0XHRcdFx0Ly8gY29uc3VtZXIgdG8gaGFuZGxlLlxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gaHR0cFN0YXR1c0NvZGVzLk9LIHx8IHJlc3BvbnNlLmJvZHkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvcihyZXNwb25zZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgdG9rZW4gcmVzcG9uc2UgaXMgdmFsaWQgaW4gY2FzZSB0aGUgQVBJIHJldHVybnMgdXMgYSAyMDAgd2l0aCBhIG1hbGZvcm1lZCB0b2tlblxuXHRcdFx0XHRpZiAoIWlzVmFsaWRUb2tlblJlc3BvbnNlKGZvcm1QYXJhbXMuZ3JhbnRfdHlwZSwgcmVzcG9uc2UuYm9keSkpIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJvcnMuYnVpbGRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCAnVG9rZW4gZm9ybWF0IGZyb20gcmVzcG9uc2UgaW52YWxpZCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR290IHZhbGlkIHRva2VuIHJlc3BvbnNlLiBQYXJzZSBvdXQgdGhlIFRva2VuSW5mbyBhbmQgcHJvcGFnYXRlIGl0IGJhY2suXG5cdFx0XHRcdHJldHVybiBnZXRUb2tlbnNGcm9tR3JhbnRSZXNwb25zZShyZXNwb25zZS5ib2R5KTtcblx0XHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBY3F1aXJlcyB0b2tlbiBpbmZvIHVzaW5nIGFuIGF1dGhvcml6YXRpb24gY29kZVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXV0aG9yaXphdGlvbkNvZGUgLSBhdXRob3JpemF0aW9uIGNvZGUgaXNzdWVkIGJ5IEJveFxuXHQgKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXSAtIFNldHMgb3B0aW9uYWwgYmVoYXZpb3IgZm9yIHRoZSB0b2tlbiBncmFudFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkluZm8+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgdG9rZW4gaW5mb1xuXHQgKi9cblx0Z2V0VG9rZW5zQXV0aG9yaXphdGlvbkNvZGVHcmFudChhdXRob3JpemF0aW9uQ29kZSwgb3B0aW9ucykge1xuXHRcdGlmICghaXNWYWxpZENvZGVPclRva2VuKGF1dGhvcml6YXRpb25Db2RlKSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBhdXRob3JpemF0aW9uIGNvZGUuJykpO1xuXHRcdH1cblxuXHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRncmFudF90eXBlOiBncmFudFR5cGVzLkFVVEhPUklaQVRJT05fQ09ERSxcblx0XHRcdGNvZGU6IGF1dGhvcml6YXRpb25Db2RlXG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLmdldFRva2VucyhwYXJhbXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBY3F1aXJlcyB0b2tlbiBpbmZvIHVzaW5nIHRoZSBjbGllbnQgY3JlZGVudGlhbHMgZ3JhbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZvXG5cdCAqL1xuXHRnZXRUb2tlbnNDbGllbnRDcmVkZW50aWFsc0dyYW50KG9wdGlvbnMpIHtcblxuXHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRncmFudF90eXBlOiBncmFudFR5cGVzLkNMSUVOVF9DUkVERU5USUFMU1xuXHRcdH07XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW5zKHBhcmFtcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZnJlc2hlcyB0aGUgYWNjZXNzIGFuZCByZWZyZXNoIHRva2VucyBmb3IgYSBnaXZlbiByZWZyZXNoIHRva2VuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcmVmcmVzaFRva2VuIC0gQSB2YWxpZCBPQXV0aCByZWZyZXNoIHRva2VuXG5cdCAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZvXG5cdCAqL1xuXHRnZXRUb2tlbnNSZWZyZXNoR3JhbnQocmVmcmVzaFRva2VuLCBvcHRpb25zKSB7XG5cdFx0aWYgKCFpc1ZhbGlkQ29kZU9yVG9rZW4ocmVmcmVzaFRva2VuKSkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCByZWZyZXNoIHRva2VuLicpKTtcblx0XHR9XG5cblx0XHR2YXIgcGFyYW1zID0ge1xuXHRcdFx0Z3JhbnRfdHlwZTogZ3JhbnRUeXBlcy5SRUZSRVNIX1RPS0VOLFxuXHRcdFx0cmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuXG5cdFx0fTtcblxuXHRcdHJldHVybiB0aGlzLmdldFRva2VucyhwYXJhbXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXRzIHRva2VucyBmb3IgZW50ZXJwcmlzZSBhZG1pbmlzdHJhdGlvbiBvZiBhcHAgdXNlcnNcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgVGhlIHR5cGUgb2YgdG9rZW4gdG8gY3JlYXRlLCBcInVzZXJcIiBvciBcImVudGVycHJpc2VcIlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSBlbnRlcnByaXNlIHRvIGdlbmVyYXRlIGEgdG9rZW4gZm9yXG5cdCAqIEBwYXJhbSB7VG9rZW5SZXF1ZXN0T3B0aW9uc30gW29wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPFRva2VuSW5mbz59IFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0b2tlbiBpbmZvXG5cdCAqL1xuXHRnZXRUb2tlbnNKV1RHcmFudCh0eXBlLCBpZCwgb3B0aW9ucykge1xuXHRcdGlmICghdGhpcy5jb25maWcuYXBwQXV0aC5rZXlJRCkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFwcCBhdXRoIGNvbmZpZ3VyYXRpb24gdG8gdXNlIEpXVCBHcmFudCcpKTtcblx0XHR9XG5cblx0XHR2YXIgY2xhaW1zID0ge1xuXHRcdFx0ZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIHRoaXMuY29uZmlnLmFwcEF1dGguZXhwaXJhdGlvblRpbWUsXG5cdFx0XHRib3hfc3ViX3R5cGU6IHR5cGVcblx0XHR9O1xuXHRcdHZhciBqd3RPcHRpb25zID0ge1xuXHRcdFx0YWxnb3JpdGhtOiB0aGlzLmNvbmZpZy5hcHBBdXRoLmFsZ29yaXRobSxcblx0XHRcdGF1ZGllbmNlOiBCT1hfSldUX0FVRElFTkNFLFxuXHRcdFx0c3ViamVjdDogaWQsXG5cdFx0XHRpc3N1ZXI6IHRoaXMuY29uZmlnLmNsaWVudElELFxuXHRcdFx0and0aWQ6IHV1aWQudjQoKSxcblx0XHRcdG5vVGltZXN0YW1wOiAhdGhpcy5jb25maWcuYXBwQXV0aC52ZXJpZnlUaW1lc3RhbXAsXG5cdFx0XHRrZXlpZDogdGhpcy5jb25maWcuYXBwQXV0aC5rZXlJRFxuXHRcdH07XG5cdFx0dmFyIGtleVBhcmFtcyA9IHtcblx0XHRcdGtleTogdGhpcy5jb25maWcuYXBwQXV0aC5wcml2YXRlS2V5LFxuXHRcdFx0cGFzc3BocmFzZTogdGhpcy5jb25maWcuYXBwQXV0aC5wYXNzcGhyYXNlXG5cdFx0fTtcblxuXHRcdHZhciBhc3NlcnRpb247XG5cdFx0dHJ5IHtcblx0XHRcdGFzc2VydGlvbiA9IGp3dC5zaWduKGNsYWltcywga2V5UGFyYW1zLCBqd3RPcHRpb25zKTtcblx0XHR9IGNhdGNoIChqd3RFcnIpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChqd3RFcnIpO1xuXHRcdH1cblxuXHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRncmFudF90eXBlOiBncmFudFR5cGVzLkpXVCxcblx0XHRcdGFzc2VydGlvblxuXHRcdH07XG5cdFx0Ly8gU3RhcnQgdGhlIHJlcXVlc3QgdGltZXIgaW1tZWRpYXRlbHkgYmVmb3JlIGV4ZWN1dGluZyB0aGUgYXN5bmMgcmVxdWVzdFxuXHRcdGFzeW5jUmVxdWVzdFRpbWVyID0gcHJvY2Vzcy5ocnRpbWUoKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRUb2tlbnMocGFyYW1zLCBvcHRpb25zKVxuXHRcdFx0LmNhdGNoKGVyciA9PiB0aGlzLnJldHJ5SldUR3JhbnQoY2xhaW1zLCBqd3RPcHRpb25zLCBrZXlQYXJhbXMsIHBhcmFtcywgb3B0aW9ucywgZXJyLCAwKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEF0dGVtcHQgYSByZXRyeSBpZiBwb3NzaWJsZSBhbmQgY3JlYXRlIGEgbmV3IEpUSSBjbGFpbS4gSWYgdGhlIHJlcXVlc3QgaGFzbid0IGV4Y2VlZGVkIGl0J3MgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcyxcblx0ICogcmUtZXhlY3V0ZSB0aGUgcmVxdWVzdCAoYWZ0ZXIgdGhlIHJldHJ5IGludGVydmFsKS4gT3RoZXJ3aXNlLCBwcm9wYWdhdGUgYSBuZXcgZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjbGFpbXMgLSBKVEkgY2xhaW1zIG9iamVjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2p3dE9wdGlvbnNdIC0gSldUIG9wdGlvbnMgZm9yIHRoZSBzaWduYXR1cmVcblx0ICogQHBhcmFtIHtPYmplY3R9IGtleVBhcmFtcyAtIEtleSBKV1QgcGFyYW1ldGVycyBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJpdmF0ZSBrZXkgYW5kIHRoZSBwYXNzcGhyYXNlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBTaG91bGQgY29udGFpbiBhbGwgcGFyYW1zIGV4cGVjdGVkIGJ5IEJveCBPQXV0aDIgdG9rZW4gZW5kcG9pbnRcblx0ICogQHBhcmFtIHtUb2tlblJlcXVlc3RPcHRpb25zfSBbb3B0aW9uc10gLSBTZXRzIG9wdGlvbmFsIGJlaGF2aW9yIGZvciB0aGUgdG9rZW4gZ3JhbnRcblx0ICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBFcnJvciBmcm9tIHRoZSBwcmV2aW91cyBKV1QgcmVxdWVzdFxuXHQgKiBAcGFyYW0ge2ludH0gbnVtUmV0cmllcyAtIE51bWJlciBvZiByZXRyaWVzIGF0dGVtcHRlZFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxUb2tlbkluZm8+fSBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgdG9rZW4gaW5mb1xuXHQgKi9cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcblx0cmV0cnlKV1RHcmFudChjbGFpbXMsIGp3dE9wdGlvbnMsIGtleVBhcmFtcywgcGFyYW1zLCBvcHRpb25zLCBlcnJvciwgbnVtUmV0cmllcykge1xuXHRcdGlmIChudW1SZXRyaWVzIDwgdGhpcy5jb25maWcubnVtTWF4UmV0cmllcyAmJiBpc0pXVEF1dGhFcnJvclJldHJ5YWJsZShlcnJvcikpIHtcblx0XHRcdHZhciByZXRyeVRpbWVvdXQ7XG5cdFx0XHRudW1SZXRyaWVzICs9IDE7XG5cdFx0XHQvLyBJZiB0aGUgcmV0cnkgc3RyYXRlZ3kgaXMgZGVmaW5lZCwgdGhlbiB1c2UgaXQgdG8gZGV0ZXJtaW5lIHRoZSB0aW1lIChpbiBtcykgdW50aWwgdGhlIG5leHQgcmV0cnkgb3IgdG9cblx0XHRcdC8vIHByb3BhZ2F0ZSBhbiBlcnJvciB0byB0aGUgdXNlci5cblx0XHRcdGlmICh0aGlzLmNvbmZpZy5yZXRyeVN0cmF0ZWd5KSB7XG5cdFx0XHRcdC8vIEdldCB0aGUgdG90YWwgZWxhcHNlZCB0aW1lIHNvIGZhciBzaW5jZSB0aGUgcmVxdWVzdCB3YXMgZXhlY3V0ZWRcblx0XHRcdFx0dmFyIHRvdGFsRWxhcHNlZFRpbWUgPSBwcm9jZXNzLmhydGltZShhc3luY1JlcXVlc3RUaW1lcik7XG5cdFx0XHRcdHZhciB0b3RhbEVsYXBzZWRUaW1lTVMgPSAodG90YWxFbGFwc2VkVGltZVswXSAqIDEwMDApICsgKHRvdGFsRWxhcHNlZFRpbWVbMV0gLyAxMDAwMDAwKTtcblx0XHRcdFx0dmFyIHJldHJ5T3B0aW9ucyA9IHtcblx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRudW1SZXRyeUF0dGVtcHRzOiBudW1SZXRyaWVzLFxuXHRcdFx0XHRcdG51bU1heFJldHJpZXM6IHRoaXMuY29uZmlnLm51bU1heFJldHJpZXMsXG5cdFx0XHRcdFx0cmV0cnlJbnRlcnZhbE1TOiB0aGlzLmNvbmZpZy5yZXRyeUludGVydmFsTVMsXG5cdFx0XHRcdFx0dG90YWxFbGFwc2VkVGltZU1TXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0cnlUaW1lb3V0ID0gdGhpcy5jb25maWcucmV0cnlTdHJhdGVneShyZXRyeU9wdGlvbnMpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSByZXRyeSBzdHJhdGVneSBkb2Vzbid0IHJldHVybiBhIG51bWJlci90aW1lIGluIG1zLCB0aGVuIHByb3BhZ2F0ZSB0aGUgcmVzcG9uc2UgZXJyb3IgdG8gdGhlIHVzZXIuXG5cdFx0XHRcdC8vIEhvd2V2ZXIsIGlmIHRoZSByZXRyeSBzdHJhdGVneSByZXR1cm5zIGl0cyBvd24gZXJyb3IsIHRoaXMgd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHRoZSB1c2VyIGluc3RlYWQuXG5cdFx0XHRcdGlmICh0eXBlb2YgcmV0cnlUaW1lb3V0ICE9PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdGlmIChyZXRyeVRpbWVvdXQgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRcdFx0ZXJyb3IgPSByZXRyeVRpbWVvdXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGVycm9yLmhhc093blByb3BlcnR5KCdyZXNwb25zZScpICYmIGVycm9yLnJlc3BvbnNlLmhhc093blByb3BlcnR5KCdoZWFkZXJzJykgJiYgZXJyb3IucmVzcG9uc2UuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eSgncmV0cnktYWZ0ZXInKSkge1xuXHRcdFx0XHRyZXRyeVRpbWVvdXQgPSBlcnJvci5yZXNwb25zZS5oZWFkZXJzWydyZXRyeS1hZnRlciddICogMTAwMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHJ5VGltZW91dCA9IGdldFJldHJ5VGltZW91dChudW1SZXRyaWVzLCB0aGlzLmNvbmZpZy5yZXRyeUludGVydmFsTVMpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXHRcdFx0aWYgKGVycm9yLnJlc3BvbnNlLmhlYWRlcnMuZGF0ZSkge1xuXHRcdFx0XHR0aW1lID0gTWF0aC5mbG9vcihEYXRlLnBhcnNlKGVycm9yLnJlc3BvbnNlLmhlYWRlcnMuZGF0ZSkgLyAxMDAwKTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBsZW5ndGggb2YgcmV0cnkgdGltZW91dCB0byBjdXJyZW50IGV4cGlyYXRpb24gdGltZSB0byBjYWxjdWxhdGUgdGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIEpUSSBjbGFpbS5cblx0XHRcdGNsYWltcy5leHAgPSB0aW1lICsgdGhpcy5jb25maWcuYXBwQXV0aC5leHBpcmF0aW9uVGltZSArIChyZXRyeVRpbWVvdXQgLyAxMDAwKTtcblx0XHRcdGp3dE9wdGlvbnMuand0aWQgPSB1dWlkLnY0KCk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHBhcmFtcy5hc3NlcnRpb24gPSBqd3Quc2lnbihjbGFpbXMsIGtleVBhcmFtcywgand0T3B0aW9ucyk7XG5cdFx0XHR9IGNhdGNoIChqd3RFcnIpIHtcblx0XHRcdFx0dGhyb3cgand0RXJyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5kZWxheShyZXRyeVRpbWVvdXQpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQvLyBTdGFydCB0aGUgcmVxdWVzdCB0aW1lciBpbW1lZGlhdGVseSBiZWZvcmUgZXhlY3V0aW5nIHRoZSBhc3luYyByZXF1ZXN0XG5cdFx0XHRcdGFzeW5jUmVxdWVzdFRpbWVyID0gcHJvY2Vzcy5ocnRpbWUoKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VG9rZW5zKHBhcmFtcywgb3B0aW9ucylcblx0XHRcdFx0XHQuY2F0Y2goZXJyID0+IHRoaXMucmV0cnlKV1RHcmFudChjbGFpbXMsIGp3dE9wdGlvbnMsIGtleVBhcmFtcywgcGFyYW1zLCBvcHRpb25zLCBlcnIsIG51bVJldHJpZXMpKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAobnVtUmV0cmllcyA+PSB0aGlzLmNvbmZpZy5udW1NYXhSZXRyaWVzKSB7XG5cdFx0XHRlcnJvci5tYXhSZXRyaWVzRXhjZWVkZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFeGNoYW5nZSBhIHZhbGlkIGFjY2VzcyB0b2tlbiBmb3Igb25lIHdpdGggYSBsb3dlciBzY29wZSwgb3IgZGVsZWdhdGVkIHRvXG5cdCAqIGFuIGV4dGVybmFsIHVzZXIgaWRlbnRpZmllci5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGFjY2Vzc1Rva2VuIC0gVGhlIHZhbGlkIGFjY2VzcyB0b2tlbiB0byBleGNoYW5nZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gc2NvcGVzIC0gVGhlIHNjb3BlKHMpIG9mIHRoZSBuZXcgYWNjZXNzIHRva2VuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzb3VyY2VdIC0gVGhlIGFic29sdXRlIFVSTCBvZiBhbiBBUEkgcmVzb3VyY2UgdG8gcmVzdHJpY3QgdGhlIG5ldyB0b2tlbiB0b1xuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuXHQgKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zLnRva2VuUmVxdWVzdE9wdGlvbnNdIC0gU2V0cyBvcHRpb25hbCBiZWhhdmlvciBmb3IgdGhlIHRva2VuIGdyYW50XG5cdCAqIEBwYXJhbSB7QWN0b3JQYXJhbXN9IFtvcHRpb25zLmFjdG9yXSAtIE9wdGlvbmFsIGFjdG9yIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIGFubm90YXRvciB0b2tlbnNcblx0ICogQHBhcmFtIHtTaGFyZWRMaW5rUGFyYW1zfSBbb3B0aW9ucy5zaGFyZWRMaW5rXSAtIE9wdGlvbmFsIHNoYXJlZCBsaW5rIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRva2VucyB1c2luZyBzaGFyZWQgbGlua3Ncblx0ICogQHJldHVybnMge1Byb21pc2U8VG9rZW5JbmZvPn0gUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG5ldyB0b2tlbiBpbmZvXG5cdCAqL1xuXHRleGNoYW5nZVRva2VuKGFjY2Vzc1Rva2VuLCBzY29wZXMsIHJlc291cmNlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHBhcmFtcyA9IHtcblx0XHRcdGdyYW50X3R5cGU6IGdyYW50VHlwZXMuVE9LRU5fRVhDSEFOR0UsXG5cdFx0XHRzdWJqZWN0X3Rva2VuX3R5cGU6IEFDQ0VTU19UT0tFTl9UWVBFLFxuXHRcdFx0c3ViamVjdF90b2tlbjogYWNjZXNzVG9rZW4sXG5cdFx0XHRzY29wZTogKHR5cGVvZiBzY29wZXMgPT09ICdzdHJpbmcnID8gc2NvcGVzIDogc2NvcGVzLmpvaW4oJyAnKSlcblx0XHR9O1xuXG5cdFx0aWYgKHJlc291cmNlKSB7XG5cdFx0XHRwYXJhbXMucmVzb3VyY2UgPSByZXNvdXJjZTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNoYXJlZExpbmspIHtcblx0XHRcdHBhcmFtcy5ib3hfc2hhcmVkX2xpbmsgPSBvcHRpb25zLnNoYXJlZExpbmsudXJsO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWN0b3IpIHtcblxuXHRcdFx0dmFyIHBheWxvYWQgPSB7XG5cdFx0XHRcdGlzczogdGhpcy5jb25maWcuY2xpZW50SUQsXG5cdFx0XHRcdHN1Yjogb3B0aW9ucy5hY3Rvci5pZCxcblx0XHRcdFx0YXVkOiBCT1hfSldUX0FVRElFTkNFLFxuXHRcdFx0XHRib3hfc3ViX3R5cGU6ICdleHRlcm5hbCcsXG5cdFx0XHRcdG5hbWU6IG9wdGlvbnMuYWN0b3IubmFtZVxuXHRcdFx0fTtcblxuXHRcdFx0dmFyIGp3dE9wdGlvbnMgPSB7XG5cdFx0XHRcdGFsZ29yaXRobTogJ25vbmUnLFxuXHRcdFx0XHRleHBpcmVzSW46ICcxbScsXG5cdFx0XHRcdG5vVGltZXN0YW1wOiB0cnVlLFxuXHRcdFx0XHRqd3RpZDogdXVpZC52NCgpXG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgdG9rZW47XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR0b2tlbiA9IGp3dC5zaWduKHBheWxvYWQsICdVTlVTRUQnLCBqd3RPcHRpb25zKTtcblx0XHRcdH0gY2F0Y2ggKGp3dEVycm9yKSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChqd3RFcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdHBhcmFtcy5hY3Rvcl90b2tlbiA9IHRva2VuO1xuXHRcdFx0cGFyYW1zLmFjdG9yX3Rva2VuX3R5cGUgPSBBQ1RPUl9UT0tFTl9UWVBFO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldFRva2VucyhwYXJhbXMsIG9wdGlvbnMgJiYgb3B0aW9ucy50b2tlblJlcXVlc3RPcHRpb25zID8gb3B0aW9ucy50b2tlblJlcXVlc3RPcHRpb25zIDogbnVsbCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldm9rZXMgYSB0b2tlbiBwYWlyIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGFjY2VzcyBvciByZWZyZXNoIHRva2VuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBBIHZhbGlkIGFjY2VzcyBvciByZWZyZXNoIHRva2VuIHRvIHJldm9rZVxuXHQgKiBAcGFyYW0ge1Rva2VuUmVxdWVzdE9wdGlvbnN9IFtvcHRpb25zXSAtIFNldHMgb3B0aW9uYWwgYmVoYXZpb3IgZm9yIHRoZSB0b2tlbiBncmFudFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZpbmcgaWYgdGhlIHJldm9rZSBzdWNjZWVkc1xuXHQgKi9cblx0cmV2b2tlVG9rZW5zKHRva2VuLCBvcHRpb25zKSB7XG5cdFx0dmFyIHBhcmFtcyA9IHtcblx0XHRcdG1ldGhvZDogJ1BPU1QnLFxuXHRcdFx0dXJsOiB0aGlzLm9hdXRoQmFzZVVSTCArIHRva2VuUGF0aHMuUkVWT0tFLFxuXHRcdFx0Zm9ybToge1xuXHRcdFx0XHR0b2tlbixcblx0XHRcdFx0Y2xpZW50X2lkOiB0aGlzLmNvbmZpZy5jbGllbnRJRCxcblx0XHRcdFx0Y2xpZW50X3NlY3JldDogdGhpcy5jb25maWcuY2xpZW50U2VjcmV0XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuaXApIHtcblx0XHRcdHBhcmFtcy5oZWFkZXJzID0ge307XG5cdFx0XHRwYXJhbXMuaGVhZGVyc1tIRUFERVJfWEZGXSA9IG9wdGlvbnMuaXA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucmVxdWVzdE1hbmFnZXIubWFrZVJlcXVlc3QocGFyYW1zKTtcblx0fVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbnRlcmFjdGlvbnMgd2l0aCBCb3ggT0F1dGgyIHRva2VuaW5nIHN5c3RlbS5cbiAqXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvdG9rZW4tbWFuYWdlclxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuTWFuYWdlcjtcbiJdLCJuYW1lcyI6WyJpc0pXVEF1dGhFcnJvclJldHJ5YWJsZSIsImVyciIsImF1dGhFeHBpcmVkIiwicmVzcG9uc2UiLCJoZWFkZXJzIiwiZGF0ZSIsImJvZHkiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImluZGV4T2YiLCJzdGF0dXNDb2RlIiwiZXJyb3JzIiwicmVxdWlyZSIsImp3dCIsInV1aWQiLCJodHRwU3RhdHVzQ29kZXMiLCJQcm9taXNlIiwiZ2V0UmV0cnlUaW1lb3V0IiwiZ3JhbnRUeXBlcyIsIkFVVEhPUklaQVRJT05fQ09ERSIsIlJFRlJFU0hfVE9LRU4iLCJDTElFTlRfQ1JFREVOVElBTFMiLCJKV1QiLCJUT0tFTl9FWENIQU5HRSIsInRva2VuUGF0aHMiLCJST09UIiwiR0VUIiwiUkVWT0tFIiwiYXN5bmNSZXF1ZXN0VGltZXIiLCJIRUFERVJfWEZGIiwiQUNDRVNTX1RPS0VOX1RZUEUiLCJBQ1RPUl9UT0tFTl9UWVBFIiwiQk9YX0pXVF9BVURJRU5DRSIsImdldFRva2Vuc0Zyb21HcmFudFJlc3BvbnNlIiwiZ3JhbnRSZXNwb25zZUJvZHkiLCJhY2Nlc3NUb2tlbiIsImFjY2Vzc190b2tlbiIsInJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJhY2Nlc3NUb2tlblRUTE1TIiwicGFyc2VJbnQiLCJleHBpcmVzX2luIiwiYWNxdWlyZWRBdE1TIiwiRGF0ZSIsIm5vdyIsImlzVmFsaWRDb2RlT3JUb2tlbiIsImNvZGVPclRva2VuIiwibGVuZ3RoIiwiaXNWYWxpZFRva2VuUmVzcG9uc2UiLCJncmFudFR5cGUiLCJyZXNwb25zZUJvZHkiLCJUb2tlbk1hbmFnZXIiLCJjb25maWciLCJyZXF1ZXN0TWFuYWdlciIsIm9hdXRoQmFzZVVSTCIsImFwaVJvb3RVUkwiLCJwcm90b3R5cGUiLCJpc0FjY2Vzc1Rva2VuVmFsaWQiLCJ0b2tlbkluZm8iLCJidWZmZXJNUyIsImV4cGlyZVRpbWUiLCJnZXRUb2tlbnMiLCJmb3JtUGFyYW1zIiwib3B0aW9ucyIsInBhcmFtcyIsIm1ldGhvZCIsInVybCIsImZvcm0iLCJjbGllbnRfaWQiLCJjbGllbnRJRCIsImNsaWVudF9zZWNyZXQiLCJjbGllbnRTZWNyZXQiLCJpcCIsIm1ha2VSZXF1ZXN0IiwidGhlbiIsImVycm9yIiwiZXJyRGVzY3JpcHRpb24iLCJtZXNzYWdlIiwidW5kZWZpbmVkIiwiYnVpbGRBdXRoRXJyb3IiLCJPSyIsIkJ1ZmZlciIsImJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IiLCJncmFudF90eXBlIiwiYnVpbGRSZXNwb25zZUVycm9yIiwiZ2V0VG9rZW5zQXV0aG9yaXphdGlvbkNvZGVHcmFudCIsImF1dGhvcml6YXRpb25Db2RlIiwicmVqZWN0IiwiRXJyb3IiLCJjb2RlIiwiZ2V0VG9rZW5zQ2xpZW50Q3JlZGVudGlhbHNHcmFudCIsImdldFRva2Vuc1JlZnJlc2hHcmFudCIsImdldFRva2Vuc0pXVEdyYW50IiwidHlwZSIsImlkIiwiYXBwQXV0aCIsImtleUlEIiwiY2xhaW1zIiwiZXhwIiwiTWF0aCIsImZsb29yIiwiZXhwaXJhdGlvblRpbWUiLCJib3hfc3ViX3R5cGUiLCJqd3RPcHRpb25zIiwiYWxnb3JpdGhtIiwiYXVkaWVuY2UiLCJzdWJqZWN0IiwiaXNzdWVyIiwiand0aWQiLCJ2NCIsIm5vVGltZXN0YW1wIiwidmVyaWZ5VGltZXN0YW1wIiwia2V5aWQiLCJrZXlQYXJhbXMiLCJrZXkiLCJwcml2YXRlS2V5IiwicGFzc3BocmFzZSIsImFzc2VydGlvbiIsInNpZ24iLCJqd3RFcnIiLCJwcm9jZXNzIiwiaHJ0aW1lIiwiY2F0Y2giLCJyZXRyeUpXVEdyYW50IiwibnVtUmV0cmllcyIsIm51bU1heFJldHJpZXMiLCJyZXRyeVRpbWVvdXQiLCJyZXRyeVN0cmF0ZWd5IiwidG90YWxFbGFwc2VkVGltZSIsInRvdGFsRWxhcHNlZFRpbWVNUyIsInJldHJ5T3B0aW9ucyIsIm51bVJldHJ5QXR0ZW1wdHMiLCJyZXRyeUludGVydmFsTVMiLCJoYXNPd25Qcm9wZXJ0eSIsInRpbWUiLCJwYXJzZSIsImRlbGF5IiwibWF4UmV0cmllc0V4Y2VlZGVkIiwiZXhjaGFuZ2VUb2tlbiIsInNjb3BlcyIsInJlc291cmNlIiwic3ViamVjdF90b2tlbl90eXBlIiwic3ViamVjdF90b2tlbiIsInNjb3BlIiwiam9pbiIsInNoYXJlZExpbmsiLCJib3hfc2hhcmVkX2xpbmsiLCJhY3RvciIsInBheWxvYWQiLCJpc3MiLCJzdWIiLCJhdWQiLCJuYW1lIiwiZXhwaXJlc0luIiwidG9rZW4iLCJqd3RFcnJvciIsImFjdG9yX3Rva2VuIiwiYWN0b3JfdG9rZW5fdHlwZSIsInRva2VuUmVxdWVzdE9wdGlvbnMiLCJyZXZva2VUb2tlbnMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/token-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/util/config.js":
/*!******************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/util/config.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Configuration Object\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar assert = __webpack_require__(/*! assert */ \"assert\"), https = __webpack_require__(/*! https */ \"https\"), merge = __webpack_require__(/*! merge-options */ \"(rsc)/./node_modules/merge-options/index.js\"), sdkVersion = (__webpack_require__(/*! ../../package.json */ \"(rsc)/./node_modules/box-node-sdk/package.json\").version), ProxyAgent = __webpack_require__(/*! proxy-agent */ \"(rsc)/./node_modules/proxy-agent/index.js\"), url = __webpack_require__(/*! url */ \"url\");\n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\nvar nodeVersion = process.version;\n/**\n * Configuration for App Auth\n * @typedef {Object} AppAuthConfig\n * @property {string} keyID The ID of the public key used for app auth\n * @property {string|Buffer} privateKey The private key used for app auth\n * @property {string} passphrase The passphrase associated with the private key\n * @property {string} [algorithm=RS256] The signing algorithm to use, \"RS256\", \"RS384\", or \"RS512\"\n * @property {int} [expirationTime=30] Number of seconds the JWT should live for\n * @property {boolean} [verifyTimestamp=false] Whether the timestamp when the auth token is created should be validated\n */ /**\n * Configuration settings used to initialize and customize the SDK\n *\n * @typedef {Object} UserConfigurationOptions\n * @property {string} clientID Client ID of your Box Application\n * @property {string} clientSecret Client secret of your Box Application\n * @property {string} [apiRootURL] The root URL to Box [Default: 'https://api.box.com']\n * @property {string} [uploadAPIRootURL] The root URL to Box for uploads [Default: 'https://upload.box.com/api']\n * @property {string} [authorizeRootURL] The root URL for the authorization screen [Default: 'https://account.box.com/api']\n * @property {int} [uploadRequestTimeoutMS] Timeout after which an upload request is aborted [Default: 60000]\n * @property {int} [retryIntervalMS] Time between auto-retries of the API call on a temp failure [Default: 2000]\n * @property {int} [numMaxRetries] Max # of times a temporarily-failed request should be retried before propagating a permanent failure [Default: 5]\n * @property {int} [expiredBufferMS] Time before expiration, in milliseconds, when we begin to treat tokens as expired [Default: 3 min.]\n * @property {Object} [request] Request options\n * @property {boolean} [request.strictSSL] Set to false to disable strict SSL checking, which allows using Dev APIs [Default: true]\n * @property {?AppAuthConfig} appAuth Optional configuration for App Auth\n */ var defaults = {\n    clientID: null,\n    clientSecret: null,\n    apiRootURL: \"https://api.box.com\",\n    uploadAPIRootURL: \"https://upload.box.com/api\",\n    authorizeRootURL: \"https://account.box.com/api\",\n    apiVersion: \"2.0\",\n    uploadRequestTimeoutMS: 60000,\n    retryIntervalMS: 2000,\n    numMaxRetries: 5,\n    retryStrategy: null,\n    expiredBufferMS: 180000,\n    staleBufferMS: 0,\n    appAuth: undefined,\n    iterators: false,\n    enterpriseID: undefined,\n    analyticsClient: null,\n    proxy: {\n        url: null,\n        username: null,\n        password: null\n    },\n    request: {\n        // By default, require API SSL cert to be valid\n        strictSSL: true,\n        // Use an agent with keep-alive enabled to avoid performing SSL handshake per connection\n        agentClass: https.Agent,\n        agentOptions: {\n            keepAlive: true\n        },\n        // Encode requests as JSON. Encode the response as well if JSON is returned.\n        json: true,\n        // Do not encode the response as a string, since the response could be a file. return Buffers instead.\n        encoding: null,\n        // A redirect is usually information we want to handle, so don't automatically follow\n        followRedirect: false,\n        // By default, we attach a version-specific user-agent string to SDK requests\n        headers: {\n            \"User-Agent\": `Box Node.js SDK v${sdkVersion} (Node ${nodeVersion})`\n        }\n    }\n};\nvar appAuthDefaults = {\n    algorithm: \"RS256\",\n    expirationTime: 30,\n    verifyTimestamp: false\n};\n/**\n * Validate the basic Config values needed for the SDK to function\n * @param {UserConfigurationOptions} params The user-supplied config values\n * @returns {void}\n * @throws {AssertionError}\n * @private\n */ function validateBasicParams(params) {\n    // Assert that the given params valid, and that required values are present\n    assert(typeof params.clientID === \"string\", '\"clientID\" must be set via init() before using the SDK.');\n    assert(typeof params.clientSecret === \"string\", '\"clientSecret\" must be set via init() before using the SDK.');\n}\n/**\n * Validate app auth-specific Config values\n * @param {Object} appAuth The user-supplied app auth values\n * @returns {void}\n * @throws {AssertionError}\n * @private\n */ function validateAppAuthParams(appAuth) {\n    assert(typeof appAuth.keyID === \"string\", \"Key ID must be provided in app auth params\");\n    assert(typeof appAuth.privateKey === \"string\" || appAuth.privateKey instanceof Buffer, \"Private key must be provided in app auth params\");\n    assert(typeof appAuth.passphrase === \"string\" && appAuth.passphrase.length > 0, \"Passphrase must be provided in app auth params\");\n    var validAlgorithms = [\n        \"RS256\",\n        \"RS384\",\n        \"RS512\"\n    ];\n    if (typeof appAuth.algorithm !== \"undefined\") {\n        assert(validAlgorithms.indexOf(appAuth.algorithm) > -1, `Algorithm in app auth params must be one of: ${validAlgorithms.join(\", \")}`);\n    }\n    if (typeof appAuth.expirationTime !== \"undefined\") {\n        assert(Number.isInteger(appAuth.expirationTime) && appAuth.expirationTime > 0 && appAuth.expirationTime <= 60, \"Valid token expiration time (0 - 60) must be provided in app auth params\");\n    }\n}\n/**\n * Update the agentClass based on the proxy config values passed in by the user\n * @param {UserConfigurationOptions} params The current Config values\n * @returns {void}\n * @private\n */ function updateRequestAgent(params) {\n    if (params.proxy.url) {\n        params.request.agentClass = ProxyAgent;\n        params.request.agentOptions = Object.assign({}, params.request.agentOptions, url.parse(params.proxy.url));\n        if (params.proxy.username && params.proxy.password) {\n            Object.assign(params.request.agentOptions, {\n                auth: `${params.proxy.username}:${params.proxy.password}`\n            });\n        }\n    }\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * A Config Object holds the configuration options of the current setup. These are all\n * customizable by the user, and will default if no value is specified in the given params\n * object. The object is frozen on initialization, so that no values can be changed after\n * setup.\n *\n * @param {UserConfigurationOptions} params - The config options set by the user\n * @constructor\n */ function Config(params) {\n    validateBasicParams(params);\n    if (typeof params.appAuth === \"object\") {\n        validateAppAuthParams(params.appAuth);\n        params.appAuth = merge({}, appAuthDefaults, params.appAuth);\n    }\n    // Ensure that we don't accidentally assign over Config methods\n    assert(!params.hasOwnProperty(\"extend\"), \"Config params may not override Config methods\");\n    assert(!params.hasOwnProperty(\"_params\"), \"Config params may not override Config methods\");\n    // Set the given params or default value if params property is missing\n    this._params = merge(defaults, params);\n    updateRequestAgent(this._params);\n    Object.assign(this, this._params);\n    // Freeze the object so that configuration options cannot be modified\n    Object.freeze(this);\n}\n/**\n * Extend the current config into a new config with new params overriding old ones\n * @param {UserConfigurationOptions} params The override options\n * @returns {Config} The extended configuration\n */ Config.prototype.extend = function(params) {\n    var newParams = merge({}, this._params, params);\n    delete newParams.extend;\n    delete newParams._params;\n    return new Config(newParams);\n};\n/**\n * @module box-node-sdk/lib/util/config\n * @see {@Link Config}\n */ module.exports = Config;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi91dGlsL2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUMseUJBQ3BCQyxRQUFRRCxtQkFBT0EsQ0FBQyx1QkFDaEJFLFFBQVFGLG1CQUFPQSxDQUFDLHFFQUNoQkcsYUFBYUgseUdBQXFDLEVBQ2xESyxhQUFhTCxtQkFBT0EsQ0FBQyxpRUFDckJNLE1BQU1OLG1CQUFPQSxDQUFDO0FBRWYsaUZBQWlGO0FBQ2pGLFVBQVU7QUFDVixpRkFBaUY7QUFFakYsSUFBSU8sY0FBY0MsUUFBUUosT0FBTztBQUVqQzs7Ozs7Ozs7O0NBU0MsR0FFRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVELElBQUlLLFdBQVc7SUFDZEMsVUFBVTtJQUNWQyxjQUFjO0lBQ2RDLFlBQVk7SUFDWkMsa0JBQWtCO0lBQ2xCQyxrQkFBa0I7SUFDbEJDLFlBQVk7SUFDWkMsd0JBQXdCO0lBQ3hCQyxpQkFBaUI7SUFDakJDLGVBQWU7SUFDZkMsZUFBZTtJQUNmQyxpQkFBaUI7SUFDakJDLGVBQWU7SUFDZkMsU0FBU0M7SUFDVEMsV0FBVztJQUNYQyxjQUFjRjtJQUNkRyxpQkFBaUI7SUFDakJDLE9BQU87UUFDTnJCLEtBQUs7UUFDTHNCLFVBQVU7UUFDVkMsVUFBVTtJQUNYO0lBQ0FDLFNBQVM7UUFDUiwrQ0FBK0M7UUFDL0NDLFdBQVc7UUFDWCx3RkFBd0Y7UUFDeEZDLFlBQVkvQixNQUFNZ0MsS0FBSztRQUN2QkMsY0FBYztZQUNiQyxXQUFXO1FBQ1o7UUFDQSw0RUFBNEU7UUFDNUVDLE1BQU07UUFDTixzR0FBc0c7UUFDdEdDLFVBQVU7UUFDVixxRkFBcUY7UUFDckZDLGdCQUFnQjtRQUNoQiw2RUFBNkU7UUFDN0VDLFNBQVM7WUFDUixjQUFjLENBQUMsaUJBQWlCLEVBQUVwQyxXQUFXLE9B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LElBQUk7QUFDbkI7QUFFQTs7OztDQUlDLEdBQ0RILE9BQU9JLFNBQVMsQ0FBQ0MsTUFBTSxHQUFHLFNBQVN0QixNQUFNO0lBQ3hDLElBQUl1QixZQUFZbEUsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDOEQsT0FBTyxFQUFFbkI7SUFDeEMsT0FBT3VCLFVBQVVELE1BQU07SUFDdkIsT0FBT0MsVUFBVUosT0FBTztJQUN4QixPQUFPLElBQUlGLE9BQU9NO0FBQ25CO0FBRUE7OztDQUdDLEdBQ0RDLE9BQU9DLE9BQU8sR0FBR1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL3V0aWwvY29uZmlnLmpzP2I0NTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbmZpZ3VyYXRpb24gT2JqZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlcXVpcmVtZW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JyksXG5cdGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKSxcblx0bWVyZ2UgPSByZXF1aXJlKCdtZXJnZS1vcHRpb25zJyksXG5cdHNka1ZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuXHRQcm94eUFnZW50ID0gcmVxdWlyZSgncHJveHktYWdlbnQnKSxcblx0dXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBub2RlVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbjtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBBcHAgQXV0aFxuICogQHR5cGVkZWYge09iamVjdH0gQXBwQXV0aENvbmZpZ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleUlEIFRoZSBJRCBvZiB0aGUgcHVibGljIGtleSB1c2VkIGZvciBhcHAgYXV0aFxuICogQHByb3BlcnR5IHtzdHJpbmd8QnVmZmVyfSBwcml2YXRlS2V5IFRoZSBwcml2YXRlIGtleSB1c2VkIGZvciBhcHAgYXV0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhc3NwaHJhc2UgVGhlIHBhc3NwaHJhc2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcml2YXRlIGtleVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthbGdvcml0aG09UlMyNTZdIFRoZSBzaWduaW5nIGFsZ29yaXRobSB0byB1c2UsIFwiUlMyNTZcIiwgXCJSUzM4NFwiLCBvciBcIlJTNTEyXCJcbiAqIEBwcm9wZXJ0eSB7aW50fSBbZXhwaXJhdGlvblRpbWU9MzBdIE51bWJlciBvZiBzZWNvbmRzIHRoZSBKV1Qgc2hvdWxkIGxpdmUgZm9yXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt2ZXJpZnlUaW1lc3RhbXA9ZmFsc2VdIFdoZXRoZXIgdGhlIHRpbWVzdGFtcCB3aGVuIHRoZSBhdXRoIHRva2VuIGlzIGNyZWF0ZWQgc2hvdWxkIGJlIHZhbGlkYXRlZFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBzZXR0aW5ncyB1c2VkIHRvIGluaXRpYWxpemUgYW5kIGN1c3RvbWl6ZSB0aGUgU0RLXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVXNlckNvbmZpZ3VyYXRpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2xpZW50SUQgQ2xpZW50IElEIG9mIHlvdXIgQm94IEFwcGxpY2F0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2xpZW50U2VjcmV0IENsaWVudCBzZWNyZXQgb2YgeW91ciBCb3ggQXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXBpUm9vdFVSTF0gVGhlIHJvb3QgVVJMIHRvIEJveCBbRGVmYXVsdDogJ2h0dHBzOi8vYXBpLmJveC5jb20nXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1cGxvYWRBUElSb290VVJMXSBUaGUgcm9vdCBVUkwgdG8gQm94IGZvciB1cGxvYWRzIFtEZWZhdWx0OiAnaHR0cHM6Ly91cGxvYWQuYm94LmNvbS9hcGknXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthdXRob3JpemVSb290VVJMXSBUaGUgcm9vdCBVUkwgZm9yIHRoZSBhdXRob3JpemF0aW9uIHNjcmVlbiBbRGVmYXVsdDogJ2h0dHBzOi8vYWNjb3VudC5ib3guY29tL2FwaSddXG4gKiBAcHJvcGVydHkge2ludH0gW3VwbG9hZFJlcXVlc3RUaW1lb3V0TVNdIFRpbWVvdXQgYWZ0ZXIgd2hpY2ggYW4gdXBsb2FkIHJlcXVlc3QgaXMgYWJvcnRlZCBbRGVmYXVsdDogNjAwMDBdXG4gKiBAcHJvcGVydHkge2ludH0gW3JldHJ5SW50ZXJ2YWxNU10gVGltZSBiZXR3ZWVuIGF1dG8tcmV0cmllcyBvZiB0aGUgQVBJIGNhbGwgb24gYSB0ZW1wIGZhaWx1cmUgW0RlZmF1bHQ6IDIwMDBdXG4gKiBAcHJvcGVydHkge2ludH0gW251bU1heFJldHJpZXNdIE1heCAjIG9mIHRpbWVzIGEgdGVtcG9yYXJpbHktZmFpbGVkIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQgYmVmb3JlIHByb3BhZ2F0aW5nIGEgcGVybWFuZW50IGZhaWx1cmUgW0RlZmF1bHQ6IDVdXG4gKiBAcHJvcGVydHkge2ludH0gW2V4cGlyZWRCdWZmZXJNU10gVGltZSBiZWZvcmUgZXhwaXJhdGlvbiwgaW4gbWlsbGlzZWNvbmRzLCB3aGVuIHdlIGJlZ2luIHRvIHRyZWF0IHRva2VucyBhcyBleHBpcmVkIFtEZWZhdWx0OiAzIG1pbi5dXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3JlcXVlc3RdIFJlcXVlc3Qgb3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVxdWVzdC5zdHJpY3RTU0xdIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHN0cmljdCBTU0wgY2hlY2tpbmcsIHdoaWNoIGFsbG93cyB1c2luZyBEZXYgQVBJcyBbRGVmYXVsdDogdHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7P0FwcEF1dGhDb25maWd9IGFwcEF1dGggT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgQXBwIEF1dGhcbiAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG5cdGNsaWVudElEOiBudWxsLFxuXHRjbGllbnRTZWNyZXQ6IG51bGwsXG5cdGFwaVJvb3RVUkw6ICdodHRwczovL2FwaS5ib3guY29tJyxcblx0dXBsb2FkQVBJUm9vdFVSTDogJ2h0dHBzOi8vdXBsb2FkLmJveC5jb20vYXBpJyxcblx0YXV0aG9yaXplUm9vdFVSTDogJ2h0dHBzOi8vYWNjb3VudC5ib3guY29tL2FwaScsXG5cdGFwaVZlcnNpb246ICcyLjAnLFxuXHR1cGxvYWRSZXF1ZXN0VGltZW91dE1TOiA2MDAwMCxcblx0cmV0cnlJbnRlcnZhbE1TOiAyMDAwLFxuXHRudW1NYXhSZXRyaWVzOiA1LFxuXHRyZXRyeVN0cmF0ZWd5OiBudWxsLFxuXHRleHBpcmVkQnVmZmVyTVM6IDE4MDAwMCxcblx0c3RhbGVCdWZmZXJNUzogMCwgLy8gREVQUkVDQVRFRCAtLSB0b2tlbiBleHBpcmF0aW9uIGJ1ZmZlciB3aWxsIGJlIG1heChleHBpcmVkQnVmZmVyTVMsIHN0YWxlQnVmZmVyTVMpXG5cdGFwcEF1dGg6IHVuZGVmaW5lZCxcblx0aXRlcmF0b3JzOiBmYWxzZSxcblx0ZW50ZXJwcmlzZUlEOiB1bmRlZmluZWQsXG5cdGFuYWx5dGljc0NsaWVudDogbnVsbCxcblx0cHJveHk6IHtcblx0XHR1cmw6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdH0sXG5cdHJlcXVlc3Q6IHtcblx0XHQvLyBCeSBkZWZhdWx0LCByZXF1aXJlIEFQSSBTU0wgY2VydCB0byBiZSB2YWxpZFxuXHRcdHN0cmljdFNTTDogdHJ1ZSxcblx0XHQvLyBVc2UgYW4gYWdlbnQgd2l0aCBrZWVwLWFsaXZlIGVuYWJsZWQgdG8gYXZvaWQgcGVyZm9ybWluZyBTU0wgaGFuZHNoYWtlIHBlciBjb25uZWN0aW9uXG5cdFx0YWdlbnRDbGFzczogaHR0cHMuQWdlbnQsXG5cdFx0YWdlbnRPcHRpb25zOiB7XG5cdFx0XHRrZWVwQWxpdmU6IHRydWVcblx0XHR9LFxuXHRcdC8vIEVuY29kZSByZXF1ZXN0cyBhcyBKU09OLiBFbmNvZGUgdGhlIHJlc3BvbnNlIGFzIHdlbGwgaWYgSlNPTiBpcyByZXR1cm5lZC5cblx0XHRqc29uOiB0cnVlLFxuXHRcdC8vIERvIG5vdCBlbmNvZGUgdGhlIHJlc3BvbnNlIGFzIGEgc3RyaW5nLCBzaW5jZSB0aGUgcmVzcG9uc2UgY291bGQgYmUgYSBmaWxlLiByZXR1cm4gQnVmZmVycyBpbnN0ZWFkLlxuXHRcdGVuY29kaW5nOiBudWxsLFxuXHRcdC8vIEEgcmVkaXJlY3QgaXMgdXN1YWxseSBpbmZvcm1hdGlvbiB3ZSB3YW50IHRvIGhhbmRsZSwgc28gZG9uJ3QgYXV0b21hdGljYWxseSBmb2xsb3dcblx0XHRmb2xsb3dSZWRpcmVjdDogZmFsc2UsXG5cdFx0Ly8gQnkgZGVmYXVsdCwgd2UgYXR0YWNoIGEgdmVyc2lvbi1zcGVjaWZpYyB1c2VyLWFnZW50IHN0cmluZyB0byBTREsgcmVxdWVzdHNcblx0XHRoZWFkZXJzOiB7XG5cdFx0XHQnVXNlci1BZ2VudCc6IGBCb3ggTm9kZS5qcyBTREsgdiR7c2RrVmVyc2lvbn0gKE5vZGUgJHtub2RlVmVyc2lvbn0pYFxuXHRcdH1cblx0fVxufTtcblxudmFyIGFwcEF1dGhEZWZhdWx0cyA9IHtcblx0YWxnb3JpdGhtOiAnUlMyNTYnLFxuXHRleHBpcmF0aW9uVGltZTogMzAsXG5cdHZlcmlmeVRpbWVzdGFtcDogZmFsc2Vcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgdGhlIGJhc2ljIENvbmZpZyB2YWx1ZXMgbmVlZGVkIGZvciB0aGUgU0RLIHRvIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VzZXJDb25maWd1cmF0aW9uT3B0aW9uc30gcGFyYW1zIFRoZSB1c2VyLXN1cHBsaWVkIGNvbmZpZyB2YWx1ZXNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7QXNzZXJ0aW9uRXJyb3J9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJhc2ljUGFyYW1zKHBhcmFtcykge1xuXHQvLyBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gcGFyYW1zIHZhbGlkLCBhbmQgdGhhdCByZXF1aXJlZCB2YWx1ZXMgYXJlIHByZXNlbnRcblx0YXNzZXJ0KHR5cGVvZiBwYXJhbXMuY2xpZW50SUQgPT09ICdzdHJpbmcnLCAnXCJjbGllbnRJRFwiIG11c3QgYmUgc2V0IHZpYSBpbml0KCkgYmVmb3JlIHVzaW5nIHRoZSBTREsuJyk7XG5cdGFzc2VydCh0eXBlb2YgcGFyYW1zLmNsaWVudFNlY3JldCA9PT0gJ3N0cmluZycsICdcImNsaWVudFNlY3JldFwiIG11c3QgYmUgc2V0IHZpYSBpbml0KCkgYmVmb3JlIHVzaW5nIHRoZSBTREsuJyk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYXBwIGF1dGgtc3BlY2lmaWMgQ29uZmlnIHZhbHVlc1xuICogQHBhcmFtIHtPYmplY3R9IGFwcEF1dGggVGhlIHVzZXItc3VwcGxpZWQgYXBwIGF1dGggdmFsdWVzXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge0Fzc2VydGlvbkVycm9yfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBcHBBdXRoUGFyYW1zKGFwcEF1dGgpIHtcblx0YXNzZXJ0KHR5cGVvZiBhcHBBdXRoLmtleUlEID09PSAnc3RyaW5nJywgJ0tleSBJRCBtdXN0IGJlIHByb3ZpZGVkIGluIGFwcCBhdXRoIHBhcmFtcycpO1xuXHRhc3NlcnQodHlwZW9mIGFwcEF1dGgucHJpdmF0ZUtleSA9PT0gJ3N0cmluZycgfHwgYXBwQXV0aC5wcml2YXRlS2V5IGluc3RhbmNlb2YgQnVmZmVyLCAnUHJpdmF0ZSBrZXkgbXVzdCBiZSBwcm92aWRlZCBpbiBhcHAgYXV0aCBwYXJhbXMnKTtcblx0YXNzZXJ0KHR5cGVvZiBhcHBBdXRoLnBhc3NwaHJhc2UgPT09ICdzdHJpbmcnICYmIGFwcEF1dGgucGFzc3BocmFzZS5sZW5ndGggPiAwLCAnUGFzc3BocmFzZSBtdXN0IGJlIHByb3ZpZGVkIGluIGFwcCBhdXRoIHBhcmFtcycpO1xuXG5cdHZhciB2YWxpZEFsZ29yaXRobXMgPSBbXG5cdFx0J1JTMjU2Jyxcblx0XHQnUlMzODQnLFxuXHRcdCdSUzUxMidcblx0XTtcblx0aWYgKHR5cGVvZiBhcHBBdXRoLmFsZ29yaXRobSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRhc3NlcnQodmFsaWRBbGdvcml0aG1zLmluZGV4T2YoYXBwQXV0aC5hbGdvcml0aG0pID4gLTEsIGBBbGdvcml0aG0gaW4gYXBwIGF1dGggcGFyYW1zIG11c3QgYmUgb25lIG9mOiAke3ZhbGlkQWxnb3JpdGhtcy5qb2luKCcsICcpfWApO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBhcHBBdXRoLmV4cGlyYXRpb25UaW1lICE9PSAndW5kZWZpbmVkJykge1xuXHRcdGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKGFwcEF1dGguZXhwaXJhdGlvblRpbWUpICYmIGFwcEF1dGguZXhwaXJhdGlvblRpbWUgPiAwICYmIGFwcEF1dGguZXhwaXJhdGlvblRpbWUgPD0gNjAsICdWYWxpZCB0b2tlbiBleHBpcmF0aW9uIHRpbWUgKDAgLSA2MCkgbXVzdCBiZSBwcm92aWRlZCBpbiBhcHAgYXV0aCBwYXJhbXMnKTtcblx0fVxufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgYWdlbnRDbGFzcyBiYXNlZCBvbiB0aGUgcHJveHkgY29uZmlnIHZhbHVlcyBwYXNzZWQgaW4gYnkgdGhlIHVzZXJcbiAqIEBwYXJhbSB7VXNlckNvbmZpZ3VyYXRpb25PcHRpb25zfSBwYXJhbXMgVGhlIGN1cnJlbnQgQ29uZmlnIHZhbHVlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVSZXF1ZXN0QWdlbnQocGFyYW1zKSB7XG5cdGlmIChwYXJhbXMucHJveHkudXJsKSB7XG5cdFx0cGFyYW1zLnJlcXVlc3QuYWdlbnRDbGFzcyA9IFByb3h5QWdlbnQ7XG5cdFx0cGFyYW1zLnJlcXVlc3QuYWdlbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLnJlcXVlc3QuYWdlbnRPcHRpb25zLCB1cmwucGFyc2UocGFyYW1zLnByb3h5LnVybCkpO1xuXHRcdGlmIChwYXJhbXMucHJveHkudXNlcm5hbWUgJiYgcGFyYW1zLnByb3h5LnBhc3N3b3JkKSB7XG5cdFx0XHRPYmplY3QuYXNzaWduKHBhcmFtcy5yZXF1ZXN0LmFnZW50T3B0aW9ucywge2F1dGg6IGAke3BhcmFtcy5wcm94eS51c2VybmFtZX06JHtwYXJhbXMucHJveHkucGFzc3dvcmR9YH0pO1xuXHRcdH1cblx0fVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFB1YmxpY1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQSBDb25maWcgT2JqZWN0IGhvbGRzIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgc2V0dXAuIFRoZXNlIGFyZSBhbGxcbiAqIGN1c3RvbWl6YWJsZSBieSB0aGUgdXNlciwgYW5kIHdpbGwgZGVmYXVsdCBpZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGdpdmVuIHBhcmFtc1xuICogb2JqZWN0LiBUaGUgb2JqZWN0IGlzIGZyb3plbiBvbiBpbml0aWFsaXphdGlvbiwgc28gdGhhdCBubyB2YWx1ZXMgY2FuIGJlIGNoYW5nZWQgYWZ0ZXJcbiAqIHNldHVwLlxuICpcbiAqIEBwYXJhbSB7VXNlckNvbmZpZ3VyYXRpb25PcHRpb25zfSBwYXJhbXMgLSBUaGUgY29uZmlnIG9wdGlvbnMgc2V0IGJ5IHRoZSB1c2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29uZmlnKHBhcmFtcykge1xuXG5cdHZhbGlkYXRlQmFzaWNQYXJhbXMocGFyYW1zKTtcblx0aWYgKHR5cGVvZiBwYXJhbXMuYXBwQXV0aCA9PT0gJ29iamVjdCcpIHtcblx0XHR2YWxpZGF0ZUFwcEF1dGhQYXJhbXMocGFyYW1zLmFwcEF1dGgpO1xuXHRcdHBhcmFtcy5hcHBBdXRoID0gbWVyZ2Uoe30sIGFwcEF1dGhEZWZhdWx0cywgcGFyYW1zLmFwcEF1dGgpO1xuXHR9XG5cblx0Ly8gRW5zdXJlIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGFzc2lnbiBvdmVyIENvbmZpZyBtZXRob2RzXG5cdGFzc2VydCghcGFyYW1zLmhhc093blByb3BlcnR5KCdleHRlbmQnKSwgJ0NvbmZpZyBwYXJhbXMgbWF5IG5vdCBvdmVycmlkZSBDb25maWcgbWV0aG9kcycpO1xuXHRhc3NlcnQoIXBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnX3BhcmFtcycpLCAnQ29uZmlnIHBhcmFtcyBtYXkgbm90IG92ZXJyaWRlIENvbmZpZyBtZXRob2RzJyk7XG5cblx0Ly8gU2V0IHRoZSBnaXZlbiBwYXJhbXMgb3IgZGVmYXVsdCB2YWx1ZSBpZiBwYXJhbXMgcHJvcGVydHkgaXMgbWlzc2luZ1xuXHR0aGlzLl9wYXJhbXMgPSBtZXJnZShkZWZhdWx0cywgcGFyYW1zKTtcblx0dXBkYXRlUmVxdWVzdEFnZW50KHRoaXMuX3BhcmFtcyk7XG5cdE9iamVjdC5hc3NpZ24odGhpcywgdGhpcy5fcGFyYW1zKTtcblx0Ly8gRnJlZXplIHRoZSBvYmplY3Qgc28gdGhhdCBjb25maWd1cmF0aW9uIG9wdGlvbnMgY2Fubm90IGJlIG1vZGlmaWVkXG5cdE9iamVjdC5mcmVlemUodGhpcyk7XG59XG5cbi8qKlxuICogRXh0ZW5kIHRoZSBjdXJyZW50IGNvbmZpZyBpbnRvIGEgbmV3IGNvbmZpZyB3aXRoIG5ldyBwYXJhbXMgb3ZlcnJpZGluZyBvbGQgb25lc1xuICogQHBhcmFtIHtVc2VyQ29uZmlndXJhdGlvbk9wdGlvbnN9IHBhcmFtcyBUaGUgb3ZlcnJpZGUgb3B0aW9uc1xuICogQHJldHVybnMge0NvbmZpZ30gVGhlIGV4dGVuZGVkIGNvbmZpZ3VyYXRpb25cbiAqL1xuQ29uZmlnLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0dmFyIG5ld1BhcmFtcyA9IG1lcmdlKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcyk7XG5cdGRlbGV0ZSBuZXdQYXJhbXMuZXh0ZW5kO1xuXHRkZWxldGUgbmV3UGFyYW1zLl9wYXJhbXM7XG5cdHJldHVybiBuZXcgQ29uZmlnKG5ld1BhcmFtcyk7XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgYm94LW5vZGUtc2RrL2xpYi91dGlsL2NvbmZpZ1xuICogQHNlZSB7QExpbmsgQ29uZmlnfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IENvbmZpZztcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiaHR0cHMiLCJtZXJnZSIsInNka1ZlcnNpb24iLCJ2ZXJzaW9uIiwiUHJveHlBZ2VudCIsInVybCIsIm5vZGVWZXJzaW9uIiwicHJvY2VzcyIsImRlZmF1bHRzIiwiY2xpZW50SUQiLCJjbGllbnRTZWNyZXQiLCJhcGlSb290VVJMIiwidXBsb2FkQVBJUm9vdFVSTCIsImF1dGhvcml6ZVJvb3RVUkwiLCJhcGlWZXJzaW9uIiwidXBsb2FkUmVxdWVzdFRpbWVvdXRNUyIsInJldHJ5SW50ZXJ2YWxNUyIsIm51bU1heFJldHJpZXMiLCJyZXRyeVN0cmF0ZWd5IiwiZXhwaXJlZEJ1ZmZlck1TIiwic3RhbGVCdWZmZXJNUyIsImFwcEF1dGgiLCJ1bmRlZmluZWQiLCJpdGVyYXRvcnMiLCJlbnRlcnByaXNlSUQiLCJhbmFseXRpY3NDbGllbnQiLCJwcm94eSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJyZXF1ZXN0Iiwic3RyaWN0U1NMIiwiYWdlbnRDbGFzcyIsIkFnZW50IiwiYWdlbnRPcHRpb25zIiwia2VlcEFsaXZlIiwianNvbiIsImVuY29kaW5nIiwiZm9sbG93UmVkaXJlY3QiLCJoZWFkZXJzIiwiYXBwQXV0aERlZmF1bHRzIiwiYWxnb3JpdGhtIiwiZXhwaXJhdGlvblRpbWUiLCJ2ZXJpZnlUaW1lc3RhbXAiLCJ2YWxpZGF0ZUJhc2ljUGFyYW1zIiwicGFyYW1zIiwidmFsaWRhdGVBcHBBdXRoUGFyYW1zIiwia2V5SUQiLCJwcml2YXRlS2V5IiwiQnVmZmVyIiwicGFzc3BocmFzZSIsImxlbmd0aCIsInZhbGlkQWxnb3JpdGhtcyIsImluZGV4T2YiLCJqb2luIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwidXBkYXRlUmVxdWVzdEFnZW50IiwiT2JqZWN0IiwiYXNzaWduIiwicGFyc2UiLCJhdXRoIiwiQ29uZmlnIiwiaGFzT3duUHJvcGVydHkiLCJfcGFyYW1zIiwiZnJlZXplIiwicHJvdG90eXBlIiwiZXh0ZW5kIiwibmV3UGFyYW1zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/util/config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/util/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/util/errors.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Errors Helper\n */ \n// ------------------------------------------------------------------------------\n// Requirements\n// ------------------------------------------------------------------------------\nvar qs = __webpack_require__(/*! querystring */ \"querystring\"), httpStatusCodes = __webpack_require__(/*! http-status */ \"(rsc)/./node_modules/http-status/lib/index.js\");\nconst TRACE_ID_HEADER_NAME = \"box-request-id\";\n// ------------------------------------------------------------------------------\n// Typedefs and Callbacks\n// ------------------------------------------------------------------------------\n/**\n * An generic error propagated when the response has caused an error.\n * @typedef {Error} Errors~ResponseError\n * @property {APIRequest~ResponseObject} response The response object that generated the error\n * @property {int} statusCode A shortcut to the status code of the response\n */ /**\n * Error propagated whenever the SDK is unable to successfully complete an action\n * due to an expired access token (and refresh token, if one was provided).\n * @typedef {Errors~ResponseError} Errors~AuthError\n * @property {boolean} authExpired - always true\n */ /**\n * Request structure for error objects\n * @param {Object} req The request object\n * @constructor\n * @private\n */ function Request(req) {\n    this.method = req.method;\n    if (req.uri) {\n        this.url = {\n            protocol: req.uri.protocol,\n            host: req.uri.host,\n            path: req.uri.pathname,\n            query: qs.parse(req.uri.query),\n            fragment: req.uri.hash\n        };\n    } else {\n        this.url = null;\n    }\n    this.httpVersion = req.response ? req.response.httpVersion : null;\n    this.headers = req.headers;\n    this.body = req.body;\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * A Helper for building errors across the SDK. Makes sure that easily-forgotten\n * fields aren't missed, and that everything is formatted properly to return to the\n * consumer.\n *\n * @name Errors\n * @module box-node-sdk/lib/util/errors\n */ module.exports = {\n    /**\n\t * Build a response error with the given message, and attaching meta data from the\n\t * response data.\n\t *\n\t * @param {?APIRequest~ResponseObject} response - The response returned by an APIRequestManager request\n\t * @param {string} message - the response error message\n\t * @returns {Errors~ResponseError} an error describing the response error\n\t */ buildResponseError (response, message) {\n        response = response || {};\n        message = message || \"API Response Error\";\n        var statusCode = response.statusCode;\n        var statusMessage = httpStatusCodes[statusCode];\n        var debugID = \"\"; // Of the form <requestID>.<traceID>, both parts optional\n        var errorCode;\n        var errorDescription;\n        if (response.headers && response.headers[TRACE_ID_HEADER_NAME]) {\n            // Append trace ID with dot separator  if not present, the dot should be omitted\n            debugID += `.${response.headers[TRACE_ID_HEADER_NAME]}`;\n        }\n        if (response.body) {\n            if (response.body.request_id) {\n                // Prepend request ID\n                debugID = response.body.request_id + debugID;\n            }\n            errorCode = response.body.code || response.body.error;\n            errorDescription = response.body.message || response.body.error_description;\n        }\n        var errorMessage;\n        if (debugID) {\n            errorMessage = `${message} [${statusCode} ${statusMessage} | ${debugID}]`;\n        } else {\n            errorMessage = `${message} [${statusCode} ${statusMessage}]`;\n        }\n        if (errorCode) {\n            errorMessage += ` ${errorCode}`;\n        }\n        if (errorDescription) {\n            errorMessage += ` - ${errorDescription}`;\n        }\n        var responseError = new Error(errorMessage);\n        responseError.statusCode = response.statusCode;\n        responseError.response = response;\n        responseError.request = response.request ? new Request(response.request) : {};\n        return responseError;\n    },\n    /**\n\t * Build an authentication error. {@see Errors~AuthError}\n\t *\n\t * @param {?APIRequest~ResponseObject} response - The response returned by an APIRequestManager request\n\t * @param {string} [message] - Optional message for the error\n\t * @returns {Errors~AuthError} A properly formatted authentication error\n\t */ buildAuthError (response, message) {\n        message = message || \"Expired Auth: Auth code or refresh token has expired\";\n        var responseError = this.buildResponseError(response, message);\n        responseError.authExpired = true;\n        return responseError;\n    },\n    /**\n\t * Build the error for an \"Unexpected Response\" from the API. This is a shortcut for\n\t * responseError built specifically for the 401 UNEXPECTED response case. It\n\t * should be called and the error should be propogated to the consumer\n\t * whenever an unexpected response was recieved from the API.\n\t *\n\t * @param {?APIRequest~ResponseObject} response - The response returned by an APIRequestManager request\n\t * @returns {Errors~ResponseError} an error describing the response error\n\t */ buildUnexpectedResponseError (response) {\n        return this.buildResponseError(response, \"Unexpected API Response\");\n    },\n    /**\n\t * Unwrap a Bluebird error and throw it, or just re-throw if the error\n\t * is not a Bluebird error.  This is necessary to preserve errors when\n\t * a function is promisified.\n\t * @param {Error} error The error to unwrap\n\t * @returns {void}\n\t * @throws {Error} The unwrapped error\n\t */ unwrapAndThrow (error) {\n        if (error.cause) {\n            throw error.cause;\n        }\n        throw error;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi91dGlsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsaUZBQWlGO0FBQ2pGLGVBQWU7QUFDZixpRkFBaUY7QUFDakYsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUMsbUNBQ2hCQyxrQkFBa0JELG1CQUFPQSxDQUFDO0FBRTNCLE1BQU1FLHVCQUF1QjtBQUU3QixpRkFBaUY7QUFDakYseUJBQXlCO0FBQ3pCLGlGQUFpRjtBQUVqRjs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBRUQ7Ozs7O0NBS0MsR0FDRCxTQUFTQyxRQUFRQyxHQUFHO0lBQ25CLElBQUksQ0FBQ0MsTUFBTSxHQUFHRCxJQUFJQyxNQUFNO0lBQ3hCLElBQUlELElBQUlFLEdBQUcsRUFBRTtRQUNaLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1lBQ1ZDLFVBQVVKLElBQUlFLEdBQUcsQ0FBQ0UsUUFBUTtZQUMxQkMsTUFBTUwsSUFBSUUsR0FBRyxDQUFDRyxJQUFJO1lBQ2xCQyxNQUFNTixJQUFJRSxHQUFHLENBQUNLLFFBQVE7WUFDdEJDLE9BQU9iLEdBQUdjLEtBQUssQ0FBQ1QsSUFBSUUsR0FBRyxDQUFDTSxLQUFLO1lBQzdCRSxVQUFVVixJQUFJRSxHQUFHLENBQUNTLElBQUk7UUFDdkI7SUFDRCxPQUFPO1FBQ04sSUFBSSxDQUFDUixHQUFHLEdBQUc7SUFDWjtJQUNBLElBQUksQ0FBQ1MsV0FBVyxHQUFHWixJQUFJYSxRQUFRLEdBQUdiLElBQUlhLFFBQVEsQ0FBQ0QsV0FBVyxHQUFHO0lBQzdELElBQUksQ0FBQ0UsT0FBTyxHQUFHZCxJQUFJYyxPQUFPO0lBQzFCLElBQUksQ0FBQ0MsSUFBSSxHQUFHZixJQUFJZSxJQUFJO0FBQ3JCO0FBRUEsaUZBQWlGO0FBQ2pGLFNBQVM7QUFDVCxpRkFBaUY7QUFFakY7Ozs7Ozs7Q0FPQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUc7SUFFaEI7Ozs7Ozs7RUFPQyxHQUNEQyxvQkFBbUJMLFFBQVEsRUFBRU0sT0FBTztRQUNuQ04sV0FBV0EsWUFBWSxDQUFDO1FBQ3hCTSxVQUFVQSxXQUFXO1FBRXJCLElBQUlDLGFBQWFQLFNBQVNPLFVBQVU7UUFDcEMsSUFBSUMsZ0JBQWdCeEIsZUFBZSxDQUFDdUIsV0FBVztRQUMvQyxJQUFJRSxVQUFVLElBQUkseURBQXlEO1FBQzNFLElBQUlDO1FBQ0osSUFBSUM7UUFFSixJQUFJWCxTQUFTQyxPQUFPLElBQUlELFNBQVNDLE9BQU8sQ0FBQ2hCLHFCQUFxQixFQUFFO1lBQy9ELGlGQUFpRjtZQUNqRndCLFdBQVcsQ0FBQyxDQUFDLEVBQUVULFNBQVNDLE9BQU8sQ0FBQ2hCLHFCQUFxQixDQUFDLENBQUM7UUFDeEQ7UUFHQSxJQUFJZSxTQUFTRSxJQUFJLEVBQUU7WUFFbEIsSUFBSUYsU0FBU0UsSUFBSSxDQUFDVSxVQUFVLEVBQUU7Z0JBQzdCLHFCQUFxQjtnQkFDckJILFVBQVVULFNBQVNFLElBQUksQ0FBQ1UsVUFBVSxHQUFHSDtZQUN0QztZQUVBQyxZQUFZVixTQUFTRSxJQUFJLENBQUNXLElBQUksSUFBSWIsU0FBU0UsSUFBSSxDQUFDWSxLQUFLO1lBQ3JESCxtQkFBbUJYLFNBQVNFLElBQUksQ0FBQ0ksT0FBTyxJQUFJTixTQUFTRSxJQUFJLENBQUNhLGlCQUFpQjtRQUM1RTtRQUVBLElBQUlDO1FBQ0osSUFBSVAsU0FBUztZQUNaTyxlQUFlLENBQUMsRUFBRVYsUUFBUSxFQUFFLEVBQUVDLFdBQVcsQ0FBQyxFQUFFQyxjQUFjLEdBQUcsRUFBRUMsUUFBUSxDQUFDLENBQUM7UUFDMUUsT0FBTztZQUNOTyxlQUFlLENBQUMsRUFBRVYsUUFBUSxFQUFFLEVBQUVDLFdBQVcsQ0FBQyxFQUFFQyxjQUFjLENBQUMsQ0FBQztRQUM3RDtRQUVBLElBQUlFLFdBQVc7WUFDZE0sZ0JBQWdCLENBQUMsQ0FBQyxFQUFFTixVQUFVLENBQUM7UUFDaEM7UUFDQSxJQUFJQyxrQkFBa0I7WUFDckJLLGdCQUFnQixDQUFDLEdBQUcsRUFBRUwsaUJBQWlCLENBQUM7UUFDekM7UUFFQSxJQUFJTSxnQkFBZ0IsSUFBSUMsTUFBTUY7UUFFOUJDLGNBQWNWLFVBQVUsR0FBR1AsU0FBU08sVUFBVTtRQUM5Q1UsY0FBY2pCLFFBQVEsR0FBR0E7UUFDekJpQixjQUFjRSxPQUFPLEdBQUduQixTQUFTbUIsT0FBTyxHQUFHLElBQUlqQyxRQUFRYyxTQUFTbUIsT0FBTyxJQUFJLENBQUM7UUFFNUUsT0FBT0Y7SUFDUjtJQUVBOzs7Ozs7RUFNQyxHQUNERyxnQkFBZXBCLFFBQVEsRUFBRU0sT0FBTztRQUUvQkEsVUFBVUEsV0FBVztRQUNyQixJQUFJVyxnQkFBZ0IsSUFBSSxDQUFDWixrQkFBa0IsQ0FBQ0wsVUFBVU07UUFDdERXLGNBQWNJLFdBQVcsR0FBRztRQUM1QixPQUFPSjtJQUNSO0lBRUE7Ozs7Ozs7O0VBUUMsR0FDREssOEJBQTZCdEIsUUFBUTtRQUNwQyxPQUFPLElBQUksQ0FBQ0ssa0JBQWtCLENBQUNMLFVBQVU7SUFDMUM7SUFFQTs7Ozs7OztFQU9DLEdBQ0R1QixnQkFBZVQsS0FBSztRQUVuQixJQUFJQSxNQUFNVSxLQUFLLEVBQUU7WUFDaEIsTUFBTVYsTUFBTVUsS0FBSztRQUNsQjtRQUVBLE1BQU1WO0lBQ1A7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvdXRpbC9lcnJvcnMuanM/ODEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXJyb3JzIEhlbHBlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1aXJlbWVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKSxcblx0aHR0cFN0YXR1c0NvZGVzID0gcmVxdWlyZSgnaHR0cC1zdGF0dXMnKTtcblxuY29uc3QgVFJBQ0VfSURfSEVBREVSX05BTUUgPSAnYm94LXJlcXVlc3QtaWQnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzIGFuZCBDYWxsYmFja3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFuIGdlbmVyaWMgZXJyb3IgcHJvcGFnYXRlZCB3aGVuIHRoZSByZXNwb25zZSBoYXMgY2F1c2VkIGFuIGVycm9yLlxuICogQHR5cGVkZWYge0Vycm9yfSBFcnJvcnN+UmVzcG9uc2VFcnJvclxuICogQHByb3BlcnR5IHtBUElSZXF1ZXN0flJlc3BvbnNlT2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIHRoZSBlcnJvclxuICogQHByb3BlcnR5IHtpbnR9IHN0YXR1c0NvZGUgQSBzaG9ydGN1dCB0byB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlXG4gKi9cblxuLyoqXG4gKiBFcnJvciBwcm9wYWdhdGVkIHdoZW5ldmVyIHRoZSBTREsgaXMgdW5hYmxlIHRvIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZSBhbiBhY3Rpb25cbiAqIGR1ZSB0byBhbiBleHBpcmVkIGFjY2VzcyB0b2tlbiAoYW5kIHJlZnJlc2ggdG9rZW4sIGlmIG9uZSB3YXMgcHJvdmlkZWQpLlxuICogQHR5cGVkZWYge0Vycm9yc35SZXNwb25zZUVycm9yfSBFcnJvcnN+QXV0aEVycm9yXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGF1dGhFeHBpcmVkIC0gYWx3YXlzIHRydWVcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3Qgc3RydWN0dXJlIGZvciBlcnJvciBvYmplY3RzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBSZXF1ZXN0KHJlcSkge1xuXHR0aGlzLm1ldGhvZCA9IHJlcS5tZXRob2Q7XG5cdGlmIChyZXEudXJpKSB7XG5cdFx0dGhpcy51cmwgPSB7XG5cdFx0XHRwcm90b2NvbDogcmVxLnVyaS5wcm90b2NvbCxcblx0XHRcdGhvc3Q6IHJlcS51cmkuaG9zdCxcblx0XHRcdHBhdGg6IHJlcS51cmkucGF0aG5hbWUsXG5cdFx0XHRxdWVyeTogcXMucGFyc2UocmVxLnVyaS5xdWVyeSksXG5cdFx0XHRmcmFnbWVudDogcmVxLnVyaS5oYXNoXG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLnVybCA9IG51bGw7XG5cdH1cblx0dGhpcy5odHRwVmVyc2lvbiA9IHJlcS5yZXNwb25zZSA/IHJlcS5yZXNwb25zZS5odHRwVmVyc2lvbiA6IG51bGw7XG5cdHRoaXMuaGVhZGVycyA9IHJlcS5oZWFkZXJzO1xuXHR0aGlzLmJvZHkgPSByZXEuYm9keTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQdWJsaWNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEEgSGVscGVyIGZvciBidWlsZGluZyBlcnJvcnMgYWNyb3NzIHRoZSBTREsuIE1ha2VzIHN1cmUgdGhhdCBlYXNpbHktZm9yZ290dGVuXG4gKiBmaWVsZHMgYXJlbid0IG1pc3NlZCwgYW5kIHRoYXQgZXZlcnl0aGluZyBpcyBmb3JtYXR0ZWQgcHJvcGVybHkgdG8gcmV0dXJuIHRvIHRoZVxuICogY29uc3VtZXIuXG4gKlxuICogQG5hbWUgRXJyb3JzXG4gKiBAbW9kdWxlIGJveC1ub2RlLXNkay9saWIvdXRpbC9lcnJvcnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG5cblx0LyoqXG5cdCAqIEJ1aWxkIGEgcmVzcG9uc2UgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSwgYW5kIGF0dGFjaGluZyBtZXRhIGRhdGEgZnJvbSB0aGVcblx0ICogcmVzcG9uc2UgZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHs/QVBJUmVxdWVzdH5SZXNwb25zZU9iamVjdH0gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2UgcmV0dXJuZWQgYnkgYW4gQVBJUmVxdWVzdE1hbmFnZXIgcmVxdWVzdFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIHRoZSByZXNwb25zZSBlcnJvciBtZXNzYWdlXG5cdCAqIEByZXR1cm5zIHtFcnJvcnN+UmVzcG9uc2VFcnJvcn0gYW4gZXJyb3IgZGVzY3JpYmluZyB0aGUgcmVzcG9uc2UgZXJyb3Jcblx0ICovXG5cdGJ1aWxkUmVzcG9uc2VFcnJvcihyZXNwb25zZSwgbWVzc2FnZSkge1xuXHRcdHJlc3BvbnNlID0gcmVzcG9uc2UgfHwge307XG5cdFx0bWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0FQSSBSZXNwb25zZSBFcnJvcic7XG5cblx0XHR2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG5cdFx0dmFyIHN0YXR1c01lc3NhZ2UgPSBodHRwU3RhdHVzQ29kZXNbc3RhdHVzQ29kZV07XG5cdFx0dmFyIGRlYnVnSUQgPSAnJzsgLy8gT2YgdGhlIGZvcm0gPHJlcXVlc3RJRD4uPHRyYWNlSUQ+LCBib3RoIHBhcnRzIG9wdGlvbmFsXG5cdFx0dmFyIGVycm9yQ29kZTtcblx0XHR2YXIgZXJyb3JEZXNjcmlwdGlvbjtcblxuXHRcdGlmIChyZXNwb25zZS5oZWFkZXJzICYmIHJlc3BvbnNlLmhlYWRlcnNbVFJBQ0VfSURfSEVBREVSX05BTUVdKSB7XG5cdFx0XHQvLyBBcHBlbmQgdHJhY2UgSUQgd2l0aCBkb3Qgc2VwYXJhdG9yIOKAlCBpZiBub3QgcHJlc2VudCwgdGhlIGRvdCBzaG91bGQgYmUgb21pdHRlZFxuXHRcdFx0ZGVidWdJRCArPSBgLiR7cmVzcG9uc2UuaGVhZGVyc1tUUkFDRV9JRF9IRUFERVJfTkFNRV19YDtcblx0XHR9XG5cblxuXHRcdGlmIChyZXNwb25zZS5ib2R5KSB7XG5cblx0XHRcdGlmIChyZXNwb25zZS5ib2R5LnJlcXVlc3RfaWQpIHtcblx0XHRcdFx0Ly8gUHJlcGVuZCByZXF1ZXN0IElEXG5cdFx0XHRcdGRlYnVnSUQgPSByZXNwb25zZS5ib2R5LnJlcXVlc3RfaWQgKyBkZWJ1Z0lEO1xuXHRcdFx0fVxuXG5cdFx0XHRlcnJvckNvZGUgPSByZXNwb25zZS5ib2R5LmNvZGUgfHwgcmVzcG9uc2UuYm9keS5lcnJvcjtcblx0XHRcdGVycm9yRGVzY3JpcHRpb24gPSByZXNwb25zZS5ib2R5Lm1lc3NhZ2UgfHwgcmVzcG9uc2UuYm9keS5lcnJvcl9kZXNjcmlwdGlvbjtcblx0XHR9XG5cblx0XHR2YXIgZXJyb3JNZXNzYWdlO1xuXHRcdGlmIChkZWJ1Z0lEKSB7XG5cdFx0XHRlcnJvck1lc3NhZ2UgPSBgJHttZXNzYWdlfSBbJHtzdGF0dXNDb2RlfSAke3N0YXR1c01lc3NhZ2V9IHwgJHtkZWJ1Z0lEfV1gO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlcnJvck1lc3NhZ2UgPSBgJHttZXNzYWdlfSBbJHtzdGF0dXNDb2RlfSAke3N0YXR1c01lc3NhZ2V9XWA7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yQ29kZSkge1xuXHRcdFx0ZXJyb3JNZXNzYWdlICs9IGAgJHtlcnJvckNvZGV9YDtcblx0XHR9XG5cdFx0aWYgKGVycm9yRGVzY3JpcHRpb24pIHtcblx0XHRcdGVycm9yTWVzc2FnZSArPSBgIC0gJHtlcnJvckRlc2NyaXB0aW9ufWA7XG5cdFx0fVxuXG5cdFx0dmFyIHJlc3BvbnNlRXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblxuXHRcdHJlc3BvbnNlRXJyb3Iuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG5cdFx0cmVzcG9uc2VFcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuXHRcdHJlc3BvbnNlRXJyb3IucmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3QgPyBuZXcgUmVxdWVzdChyZXNwb25zZS5yZXF1ZXN0KSA6IHt9O1xuXG5cdFx0cmV0dXJuIHJlc3BvbnNlRXJyb3I7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEJ1aWxkIGFuIGF1dGhlbnRpY2F0aW9uIGVycm9yLiB7QHNlZSBFcnJvcnN+QXV0aEVycm9yfVxuXHQgKlxuXHQgKiBAcGFyYW0gez9BUElSZXF1ZXN0flJlc3BvbnNlT2JqZWN0fSByZXNwb25zZSAtIFRoZSByZXNwb25zZSByZXR1cm5lZCBieSBhbiBBUElSZXF1ZXN0TWFuYWdlciByZXF1ZXN0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gLSBPcHRpb25hbCBtZXNzYWdlIGZvciB0aGUgZXJyb3Jcblx0ICogQHJldHVybnMge0Vycm9yc35BdXRoRXJyb3J9IEEgcHJvcGVybHkgZm9ybWF0dGVkIGF1dGhlbnRpY2F0aW9uIGVycm9yXG5cdCAqL1xuXHRidWlsZEF1dGhFcnJvcihyZXNwb25zZSwgbWVzc2FnZSkge1xuXG5cdFx0bWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0V4cGlyZWQgQXV0aDogQXV0aCBjb2RlIG9yIHJlZnJlc2ggdG9rZW4gaGFzIGV4cGlyZWQnO1xuXHRcdHZhciByZXNwb25zZUVycm9yID0gdGhpcy5idWlsZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UsIG1lc3NhZ2UpO1xuXHRcdHJlc3BvbnNlRXJyb3IuYXV0aEV4cGlyZWQgPSB0cnVlO1xuXHRcdHJldHVybiByZXNwb25zZUVycm9yO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBCdWlsZCB0aGUgZXJyb3IgZm9yIGFuIFwiVW5leHBlY3RlZCBSZXNwb25zZVwiIGZyb20gdGhlIEFQSS4gVGhpcyBpcyBhIHNob3J0Y3V0IGZvclxuXHQgKiByZXNwb25zZUVycm9yIGJ1aWx0IHNwZWNpZmljYWxseSBmb3IgdGhlIDQwMSBVTkVYUEVDVEVEIHJlc3BvbnNlIGNhc2UuIEl0XG5cdCAqIHNob3VsZCBiZSBjYWxsZWQgYW5kIHRoZSBlcnJvciBzaG91bGQgYmUgcHJvcG9nYXRlZCB0byB0aGUgY29uc3VtZXJcblx0ICogd2hlbmV2ZXIgYW4gdW5leHBlY3RlZCByZXNwb25zZSB3YXMgcmVjaWV2ZWQgZnJvbSB0aGUgQVBJLlxuXHQgKlxuXHQgKiBAcGFyYW0gez9BUElSZXF1ZXN0flJlc3BvbnNlT2JqZWN0fSByZXNwb25zZSAtIFRoZSByZXNwb25zZSByZXR1cm5lZCBieSBhbiBBUElSZXF1ZXN0TWFuYWdlciByZXF1ZXN0XG5cdCAqIEByZXR1cm5zIHtFcnJvcnN+UmVzcG9uc2VFcnJvcn0gYW4gZXJyb3IgZGVzY3JpYmluZyB0aGUgcmVzcG9uc2UgZXJyb3Jcblx0ICovXG5cdGJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpIHtcblx0XHRyZXR1cm4gdGhpcy5idWlsZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UsICdVbmV4cGVjdGVkIEFQSSBSZXNwb25zZScpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVbndyYXAgYSBCbHVlYmlyZCBlcnJvciBhbmQgdGhyb3cgaXQsIG9yIGp1c3QgcmUtdGhyb3cgaWYgdGhlIGVycm9yXG5cdCAqIGlzIG5vdCBhIEJsdWViaXJkIGVycm9yLiAgVGhpcyBpcyBuZWNlc3NhcnkgdG8gcHJlc2VydmUgZXJyb3JzIHdoZW5cblx0ICogYSBmdW5jdGlvbiBpcyBwcm9taXNpZmllZC5cblx0ICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVud3JhcFxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQHRocm93cyB7RXJyb3J9IFRoZSB1bndyYXBwZWQgZXJyb3Jcblx0ICovXG5cdHVud3JhcEFuZFRocm93KGVycm9yKSB7XG5cblx0XHRpZiAoZXJyb3IuY2F1c2UpIHtcblx0XHRcdHRocm93IGVycm9yLmNhdXNlO1xuXHRcdH1cblxuXHRcdHRocm93IGVycm9yO1xuXHR9XG5cbn07XG4iXSwibmFtZXMiOlsicXMiLCJyZXF1aXJlIiwiaHR0cFN0YXR1c0NvZGVzIiwiVFJBQ0VfSURfSEVBREVSX05BTUUiLCJSZXF1ZXN0IiwicmVxIiwibWV0aG9kIiwidXJpIiwidXJsIiwicHJvdG9jb2wiLCJob3N0IiwicGF0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJwYXJzZSIsImZyYWdtZW50IiwiaGFzaCIsImh0dHBWZXJzaW9uIiwicmVzcG9uc2UiLCJoZWFkZXJzIiwiYm9keSIsIm1vZHVsZSIsImV4cG9ydHMiLCJidWlsZFJlc3BvbnNlRXJyb3IiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsInN0YXR1c01lc3NhZ2UiLCJkZWJ1Z0lEIiwiZXJyb3JDb2RlIiwiZXJyb3JEZXNjcmlwdGlvbiIsInJlcXVlc3RfaWQiLCJjb2RlIiwiZXJyb3IiLCJlcnJvcl9kZXNjcmlwdGlvbiIsImVycm9yTWVzc2FnZSIsInJlc3BvbnNlRXJyb3IiLCJFcnJvciIsInJlcXVlc3QiLCJidWlsZEF1dGhFcnJvciIsImF1dGhFeHBpcmVkIiwiYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsInVud3JhcEFuZFRocm93IiwiY2F1c2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/util/exponential-backoff.js":
/*!*******************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/util/exponential-backoff.js ***!
  \*******************************************************************/
/***/ ((module) => {

eval("/**\n * @fileoverview Calculate exponential backoff time\n */ \n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// Retry intervals are between 50% and 150% of the exponentially increasing base amount\nconst RETRY_RANDOMIZATION_FACTOR = 0.5;\n/**\n * Calculate the exponential backoff time with randomized jitter\n * @param {int} numRetries Which retry number this one will be\n * @param {int} baseInterval The base retry interval set in config\n * @returns {int} The number of milliseconds after which to retry\n */ function getRetryTimeout(numRetries, baseInterval) {\n    var minRandomization = 1 - RETRY_RANDOMIZATION_FACTOR;\n    var maxRandomization = 1 + RETRY_RANDOMIZATION_FACTOR;\n    var randomization = Math.random() * (maxRandomization - minRandomization) + minRandomization;\n    var exponential = Math.pow(2, numRetries - 1);\n    return Math.ceil(exponential * baseInterval * randomization);\n}\nmodule.exports = getRetryTimeout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi91dGlsL2V4cG9uZW50aWFsLWJhY2tvZmYuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBLGlGQUFpRjtBQUNqRixVQUFVO0FBQ1YsaUZBQWlGO0FBRWpGLHVGQUF1RjtBQUN2RixNQUFNQSw2QkFBNkI7QUFFbkM7Ozs7O0NBS0MsR0FDRCxTQUFTQyxnQkFBZ0JDLFVBQVUsRUFBRUMsWUFBWTtJQUVoRCxJQUFJQyxtQkFBbUIsSUFBSUo7SUFDM0IsSUFBSUssbUJBQW1CLElBQUlMO0lBQzNCLElBQUlNLGdCQUFnQixLQUFNRSxNQUFNLEtBQU1ILENBQUFBLG1CQUFtQkQsZ0JBQWUsSUFBTUE7SUFDOUUsSUFBSUssY0FBY0YsS0FBS0csR0FBRyxDQUFDLEdBQUdSLGFBQWE7SUFDM0MsT0FBT0ssS0FBS0ksSUFBSSxDQUFDRixjQUFjTixlQUFlRztBQUMvQztBQUVBTSxPQUFPQyxPQUFPLEdBQUdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi91dGlsL2V4cG9uZW50aWFsLWJhY2tvZmYuanM/MzRiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgQ2FsY3VsYXRlIGV4cG9uZW50aWFsIGJhY2tvZmYgdGltZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUmV0cnkgaW50ZXJ2YWxzIGFyZSBiZXR3ZWVuIDUwJSBhbmQgMTUwJSBvZiB0aGUgZXhwb25lbnRpYWxseSBpbmNyZWFzaW5nIGJhc2UgYW1vdW50XG5jb25zdCBSRVRSWV9SQU5ET01JWkFUSU9OX0ZBQ1RPUiA9IDAuNTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIGJhY2tvZmYgdGltZSB3aXRoIHJhbmRvbWl6ZWQgaml0dGVyXG4gKiBAcGFyYW0ge2ludH0gbnVtUmV0cmllcyBXaGljaCByZXRyeSBudW1iZXIgdGhpcyBvbmUgd2lsbCBiZVxuICogQHBhcmFtIHtpbnR9IGJhc2VJbnRlcnZhbCBUaGUgYmFzZSByZXRyeSBpbnRlcnZhbCBzZXQgaW4gY29uZmlnXG4gKiBAcmV0dXJucyB7aW50fSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0byByZXRyeVxuICovXG5mdW5jdGlvbiBnZXRSZXRyeVRpbWVvdXQobnVtUmV0cmllcywgYmFzZUludGVydmFsKSB7XG5cblx0dmFyIG1pblJhbmRvbWl6YXRpb24gPSAxIC0gUkVUUllfUkFORE9NSVpBVElPTl9GQUNUT1I7XG5cdHZhciBtYXhSYW5kb21pemF0aW9uID0gMSArIFJFVFJZX1JBTkRPTUlaQVRJT05fRkFDVE9SO1xuXHR2YXIgcmFuZG9taXphdGlvbiA9IChNYXRoLnJhbmRvbSgpICogKG1heFJhbmRvbWl6YXRpb24gLSBtaW5SYW5kb21pemF0aW9uKSkgKyBtaW5SYW5kb21pemF0aW9uO1xuXHR2YXIgZXhwb25lbnRpYWwgPSBNYXRoLnBvdygyLCBudW1SZXRyaWVzIC0gMSk7XG5cdHJldHVybiBNYXRoLmNlaWwoZXhwb25lbnRpYWwgKiBiYXNlSW50ZXJ2YWwgKiByYW5kb21pemF0aW9uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSZXRyeVRpbWVvdXQ7XG4iXSwibmFtZXMiOlsiUkVUUllfUkFORE9NSVpBVElPTl9GQUNUT1IiLCJnZXRSZXRyeVRpbWVvdXQiLCJudW1SZXRyaWVzIiwiYmFzZUludGVydmFsIiwibWluUmFuZG9taXphdGlvbiIsIm1heFJhbmRvbWl6YXRpb24iLCJyYW5kb21pemF0aW9uIiwiTWF0aCIsInJhbmRvbSIsImV4cG9uZW50aWFsIiwicG93IiwiY2VpbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/util/exponential-backoff.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/util/paging-iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/util/paging-iterator.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Iterator for paged responses\n */ \n// -----------------------------------------------------------------------------\n// Typedefs\n// -----------------------------------------------------------------------------\n/**\n * The iterator response object\n * @typedef {Object} IteratorData\n * @property {Array} [value] - The next set of values from the iterator\n * @property {boolean} done - Whether the iterator is completed\n */ /**\n * Iterator callback\n * @callback IteratorCallback\n * @param {?Error} err - An error if the iterator encountered one\n * @param {IteratorData} [data] - New data from the iterator\n * @returns {void}\n */ // -----------------------------------------------------------------------------\n// Requirements\n// -----------------------------------------------------------------------------\nvar querystring = __webpack_require__(/*! querystring */ \"querystring\"), Promise = __webpack_require__(/*! bluebird */ \"(rsc)/./node_modules/bluebird/js/release/bluebird.js\"), PromiseQueue = __webpack_require__(/*! promise-queue */ \"(rsc)/./node_modules/promise-queue/index.js\"), errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/box-node-sdk/lib/util/errors.js\");\nPromiseQueue.configure(Promise);\n// -----------------------------------------------------------------------------\n// Private\n// -----------------------------------------------------------------------------\nconst PAGING_MODES = Object.freeze({\n    MARKER: \"marker\",\n    OFFSET: \"offset\"\n});\n// -----------------------------------------------------------------------------\n// Public\n// -----------------------------------------------------------------------------\n/**\n * Asynchronous iterator for paged collections\n */ class PagingIterator {\n    /**\n\t * Determine if a response is iterable\n\t * @param {Object} response - The API response\n\t * @returns {boolean} Whether the response is iterable\n\t */ static isIterable(response) {\n        // POST responses for uploading a file are explicitly excluded here because, while the response is iterable,\n        // it always contains only a single entry and historically has not been handled as iterable in the SDK.\n        // This behavior is being preserved here to avoid a breaking change.\n        let UPLOAD_PATTERN = /.*upload\\.box\\.com.*\\/content/;\n        var isGetOrPostRequest = response.request && (response.request.method === \"GET\" || response.request.method === \"POST\" && !UPLOAD_PATTERN.test(response.request.uri.href)), hasEntries = response.body && Array.isArray(response.body.entries), notEventStream = response.body && !response.body.next_stream_position;\n        return Boolean(isGetOrPostRequest && hasEntries && notEventStream);\n    }\n    /**\n\t * @constructor\n\t * @param {Object} response - The original API response\n\t * @param {BoxClient} client - An API client to make further requests\n\t * @returns {void}\n\t * @throws {Error} Will throw when collection cannot be paged\n\t */ constructor(response, client){\n        if (!PagingIterator.isIterable(response)) {\n            throw new Error(\"Cannot create paging iterator for non-paged response!\");\n        }\n        var data = response.body;\n        if (Number.isSafeInteger(data.offset)) {\n            this.nextField = PAGING_MODES.OFFSET;\n            this.nextValue = data.offset;\n        } else if (typeof data.next_marker === \"undefined\") {\n            // Default to a finished marker collection when there's no field present,\n            // since some endpoints indicate completed paging this way\n            this.nextField = PAGING_MODES.MARKER;\n            this.nextValue = null;\n        } else {\n            this.nextField = PAGING_MODES.MARKER;\n            this.nextValue = data.next_marker;\n        }\n        this.limit = data.limit || data.entries.length;\n        this.done = false;\n        var href = response.request.href.split(\"?\")[0];\n        this.options = {\n            headers: response.request.headers,\n            qs: querystring.parse(response.request.uri.query)\n        };\n        if (response.request.body) {\n            if (Object.prototype.toString.call(response.request.body) === \"[object Object]\") {\n                this.options.body = response.request.body;\n            } else {\n                this.options.body = JSON.parse(response.request.body);\n            }\n        }\n        // querystring.parse() makes everything a string, ensure numeric params are the correct type\n        if (this.options.qs.limit) {\n            this.options.qs.limit = parseInt(this.options.qs.limit, 10);\n        }\n        if (this.options.qs.offset) {\n            this.options.qs.offset = parseInt(this.options.qs.offset, 10);\n        }\n        delete this.options.headers.Authorization;\n        if (response.request.method === \"GET\") {\n            this.fetch = client.get.bind(client, href);\n        }\n        if (response.request.method === \"POST\") {\n            this.fetch = client.post.bind(client, href);\n        }\n        this.buffer = response.body.entries;\n        this.queue = new PromiseQueue(1, Infinity);\n        this._updatePaging(response);\n    }\n    /**\n\t * Update the paging parameters for the iterator\n\t * @private\n\t * @param {Object} response - The latest API response\n\t * @returns {void}\n\t */ _updatePaging(response) {\n        var data = response.body;\n        if (this.nextField === PAGING_MODES.OFFSET) {\n            this.nextValue += this.limit;\n            if (Number.isSafeInteger(data.total_count)) {\n                this.done = data.offset + this.limit >= data.total_count;\n            } else {\n                this.done = data.entries.length === 0;\n            }\n        } else if (this.nextField === PAGING_MODES.MARKER) {\n            if (data.next_marker) {\n                this.nextValue = data.next_marker;\n            } else {\n                this.nextValue = null;\n                this.done = true;\n            }\n        }\n        if (response.request.method === \"GET\") {\n            this.options.qs[this.nextField] = this.nextValue;\n        } else if (response.request.method === \"POST\") {\n            if (!this.options.body) {\n                this.options.body = {};\n            }\n            this.options.body[this.nextField] = this.nextValue;\n            let bodyString = JSON.stringify(this.options.body);\n            this.options.headers[\"content-length\"] = bodyString.length;\n        }\n    }\n    /**\n\t * Fetch the next page of results\n\t * @returns {Promise} Promise resolving to iterator state\n\t */ _getData() {\n        return this.fetch(this.options).then((response)=>{\n            if (response.statusCode !== 200) {\n                throw errors.buildUnexpectedResponseError(response);\n            }\n            this._updatePaging(response);\n            this.buffer = this.buffer.concat(response.body.entries);\n            if (this.buffer.length === 0) {\n                if (this.done) {\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                }\n                // If we didn't get any data in this page, but the paging\n                // parameters indicate that there is more data, attempt\n                // to fetch more.  This occurs in multiple places in the API\n                return this._getData();\n            }\n            return {\n                value: this.buffer.shift(),\n                done: false\n            };\n        });\n    }\n    /**\n\t * Fetch the next page of the collection\n\t * @returns {Promise} Promise resolving to iterator state\n\t */ next() {\n        if (this.buffer.length > 0) {\n            return Promise.resolve({\n                value: this.buffer.shift(),\n                done: false\n            });\n        }\n        if (this.done) {\n            return Promise.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        return this.queue.add(this._getData.bind(this));\n    }\n    /**\n\t * Fetch the next marker\n\t * @returns {string|int} String that is the next marker or int that is the next offset\n\t */ getNextMarker() {\n        return this.nextValue;\n    }\n}\nmodule.exports = PagingIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi91dGlsL3BhZ2luZy1pdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUVEO0FBRUEsZ0ZBQWdGO0FBQ2hGLFdBQVc7QUFDWCxnRkFBZ0Y7QUFFaEY7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FFRCxnRkFBZ0Y7QUFDaEYsZUFBZTtBQUNmLGdGQUFnRjtBQUVoRixJQUFJQSxjQUFjQyxtQkFBT0EsQ0FBQyxtQ0FDekJDLFVBQVVELG1CQUFPQSxDQUFDLHlFQUNsQkUsZUFBZUYsbUJBQU9BLENBQUMscUVBQ3ZCRyxTQUFTSCxtQkFBT0EsQ0FBQztBQUVsQkUsYUFBYUUsU0FBUyxDQUFDSDtBQUV2QixnRkFBZ0Y7QUFDaEYsVUFBVTtBQUNWLGdGQUFnRjtBQUVoRixNQUFNSSxlQUFlQyxPQUFPQyxNQUFNLENBQUM7SUFDbENDLFFBQVE7SUFDUkMsUUFBUTtBQUNUO0FBRUEsZ0ZBQWdGO0FBQ2hGLFNBQVM7QUFDVCxnRkFBZ0Y7QUFFaEY7O0NBRUMsR0FDRCxNQUFNQztJQUVMOzs7O0VBSUMsR0FDRCxPQUFPQyxXQUFXQyxRQUFRLEVBQUU7UUFDM0IsNEdBQTRHO1FBQzVHLHVHQUF1RztRQUN2RyxvRUFBb0U7UUFDcEUsSUFBSUMsaUJBQWlCO1FBQ3JCLElBQUlDLHFCQUFzQkYsU0FBU0csT0FBTyxJQUFLSCxDQUFBQSxTQUFTRyxPQUFPLENBQUNDLE1BQU0sS0FBSyxTQUFVSixTQUFTRyxPQUFPLENBQUNDLE1BQU0sS0FBSyxVQUFVLENBQUNILGVBQWVJLElBQUksQ0FBQ0wsU0FBU0csT0FBTyxDQUFDRyxHQUFHLENBQUNDLElBQUksQ0FBQyxHQUN6S0MsYUFBY1IsU0FBU1MsSUFBSSxJQUFJQyxNQUFNQyxPQUFPLENBQUNYLFNBQVNTLElBQUksQ0FBQ0csT0FBTyxHQUNsRUMsaUJBQWtCYixTQUFTUyxJQUFJLElBQUksQ0FBQ1QsU0FBU1MsSUFBSSxDQUFDSyxvQkFBb0I7UUFF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T0FBTyxDQUFDO2dCQUN0QkosT0FBTyxJQUFJLENBQUNaLE1BQU0sQ0FBQ2MsS0FBSztnQkFDeEIvQixNQUFNO1lBQ1A7UUFDRDtRQUVBLElBQUksSUFBSSxDQUFDQSxJQUFJLEVBQUU7WUFFZCxPQUFPdkMsUUFBUXdFLE9BQU8sQ0FBQztnQkFDdEJKLE9BQU9DO2dCQUNQOUIsTUFBTTtZQUNQO1FBQ0Q7UUFFQSxPQUFPLElBQUksQ0FBQ2tCLEtBQUssQ0FBQ2dCLEdBQUcsQ0FBQyxJQUFJLENBQUNWLFFBQVEsQ0FBQ1QsSUFBSSxDQUFDLElBQUk7SUFDOUM7SUFFQTs7O0VBR0MsR0FDRG9CLGdCQUFnQjtRQUNmLE9BQU8sSUFBSSxDQUFDdkMsU0FBUztJQUN0QjtBQUNEO0FBRUF3QyxPQUFPQyxPQUFPLEdBQUduRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2JveC1ub2RlLXNkay9saWIvdXRpbC9wYWdpbmctaXRlcmF0b3IuanM/NTVlOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgSXRlcmF0b3IgZm9yIHBhZ2VkIHJlc3BvbnNlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFR5cGVkZWZzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRoZSBpdGVyYXRvciByZXNwb25zZSBvYmplY3RcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEl0ZXJhdG9yRGF0YVxuICogQHByb3BlcnR5IHtBcnJheX0gW3ZhbHVlXSAtIFRoZSBuZXh0IHNldCBvZiB2YWx1ZXMgZnJvbSB0aGUgaXRlcmF0b3JcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZG9uZSAtIFdoZXRoZXIgdGhlIGl0ZXJhdG9yIGlzIGNvbXBsZXRlZFxuICovXG5cbi8qKlxuICogSXRlcmF0b3IgY2FsbGJhY2tcbiAqIEBjYWxsYmFjayBJdGVyYXRvckNhbGxiYWNrXG4gKiBAcGFyYW0gez9FcnJvcn0gZXJyIC0gQW4gZXJyb3IgaWYgdGhlIGl0ZXJhdG9yIGVuY291bnRlcmVkIG9uZVxuICogQHBhcmFtIHtJdGVyYXRvckRhdGF9IFtkYXRhXSAtIE5ldyBkYXRhIGZyb20gdGhlIGl0ZXJhdG9yXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVxdWlyZW1lbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpLFxuXHRQcm9taXNlID0gcmVxdWlyZSgnYmx1ZWJpcmQnKSxcblx0UHJvbWlzZVF1ZXVlID0gcmVxdWlyZSgncHJvbWlzZS1xdWV1ZScpLFxuXHRlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5Qcm9taXNlUXVldWUuY29uZmlndXJlKFByb21pc2UpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJpdmF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgUEFHSU5HX01PREVTID0gT2JqZWN0LmZyZWV6ZSh7XG5cdE1BUktFUjogJ21hcmtlcicsXG5cdE9GRlNFVDogJ29mZnNldCdcbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFzeW5jaHJvbm91cyBpdGVyYXRvciBmb3IgcGFnZWQgY29sbGVjdGlvbnNcbiAqL1xuY2xhc3MgUGFnaW5nSXRlcmF0b3Ige1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgYSByZXNwb25zZSBpcyBpdGVyYWJsZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgLSBUaGUgQVBJIHJlc3BvbnNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSByZXNwb25zZSBpcyBpdGVyYWJsZVxuXHQgKi9cblx0c3RhdGljIGlzSXRlcmFibGUocmVzcG9uc2UpIHtcblx0XHQvLyBQT1NUIHJlc3BvbnNlcyBmb3IgdXBsb2FkaW5nIGEgZmlsZSBhcmUgZXhwbGljaXRseSBleGNsdWRlZCBoZXJlIGJlY2F1c2UsIHdoaWxlIHRoZSByZXNwb25zZSBpcyBpdGVyYWJsZSxcblx0XHQvLyBpdCBhbHdheXMgY29udGFpbnMgb25seSBhIHNpbmdsZSBlbnRyeSBhbmQgaGlzdG9yaWNhbGx5IGhhcyBub3QgYmVlbiBoYW5kbGVkIGFzIGl0ZXJhYmxlIGluIHRoZSBTREsuXG5cdFx0Ly8gVGhpcyBiZWhhdmlvciBpcyBiZWluZyBwcmVzZXJ2ZWQgaGVyZSB0byBhdm9pZCBhIGJyZWFraW5nIGNoYW5nZS5cblx0XHRsZXQgVVBMT0FEX1BBVFRFUk4gPSAvLip1cGxvYWRcXC5ib3hcXC5jb20uKlxcL2NvbnRlbnQvO1xuXHRcdHZhciBpc0dldE9yUG9zdFJlcXVlc3QgPSAocmVzcG9uc2UucmVxdWVzdCAmJiAocmVzcG9uc2UucmVxdWVzdC5tZXRob2QgPT09ICdHRVQnIHx8IChyZXNwb25zZS5yZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnICYmICFVUExPQURfUEFUVEVSTi50ZXN0KHJlc3BvbnNlLnJlcXVlc3QudXJpLmhyZWYpKSkpLFxuXHRcdFx0aGFzRW50cmllcyA9IChyZXNwb25zZS5ib2R5ICYmIEFycmF5LmlzQXJyYXkocmVzcG9uc2UuYm9keS5lbnRyaWVzKSksXG5cdFx0XHRub3RFdmVudFN0cmVhbSA9IChyZXNwb25zZS5ib2R5ICYmICFyZXNwb25zZS5ib2R5Lm5leHRfc3RyZWFtX3Bvc2l0aW9uKTtcblxuXHRcdHJldHVybiBCb29sZWFuKGlzR2V0T3JQb3N0UmVxdWVzdCAmJiBoYXNFbnRyaWVzICYmIG5vdEV2ZW50U3RyZWFtKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gVGhlIG9yaWdpbmFsIEFQSSByZXNwb25zZVxuXHQgKiBAcGFyYW0ge0JveENsaWVudH0gY2xpZW50IC0gQW4gQVBJIGNsaWVudCB0byBtYWtlIGZ1cnRoZXIgcmVxdWVzdHNcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IHdoZW4gY29sbGVjdGlvbiBjYW5ub3QgYmUgcGFnZWRcblx0ICovXG5cdGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBjbGllbnQpIHtcblxuXHRcdGlmICghUGFnaW5nSXRlcmF0b3IuaXNJdGVyYWJsZShyZXNwb25zZSkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNyZWF0ZSBwYWdpbmcgaXRlcmF0b3IgZm9yIG5vbi1wYWdlZCByZXNwb25zZSEnKTtcblx0XHR9XG5cblxuXHRcdHZhciBkYXRhID0gcmVzcG9uc2UuYm9keTtcblx0XHRpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoZGF0YS5vZmZzZXQpKSB7XG5cdFx0XHR0aGlzLm5leHRGaWVsZCA9IFBBR0lOR19NT0RFUy5PRkZTRVQ7XG5cdFx0XHR0aGlzLm5leHRWYWx1ZSA9IGRhdGEub2Zmc2V0O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGRhdGEubmV4dF9tYXJrZXIgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHQvLyBEZWZhdWx0IHRvIGEgZmluaXNoZWQgbWFya2VyIGNvbGxlY3Rpb24gd2hlbiB0aGVyZSdzIG5vIGZpZWxkIHByZXNlbnQsXG5cdFx0XHQvLyBzaW5jZSBzb21lIGVuZHBvaW50cyBpbmRpY2F0ZSBjb21wbGV0ZWQgcGFnaW5nIHRoaXMgd2F5XG5cdFx0XHR0aGlzLm5leHRGaWVsZCA9IFBBR0lOR19NT0RFUy5NQVJLRVI7XG5cdFx0XHR0aGlzLm5leHRWYWx1ZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubmV4dEZpZWxkID0gUEFHSU5HX01PREVTLk1BUktFUjtcblx0XHRcdHRoaXMubmV4dFZhbHVlID0gZGF0YS5uZXh0X21hcmtlcjtcblx0XHR9XG5cblx0XHR0aGlzLmxpbWl0ID0gZGF0YS5saW1pdCB8fCBkYXRhLmVudHJpZXMubGVuZ3RoO1xuXHRcdHRoaXMuZG9uZSA9IGZhbHNlO1xuXG5cdFx0dmFyIGhyZWYgPSByZXNwb25zZS5yZXF1ZXN0LmhyZWYuc3BsaXQoJz8nKVswXTtcblx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRoZWFkZXJzOiByZXNwb25zZS5yZXF1ZXN0LmhlYWRlcnMsXG5cdFx0XHRxczogcXVlcnlzdHJpbmcucGFyc2UocmVzcG9uc2UucmVxdWVzdC51cmkucXVlcnkpXG5cdFx0fTtcblx0XHRpZiAocmVzcG9uc2UucmVxdWVzdC5ib2R5KSB7XG5cdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlc3BvbnNlLnJlcXVlc3QuYm9keSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5ib2R5ID0gcmVzcG9uc2UucmVxdWVzdC5ib2R5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlLnJlcXVlc3QuYm9keSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gcXVlcnlzdHJpbmcucGFyc2UoKSBtYWtlcyBldmVyeXRoaW5nIGEgc3RyaW5nLCBlbnN1cmUgbnVtZXJpYyBwYXJhbXMgYXJlIHRoZSBjb3JyZWN0IHR5cGVcblx0XHRpZiAodGhpcy5vcHRpb25zLnFzLmxpbWl0KSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMucXMubGltaXQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMucXMubGltaXQsIDEwKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5xcy5vZmZzZXQpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5xcy5vZmZzZXQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMucXMub2Zmc2V0LCAxMCk7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIHRoaXMub3B0aW9ucy5oZWFkZXJzLkF1dGhvcml6YXRpb247XG5cdFx0aWYgKHJlc3BvbnNlLnJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuXHRcdFx0dGhpcy5mZXRjaCA9IGNsaWVudC5nZXQuYmluZChjbGllbnQsIGhyZWYpO1xuXHRcdH1cblx0XHRpZiAocmVzcG9uc2UucmVxdWVzdC5tZXRob2QgPT09ICdQT1NUJykge1xuXHRcdFx0dGhpcy5mZXRjaCA9IGNsaWVudC5wb3N0LmJpbmQoY2xpZW50LCBocmVmKTtcblx0XHR9XG5cdFx0dGhpcy5idWZmZXIgPSByZXNwb25zZS5ib2R5LmVudHJpZXM7XG5cdFx0dGhpcy5xdWV1ZSA9IG5ldyBQcm9taXNlUXVldWUoMSwgSW5maW5pdHkpO1xuXHRcdHRoaXMuX3VwZGF0ZVBhZ2luZyhyZXNwb25zZSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBwYWdpbmcgcGFyYW1ldGVycyBmb3IgdGhlIGl0ZXJhdG9yXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSAtIFRoZSBsYXRlc3QgQVBJIHJlc3BvbnNlXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cblx0X3VwZGF0ZVBhZ2luZyhyZXNwb25zZSkge1xuXG5cdFx0dmFyIGRhdGEgPSByZXNwb25zZS5ib2R5O1xuXG5cdFx0aWYgKHRoaXMubmV4dEZpZWxkID09PSBQQUdJTkdfTU9ERVMuT0ZGU0VUKSB7XG5cblx0XHRcdHRoaXMubmV4dFZhbHVlICs9IHRoaXMubGltaXQ7XG5cblx0XHRcdGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihkYXRhLnRvdGFsX2NvdW50KSkge1xuXHRcdFx0XHR0aGlzLmRvbmUgPSBkYXRhLm9mZnNldCArIHRoaXMubGltaXQgPj0gZGF0YS50b3RhbF9jb3VudDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZG9uZSA9IGRhdGEuZW50cmllcy5sZW5ndGggPT09IDA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5leHRGaWVsZCA9PT0gUEFHSU5HX01PREVTLk1BUktFUikge1xuXG5cdFx0XHRpZiAoZGF0YS5uZXh0X21hcmtlcikge1xuXHRcdFx0XHR0aGlzLm5leHRWYWx1ZSA9IGRhdGEubmV4dF9tYXJrZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5leHRWYWx1ZSA9IG51bGw7XG5cdFx0XHRcdHRoaXMuZG9uZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChyZXNwb25zZS5yZXF1ZXN0Lm1ldGhvZCA9PT0gJ0dFVCcpIHtcblx0XHRcdHRoaXMub3B0aW9ucy5xc1t0aGlzLm5leHRGaWVsZF0gPSB0aGlzLm5leHRWYWx1ZTtcblx0XHR9IGVsc2UgaWYgKHJlc3BvbnNlLnJlcXVlc3QubWV0aG9kID09PSAnUE9TVCcpIHtcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmJvZHkpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zLmJvZHkgPSB7fTtcblx0XHRcdH1cblx0XHRcdHRoaXMub3B0aW9ucy5ib2R5W3RoaXMubmV4dEZpZWxkXSA9IHRoaXMubmV4dFZhbHVlO1xuXHRcdFx0bGV0IGJvZHlTdHJpbmcgPSBKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMuYm9keSk7XG5cdFx0XHR0aGlzLm9wdGlvbnMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IGJvZHlTdHJpbmcubGVuZ3RoO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBGZXRjaCB0aGUgbmV4dCBwYWdlIG9mIHJlc3VsdHNcblx0ICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgcmVzb2x2aW5nIHRvIGl0ZXJhdG9yIHN0YXRlXG5cdCAqL1xuXHRfZ2V0RGF0YSgpIHtcblxuXHRcdHJldHVybiB0aGlzLmZldGNoKHRoaXMub3B0aW9ucylcblx0XHRcdC50aGVuKHJlc3BvbnNlID0+IHtcblxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JzLmJ1aWxkVW5leHBlY3RlZFJlc3BvbnNlRXJyb3IocmVzcG9uc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fdXBkYXRlUGFnaW5nKHJlc3BvbnNlKTtcblxuXHRcdFx0XHR0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLmNvbmNhdChyZXNwb25zZS5ib2R5LmVudHJpZXMpO1xuXG5cdFx0XHRcdGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmRvbmUpIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdFx0XHRcdFx0ZG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFueSBkYXRhIGluIHRoaXMgcGFnZSwgYnV0IHRoZSBwYWdpbmdcblx0XHRcdFx0XHQvLyBwYXJhbWV0ZXJzIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgbW9yZSBkYXRhLCBhdHRlbXB0XG5cdFx0XHRcdFx0Ly8gdG8gZmV0Y2ggbW9yZS4gIFRoaXMgb2NjdXJzIGluIG11bHRpcGxlIHBsYWNlcyBpbiB0aGUgQVBJXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2dldERhdGEoKTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2YWx1ZTogdGhpcy5idWZmZXIuc2hpZnQoKSxcblx0XHRcdFx0XHRkb25lOiBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRmV0Y2ggdGhlIG5leHQgcGFnZSBvZiB0aGUgY29sbGVjdGlvblxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSByZXNvbHZpbmcgdG8gaXRlcmF0b3Igc3RhdGVcblx0ICovXG5cdG5leHQoKSB7XG5cblx0XHRpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcblx0XHRcdFx0dmFsdWU6IHRoaXMuYnVmZmVyLnNoaWZ0KCksXG5cdFx0XHRcdGRvbmU6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5kb25lKSB7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuXHRcdFx0XHR2YWx1ZTogdW5kZWZpbmVkLFxuXHRcdFx0XHRkb25lOiB0cnVlXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5xdWV1ZS5hZGQodGhpcy5fZ2V0RGF0YS5iaW5kKHRoaXMpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGZXRjaCB0aGUgbmV4dCBtYXJrZXJcblx0ICogQHJldHVybnMge3N0cmluZ3xpbnR9IFN0cmluZyB0aGF0IGlzIHRoZSBuZXh0IG1hcmtlciBvciBpbnQgdGhhdCBpcyB0aGUgbmV4dCBvZmZzZXRcblx0ICovXG5cdGdldE5leHRNYXJrZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMubmV4dFZhbHVlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGFnaW5nSXRlcmF0b3I7XG4iXSwibmFtZXMiOlsicXVlcnlzdHJpbmciLCJyZXF1aXJlIiwiUHJvbWlzZSIsIlByb21pc2VRdWV1ZSIsImVycm9ycyIsImNvbmZpZ3VyZSIsIlBBR0lOR19NT0RFUyIsIk9iamVjdCIsImZyZWV6ZSIsIk1BUktFUiIsIk9GRlNFVCIsIlBhZ2luZ0l0ZXJhdG9yIiwiaXNJdGVyYWJsZSIsInJlc3BvbnNlIiwiVVBMT0FEX1BBVFRFUk4iLCJpc0dldE9yUG9zdFJlcXVlc3QiLCJyZXF1ZXN0IiwibWV0aG9kIiwidGVzdCIsInVyaSIsImhyZWYiLCJoYXNFbnRyaWVzIiwiYm9keSIsIkFycmF5IiwiaXNBcnJheSIsImVudHJpZXMiLCJub3RFdmVudFN0cmVhbSIsIm5leHRfc3RyZWFtX3Bvc2l0aW9uIiwiQm9vbGVhbiIsImNvbnN0cnVjdG9yIiwiY2xpZW50IiwiRXJyb3IiLCJkYXRhIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm9mZnNldCIsIm5leHRGaWVsZCIsIm5leHRWYWx1ZSIsIm5leHRfbWFya2VyIiwibGltaXQiLCJsZW5ndGgiLCJkb25lIiwic3BsaXQiLCJvcHRpb25zIiwiaGVhZGVycyIsInFzIiwicGFyc2UiLCJxdWVyeSIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkpTT04iLCJwYXJzZUludCIsIkF1dGhvcml6YXRpb24iLCJmZXRjaCIsImdldCIsImJpbmQiLCJwb3N0IiwiYnVmZmVyIiwicXVldWUiLCJJbmZpbml0eSIsIl91cGRhdGVQYWdpbmciLCJ0b3RhbF9jb3VudCIsImJvZHlTdHJpbmciLCJzdHJpbmdpZnkiLCJfZ2V0RGF0YSIsInRoZW4iLCJzdGF0dXNDb2RlIiwiYnVpbGRVbmV4cGVjdGVkUmVzcG9uc2VFcnJvciIsImNvbmNhdCIsInZhbHVlIiwidW5kZWZpbmVkIiwic2hpZnQiLCJuZXh0IiwicmVzb2x2ZSIsImFkZCIsImdldE5leHRNYXJrZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/util/paging-iterator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js":
/*!********************************************************!*\
  !*** ./node_modules/box-node-sdk/lib/util/url-path.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/**\n * @fileoverview URL Path Builder\n */ \n// ------------------------------------------------------------------------------\n// Private\n// ------------------------------------------------------------------------------\n// Pattern to check for relative paths\nvar PATTERN = /\\/\\.+/;\n/**\n * remove leading & trailing slashes from some string. This is useful for\n * removing slashes from the path segments that are actually a part of the\n * path itself. Without this step, these slashes would be uri-encoded.\n *\n * @param {string} segment The path segment (ex: '/users')\n * @returns {string} The path segment with slashes trimmed (ex: 'users')\n * @private\n */ function trimSlashes(segment) {\n    return segment.replace(/^\\/|\\/$/g, \"\");\n}\n// ------------------------------------------------------------------------------\n// Public\n// ------------------------------------------------------------------------------\n/**\n * URLPath will create a full URL path from the given array of segments.\n *\n * It also provides the following features:\n * - convert all segments to strings\n * - add/remove slashes between segments, where appropriate\n * - encode each path segment to prevent path manipulation\n *\n * @name URLPath\n * @returns {string} Return a valid URL path comprised of the given path segments\n */ module.exports = function urlPath() {\n    var args = Array.prototype.slice.call(arguments);\n    var path = args.map((x)=>String(x)).map((x)=>{\n        var trimmedX = trimSlashes(x);\n        if (PATTERN.test(trimmedX)) {\n            throw new Error(`An invalid path parameter exists in ${trimmedX}. Relative path parameters cannot be passed.`);\n        }\n        return trimmedX;\n    }).map((x)=>encodeURIComponent(x)).join(\"/\");\n    return `/${path}`;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYm94LW5vZGUtc2RrL2xpYi91dGlsL3VybC1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQSxpRkFBaUY7QUFDakYsVUFBVTtBQUNWLGlGQUFpRjtBQUVqRixzQ0FBc0M7QUFDdEMsSUFBSUEsVUFBVTtBQUNkOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsWUFBWUMsT0FBTztJQUMzQixPQUFPQSxRQUFRQyxPQUFPLENBQUMsWUFBWTtBQUNwQztBQUdBLGlGQUFpRjtBQUNqRixTQUFTO0FBQ1QsaUZBQWlGO0FBRWpGOzs7Ozs7Ozs7O0NBVUMsR0FDREMsT0FBT0MsT0FBTyxHQUFHLFNBQVNDO0lBQ3pCLElBQUlDLE9BQU9DLE1BQU1DLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNDO0lBQ3RDLElBQUlDLE9BQU9OLEtBQUtPLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0MsT0FBT0QsSUFDOUJELEdBQUcsQ0FBQ0MsQ0FBQUE7UUFDSixJQUFJRSxXQUFXaEIsWUFBWWM7UUFDM0IsSUFBSWYsUUFBUWtCLElBQUksQ0FBQ0QsV0FBVztZQUMzQixNQUFNLElBQUlFLE1BQU0sQ0FBQyxvQ0FBb0MsRUFBRUYsU0FBUyw0Q0FBNEMsQ0FBQztRQUM5RztRQUNBLE9BQU9BO0lBQ1IsR0FDQ0gsR0FBRyxDQUFDQyxDQUFBQSxJQUFLSyxtQkFBbUJMLElBQzVCTSxJQUFJLENBQUM7SUFDUCxPQUFPLENBQUMsQ0FBQyxFQUFFUixLQUFLLENBQUM7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9ib3gtbm9kZS1zZGsvbGliL3V0aWwvdXJsLXBhdGguanM/OTZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlb3ZlcnZpZXcgVVJMIFBhdGggQnVpbGRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcml2YXRlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUGF0dGVybiB0byBjaGVjayBmb3IgcmVsYXRpdmUgcGF0aHNcbnZhciBQQVRURVJOID0gL1xcL1xcLisvO1xuLyoqXG4gKiByZW1vdmUgbGVhZGluZyAmIHRyYWlsaW5nIHNsYXNoZXMgZnJvbSBzb21lIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gKiByZW1vdmluZyBzbGFzaGVzIGZyb20gdGhlIHBhdGggc2VnbWVudHMgdGhhdCBhcmUgYWN0dWFsbHkgYSBwYXJ0IG9mIHRoZVxuICogcGF0aCBpdHNlbGYuIFdpdGhvdXQgdGhpcyBzdGVwLCB0aGVzZSBzbGFzaGVzIHdvdWxkIGJlIHVyaS1lbmNvZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWdtZW50IFRoZSBwYXRoIHNlZ21lbnQgKGV4OiAnL3VzZXJzJylcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHNlZ21lbnQgd2l0aCBzbGFzaGVzIHRyaW1tZWQgKGV4OiAndXNlcnMnKVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJpbVNsYXNoZXMoc2VnbWVudCkge1xuXHRyZXR1cm4gc2VnbWVudC5yZXBsYWNlKC9eXFwvfFxcLyQvZywgJycpO1xufVxuXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBVUkxQYXRoIHdpbGwgY3JlYXRlIGEgZnVsbCBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBzZWdtZW50cy5cbiAqXG4gKiBJdCBhbHNvIHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXM6XG4gKiAtIGNvbnZlcnQgYWxsIHNlZ21lbnRzIHRvIHN0cmluZ3NcbiAqIC0gYWRkL3JlbW92ZSBzbGFzaGVzIGJldHdlZW4gc2VnbWVudHMsIHdoZXJlIGFwcHJvcHJpYXRlXG4gKiAtIGVuY29kZSBlYWNoIHBhdGggc2VnbWVudCB0byBwcmV2ZW50IHBhdGggbWFuaXB1bGF0aW9uXG4gKlxuICogQG5hbWUgVVJMUGF0aFxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJuIGEgdmFsaWQgVVJMIHBhdGggY29tcHJpc2VkIG9mIHRoZSBnaXZlbiBwYXRoIHNlZ21lbnRzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdXJsUGF0aCgvKiBhcmd1bWVudHMqLykge1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdHZhciBwYXRoID0gYXJncy5tYXAoeCA9PiBTdHJpbmcoeCkpXG5cdFx0Lm1hcCh4ID0+IHtcblx0XHRcdHZhciB0cmltbWVkWCA9IHRyaW1TbGFzaGVzKHgpO1xuXHRcdFx0aWYgKFBBVFRFUk4udGVzdCh0cmltbWVkWCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBBbiBpbnZhbGlkIHBhdGggcGFyYW1ldGVyIGV4aXN0cyBpbiAke3RyaW1tZWRYfS4gUmVsYXRpdmUgcGF0aCBwYXJhbWV0ZXJzIGNhbm5vdCBiZSBwYXNzZWQuYCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJpbW1lZFg7XG5cdFx0fSlcblx0XHQubWFwKHggPT4gZW5jb2RlVVJJQ29tcG9uZW50KHgpKVxuXHRcdC5qb2luKCcvJyk7XG5cdHJldHVybiBgLyR7cGF0aH1gO1xufTtcbiJdLCJuYW1lcyI6WyJQQVRURVJOIiwidHJpbVNsYXNoZXMiLCJzZWdtZW50IiwicmVwbGFjZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1cmxQYXRoIiwiYXJncyIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiYXJndW1lbnRzIiwicGF0aCIsIm1hcCIsIngiLCJTdHJpbmciLCJ0cmltbWVkWCIsInRlc3QiLCJFcnJvciIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/box-node-sdk/lib/util/url-path.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/box-node-sdk/package.json":
/*!************************************************!*\
  !*** ./node_modules/box-node-sdk/package.json ***!
  \************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"box-node-sdk","author":"Box <oss@box.com>","version":"1.37.0","description":"Official SDK for Box Plaform APIs","license":"Apache-2.0","repository":{"type":"git","url":"https://github.com/box/box-node-sdk.git"},"keywords":["box","platform","api","apis","upload","download","sdk"],"engines":{"node":">= 4.0.0"},"main":"./lib/box-node-sdk.js","scripts":{"test":"node Makefile.js","lint":"node Makefile.js lint","docs":"node Makefile.js docs","docs-dev":"node Makefile.js docsDev","deps":"npm prune && npm install","patch":"node Makefile.js patch","minor":"node Makefile.js minor","major":"node Makefile.js major"},"dependencies":{"ajv":"^6.12.3","bluebird":"^3.7.1","http-status":"^1.4.1","jsonwebtoken":"^8.5.1","merge-options":"^1.0.1","promise-queue":"^2.2.3","proxy-agent":"^4.0.0","request":"^2.88.0","url-template":"^2.0.8","uuid":"^3.3.3"},"devDependencies":{"chai":"^4.2.0","coveralls":"^3.1.0","eslint":"^4.19.1","eslint-plugin-node":"^6.0.1","eslint-plugin-promise":"^3.8.0","eslint-plugin-unicorn":"^4.0.3","istanbul":"^0.4.3","jsdoc":"^3.6.3","jsonlint2":"^1.7.1","leche":"^2.3.0","mocha":"^6.0.0","mockery":"^2.1.0","nock":"^9.6.1","np":"^7.2.0","npm-force-resolutions":"0.0.3","npm-upgrade":"^3.0.0","nyc":"^14.0.0","shelljs":"^0.8.3","shelljs-nodecli":"^0.1.1","sinon":"^7.5.0"},"files":["config","lib"],"resolutions":{"handlebars":"4.5.3","minimist":"1.2.5"}}');

/***/ })

};
;