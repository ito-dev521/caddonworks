/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/http-signature";
exports.ids = ["vendor-chunks/http-signature"];
exports.modules = {

/***/ "(rsc)/./node_modules/http-signature/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\nvar parser = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/http-signature/lib/parser.js\");\nvar signer = __webpack_require__(/*! ./signer */ \"(rsc)/./node_modules/http-signature/lib/signer.js\");\nvar verify = __webpack_require__(/*! ./verify */ \"(rsc)/./node_modules/http-signature/lib/verify.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\n///--- API\nmodule.exports = {\n    parse: parser.parseRequest,\n    parseRequest: parser.parseRequest,\n    sign: signer.signRequest,\n    signRequest: signer.signRequest,\n    createSigner: signer.createSigner,\n    isSigner: signer.isSigner,\n    sshKeyToPEM: utils.sshKeyToPEM,\n    sshKeyFingerprint: utils.fingerprint,\n    pemToRsaSSHKey: utils.pemToRsaSSHKey,\n    verify: verify.verifySignature,\n    verifySignature: verify.verifySignature,\n    verifyHMAC: verify.verifyHMAC\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDhCQUE4QjtBQUU5QixJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztBQUNyQixJQUFJRyxRQUFRSCxtQkFBT0EsQ0FBQztBQUlwQixVQUFVO0FBRVZJLE9BQU9DLE9BQU8sR0FBRztJQUVmQyxPQUFPUCxPQUFPUSxZQUFZO0lBQzFCQSxjQUFjUixPQUFPUSxZQUFZO0lBRWpDQyxNQUFNUCxPQUFPUSxXQUFXO0lBQ3hCQSxhQUFhUixPQUFPUSxXQUFXO0lBQy9CQyxjQUFjVCxPQUFPUyxZQUFZO0lBQ2pDQyxVQUFVVixPQUFPVSxRQUFRO0lBRXpCQyxhQUFhVCxNQUFNUyxXQUFXO0lBQzlCQyxtQkFBbUJWLE1BQU1XLFdBQVc7SUFDcENDLGdCQUFnQlosTUFBTVksY0FBYztJQUVwQ2IsUUFBUUEsT0FBT2MsZUFBZTtJQUM5QkEsaUJBQWlCZCxPQUFPYyxlQUFlO0lBQ3ZDQyxZQUFZZixPQUFPZSxVQUFVO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL2luZGV4LmpzPzYyYmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IDIwMTUgSm95ZW50LCBJbmMuXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xudmFyIHNpZ25lciA9IHJlcXVpcmUoJy4vc2lnbmVyJyk7XG52YXIgdmVyaWZ5ID0gcmVxdWlyZSgnLi92ZXJpZnknKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgcGFyc2U6IHBhcnNlci5wYXJzZVJlcXVlc3QsXG4gIHBhcnNlUmVxdWVzdDogcGFyc2VyLnBhcnNlUmVxdWVzdCxcblxuICBzaWduOiBzaWduZXIuc2lnblJlcXVlc3QsXG4gIHNpZ25SZXF1ZXN0OiBzaWduZXIuc2lnblJlcXVlc3QsXG4gIGNyZWF0ZVNpZ25lcjogc2lnbmVyLmNyZWF0ZVNpZ25lcixcbiAgaXNTaWduZXI6IHNpZ25lci5pc1NpZ25lcixcblxuICBzc2hLZXlUb1BFTTogdXRpbHMuc3NoS2V5VG9QRU0sXG4gIHNzaEtleUZpbmdlcnByaW50OiB1dGlscy5maW5nZXJwcmludCxcbiAgcGVtVG9Sc2FTU0hLZXk6IHV0aWxzLnBlbVRvUnNhU1NIS2V5LFxuXG4gIHZlcmlmeTogdmVyaWZ5LnZlcmlmeVNpZ25hdHVyZSxcbiAgdmVyaWZ5U2lnbmF0dXJlOiB2ZXJpZnkudmVyaWZ5U2lnbmF0dXJlLFxuICB2ZXJpZnlITUFDOiB2ZXJpZnkudmVyaWZ5SE1BQ1xufTtcbiJdLCJuYW1lcyI6WyJwYXJzZXIiLCJyZXF1aXJlIiwic2lnbmVyIiwidmVyaWZ5IiwidXRpbHMiLCJtb2R1bGUiLCJleHBvcnRzIiwicGFyc2UiLCJwYXJzZVJlcXVlc3QiLCJzaWduIiwic2lnblJlcXVlc3QiLCJjcmVhdGVTaWduZXIiLCJpc1NpZ25lciIsInNzaEtleVRvUEVNIiwic3NoS2V5RmluZ2VycHJpbnQiLCJmaW5nZXJwcmludCIsInBlbVRvUnNhU1NIS2V5IiwidmVyaWZ5U2lnbmF0dXJlIiwidmVyaWZ5SE1BQyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/parser.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/parser.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\n///--- Globals\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar validateAlgorithm = utils.validateAlgorithm;\nvar State = {\n    New: 0,\n    Params: 1\n};\nvar ParamsState = {\n    Name: 0,\n    Quote: 1,\n    Value: 2,\n    Comma: 3\n};\n///--- Specific Errors\nfunction ExpiredRequestError(message) {\n    HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\nfunction InvalidHeaderError(message) {\n    HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\nfunction InvalidParamsError(message) {\n    HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\nfunction MissingHeaderError(message) {\n    HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n    HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n///--- Exported API\nmodule.exports = {\n    /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"digest\"\n   *         ],\n   *         \"signature\": \"base64\"\n   *       },\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   *                   - strict: should enforce latest spec parsing\n   *                             (default: false).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {StrictParsingError} if old attributes are used in strict parsing\n   *                              mode.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */ parseRequest: function parseRequest(request, options) {\n        assert.object(request, \"request\");\n        assert.object(request.headers, \"request.headers\");\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.headers === undefined) {\n            options.headers = [\n                request.headers[\"x-date\"] ? \"x-date\" : \"date\"\n            ];\n        }\n        assert.object(options, \"options\");\n        assert.arrayOfString(options.headers, \"options.headers\");\n        assert.optionalFinite(options.clockSkew, \"options.clockSkew\");\n        var authzHeaderName = options.authorizationHeaderName || \"authorization\";\n        if (!request.headers[authzHeaderName]) {\n            throw new MissingHeaderError(\"no \" + authzHeaderName + \" header \" + \"present in the request\");\n        }\n        options.clockSkew = options.clockSkew || 300;\n        var i = 0;\n        var state = State.New;\n        var substate = ParamsState.Name;\n        var tmpName = \"\";\n        var tmpValue = \"\";\n        var parsed = {\n            scheme: \"\",\n            params: {},\n            signingString: \"\"\n        };\n        var authz = request.headers[authzHeaderName];\n        for(i = 0; i < authz.length; i++){\n            var c = authz.charAt(i);\n            switch(Number(state)){\n                case State.New:\n                    if (c !== \" \") parsed.scheme += c;\n                    else state = State.Params;\n                    break;\n                case State.Params:\n                    switch(Number(substate)){\n                        case ParamsState.Name:\n                            var code = c.charCodeAt(0);\n                            // restricted name of A-Z / a-z\n                            if (code >= 0x41 && code <= 0x5a || // A-Z\n                            code >= 0x61 && code <= 0x7a) {\n                                tmpName += c;\n                            } else if (c === \"=\") {\n                                if (tmpName.length === 0) throw new InvalidHeaderError(\"bad param format\");\n                                substate = ParamsState.Quote;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        case ParamsState.Quote:\n                            if (c === '\"') {\n                                tmpValue = \"\";\n                                substate = ParamsState.Value;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        case ParamsState.Value:\n                            if (c === '\"') {\n                                parsed.params[tmpName] = tmpValue;\n                                substate = ParamsState.Comma;\n                            } else {\n                                tmpValue += c;\n                            }\n                            break;\n                        case ParamsState.Comma:\n                            if (c === \",\") {\n                                tmpName = \"\";\n                                substate = ParamsState.Name;\n                            } else {\n                                throw new InvalidHeaderError(\"bad param format\");\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Invalid substate\");\n                    }\n                    break;\n                default:\n                    throw new Error(\"Invalid substate\");\n            }\n        }\n        if (!parsed.params.headers || parsed.params.headers === \"\") {\n            if (request.headers[\"x-date\"]) {\n                parsed.params.headers = [\n                    \"x-date\"\n                ];\n            } else {\n                parsed.params.headers = [\n                    \"date\"\n                ];\n            }\n        } else {\n            parsed.params.headers = parsed.params.headers.split(\" \");\n        }\n        // Minimally validate the parsed object\n        if (!parsed.scheme || parsed.scheme !== \"Signature\") throw new InvalidHeaderError('scheme was not \"Signature\"');\n        if (!parsed.params.keyId) throw new InvalidHeaderError(\"keyId was not specified\");\n        if (!parsed.params.algorithm) throw new InvalidHeaderError(\"algorithm was not specified\");\n        if (!parsed.params.signature) throw new InvalidHeaderError(\"signature was not specified\");\n        // Check the algorithm against the official list\n        parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n        try {\n            validateAlgorithm(parsed.params.algorithm);\n        } catch (e) {\n            if (e instanceof InvalidAlgorithmError) throw new InvalidParamsError(parsed.params.algorithm + \" is not \" + \"supported\");\n            else throw e;\n        }\n        // Build the signingString\n        for(i = 0; i < parsed.params.headers.length; i++){\n            var h = parsed.params.headers[i].toLowerCase();\n            parsed.params.headers[i] = h;\n            if (h === \"request-line\") {\n                if (!options.strict) {\n                    /*\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */ parsed.signingString += request.method + \" \" + request.url + \" HTTP/\" + request.httpVersion;\n                } else {\n                    /* Strict parsing doesn't allow older draft headers. */ throw new StrictParsingError(\"request-line is not a valid header \" + \"with strict parsing enabled.\");\n                }\n            } else if (h === \"(request-target)\") {\n                parsed.signingString += \"(request-target): \" + request.method.toLowerCase() + \" \" + request.url;\n            } else {\n                var value = request.headers[h];\n                if (value === undefined) throw new MissingHeaderError(h + \" was not in the request\");\n                parsed.signingString += h + \": \" + value;\n            }\n            if (i + 1 < parsed.params.headers.length) parsed.signingString += \"\\n\";\n        }\n        // Check against the constraints\n        var date;\n        if (request.headers.date || request.headers[\"x-date\"]) {\n            if (request.headers[\"x-date\"]) {\n                date = new Date(request.headers[\"x-date\"]);\n            } else {\n                date = new Date(request.headers.date);\n            }\n            var now = new Date();\n            var skew = Math.abs(now.getTime() - date.getTime());\n            if (skew > options.clockSkew * 1000) {\n                throw new ExpiredRequestError(\"clock skew of \" + skew / 1000 + \"s was greater than \" + options.clockSkew + \"s\");\n            }\n        }\n        options.headers.forEach(function(hdr) {\n            // Remember that we already checked any headers in the params\n            // were in the request, so if this passes we're good.\n            if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0) throw new MissingHeaderError(hdr + \" was not a signed header\");\n        });\n        if (options.algorithms) {\n            if (options.algorithms.indexOf(parsed.params.algorithm) === -1) throw new InvalidParamsError(parsed.params.algorithm + \" is not a supported algorithm\");\n        }\n        parsed.algorithm = parsed.params.algorithm.toUpperCase();\n        parsed.keyId = parsed.params.keyId;\n        return parsed;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvREFBb0Q7QUFFcEQsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsT0FBT0QsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFJcEIsY0FBYztBQUVkLElBQUlHLGFBQWFELE1BQU1DLFVBQVU7QUFDakMsSUFBSUMsV0FBV0YsTUFBTUUsUUFBUTtBQUM3QixJQUFJQyxxQkFBcUJILE1BQU1HLGtCQUFrQjtBQUNqRCxJQUFJQyx3QkFBd0JKLE1BQU1JLHFCQUFxQjtBQUN2RCxJQUFJQyxvQkFBb0JMLE1BQU1LLGlCQUFpQjtBQUUvQyxJQUFJQyxRQUFRO0lBQ1ZDLEtBQUs7SUFDTEMsUUFBUTtBQUNWO0FBRUEsSUFBSUMsY0FBYztJQUNoQkMsTUFBTTtJQUNOQyxPQUFPO0lBQ1BDLE9BQU87SUFDUEMsT0FBTztBQUNUO0FBR0Esc0JBQXNCO0FBR3RCLFNBQVNDLG9CQUFvQkMsT0FBTztJQUNsQ1osbUJBQW1CYSxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTRDtBQUN6QztBQUNBZixLQUFLa0IsUUFBUSxDQUFDSCxxQkFBcUJYO0FBR25DLFNBQVNlLG1CQUFtQkgsT0FBTztJQUNqQ1osbUJBQW1CYSxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTRztBQUN6QztBQUNBbkIsS0FBS2tCLFFBQVEsQ0FBQ0Msb0JBQW9CZjtBQUdsQyxTQUFTZ0IsbUJBQW1CSixPQUFPO0lBQ2pDWixtQkFBbUJhLElBQUksQ0FBQyxJQUFJLEVBQUVELFNBQVNJO0FBQ3pDO0FBQ0FwQixLQUFLa0IsUUFBUSxDQUFDRSxvQkFBb0JoQjtBQUdsQyxTQUFTaUIsbUJBQW1CTCxPQUFPO0lBQ2pDWixtQkFBbUJhLElBQUksQ0FBQyxJQUFJLEVBQUVELFNBQVNLO0FBQ3pDO0FBQ0FyQixLQUFLa0IsUUFBUSxDQUFDRyxvQkFBb0JqQjtBQUVsQyxTQUFTa0IsbUJBQW1CTixPQUFPO0lBQ2pDWixtQkFBbUJhLElBQUksQ0FBQyxJQUFJLEVBQUVELFNBQVNNO0FBQ3pDO0FBQ0F0QixLQUFLa0IsUUFBUSxDQUFDSSxvQkFBb0JsQjtBQUVsQyxtQkFBbUI7QUFFbkJtQixPQUFPQyxPQUFPLEdBQUc7SUFFZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMENDLEdBQ0RDLGNBQWMsU0FBU0EsYUFBYUMsT0FBTyxFQUFFQyxPQUFPO1FBQ2xEN0IsT0FBTzhCLE1BQU0sQ0FBQ0YsU0FBUztRQUN2QjVCLE9BQU84QixNQUFNLENBQUNGLFFBQVFHLE9BQU8sRUFBRTtRQUMvQixJQUFJRixZQUFZRyxXQUFXO1lBQ3pCSCxVQUFVLENBQUM7UUFDYjtRQUNBLElBQUlBLFFBQVFFLE9BQU8sS0FBS0MsV0FBVztZQUNqQ0gsUUFBUUUsT0FBTyxHQUFHO2dCQUFDSCxRQUFRRyxPQUFPLENBQUMsU0FBUyxHQUFHLFdBQVc7YUFBTztRQUNuRTtRQUNBL0IsT0FBTzhCLE1BQU0sQ0FBQ0QsU0FBUztRQUN2QjdCLE9BQU9pQyxhQUFhLENBQUNKLFFBQVFFLE9BQU8sRUFBRTtRQUN0Qy9CLE9BQU9rQyxjQUFjLENBQUNMLFFBQVFNLFNBQVMsRUFBRTtRQUV6QyxJQUFJQyxrQkFBa0JQLFFBQVFRLHVCQUF1QixJQUFJO1FBRXpELElBQUksQ0FBQ1QsUUFBUUcsT0FBTyxDQUFDSyxnQkFBZ0IsRUFBRTtZQUNyQyxNQUFNLElBQUliLG1CQUFtQixRQUFRYSxrQkFBa0IsYUFDMUI7UUFDL0I7UUFFQVAsUUFBUU0sU0FBUyxHQUFHTixRQUFRTSxTQUFTLElBQUk7UUFHekMsSUFBSUcsSUFBSTtRQUNSLElBQUlDLFFBQVE5QixNQUFNQyxHQUFHO1FBQ3JCLElBQUk4QixXQUFXNUIsWUFBWUMsSUFBSTtRQUMvQixJQUFJNEIsVUFBVTtRQUNkLElBQUlDLFdBQVc7UUFFZixJQUFJQyxTQUFTO1lBQ1hDLFFBQVE7WUFDUkMsUUFBUSxDQUFDO1lBQ1RDLGVBQWU7UUFDakI7UUFFQSxJQUFJQyxRQUFRbkIsUUFBUUcsT0FBTyxDQUFDSyxnQkFBZ0I7UUFDNUMsSUFBS0UsSUFBSSxHQUFHQSxJQUFJUyxNQUFNQyxNQUFNLEVBQUVWLElBQUs7WUFDakMsSUFBSVcsSUFBSUYsTUFBTUcsTUFBTSxDQUFDWjtZQUVyQixPQUFRYSxPQUFPWjtnQkFFZixLQUFLOUIsTUFBTUMsR0FBRztvQkFDWixJQUFJdUMsTUFBTSxLQUFLTixPQUFPQyxNQUFNLElBQUlLO3lCQUMzQlYsUUFBUTlCLE1BQU1FLE1BQU07b0JBQ3pCO2dCQUVGLEtBQUtGLE1BQU1FLE1BQU07b0JBQ2YsT0FBUXdDLE9BQU9YO3dCQUVmLEtBQUs1QixZQUFZQyxJQUFJOzRCQUNuQixJQUFJdUMsT0FBT0gsRUFBRUksVUFBVSxDQUFDOzRCQUN4QiwrQkFBK0I7NEJBQy9CLElBQUksUUFBUyxRQUFRRCxRQUFRLFFBQVMsTUFBTTs0QkFDdkNBLFFBQVEsUUFBUUEsUUFBUSxNQUFPO2dDQUNsQ1gsV0FBV1E7NEJBQ2IsT0FBTyxJQUFJQSxNQUFNLEtBQUs7Z0NBQ3BCLElBQUlSLFFBQVFPLE1BQU0sS0FBSyxHQUNyQixNQUFNLElBQUkzQixtQkFBbUI7Z0NBQy9CbUIsV0FBVzVCLFlBQVlFLEtBQUs7NEJBQzlCLE9BQU87Z0NBQ0wsTUFBTSxJQUFJTyxtQkFBbUI7NEJBQy9COzRCQUNBO3dCQUVGLEtBQUtULFlBQVlFLEtBQUs7NEJBQ3BCLElBQUltQyxNQUFNLEtBQUs7Z0NBQ2JQLFdBQVc7Z0NBQ1hGLFdBQVc1QixZQUFZRyxLQUFLOzRCQUM5QixPQUFPO2dDQUNMLE1BQU0sSUFBSU0sbUJBQW1COzRCQUMvQjs0QkFDQTt3QkFFRixLQUFLVCxZQUFZRyxLQUFLOzRCQUNwQixJQUFJa0MsTUFBTSxLQUFLO2dDQUNiTixPQUFPRSxNQUFNLENBQUNKLFFBQVEsR0FBR0M7Z0NBQ3pCRixXQUFXNUIsWUFBWUksS0FBSzs0QkFDOUIsT0FBTztnQ0FDTDBCLFlBQVlPOzRCQUNkOzRCQUNBO3dCQUVGLEtBQUtyQyxZQUFZSSxLQUFLOzRCQUNwQixJQUFJaUMsTUFBTSxLQUFLO2dDQUNiUixVQUFVO2dDQUNWRCxXQUFXNUIsWUFBWUMsSUFBSTs0QkFDN0IsT0FBTztnQ0FDTCxNQUFNLElBQUlRLG1CQUFtQjs0QkFDL0I7NEJBQ0E7d0JBRUY7NEJBQ0UsTUFBTSxJQUFJaUMsTUFBTTtvQkFDbEI7b0JBQ0E7Z0JBRUY7b0JBQ0UsTUFBTSxJQUFJQSxNQUFNO1lBQ2xCO1FBRUY7UUFFQSxJQUFJLENBQUNYLE9BQU9FLE1BQU0sQ0FBQ2QsT0FBTyxJQUFJWSxPQUFPRSxNQUFNLENBQUNkLE9BQU8sS0FBSyxJQUFJO1lBQzFELElBQUlILFFBQVFHLE9BQU8sQ0FBQyxTQUFTLEVBQUU7Z0JBQzdCWSxPQUFPRSxNQUFNLENBQUNkLE9BQU8sR0FBRztvQkFBQztpQkFBUztZQUNwQyxPQUFPO2dCQUNMWSxPQUFPRSxNQUFNLENBQUNkLE9BQU8sR0FBRztvQkFBQztpQkFBTztZQUNsQztRQUNGLE9BQU87WUFDTFksT0FBT0UsTUFBTSxDQUFDZCxPQUFPLEdBQUdZLE9BQU9FLE1BQU0sQ0FBQ2QsT0FBTyxDQUFDd0IsS0FBSyxDQUFDO1FBQ3REO1FBRUEsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQ1osT0FBT0MsTUFBTSxJQUFJRCxPQUFPQyxNQUFNLEtBQUssYUFDdEMsTUFBTSxJQUFJdkIsbUJBQW1CO1FBRS9CLElBQUksQ0FBQ3NCLE9BQU9FLE1BQU0sQ0FBQ1csS0FBSyxFQUN0QixNQUFNLElBQUluQyxtQkFBbUI7UUFFL0IsSUFBSSxDQUFDc0IsT0FBT0UsTUFBTSxDQUFDWSxTQUFTLEVBQzFCLE1BQU0sSUFBSXBDLG1CQUFtQjtRQUUvQixJQUFJLENBQUNzQixPQUFPRSxNQUFNLENBQUNhLFNBQVMsRUFDMUIsTUFBTSxJQUFJckMsbUJBQW1CO1FBRS9CLGdEQUFnRDtRQUNoRHNCLE9BQU9FLE1BQU0sQ0FBQ1ksU0FBUyxHQUFHZCxPQUFPRSxNQUFNLENBQUNZLFNBQVMsQ0FBQ0UsV0FBVztRQUM3RCxJQUFJO1lBQ0ZuRCxrQkFBa0JtQyxPQUFPRSxNQUFNLENBQUNZLFNBQVM7UUFDM0MsRUFBRSxPQUFPRyxHQUFHO1lBQ1YsSUFBSUEsYUFBYXJELHVCQUNmLE1BQU8sSUFBSWUsbUJBQW1CcUIsT0FBT0UsTUFBTSxDQUFDWSxTQUFTLEdBQUcsYUFDdEQ7aUJBRUYsTUFBT0c7UUFDWDtRQUVBLDBCQUEwQjtRQUMxQixJQUFLdEIsSUFBSSxHQUFHQSxJQUFJSyxPQUFPRSxNQUFNLENBQUNkLE9BQU8sQ0FBQ2lCLE1BQU0sRUFBRVYsSUFBSztZQUNqRCxJQUFJdUIsSUFBSWxCLE9BQU9FLE1BQU0sQ0FBQ2QsT0FBTyxDQUFDTyxFQUFFLENBQUNxQixXQUFXO1lBQzVDaEIsT0FBT0UsTUFBTSxDQUFDZCxPQUFPLENBQUNPLEVBQUUsR0FBR3VCO1lBRTNCLElBQUlBLE1BQU0sZ0JBQWdCO2dCQUN4QixJQUFJLENBQUNoQyxRQUFRaUMsTUFBTSxFQUFFO29CQUNuQjs7O1dBR0MsR0FDRG5CLE9BQU9HLGFBQWEsSUFDbEJsQixRQUFRbUMsTUFBTSxHQUFHLE1BQU1uQyxRQUFRb0MsR0FBRyxHQUFHLFdBQVdwQyxRQUFRcUMsV0FBVztnQkFDdkUsT0FBTztvQkFDTCxxREFBcUQsR0FDckQsTUFBTyxJQUFJekMsbUJBQW1CLHdDQUM1QjtnQkFDSjtZQUNGLE9BQU8sSUFBSXFDLE1BQU0sb0JBQW9CO2dCQUNuQ2xCLE9BQU9HLGFBQWEsSUFDbEIsdUJBQXVCbEIsUUFBUW1DLE1BQU0sQ0FBQ0osV0FBVyxLQUFLLE1BQ3REL0IsUUFBUW9DLEdBQUc7WUFDZixPQUFPO2dCQUNMLElBQUlFLFFBQVF0QyxRQUFRRyxPQUFPLENBQUM4QixFQUFFO2dCQUM5QixJQUFJSyxVQUFVbEMsV0FDWixNQUFNLElBQUlULG1CQUFtQnNDLElBQUk7Z0JBQ25DbEIsT0FBT0csYUFBYSxJQUFJZSxJQUFJLE9BQU9LO1lBQ3JDO1lBRUEsSUFBSSxJQUFLLElBQUt2QixPQUFPRSxNQUFNLENBQUNkLE9BQU8sQ0FBQ2lCLE1BQU0sRUFDeENMLE9BQU9HLGFBQWEsSUFBSTtRQUM1QjtRQUVBLGdDQUFnQztRQUNoQyxJQUFJcUI7UUFDSixJQUFJdkMsUUFBUUcsT0FBTyxDQUFDb0MsSUFBSSxJQUFJdkMsUUFBUUcsT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNuRCxJQUFJSCxRQUFRRyxPQUFPLENBQUMsU0FBUyxFQUFFO2dCQUM3Qm9DLE9BQU8sSUFBSUMsS0FBS3hDLFFBQVFHLE9BQU8sQ0FBQyxTQUFTO1lBQzNDLE9BQU87Z0JBQ0xvQyxPQUFPLElBQUlDLEtBQUt4QyxRQUFRRyxPQUFPLENBQUNvQyxJQUFJO1lBQ3RDO1lBQ0YsSUFBSUUsTUFBTSxJQUFJRDtZQUNkLElBQUlFLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQ0gsSUFBSUksT0FBTyxLQUFLTixLQUFLTSxPQUFPO1lBRWhELElBQUlILE9BQU96QyxRQUFRTSxTQUFTLEdBQUcsTUFBTTtnQkFDbkMsTUFBTSxJQUFJbEIsb0JBQW9CLG1CQUNDcUQsT0FBTyxPQUNSLHdCQUNBekMsUUFBUU0sU0FBUyxHQUFHO1lBQ3BEO1FBQ0Y7UUFFQU4sUUFBUUUsT0FBTyxDQUFDMkMsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFDbkMsNkRBQTZEO1lBQzdELHFEQUFxRDtZQUNyRCxJQUFJaEMsT0FBT0UsTUFBTSxDQUFDZCxPQUFPLENBQUM2QyxPQUFPLENBQUNELElBQUloQixXQUFXLE1BQU0sR0FDckQsTUFBTSxJQUFJcEMsbUJBQW1Cb0QsTUFBTTtRQUN2QztRQUVBLElBQUk5QyxRQUFRZ0QsVUFBVSxFQUFFO1lBQ3RCLElBQUloRCxRQUFRZ0QsVUFBVSxDQUFDRCxPQUFPLENBQUNqQyxPQUFPRSxNQUFNLENBQUNZLFNBQVMsTUFBTSxDQUFDLEdBQzNELE1BQU0sSUFBSW5DLG1CQUFtQnFCLE9BQU9FLE1BQU0sQ0FBQ1ksU0FBUyxHQUN2QjtRQUNqQztRQUVBZCxPQUFPYyxTQUFTLEdBQUdkLE9BQU9FLE1BQU0sQ0FBQ1ksU0FBUyxDQUFDcUIsV0FBVztRQUN0RG5DLE9BQU9hLEtBQUssR0FBR2IsT0FBT0UsTUFBTSxDQUFDVyxLQUFLO1FBQ2xDLE9BQU9iO0lBQ1Q7QUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi9wYXJzZXIuanM/NTE5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuXG4vLy8tLS0gR2xvYmFsc1xuXG52YXIgSEFTSF9BTEdPUyA9IHV0aWxzLkhBU0hfQUxHT1M7XG52YXIgUEtfQUxHT1MgPSB1dGlscy5QS19BTEdPUztcbnZhciBIdHRwU2lnbmF0dXJlRXJyb3IgPSB1dGlscy5IdHRwU2lnbmF0dXJlRXJyb3I7XG52YXIgSW52YWxpZEFsZ29yaXRobUVycm9yID0gdXRpbHMuSW52YWxpZEFsZ29yaXRobUVycm9yO1xudmFyIHZhbGlkYXRlQWxnb3JpdGhtID0gdXRpbHMudmFsaWRhdGVBbGdvcml0aG07XG5cbnZhciBTdGF0ZSA9IHtcbiAgTmV3OiAwLFxuICBQYXJhbXM6IDFcbn07XG5cbnZhciBQYXJhbXNTdGF0ZSA9IHtcbiAgTmFtZTogMCxcbiAgUXVvdGU6IDEsXG4gIFZhbHVlOiAyLFxuICBDb21tYTogM1xufTtcblxuXG4vLy8tLS0gU3BlY2lmaWMgRXJyb3JzXG5cblxuZnVuY3Rpb24gRXhwaXJlZFJlcXVlc3RFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEV4cGlyZWRSZXF1ZXN0RXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhFeHBpcmVkUmVxdWVzdEVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5cbmZ1bmN0aW9uIEludmFsaWRIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEludmFsaWRIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEludmFsaWRIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuXG5mdW5jdGlvbiBJbnZhbGlkUGFyYW1zRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBJbnZhbGlkUGFyYW1zRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhJbnZhbGlkUGFyYW1zRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cblxuZnVuY3Rpb24gTWlzc2luZ0hlYWRlckVycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgTWlzc2luZ0hlYWRlckVycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoTWlzc2luZ0hlYWRlckVycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG5mdW5jdGlvbiBTdHJpY3RQYXJzaW5nRXJyb3IobWVzc2FnZSkge1xuICBIdHRwU2lnbmF0dXJlRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCBTdHJpY3RQYXJzaW5nRXJyb3IpO1xufVxudXRpbC5pbmhlcml0cyhTdHJpY3RQYXJzaW5nRXJyb3IsIEh0dHBTaWduYXR1cmVFcnJvcik7XG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgJ0F1dGhvcml6YXRpb24nIGhlYWRlciBvdXQgb2YgYW4gaHR0cC5TZXJ2ZXJSZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgQVBJIHdpbGwgZnVsbHkgdmFsaWRhdGUgdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyLCBhbmQgdGhyb3dcbiAgICogb24gYW55IGVycm9yLiAgSXQgd2lsbCBub3QgaG93ZXZlciBjaGVjayB0aGUgc2lnbmF0dXJlLCBvciB0aGUga2V5SWQgZm9ybWF0XG4gICAqIGFzIHRob3NlIGFyZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50LiAgWW91IGNhbiB1c2UgdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAqIHRvIHBhc3MgaW4gZXh0cmEgY29uc3RyYWludHMuXG4gICAqXG4gICAqIEFzIGEgcmVzcG9uc2Ugb2JqZWN0IHlvdSBjYW4gZXhwZWN0IHRoaXM6XG4gICAqXG4gICAqICAgICB7XG4gICAqICAgICAgIFwic2NoZW1lXCI6IFwiU2lnbmF0dXJlXCIsXG4gICAqICAgICAgIFwicGFyYW1zXCI6IHtcbiAgICogICAgICAgICBcImtleUlkXCI6IFwiZm9vXCIsXG4gICAqICAgICAgICAgXCJhbGdvcml0aG1cIjogXCJyc2Etc2hhMjU2XCIsXG4gICAqICAgICAgICAgXCJoZWFkZXJzXCI6IFtcbiAgICogICAgICAgICAgIFwiZGF0ZVwiIG9yIFwieC1kYXRlXCIsXG4gICAqICAgICAgICAgICBcImRpZ2VzdFwiXG4gICAqICAgICAgICAgXSxcbiAgICogICAgICAgICBcInNpZ25hdHVyZVwiOiBcImJhc2U2NFwiXG4gICAqICAgICAgIH0sXG4gICAqICAgICAgIFwic2lnbmluZ1N0cmluZ1wiOiBcInJlYWR5IHRvIGJlIHBhc3NlZCB0byBjcnlwdG8udmVyaWZ5KClcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBhbiBodHRwLlNlcnZlclJlcXVlc3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHdpdGg6XG4gICAqICAgICAgICAgICAgICAgICAgIC0gY2xvY2tTa2V3OiBhbGxvd2VkIGNsb2NrIHNrZXcgaW4gc2Vjb25kcyAoZGVmYXVsdCAzMDApLlxuICAgKiAgICAgICAgICAgICAgICAgICAtIGhlYWRlcnM6IHJlcXVpcmVkIGhlYWRlciBuYW1lcyAoZGVmOiBkYXRlIG9yIHgtZGF0ZSlcbiAgICogICAgICAgICAgICAgICAgICAgLSBhbGdvcml0aG1zOiBhbGdvcml0aG1zIHRvIHN1cHBvcnQgKGRlZmF1bHQ6IGFsbCkuXG4gICAqICAgICAgICAgICAgICAgICAgIC0gc3RyaWN0OiBzaG91bGQgZW5mb3JjZSBsYXRlc3Qgc3BlYyBwYXJzaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdDogZmFsc2UpLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhcnNlZCBvdXQgb2JqZWN0IChzZWUgYWJvdmUpLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGludmFsaWQgaW5wdXQuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRIZWFkZXJFcnJvcn0gb24gYW4gaW52YWxpZCBBdXRob3JpemF0aW9uIGhlYWRlciBlcnJvci5cbiAgICogQHRocm93cyB7SW52YWxpZFBhcmFtc0Vycm9yfSBpZiB0aGUgcGFyYW1zIGluIHRoZSBzY2hlbWUgYXJlIGludmFsaWQuXG4gICAqIEB0aHJvd3Mge01pc3NpbmdIZWFkZXJFcnJvcn0gaWYgdGhlIHBhcmFtcyBpbmRpY2F0ZSBhIGhlYWRlciBub3QgcHJlc2VudCxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXIgaW4gdGhlIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoZSBwYXJhbXMsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Igbm90IGluIHRoZSBwYXJhbXMgZnJvbSBhIHJlcXVpcmVkIGhlYWRlclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG9wdGlvbnMuXG4gICAqIEB0aHJvd3Mge1N0cmljdFBhcnNpbmdFcnJvcn0gaWYgb2xkIGF0dHJpYnV0ZXMgYXJlIHVzZWQgaW4gc3RyaWN0IHBhcnNpbmdcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlLlxuICAgKiBAdGhyb3dzIHtFeHBpcmVkUmVxdWVzdEVycm9yfSBpZiB0aGUgdmFsdWUgb2YgZGF0ZSBvciB4LWRhdGUgZXhjZWVkcyBza2V3LlxuICAgKi9cbiAgcGFyc2VSZXF1ZXN0OiBmdW5jdGlvbiBwYXJzZVJlcXVlc3QocmVxdWVzdCwgb3B0aW9ucykge1xuICAgIGFzc2VydC5vYmplY3QocmVxdWVzdCwgJ3JlcXVlc3QnKTtcbiAgICBhc3NlcnQub2JqZWN0KHJlcXVlc3QuaGVhZGVycywgJ3JlcXVlc3QuaGVhZGVycycpO1xuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBbcmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSA/ICd4LWRhdGUnIDogJ2RhdGUnXTtcbiAgICB9XG4gICAgYXNzZXJ0Lm9iamVjdChvcHRpb25zLCAnb3B0aW9ucycpO1xuICAgIGFzc2VydC5hcnJheU9mU3RyaW5nKG9wdGlvbnMuaGVhZGVycywgJ29wdGlvbnMuaGVhZGVycycpO1xuICAgIGFzc2VydC5vcHRpb25hbEZpbml0ZShvcHRpb25zLmNsb2NrU2tldywgJ29wdGlvbnMuY2xvY2tTa2V3Jyk7XG5cbiAgICB2YXIgYXV0aHpIZWFkZXJOYW1lID0gb3B0aW9ucy5hdXRob3JpemF0aW9uSGVhZGVyTmFtZSB8fCAnYXV0aG9yaXphdGlvbic7XG5cbiAgICBpZiAoIXJlcXVlc3QuaGVhZGVyc1thdXRoekhlYWRlck5hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKCdubyAnICsgYXV0aHpIZWFkZXJOYW1lICsgJyBoZWFkZXIgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmVzZW50IGluIHRoZSByZXF1ZXN0Jyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5jbG9ja1NrZXcgPSBvcHRpb25zLmNsb2NrU2tldyB8fCAzMDA7XG5cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgc3RhdGUgPSBTdGF0ZS5OZXc7XG4gICAgdmFyIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuTmFtZTtcbiAgICB2YXIgdG1wTmFtZSA9ICcnO1xuICAgIHZhciB0bXBWYWx1ZSA9ICcnO1xuXG4gICAgdmFyIHBhcnNlZCA9IHtcbiAgICAgIHNjaGVtZTogJycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgc2lnbmluZ1N0cmluZzogJydcbiAgICB9O1xuXG4gICAgdmFyIGF1dGh6ID0gcmVxdWVzdC5oZWFkZXJzW2F1dGh6SGVhZGVyTmFtZV07XG4gICAgZm9yIChpID0gMDsgaSA8IGF1dGh6Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGF1dGh6LmNoYXJBdChpKTtcblxuICAgICAgc3dpdGNoIChOdW1iZXIoc3RhdGUpKSB7XG5cbiAgICAgIGNhc2UgU3RhdGUuTmV3OlxuICAgICAgICBpZiAoYyAhPT0gJyAnKSBwYXJzZWQuc2NoZW1lICs9IGM7XG4gICAgICAgIGVsc2Ugc3RhdGUgPSBTdGF0ZS5QYXJhbXM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0YXRlLlBhcmFtczpcbiAgICAgICAgc3dpdGNoIChOdW1iZXIoc3Vic3RhdGUpKSB7XG5cbiAgICAgICAgY2FzZSBQYXJhbXNTdGF0ZS5OYW1lOlxuICAgICAgICAgIHZhciBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIC8vIHJlc3RyaWN0ZWQgbmFtZSBvZiBBLVogLyBhLXpcbiAgICAgICAgICBpZiAoKGNvZGUgPj0gMHg0MSAmJiBjb2RlIDw9IDB4NWEpIHx8IC8vIEEtWlxuICAgICAgICAgICAgICAoY29kZSA+PSAweDYxICYmIGNvZGUgPD0gMHg3YSkpIHsgLy8gYS16XG4gICAgICAgICAgICB0bXBOYW1lICs9IGM7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAnPScpIHtcbiAgICAgICAgICAgIGlmICh0bXBOYW1lLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5RdW90ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLlF1b3RlOlxuICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICB0bXBWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgc3Vic3RhdGUgPSBQYXJhbXNTdGF0ZS5WYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLlZhbHVlOlxuICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICBwYXJzZWQucGFyYW1zW3RtcE5hbWVdID0gdG1wVmFsdWU7XG4gICAgICAgICAgICBzdWJzdGF0ZSA9IFBhcmFtc1N0YXRlLkNvbW1hO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0bXBWYWx1ZSArPSBjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhcmFtc1N0YXRlLkNvbW1hOlxuICAgICAgICAgIGlmIChjID09PSAnLCcpIHtcbiAgICAgICAgICAgIHRtcE5hbWUgPSAnJztcbiAgICAgICAgICAgIHN1YnN0YXRlID0gUGFyYW1zU3RhdGUuTmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignYmFkIHBhcmFtIGZvcm1hdCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdWJzdGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic3RhdGUnKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5oZWFkZXJzIHx8IHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9PT0gJycpIHtcbiAgICAgIGlmIChyZXF1ZXN0LmhlYWRlcnNbJ3gtZGF0ZSddKSB7XG4gICAgICAgIHBhcnNlZC5wYXJhbXMuaGVhZGVycyA9IFsneC1kYXRlJ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnMgPSBbJ2RhdGUnXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnBhcmFtcy5oZWFkZXJzID0gcGFyc2VkLnBhcmFtcy5oZWFkZXJzLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgLy8gTWluaW1hbGx5IHZhbGlkYXRlIHRoZSBwYXJzZWQgb2JqZWN0XG4gICAgaWYgKCFwYXJzZWQuc2NoZW1lIHx8IHBhcnNlZC5zY2hlbWUgIT09ICdTaWduYXR1cmUnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcignc2NoZW1lIHdhcyBub3QgXCJTaWduYXR1cmVcIicpO1xuXG4gICAgaWYgKCFwYXJzZWQucGFyYW1zLmtleUlkKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRIZWFkZXJFcnJvcigna2V5SWQgd2FzIG5vdCBzcGVjaWZpZWQnKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0pXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdhbGdvcml0aG0gd2FzIG5vdCBzcGVjaWZpZWQnKTtcblxuICAgIGlmICghcGFyc2VkLnBhcmFtcy5zaWduYXR1cmUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEhlYWRlckVycm9yKCdzaWduYXR1cmUgd2FzIG5vdCBzcGVjaWZpZWQnKTtcblxuICAgIC8vIENoZWNrIHRoZSBhbGdvcml0aG0gYWdhaW5zdCB0aGUgb2ZmaWNpYWwgbGlzdFxuICAgIHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtID0gcGFyc2VkLnBhcmFtcy5hbGdvcml0aG0udG9Mb3dlckNhc2UoKTtcbiAgICB0cnkge1xuICAgICAgdmFsaWRhdGVBbGdvcml0aG0ocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgSW52YWxpZEFsZ29yaXRobUVycm9yKVxuICAgICAgICB0aHJvdyAobmV3IEludmFsaWRQYXJhbXNFcnJvcihwYXJzZWQucGFyYW1zLmFsZ29yaXRobSArICcgaXMgbm90ICcgK1xuICAgICAgICAgICdzdXBwb3J0ZWQnKSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IChlKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgc2lnbmluZ1N0cmluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXJzZWQucGFyYW1zLmhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoID0gcGFyc2VkLnBhcmFtcy5oZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgICBwYXJzZWQucGFyYW1zLmhlYWRlcnNbaV0gPSBoO1xuXG4gICAgICBpZiAoaCA9PT0gJ3JlcXVlc3QtbGluZScpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICogV2UgYWxsb3cgaGVhZGVycyBmcm9tIHRoZSBvbGRlciBzcGVjIGRyYWZ0cyBpZiBzdHJpY3QgcGFyc2luZyBpc24ndFxuICAgICAgICAgICAqIHNwZWNpZmllZCBpbiBvcHRpb25zLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9XG4gICAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCArICcgJyArIHJlcXVlc3QudXJsICsgJyBIVFRQLycgKyByZXF1ZXN0Lmh0dHBWZXJzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFN0cmljdCBwYXJzaW5nIGRvZXNuJ3QgYWxsb3cgb2xkZXIgZHJhZnQgaGVhZGVycy4gKi9cbiAgICAgICAgICB0aHJvdyAobmV3IFN0cmljdFBhcnNpbmdFcnJvcigncmVxdWVzdC1saW5lIGlzIG5vdCBhIHZhbGlkIGhlYWRlciAnICtcbiAgICAgICAgICAgICd3aXRoIHN0cmljdCBwYXJzaW5nIGVuYWJsZWQuJykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGggPT09ICcocmVxdWVzdC10YXJnZXQpJykge1xuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPVxuICAgICAgICAgICcocmVxdWVzdC10YXJnZXQpOiAnICsgcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSArICcgJyArXG4gICAgICAgICAgcmVxdWVzdC51cmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSByZXF1ZXN0LmhlYWRlcnNbaF07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nSGVhZGVyRXJyb3IoaCArICcgd2FzIG5vdCBpbiB0aGUgcmVxdWVzdCcpO1xuICAgICAgICBwYXJzZWQuc2lnbmluZ1N0cmluZyArPSBoICsgJzogJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGkgKyAxKSA8IHBhcnNlZC5wYXJhbXMuaGVhZGVycy5sZW5ndGgpXG4gICAgICAgIHBhcnNlZC5zaWduaW5nU3RyaW5nICs9ICdcXG4nO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGFnYWluc3QgdGhlIGNvbnN0cmFpbnRzXG4gICAgdmFyIGRhdGU7XG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycy5kYXRlIHx8IHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVyc1sneC1kYXRlJ10pIHtcbiAgICAgICAgICBkYXRlID0gbmV3IERhdGUocmVxdWVzdC5oZWFkZXJzWyd4LWRhdGUnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHJlcXVlc3QuaGVhZGVycy5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICB2YXIgc2tldyA9IE1hdGguYWJzKG5vdy5nZXRUaW1lKCkgLSBkYXRlLmdldFRpbWUoKSk7XG5cbiAgICAgIGlmIChza2V3ID4gb3B0aW9ucy5jbG9ja1NrZXcgKiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFeHBpcmVkUmVxdWVzdEVycm9yKCdjbG9jayBza2V3IG9mICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2tldyAvIDEwMDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3Mgd2FzIGdyZWF0ZXIgdGhhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jbG9ja1NrZXcgKyAncycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoZHIpIHtcbiAgICAgIC8vIFJlbWVtYmVyIHRoYXQgd2UgYWxyZWFkeSBjaGVja2VkIGFueSBoZWFkZXJzIGluIHRoZSBwYXJhbXNcbiAgICAgIC8vIHdlcmUgaW4gdGhlIHJlcXVlc3QsIHNvIGlmIHRoaXMgcGFzc2VzIHdlJ3JlIGdvb2QuXG4gICAgICBpZiAocGFyc2VkLnBhcmFtcy5oZWFkZXJzLmluZGV4T2YoaGRyLnRvTG93ZXJDYXNlKCkpIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdIZWFkZXJFcnJvcihoZHIgKyAnIHdhcyBub3QgYSBzaWduZWQgaGVhZGVyJyk7XG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5hbGdvcml0aG1zKSB7XG4gICAgICBpZiAob3B0aW9ucy5hbGdvcml0aG1zLmluZGV4T2YocGFyc2VkLnBhcmFtcy5hbGdvcml0aG0pID09PSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbXNFcnJvcihwYXJzZWQucGFyYW1zLmFsZ29yaXRobSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBpcyBub3QgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtJyk7XG4gICAgfVxuXG4gICAgcGFyc2VkLmFsZ29yaXRobSA9IHBhcnNlZC5wYXJhbXMuYWxnb3JpdGhtLnRvVXBwZXJDYXNlKCk7XG4gICAgcGFyc2VkLmtleUlkID0gcGFyc2VkLnBhcmFtcy5rZXlJZDtcbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbn07XG4iXSwibmFtZXMiOlsiYXNzZXJ0IiwicmVxdWlyZSIsInV0aWwiLCJ1dGlscyIsIkhBU0hfQUxHT1MiLCJQS19BTEdPUyIsIkh0dHBTaWduYXR1cmVFcnJvciIsIkludmFsaWRBbGdvcml0aG1FcnJvciIsInZhbGlkYXRlQWxnb3JpdGhtIiwiU3RhdGUiLCJOZXciLCJQYXJhbXMiLCJQYXJhbXNTdGF0ZSIsIk5hbWUiLCJRdW90ZSIsIlZhbHVlIiwiQ29tbWEiLCJFeHBpcmVkUmVxdWVzdEVycm9yIiwibWVzc2FnZSIsImNhbGwiLCJpbmhlcml0cyIsIkludmFsaWRIZWFkZXJFcnJvciIsIkludmFsaWRQYXJhbXNFcnJvciIsIk1pc3NpbmdIZWFkZXJFcnJvciIsIlN0cmljdFBhcnNpbmdFcnJvciIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYXJzZVJlcXVlc3QiLCJyZXF1ZXN0Iiwib3B0aW9ucyIsIm9iamVjdCIsImhlYWRlcnMiLCJ1bmRlZmluZWQiLCJhcnJheU9mU3RyaW5nIiwib3B0aW9uYWxGaW5pdGUiLCJjbG9ja1NrZXciLCJhdXRoekhlYWRlck5hbWUiLCJhdXRob3JpemF0aW9uSGVhZGVyTmFtZSIsImkiLCJzdGF0ZSIsInN1YnN0YXRlIiwidG1wTmFtZSIsInRtcFZhbHVlIiwicGFyc2VkIiwic2NoZW1lIiwicGFyYW1zIiwic2lnbmluZ1N0cmluZyIsImF1dGh6IiwibGVuZ3RoIiwiYyIsImNoYXJBdCIsIk51bWJlciIsImNvZGUiLCJjaGFyQ29kZUF0IiwiRXJyb3IiLCJzcGxpdCIsImtleUlkIiwiYWxnb3JpdGhtIiwic2lnbmF0dXJlIiwidG9Mb3dlckNhc2UiLCJlIiwiaCIsInN0cmljdCIsIm1ldGhvZCIsInVybCIsImh0dHBWZXJzaW9uIiwidmFsdWUiLCJkYXRlIiwiRGF0ZSIsIm5vdyIsInNrZXciLCJNYXRoIiwiYWJzIiwiZ2V0VGltZSIsImZvckVhY2giLCJoZHIiLCJpbmRleE9mIiwiYWxnb3JpdGhtcyIsInRvVXBwZXJDYXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/signer.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/signer.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(rsc)/./node_modules/sshpk/lib/index.js\");\nvar jsprim = __webpack_require__(/*! jsprim */ \"(rsc)/./node_modules/jsprim/lib/jsprim.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\nvar sprintf = (__webpack_require__(/*! util */ \"util\").format);\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar validateAlgorithm = utils.validateAlgorithm;\n///--- Globals\nvar AUTHZ_FMT = 'Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\",signature=\"%s\"';\n///--- Specific Errors\nfunction MissingHeaderError(message) {\n    HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\nfunction StrictParsingError(message) {\n    HttpSignatureError.call(this, message, StrictParsingError);\n}\nutil.inherits(StrictParsingError, HttpSignatureError);\n/* See createSigner() */ function RequestSigner(options) {\n    assert.object(options, \"options\");\n    var alg = [];\n    if (options.algorithm !== undefined) {\n        assert.string(options.algorithm, \"options.algorithm\");\n        alg = validateAlgorithm(options.algorithm);\n    }\n    this.rs_alg = alg;\n    /*\n   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones\n   * with an rs_signer.\n   *\n   * rs_signFunc-based RequestSigners have to build up their entire signing\n   * string within the rs_lines array and give it to rs_signFunc as a single\n   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to\n   * their signing state by using rs_signer.update(), thus only needing to\n   * buffer the hash function state and one line at a time.\n   */ if (options.sign !== undefined) {\n        assert.func(options.sign, \"options.sign\");\n        this.rs_signFunc = options.sign;\n    } else if (alg[0] === \"hmac\" && options.key !== undefined) {\n        assert.string(options.keyId, \"options.keyId\");\n        this.rs_keyId = options.keyId;\n        if (typeof options.key !== \"string\" && !Buffer.isBuffer(options.key)) throw new TypeError(\"options.key for HMAC must be a string or Buffer\");\n        /*\n     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their\n     * data in chunks rather than requiring it all to be given in one go\n     * at the end, so they are more similar to signers than signFuncs.\n     */ this.rs_signer = crypto.createHmac(alg[1].toUpperCase(), options.key);\n        this.rs_signer.sign = function() {\n            var digest = this.digest(\"base64\");\n            return {\n                hashAlgorithm: alg[1],\n                toString: function() {\n                    return digest;\n                }\n            };\n        };\n    } else if (options.key !== undefined) {\n        var key = options.key;\n        if (typeof key === \"string\" || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(key);\n        assert.ok(sshpk.PrivateKey.isPrivateKey(key, [\n            1,\n            2\n        ]), \"options.key must be a sshpk.PrivateKey\");\n        this.rs_key = key;\n        assert.string(options.keyId, \"options.keyId\");\n        this.rs_keyId = options.keyId;\n        if (!PK_ALGOS[key.type]) {\n            throw new InvalidAlgorithmError(key.type.toUpperCase() + \" type \" + \"keys are not supported\");\n        }\n        if (alg[0] !== undefined && key.type !== alg[0]) {\n            throw new InvalidAlgorithmError(\"options.key must be a \" + alg[0].toUpperCase() + \" key, was given a \" + key.type.toUpperCase() + \" key instead\");\n        }\n        this.rs_signer = key.createSign(alg[1]);\n    } else {\n        throw new TypeError(\"options.sign (func) or options.key is required\");\n    }\n    this.rs_headers = [];\n    this.rs_lines = [];\n}\n/**\n * Adds a header to be signed, with its value, into this signer.\n *\n * @param {String} header\n * @param {String} value\n * @return {String} value written\n */ RequestSigner.prototype.writeHeader = function(header, value) {\n    assert.string(header, \"header\");\n    header = header.toLowerCase();\n    assert.string(value, \"value\");\n    this.rs_headers.push(header);\n    if (this.rs_signFunc) {\n        this.rs_lines.push(header + \": \" + value);\n    } else {\n        var line = header + \": \" + value;\n        if (this.rs_headers.length > 0) line = \"\\n\" + line;\n        this.rs_signer.update(line);\n    }\n    return value;\n};\n/**\n * Adds a default Date header, returning its value.\n *\n * @return {String}\n */ RequestSigner.prototype.writeDateHeader = function() {\n    return this.writeHeader(\"date\", jsprim.rfc1123(new Date()));\n};\n/**\n * Adds the request target line to be signed.\n *\n * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')\n * @param {String} path\n */ RequestSigner.prototype.writeTarget = function(method, path) {\n    assert.string(method, \"method\");\n    assert.string(path, \"path\");\n    method = method.toLowerCase();\n    this.writeHeader(\"(request-target)\", method + \" \" + path);\n};\n/**\n * Calculate the value for the Authorization header on this request\n * asynchronously.\n *\n * @param {Func} callback (err, authz)\n */ RequestSigner.prototype.sign = function(cb) {\n    assert.func(cb, \"callback\");\n    if (this.rs_headers.length < 1) throw new Error(\"At least one header must be signed\");\n    var alg, authz;\n    if (this.rs_signFunc) {\n        var data = this.rs_lines.join(\"\\n\");\n        var self = this;\n        this.rs_signFunc(data, function(err, sig) {\n            if (err) {\n                cb(err);\n                return;\n            }\n            try {\n                assert.object(sig, \"signature\");\n                assert.string(sig.keyId, \"signature.keyId\");\n                assert.string(sig.algorithm, \"signature.algorithm\");\n                assert.string(sig.signature, \"signature.signature\");\n                alg = validateAlgorithm(sig.algorithm);\n                authz = sprintf(AUTHZ_FMT, sig.keyId, sig.algorithm, self.rs_headers.join(\" \"), sig.signature);\n            } catch (e) {\n                cb(e);\n                return;\n            }\n            cb(null, authz);\n        });\n    } else {\n        try {\n            var sigObj = this.rs_signer.sign();\n        } catch (e) {\n            cb(e);\n            return;\n        }\n        alg = (this.rs_alg[0] || this.rs_key.type) + \"-\" + sigObj.hashAlgorithm;\n        var signature = sigObj.toString();\n        authz = sprintf(AUTHZ_FMT, this.rs_keyId, alg, this.rs_headers.join(\" \"), signature);\n        cb(null, authz);\n    }\n};\n///--- Exported API\nmodule.exports = {\n    /**\n   * Identifies whether a given object is a request signer or not.\n   *\n   * @param {Object} object, the object to identify\n   * @returns {Boolean}\n   */ isSigner: function(obj) {\n        if (typeof obj === \"object\" && obj instanceof RequestSigner) return true;\n        return false;\n    },\n    /**\n   * Creates a request signer, used to asynchronously build a signature\n   * for a request (does not have to be an http.ClientRequest).\n   *\n   * @param {Object} options, either:\n   *                   - {String} keyId\n   *                   - {String|Buffer} key\n   *                   - {String} algorithm (optional, required for HMAC)\n   *                 or:\n   *                   - {Func} sign (data, cb)\n   * @return {RequestSigner}\n   */ createSigner: function createSigner(options) {\n        return new RequestSigner(options);\n    },\n    /**\n   * Adds an 'Authorization' header to an http.ClientRequest object.\n   *\n   * Note that this API will add a Date header if it's not already set. Any\n   * other headers in the options.headers array MUST be present, or this\n   * will throw.\n   *\n   * You shouldn't need to check the return type; it's just there if you want\n   * to be pedantic.\n   *\n   * The optional flag indicates whether parsing should use strict enforcement\n   * of the version draft-cavage-http-signatures-04 of the spec or beyond.\n   * The default is to be loose and support\n   * older versions for compatibility.\n   *\n   * @param {Object} request an instance of http.ClientRequest.\n   * @param {Object} options signing parameters object:\n   *                   - {String} keyId required.\n   *                   - {String} key required (either a PEM or HMAC key).\n   *                   - {Array} headers optional; defaults to ['date'].\n   *                   - {String} algorithm optional (unless key is HMAC);\n   *                              default is the same as the sshpk default\n   *                              signing algorithm for the type of key given\n   *                   - {String} httpVersion optional; defaults to '1.1'.\n   *                   - {Boolean} strict optional; defaults to 'false'.\n   * @return {Boolean} true if Authorization (and optionally Date) were added.\n   * @throws {TypeError} on bad parameter types (input).\n   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with\n   *                                 the given key.\n   * @throws {sshpk.KeyParseError} if key was bad.\n   * @throws {MissingHeaderError} if a header to be signed was specified but\n   *                              was not present.\n   */ signRequest: function signRequest(request, options) {\n        assert.object(request, \"request\");\n        assert.object(options, \"options\");\n        assert.optionalString(options.algorithm, \"options.algorithm\");\n        assert.string(options.keyId, \"options.keyId\");\n        assert.optionalArrayOfString(options.headers, \"options.headers\");\n        assert.optionalString(options.httpVersion, \"options.httpVersion\");\n        if (!request.getHeader(\"Date\")) request.setHeader(\"Date\", jsprim.rfc1123(new Date()));\n        if (!options.headers) options.headers = [\n            \"date\"\n        ];\n        if (!options.httpVersion) options.httpVersion = \"1.1\";\n        var alg = [];\n        if (options.algorithm) {\n            options.algorithm = options.algorithm.toLowerCase();\n            alg = validateAlgorithm(options.algorithm);\n        }\n        var i;\n        var stringToSign = \"\";\n        for(i = 0; i < options.headers.length; i++){\n            if (typeof options.headers[i] !== \"string\") throw new TypeError(\"options.headers must be an array of Strings\");\n            var h = options.headers[i].toLowerCase();\n            if (h === \"request-line\") {\n                if (!options.strict) {\n                    /**\n           * We allow headers from the older spec drafts if strict parsing isn't\n           * specified in options.\n           */ stringToSign += request.method + \" \" + request.path + \" HTTP/\" + options.httpVersion;\n                } else {\n                    /* Strict parsing doesn't allow older draft headers. */ throw new StrictParsingError(\"request-line is not a valid header \" + \"with strict parsing enabled.\");\n                }\n            } else if (h === \"(request-target)\") {\n                stringToSign += \"(request-target): \" + request.method.toLowerCase() + \" \" + request.path;\n            } else {\n                var value = request.getHeader(h);\n                if (value === undefined || value === \"\") {\n                    throw new MissingHeaderError(h + \" was not in the request\");\n                }\n                stringToSign += h + \": \" + value;\n            }\n            if (i + 1 < options.headers.length) stringToSign += \"\\n\";\n        }\n        /* This is just for unit tests. */ if (request.hasOwnProperty(\"_stringToSign\")) {\n            request._stringToSign = stringToSign;\n        }\n        var signature;\n        if (alg[0] === \"hmac\") {\n            if (typeof options.key !== \"string\" && !Buffer.isBuffer(options.key)) throw new TypeError(\"options.key must be a string or Buffer\");\n            var hmac = crypto.createHmac(alg[1].toUpperCase(), options.key);\n            hmac.update(stringToSign);\n            signature = hmac.digest(\"base64\");\n        } else {\n            var key = options.key;\n            if (typeof key === \"string\" || Buffer.isBuffer(key)) key = sshpk.parsePrivateKey(options.key);\n            assert.ok(sshpk.PrivateKey.isPrivateKey(key, [\n                1,\n                2\n            ]), \"options.key must be a sshpk.PrivateKey\");\n            if (!PK_ALGOS[key.type]) {\n                throw new InvalidAlgorithmError(key.type.toUpperCase() + \" type \" + \"keys are not supported\");\n            }\n            if (alg[0] !== undefined && key.type !== alg[0]) {\n                throw new InvalidAlgorithmError(\"options.key must be a \" + alg[0].toUpperCase() + \" key, was given a \" + key.type.toUpperCase() + \" key instead\");\n            }\n            var signer = key.createSign(alg[1]);\n            signer.update(stringToSign);\n            var sigObj = signer.sign();\n            if (!HASH_ALGOS[sigObj.hashAlgorithm]) {\n                throw new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() + \" is not a supported hash algorithm\");\n            }\n            options.algorithm = key.type + \"-\" + sigObj.hashAlgorithm;\n            signature = sigObj.toString();\n            assert.notStrictEqual(signature, \"\", \"empty signature produced\");\n        }\n        var authzHeaderName = options.authorizationHeaderName || \"Authorization\";\n        request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT, options.keyId, options.algorithm, options.headers.join(\" \"), signature));\n        return true;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvREFBb0Q7QUFFcEQsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUcsT0FBT0gsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUksUUFBUUosbUJBQU9BLENBQUM7QUFDcEIsSUFBSUssU0FBU0wsbUJBQU9BLENBQUM7QUFDckIsSUFBSU0sUUFBUU4sbUJBQU9BLENBQUM7QUFFcEIsSUFBSU8sVUFBVVAsZ0RBQXNCO0FBRXBDLElBQUlTLGFBQWFILE1BQU1HLFVBQVU7QUFDakMsSUFBSUMsV0FBV0osTUFBTUksUUFBUTtBQUM3QixJQUFJQyx3QkFBd0JMLE1BQU1LLHFCQUFxQjtBQUN2RCxJQUFJQyxxQkFBcUJOLE1BQU1NLGtCQUFrQjtBQUNqRCxJQUFJQyxvQkFBb0JQLE1BQU1PLGlCQUFpQjtBQUUvQyxjQUFjO0FBRWQsSUFBSUMsWUFDRjtBQUVGLHNCQUFzQjtBQUV0QixTQUFTQyxtQkFBbUJDLE9BQU87SUFDakNKLG1CQUFtQkssSUFBSSxDQUFDLElBQUksRUFBRUQsU0FBU0Q7QUFDekM7QUFDQVosS0FBS2UsUUFBUSxDQUFDSCxvQkFBb0JIO0FBRWxDLFNBQVNPLG1CQUFtQkgsT0FBTztJQUNqQ0osbUJBQW1CSyxJQUFJLENBQUMsSUFBSSxFQUFFRCxTQUFTRztBQUN6QztBQUNBaEIsS0FBS2UsUUFBUSxDQUFDQyxvQkFBb0JQO0FBRWxDLHNCQUFzQixHQUN0QixTQUFTUSxjQUFjQyxPQUFPO0lBQzVCdEIsT0FBT3VCLE1BQU0sQ0FBQ0QsU0FBUztJQUV2QixJQUFJRSxNQUFNLEVBQUU7SUFDWixJQUFJRixRQUFRRyxTQUFTLEtBQUtDLFdBQVc7UUFDbkMxQixPQUFPMkIsTUFBTSxDQUFDTCxRQUFRRyxTQUFTLEVBQUU7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UWdGLHVCQUF1QixJQUFJO1FBRXpEakIsUUFBUU0sU0FBUyxDQUFDVSxpQkFBaUI3RixRQUFRTyxXQUNBTyxRQUFRVyxLQUFLLEVBQ2JYLFFBQVFHLFNBQVMsRUFDakJILFFBQVFrRSxPQUFPLENBQUNoQixJQUFJLENBQUMsTUFDckJJO1FBRTNDLE9BQU87SUFDVDtBQUVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3NpZ25lci5qcz9hOTg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDEyIEpveWVudCwgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHNzaHBrID0gcmVxdWlyZSgnc3NocGsnKTtcbnZhciBqc3ByaW0gPSByZXF1aXJlKCdqc3ByaW0nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIHNwcmludGYgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuXG52YXIgSEFTSF9BTEdPUyA9IHV0aWxzLkhBU0hfQUxHT1M7XG52YXIgUEtfQUxHT1MgPSB1dGlscy5QS19BTEdPUztcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSB1dGlscy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgSHR0cFNpZ25hdHVyZUVycm9yID0gdXRpbHMuSHR0cFNpZ25hdHVyZUVycm9yO1xudmFyIHZhbGlkYXRlQWxnb3JpdGhtID0gdXRpbHMudmFsaWRhdGVBbGdvcml0aG07XG5cbi8vLy0tLSBHbG9iYWxzXG5cbnZhciBBVVRIWl9GTVQgPVxuICAnU2lnbmF0dXJlIGtleUlkPVwiJXNcIixhbGdvcml0aG09XCIlc1wiLGhlYWRlcnM9XCIlc1wiLHNpZ25hdHVyZT1cIiVzXCInO1xuXG4vLy8tLS0gU3BlY2lmaWMgRXJyb3JzXG5cbmZ1bmN0aW9uIE1pc3NpbmdIZWFkZXJFcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIE1pc3NpbmdIZWFkZXJFcnJvcik7XG59XG51dGlsLmluaGVyaXRzKE1pc3NpbmdIZWFkZXJFcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuZnVuY3Rpb24gU3RyaWN0UGFyc2luZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgSHR0cFNpZ25hdHVyZUVycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgU3RyaWN0UGFyc2luZ0Vycm9yKTtcbn1cbnV0aWwuaW5oZXJpdHMoU3RyaWN0UGFyc2luZ0Vycm9yLCBIdHRwU2lnbmF0dXJlRXJyb3IpO1xuXG4vKiBTZWUgY3JlYXRlU2lnbmVyKCkgKi9cbmZ1bmN0aW9uIFJlcXVlc3RTaWduZXIob3B0aW9ucykge1xuICBhc3NlcnQub2JqZWN0KG9wdGlvbnMsICdvcHRpb25zJyk7XG5cbiAgdmFyIGFsZyA9IFtdO1xuICBpZiAob3B0aW9ucy5hbGdvcml0aG0gIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuICAgIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKG9wdGlvbnMuYWxnb3JpdGhtKTtcbiAgfVxuICB0aGlzLnJzX2FsZyA9IGFsZztcblxuICAvKlxuICAgKiBSZXF1ZXN0U2lnbmVycyBjb21lIGluIHR3byB2YXJpZXRpZXM6IG9uZXMgd2l0aCBhbiByc19zaWduRnVuYywgYW5kIG9uZXNcbiAgICogd2l0aCBhbiByc19zaWduZXIuXG4gICAqXG4gICAqIHJzX3NpZ25GdW5jLWJhc2VkIFJlcXVlc3RTaWduZXJzIGhhdmUgdG8gYnVpbGQgdXAgdGhlaXIgZW50aXJlIHNpZ25pbmdcbiAgICogc3RyaW5nIHdpdGhpbiB0aGUgcnNfbGluZXMgYXJyYXkgYW5kIGdpdmUgaXQgdG8gcnNfc2lnbkZ1bmMgYXMgYSBzaW5nbGVcbiAgICogY29uY2F0J2QgYmxvYi4gcnNfc2lnbmVyLWJhc2VkIFJlcXVlc3RTaWduZXJzIGNhbiBhZGQgYSBsaW5lIGF0IGEgdGltZSB0b1xuICAgKiB0aGVpciBzaWduaW5nIHN0YXRlIGJ5IHVzaW5nIHJzX3NpZ25lci51cGRhdGUoKSwgdGh1cyBvbmx5IG5lZWRpbmcgdG9cbiAgICogYnVmZmVyIHRoZSBoYXNoIGZ1bmN0aW9uIHN0YXRlIGFuZCBvbmUgbGluZSBhdCBhIHRpbWUuXG4gICAqL1xuICBpZiAob3B0aW9ucy5zaWduICE9PSB1bmRlZmluZWQpIHtcbiAgICBhc3NlcnQuZnVuYyhvcHRpb25zLnNpZ24sICdvcHRpb25zLnNpZ24nKTtcbiAgICB0aGlzLnJzX3NpZ25GdW5jID0gb3B0aW9ucy5zaWduO1xuXG4gIH0gZWxzZSBpZiAoYWxnWzBdID09PSAnaG1hYycgJiYgb3B0aW9ucy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5rZXlJZCwgJ29wdGlvbnMua2V5SWQnKTtcbiAgICB0aGlzLnJzX2tleUlkID0gb3B0aW9ucy5rZXlJZDtcblxuICAgIGlmICh0eXBlb2YgKG9wdGlvbnMua2V5KSAhPT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmtleSkpXG4gICAgICB0aHJvdyAobmV3IFR5cGVFcnJvcignb3B0aW9ucy5rZXkgZm9yIEhNQUMgbXVzdCBiZSBhIHN0cmluZyBvciBCdWZmZXInKSk7XG5cbiAgICAvKlxuICAgICAqIE1ha2UgYW4gcnNfc2lnbmVyIGZvciBITUFDcywgbm90IGEgcnNfc2lnbkZ1bmMgLS0gSE1BQ3MgZGlnZXN0IHRoZWlyXG4gICAgICogZGF0YSBpbiBjaHVua3MgcmF0aGVyIHRoYW4gcmVxdWlyaW5nIGl0IGFsbCB0byBiZSBnaXZlbiBpbiBvbmUgZ29cbiAgICAgKiBhdCB0aGUgZW5kLCBzbyB0aGV5IGFyZSBtb3JlIHNpbWlsYXIgdG8gc2lnbmVycyB0aGFuIHNpZ25GdW5jcy5cbiAgICAgKi9cbiAgICB0aGlzLnJzX3NpZ25lciA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ1sxXS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLmtleSk7XG4gICAgdGhpcy5yc19zaWduZXIuc2lnbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkaWdlc3QgPSB0aGlzLmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgICByZXR1cm4gKHtcbiAgICAgICAgaGFzaEFsZ29yaXRobTogYWxnWzFdLFxuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gKGRpZ2VzdCk7IH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgfSBlbHNlIGlmIChvcHRpb25zLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIGlmICh0eXBlb2YgKGtleSkgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihrZXkpKVxuICAgICAga2V5ID0gc3NocGsucGFyc2VQcml2YXRlS2V5KGtleSk7XG5cbiAgICBhc3NlcnQub2soc3NocGsuUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5LCBbMSwgMl0pLFxuICAgICAgJ29wdGlvbnMua2V5IG11c3QgYmUgYSBzc2hway5Qcml2YXRlS2V5Jyk7XG4gICAgdGhpcy5yc19rZXkgPSBrZXk7XG5cbiAgICBhc3NlcnQuc3RyaW5nKG9wdGlvbnMua2V5SWQsICdvcHRpb25zLmtleUlkJyk7XG4gICAgdGhpcy5yc19rZXlJZCA9IG9wdGlvbnMua2V5SWQ7XG5cbiAgICBpZiAoIVBLX0FMR09TW2tleS50eXBlXSkge1xuICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Ioa2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcgdHlwZSAnICtcbiAgICAgICAgJ2tleXMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKGFsZ1swXSAhPT0gdW5kZWZpbmVkICYmIGtleS50eXBlICE9PSBhbGdbMF0pIHtcbiAgICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKCdvcHRpb25zLmtleSBtdXN0IGJlIGEgJyArXG4gICAgICAgIGFsZ1swXS50b1VwcGVyQ2FzZSgpICsgJyBrZXksIHdhcyBnaXZlbiBhICcgK1xuICAgICAgICBrZXkudHlwZS50b1VwcGVyQ2FzZSgpICsgJyBrZXkgaW5zdGVhZCcpKTtcbiAgICB9XG5cbiAgICB0aGlzLnJzX3NpZ25lciA9IGtleS5jcmVhdGVTaWduKGFsZ1sxXSk7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAobmV3IFR5cGVFcnJvcignb3B0aW9ucy5zaWduIChmdW5jKSBvciBvcHRpb25zLmtleSBpcyByZXF1aXJlZCcpKTtcbiAgfVxuXG4gIHRoaXMucnNfaGVhZGVycyA9IFtdO1xuICB0aGlzLnJzX2xpbmVzID0gW107XG59XG5cbi8qKlxuICogQWRkcyBhIGhlYWRlciB0byBiZSBzaWduZWQsIHdpdGggaXRzIHZhbHVlLCBpbnRvIHRoaXMgc2lnbmVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSB2YWx1ZSB3cml0dGVuXG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLndyaXRlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlciwgdmFsdWUpIHtcbiAgYXNzZXJ0LnN0cmluZyhoZWFkZXIsICdoZWFkZXInKTtcbiAgaGVhZGVyID0gaGVhZGVyLnRvTG93ZXJDYXNlKCk7XG4gIGFzc2VydC5zdHJpbmcodmFsdWUsICd2YWx1ZScpO1xuXG4gIHRoaXMucnNfaGVhZGVycy5wdXNoKGhlYWRlcik7XG5cbiAgaWYgKHRoaXMucnNfc2lnbkZ1bmMpIHtcbiAgICB0aGlzLnJzX2xpbmVzLnB1c2goaGVhZGVyICsgJzogJyArIHZhbHVlKTtcblxuICB9IGVsc2Uge1xuICAgIHZhciBsaW5lID0gaGVhZGVyICsgJzogJyArIHZhbHVlO1xuICAgIGlmICh0aGlzLnJzX2hlYWRlcnMubGVuZ3RoID4gMClcbiAgICAgIGxpbmUgPSAnXFxuJyArIGxpbmU7XG4gICAgdGhpcy5yc19zaWduZXIudXBkYXRlKGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuICh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBkZWZhdWx0IERhdGUgaGVhZGVyLCByZXR1cm5pbmcgaXRzIHZhbHVlLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuUmVxdWVzdFNpZ25lci5wcm90b3R5cGUud3JpdGVEYXRlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMud3JpdGVIZWFkZXIoJ2RhdGUnLCBqc3ByaW0ucmZjMTEyMyhuZXcgRGF0ZSgpKSkpO1xufTtcblxuLyoqXG4gKiBBZGRzIHRoZSByZXF1ZXN0IHRhcmdldCBsaW5lIHRvIGJlIHNpZ25lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kLCBIVFRQIG1ldGhvZCAoZS5nLiAnZ2V0JywgJ3Bvc3QnLCAncHV0JylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLndyaXRlVGFyZ2V0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGF0aCkge1xuICBhc3NlcnQuc3RyaW5nKG1ldGhvZCwgJ21ldGhvZCcpO1xuICBhc3NlcnQuc3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gIG1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLndyaXRlSGVhZGVyKCcocmVxdWVzdC10YXJnZXQpJywgbWV0aG9kICsgJyAnICsgcGF0aCk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgdmFsdWUgZm9yIHRoZSBBdXRob3JpemF0aW9uIGhlYWRlciBvbiB0aGlzIHJlcXVlc3RcbiAqIGFzeW5jaHJvbm91c2x5LlxuICpcbiAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgKGVyciwgYXV0aHopXG4gKi9cblJlcXVlc3RTaWduZXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoY2IpIHtcbiAgYXNzZXJ0LmZ1bmMoY2IsICdjYWxsYmFjaycpO1xuXG4gIGlmICh0aGlzLnJzX2hlYWRlcnMubGVuZ3RoIDwgMSlcbiAgICB0aHJvdyAobmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgaGVhZGVyIG11c3QgYmUgc2lnbmVkJykpO1xuXG4gIHZhciBhbGcsIGF1dGh6O1xuICBpZiAodGhpcy5yc19zaWduRnVuYykge1xuICAgIHZhciBkYXRhID0gdGhpcy5yc19saW5lcy5qb2luKCdcXG4nKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5yc19zaWduRnVuYyhkYXRhLCBmdW5jdGlvbiAoZXJyLCBzaWcpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0Lm9iamVjdChzaWcsICdzaWduYXR1cmUnKTtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyhzaWcua2V5SWQsICdzaWduYXR1cmUua2V5SWQnKTtcbiAgICAgICAgYXNzZXJ0LnN0cmluZyhzaWcuYWxnb3JpdGhtLCAnc2lnbmF0dXJlLmFsZ29yaXRobScpO1xuICAgICAgICBhc3NlcnQuc3RyaW5nKHNpZy5zaWduYXR1cmUsICdzaWduYXR1cmUuc2lnbmF0dXJlJyk7XG4gICAgICAgIGFsZyA9IHZhbGlkYXRlQWxnb3JpdGhtKHNpZy5hbGdvcml0aG0pO1xuXG4gICAgICAgIGF1dGh6ID0gc3ByaW50ZihBVVRIWl9GTVQsXG4gICAgICAgICAgc2lnLmtleUlkLFxuICAgICAgICAgIHNpZy5hbGdvcml0aG0sXG4gICAgICAgICAgc2VsZi5yc19oZWFkZXJzLmpvaW4oJyAnKSxcbiAgICAgICAgICBzaWcuc2lnbmF0dXJlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2IoZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNiKG51bGwsIGF1dGh6KTtcbiAgICB9KTtcblxuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICB2YXIgc2lnT2JqID0gdGhpcy5yc19zaWduZXIuc2lnbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbGcgPSAodGhpcy5yc19hbGdbMF0gfHwgdGhpcy5yc19rZXkudHlwZSkgKyAnLScgKyBzaWdPYmouaGFzaEFsZ29yaXRobTtcbiAgICB2YXIgc2lnbmF0dXJlID0gc2lnT2JqLnRvU3RyaW5nKCk7XG4gICAgYXV0aHogPSBzcHJpbnRmKEFVVEhaX0ZNVCxcbiAgICAgIHRoaXMucnNfa2V5SWQsXG4gICAgICBhbGcsXG4gICAgICB0aGlzLnJzX2hlYWRlcnMuam9pbignICcpLFxuICAgICAgc2lnbmF0dXJlKTtcbiAgICBjYihudWxsLCBhdXRoeik7XG4gIH1cbn07XG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVzIHdoZXRoZXIgYSBnaXZlbiBvYmplY3QgaXMgYSByZXF1ZXN0IHNpZ25lciBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QsIHRoZSBvYmplY3QgdG8gaWRlbnRpZnlcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1NpZ25lcjogZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICh0eXBlb2YgKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiBpbnN0YW5jZW9mIFJlcXVlc3RTaWduZXIpXG4gICAgICByZXR1cm4gKHRydWUpO1xuICAgIHJldHVybiAoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVxdWVzdCBzaWduZXIsIHVzZWQgdG8gYXN5bmNocm9ub3VzbHkgYnVpbGQgYSBzaWduYXR1cmVcbiAgICogZm9yIGEgcmVxdWVzdCAoZG9lcyBub3QgaGF2ZSB0byBiZSBhbiBodHRwLkNsaWVudFJlcXVlc3QpLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucywgZWl0aGVyOlxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGtleUlkXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge1N0cmluZ3xCdWZmZXJ9IGtleVxuICAgKiAgICAgICAgICAgICAgICAgICAtIHtTdHJpbmd9IGFsZ29yaXRobSAob3B0aW9uYWwsIHJlcXVpcmVkIGZvciBITUFDKVxuICAgKiAgICAgICAgICAgICAgICAgb3I6XG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0Z1bmN9IHNpZ24gKGRhdGEsIGNiKVxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0U2lnbmVyfVxuICAgKi9cbiAgY3JlYXRlU2lnbmVyOiBmdW5jdGlvbiBjcmVhdGVTaWduZXIob3B0aW9ucykge1xuICAgIHJldHVybiAobmV3IFJlcXVlc3RTaWduZXIob3B0aW9ucykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGFuICdBdXRob3JpemF0aW9uJyBoZWFkZXIgdG8gYW4gaHR0cC5DbGllbnRSZXF1ZXN0IG9iamVjdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgQVBJIHdpbGwgYWRkIGEgRGF0ZSBoZWFkZXIgaWYgaXQncyBub3QgYWxyZWFkeSBzZXQuIEFueVxuICAgKiBvdGhlciBoZWFkZXJzIGluIHRoZSBvcHRpb25zLmhlYWRlcnMgYXJyYXkgTVVTVCBiZSBwcmVzZW50LCBvciB0aGlzXG4gICAqIHdpbGwgdGhyb3cuXG4gICAqXG4gICAqIFlvdSBzaG91bGRuJ3QgbmVlZCB0byBjaGVjayB0aGUgcmV0dXJuIHR5cGU7IGl0J3MganVzdCB0aGVyZSBpZiB5b3Ugd2FudFxuICAgKiB0byBiZSBwZWRhbnRpYy5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGZsYWcgaW5kaWNhdGVzIHdoZXRoZXIgcGFyc2luZyBzaG91bGQgdXNlIHN0cmljdCBlbmZvcmNlbWVudFxuICAgKiBvZiB0aGUgdmVyc2lvbiBkcmFmdC1jYXZhZ2UtaHR0cC1zaWduYXR1cmVzLTA0IG9mIHRoZSBzcGVjIG9yIGJleW9uZC5cbiAgICogVGhlIGRlZmF1bHQgaXMgdG8gYmUgbG9vc2UgYW5kIHN1cHBvcnRcbiAgICogb2xkZXIgdmVyc2lvbnMgZm9yIGNvbXBhdGliaWxpdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGFuIGluc3RhbmNlIG9mIGh0dHAuQ2xpZW50UmVxdWVzdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgc2lnbmluZyBwYXJhbWV0ZXJzIG9iamVjdDpcbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXlJZCByZXF1aXJlZC5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBrZXkgcmVxdWlyZWQgKGVpdGhlciBhIFBFTSBvciBITUFDIGtleSkuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0FycmF5fSBoZWFkZXJzIG9wdGlvbmFsOyBkZWZhdWx0cyB0byBbJ2RhdGUnXS5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBhbGdvcml0aG0gb3B0aW9uYWwgKHVubGVzcyBrZXkgaXMgSE1BQyk7XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCBpcyB0aGUgc2FtZSBhcyB0aGUgc3NocGsgZGVmYXVsdFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pbmcgYWxnb3JpdGhtIGZvciB0aGUgdHlwZSBvZiBrZXkgZ2l2ZW5cbiAgICogICAgICAgICAgICAgICAgICAgLSB7U3RyaW5nfSBodHRwVmVyc2lvbiBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJzEuMScuXG4gICAqICAgICAgICAgICAgICAgICAgIC0ge0Jvb2xlYW59IHN0cmljdCBvcHRpb25hbDsgZGVmYXVsdHMgdG8gJ2ZhbHNlJy5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBBdXRob3JpemF0aW9uIChhbmQgb3B0aW9uYWxseSBEYXRlKSB3ZXJlIGFkZGVkLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBwYXJhbWV0ZXIgdHlwZXMgKGlucHV0KS5cbiAgICogQHRocm93cyB7SW52YWxpZEFsZ29yaXRobUVycm9yfSBpZiBhbGdvcml0aG0gd2FzIGJhZCBvciBpbmNvbXBhdGlibGUgd2l0aFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBnaXZlbiBrZXkuXG4gICAqIEB0aHJvd3Mge3NzaHBrLktleVBhcnNlRXJyb3J9IGlmIGtleSB3YXMgYmFkLlxuICAgKiBAdGhyb3dzIHtNaXNzaW5nSGVhZGVyRXJyb3J9IGlmIGEgaGVhZGVyIHRvIGJlIHNpZ25lZCB3YXMgc3BlY2lmaWVkIGJ1dFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhcyBub3QgcHJlc2VudC5cbiAgICovXG4gIHNpZ25SZXF1ZXN0OiBmdW5jdGlvbiBzaWduUmVxdWVzdChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0Lm9iamVjdChyZXF1ZXN0LCAncmVxdWVzdCcpO1xuICAgIGFzc2VydC5vYmplY3Qob3B0aW9ucywgJ29wdGlvbnMnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxTdHJpbmcob3B0aW9ucy5hbGdvcml0aG0sICdvcHRpb25zLmFsZ29yaXRobScpO1xuICAgIGFzc2VydC5zdHJpbmcob3B0aW9ucy5rZXlJZCwgJ29wdGlvbnMua2V5SWQnKTtcbiAgICBhc3NlcnQub3B0aW9uYWxBcnJheU9mU3RyaW5nKG9wdGlvbnMuaGVhZGVycywgJ29wdGlvbnMuaGVhZGVycycpO1xuICAgIGFzc2VydC5vcHRpb25hbFN0cmluZyhvcHRpb25zLmh0dHBWZXJzaW9uLCAnb3B0aW9ucy5odHRwVmVyc2lvbicpO1xuXG4gICAgaWYgKCFyZXF1ZXN0LmdldEhlYWRlcignRGF0ZScpKVxuICAgICAgcmVxdWVzdC5zZXRIZWFkZXIoJ0RhdGUnLCBqc3ByaW0ucmZjMTEyMyhuZXcgRGF0ZSgpKSk7XG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpXG4gICAgICBvcHRpb25zLmhlYWRlcnMgPSBbJ2RhdGUnXTtcbiAgICBpZiAoIW9wdGlvbnMuaHR0cFZlcnNpb24pXG4gICAgICBvcHRpb25zLmh0dHBWZXJzaW9uID0gJzEuMSc7XG5cbiAgICB2YXIgYWxnID0gW107XG4gICAgaWYgKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9IG9wdGlvbnMuYWxnb3JpdGhtLnRvTG93ZXJDYXNlKCk7XG4gICAgICBhbGcgPSB2YWxpZGF0ZUFsZ29yaXRobShvcHRpb25zLmFsZ29yaXRobSk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIHN0cmluZ1RvU2lnbiA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuaGVhZGVyc1tpXSkgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmhlYWRlcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBTdHJpbmdzJyk7XG5cbiAgICAgIHZhciBoID0gb3B0aW9ucy5oZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmIChoID09PSAncmVxdWVzdC1saW5lJykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogV2UgYWxsb3cgaGVhZGVycyBmcm9tIHRoZSBvbGRlciBzcGVjIGRyYWZ0cyBpZiBzdHJpY3QgcGFyc2luZyBpc24ndFxuICAgICAgICAgICAqIHNwZWNpZmllZCBpbiBvcHRpb25zLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHN0cmluZ1RvU2lnbiArPVxuICAgICAgICAgICAgcmVxdWVzdC5tZXRob2QgKyAnICcgKyByZXF1ZXN0LnBhdGggKyAnIEhUVFAvJyArXG4gICAgICAgICAgICBvcHRpb25zLmh0dHBWZXJzaW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qIFN0cmljdCBwYXJzaW5nIGRvZXNuJ3QgYWxsb3cgb2xkZXIgZHJhZnQgaGVhZGVycy4gKi9cbiAgICAgICAgICB0aHJvdyAobmV3IFN0cmljdFBhcnNpbmdFcnJvcigncmVxdWVzdC1saW5lIGlzIG5vdCBhIHZhbGlkIGhlYWRlciAnICtcbiAgICAgICAgICAgICd3aXRoIHN0cmljdCBwYXJzaW5nIGVuYWJsZWQuJykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGggPT09ICcocmVxdWVzdC10YXJnZXQpJykge1xuICAgICAgICBzdHJpbmdUb1NpZ24gKz1cbiAgICAgICAgICAnKHJlcXVlc3QtdGFyZ2V0KTogJyArIHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgKyAnICcgK1xuICAgICAgICAgIHJlcXVlc3QucGF0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKGgpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ0hlYWRlckVycm9yKGggKyAnIHdhcyBub3QgaW4gdGhlIHJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz0gaCArICc6ICcgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChpICsgMSkgPCBvcHRpb25zLmhlYWRlcnMubGVuZ3RoKVxuICAgICAgICBzdHJpbmdUb1NpZ24gKz0gJ1xcbic7XG4gICAgfVxuXG4gICAgLyogVGhpcyBpcyBqdXN0IGZvciB1bml0IHRlc3RzLiAqL1xuICAgIGlmIChyZXF1ZXN0Lmhhc093blByb3BlcnR5KCdfc3RyaW5nVG9TaWduJykpIHtcbiAgICAgIHJlcXVlc3QuX3N0cmluZ1RvU2lnbiA9IHN0cmluZ1RvU2lnbjtcbiAgICB9XG5cbiAgICB2YXIgc2lnbmF0dXJlO1xuICAgIGlmIChhbGdbMF0gPT09ICdobWFjJykge1xuICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy5rZXkpICE9PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMua2V5KSlcbiAgICAgICAgdGhyb3cgKG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMua2V5IG11c3QgYmUgYSBzdHJpbmcgb3IgQnVmZmVyJykpO1xuXG4gICAgICB2YXIgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGFsZ1sxXS50b1VwcGVyQ2FzZSgpLCBvcHRpb25zLmtleSk7XG4gICAgICBobWFjLnVwZGF0ZShzdHJpbmdUb1NpZ24pO1xuICAgICAgc2lnbmF0dXJlID0gaG1hYy5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgICAgIGlmICh0eXBlb2YgKGtleSkgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihrZXkpKVxuICAgICAgICBrZXkgPSBzc2hway5wYXJzZVByaXZhdGVLZXkob3B0aW9ucy5rZXkpO1xuXG4gICAgICBhc3NlcnQub2soc3NocGsuUHJpdmF0ZUtleS5pc1ByaXZhdGVLZXkoa2V5LCBbMSwgMl0pLFxuICAgICAgICAnb3B0aW9ucy5rZXkgbXVzdCBiZSBhIHNzaHBrLlByaXZhdGVLZXknKTtcblxuICAgICAgaWYgKCFQS19BTEdPU1trZXkudHlwZV0pIHtcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Ioa2V5LnR5cGUudG9VcHBlckNhc2UoKSArICcgdHlwZSAnICtcbiAgICAgICAgICAna2V5cyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsZ1swXSAhPT0gdW5kZWZpbmVkICYmIGtleS50eXBlICE9PSBhbGdbMF0pIHtcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoJ29wdGlvbnMua2V5IG11c3QgYmUgYSAnICtcbiAgICAgICAgICBhbGdbMF0udG9VcHBlckNhc2UoKSArICcga2V5LCB3YXMgZ2l2ZW4gYSAnICtcbiAgICAgICAgICBrZXkudHlwZS50b1VwcGVyQ2FzZSgpICsgJyBrZXkgaW5zdGVhZCcpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpZ25lciA9IGtleS5jcmVhdGVTaWduKGFsZ1sxXSk7XG4gICAgICBzaWduZXIudXBkYXRlKHN0cmluZ1RvU2lnbik7XG4gICAgICB2YXIgc2lnT2JqID0gc2lnbmVyLnNpZ24oKTtcbiAgICAgIGlmICghSEFTSF9BTEdPU1tzaWdPYmouaGFzaEFsZ29yaXRobV0pIHtcbiAgICAgICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3Ioc2lnT2JqLmhhc2hBbGdvcml0aG0udG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgJyBpcyBub3QgYSBzdXBwb3J0ZWQgaGFzaCBhbGdvcml0aG0nKSk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLmFsZ29yaXRobSA9IGtleS50eXBlICsgJy0nICsgc2lnT2JqLmhhc2hBbGdvcml0aG07XG4gICAgICBzaWduYXR1cmUgPSBzaWdPYmoudG9TdHJpbmcoKTtcbiAgICAgIGFzc2VydC5ub3RTdHJpY3RFcXVhbChzaWduYXR1cmUsICcnLCAnZW1wdHkgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgfVxuXG4gICAgdmFyIGF1dGh6SGVhZGVyTmFtZSA9IG9wdGlvbnMuYXV0aG9yaXphdGlvbkhlYWRlck5hbWUgfHwgJ0F1dGhvcml6YXRpb24nO1xuXG4gICAgcmVxdWVzdC5zZXRIZWFkZXIoYXV0aHpIZWFkZXJOYW1lLCBzcHJpbnRmKEFVVEhaX0ZNVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5rZXlJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5hbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5qb2luKCcgJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiY3J5cHRvIiwiaHR0cCIsInV0aWwiLCJzc2hwayIsImpzcHJpbSIsInV0aWxzIiwic3ByaW50ZiIsImZvcm1hdCIsIkhBU0hfQUxHT1MiLCJQS19BTEdPUyIsIkludmFsaWRBbGdvcml0aG1FcnJvciIsIkh0dHBTaWduYXR1cmVFcnJvciIsInZhbGlkYXRlQWxnb3JpdGhtIiwiQVVUSFpfRk1UIiwiTWlzc2luZ0hlYWRlckVycm9yIiwibWVzc2FnZSIsImNhbGwiLCJpbmhlcml0cyIsIlN0cmljdFBhcnNpbmdFcnJvciIsIlJlcXVlc3RTaWduZXIiLCJvcHRpb25zIiwib2JqZWN0IiwiYWxnIiwiYWxnb3JpdGhtIiwidW5kZWZpbmVkIiwic3RyaW5nIiwicnNfYWxnIiwic2lnbiIsImZ1bmMiLCJyc19zaWduRnVuYyIsImtleSIsImtleUlkIiwicnNfa2V5SWQiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIlR5cGVFcnJvciIsInJzX3NpZ25lciIsImNyZWF0ZUhtYWMiLCJ0b1VwcGVyQ2FzZSIsImRpZ2VzdCIsImhhc2hBbGdvcml0aG0iLCJ0b1N0cmluZyIsInBhcnNlUHJpdmF0ZUtleSIsIm9rIiwiUHJpdmF0ZUtleSIsImlzUHJpdmF0ZUtleSIsInJzX2tleSIsInR5cGUiLCJjcmVhdGVTaWduIiwicnNfaGVhZGVycyIsInJzX2xpbmVzIiwicHJvdG90eXBlIiwid3JpdGVIZWFkZXIiLCJoZWFkZXIiLCJ2YWx1ZSIsInRvTG93ZXJDYXNlIiwicHVzaCIsImxpbmUiLCJsZW5ndGgiLCJ1cGRhdGUiLCJ3cml0ZURhdGVIZWFkZXIiLCJyZmMxMTIzIiwiRGF0ZSIsIndyaXRlVGFyZ2V0IiwibWV0aG9kIiwicGF0aCIsImNiIiwiRXJyb3IiLCJhdXRoeiIsImRhdGEiLCJqb2luIiwic2VsZiIsImVyciIsInNpZyIsInNpZ25hdHVyZSIsImUiLCJzaWdPYmoiLCJtb2R1bGUiLCJleHBvcnRzIiwiaXNTaWduZXIiLCJvYmoiLCJjcmVhdGVTaWduZXIiLCJzaWduUmVxdWVzdCIsInJlcXVlc3QiLCJvcHRpb25hbFN0cmluZyIsIm9wdGlvbmFsQXJyYXlPZlN0cmluZyIsImhlYWRlcnMiLCJodHRwVmVyc2lvbiIsImdldEhlYWRlciIsInNldEhlYWRlciIsImkiLCJzdHJpbmdUb1NpZ24iLCJoIiwic3RyaWN0IiwiaGFzT3duUHJvcGVydHkiLCJfc3RyaW5nVG9TaWduIiwiaG1hYyIsInNpZ25lciIsIm5vdFN0cmljdEVxdWFsIiwiYXV0aHpIZWFkZXJOYW1lIiwiYXV0aG9yaXphdGlvbkhlYWRlck5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/signer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/http-signature/lib/utils.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(rsc)/./node_modules/sshpk/lib/index.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar HASH_ALGOS = {\n    \"sha1\": true,\n    \"sha256\": true,\n    \"sha512\": true\n};\nvar PK_ALGOS = {\n    \"rsa\": true,\n    \"dsa\": true,\n    \"ecdsa\": true\n};\nfunction HttpSignatureError(message, caller) {\n    if (Error.captureStackTrace) Error.captureStackTrace(this, caller || HttpSignatureError);\n    this.message = message;\n    this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\nfunction InvalidAlgorithmError(message) {\n    HttpSignatureError.call(this, message, InvalidAlgorithmError);\n}\nutil.inherits(InvalidAlgorithmError, HttpSignatureError);\nfunction validateAlgorithm(algorithm) {\n    var alg = algorithm.toLowerCase().split(\"-\");\n    if (alg.length !== 2) {\n        throw new InvalidAlgorithmError(alg[0].toUpperCase() + \" is not a \" + \"valid algorithm\");\n    }\n    if (alg[0] !== \"hmac\" && !PK_ALGOS[alg[0]]) {\n        throw new InvalidAlgorithmError(alg[0].toUpperCase() + \" type keys \" + \"are not supported\");\n    }\n    if (!HASH_ALGOS[alg[1]]) {\n        throw new InvalidAlgorithmError(alg[1].toUpperCase() + \" is not a \" + \"supported hash algorithm\");\n    }\n    return alg;\n}\n///--- API\nmodule.exports = {\n    HASH_ALGOS: HASH_ALGOS,\n    PK_ALGOS: PK_ALGOS,\n    HttpSignatureError: HttpSignatureError,\n    InvalidAlgorithmError: InvalidAlgorithmError,\n    validateAlgorithm: validateAlgorithm,\n    /**\n   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.\n   *\n   * The intent of this module is to interoperate with OpenSSL only,\n   * specifically the node crypto module's `verify` method.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} PEM encoded form of the RSA public key.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} on invalid ssh key formatted data.\n   */ sshKeyToPEM: function sshKeyToPEM(key) {\n        assert.string(key, \"ssh_key\");\n        var k = sshpk.parseKey(key, \"ssh\");\n        return k.toString(\"pem\");\n    },\n    /**\n   * Generates an OpenSSH fingerprint from an ssh public key.\n   *\n   * @param {String} key an OpenSSH public key.\n   * @return {String} key fingerprint.\n   * @throws {TypeError} on bad input.\n   * @throws {Error} if what you passed doesn't look like an ssh public key.\n   */ fingerprint: function fingerprint(key) {\n        assert.string(key, \"ssh_key\");\n        var k = sshpk.parseKey(key, \"ssh\");\n        return k.fingerprint(\"md5\").toString(\"hex\");\n    },\n    /**\n   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)\n   *\n   * The reverse of the above function.\n   */ pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {\n        assert.equal(\"string\", typeof pem, \"typeof pem\");\n        var k = sshpk.parseKey(pem, \"pem\");\n        k.comment = comment;\n        return k.toString(\"ssh\");\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9EQUFvRDtBQUVwRCxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxRQUFRRCxtQkFBT0EsQ0FBQztBQUNwQixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUVuQixJQUFJRyxhQUFhO0lBQ2YsUUFBUTtJQUNSLFVBQVU7SUFDVixVQUFVO0FBQ1o7QUFFQSxJQUFJQyxXQUFXO0lBQ2IsT0FBTztJQUNQLE9BQU87SUFDUCxTQUFTO0FBQ1g7QUFFQSxTQUFTQyxtQkFBbUJDLE9BQU8sRUFBRUMsTUFBTTtJQUN6QyxJQUFJQyxNQUFNQyxpQkFBaUIsRUFDekJELE1BQU1DLGlCQUFpQixDQUFDLElBQUksRUFBRUYsVUFBVUY7SUFFMUMsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO0lBQ2YsSUFBSSxDQUFDSSxJQUFJLEdBQUdILE9BQU9HLElBQUk7QUFDekI7QUFDQVIsS0FBS1MsUUFBUSxDQUFDTixvQkFBb0JHO0FBRWxDLFNBQVNJLHNCQUFzQk4sT0FBTztJQUNwQ0QsbUJBQW1CUSxJQUFJLENBQUMsSUFBSSxFQUFFUCxTQUFTTTtBQUN6QztBQUNBVixLQUFLUyxRQUFRLENBQUNDLHVCQUF1QlA7QUFFckMsU0FBU1Msa0JBQWtCQyxTQUFTO0lBQ2xDLElBQUlDLE1BQU1ELFVBQVVFLFdBQVcsR0FBR0MsS0FBSyxDQUFDO0lBRXhDLElBQUlGLElBQUlHLE1BQU0sS0FBSyxHQUFHO1FBQ3BCLE1BQU8sSUFBSVAsc0JBQXNCSSxHQUFHLENBQUMsRUFBRSxDQUFDSSxXQUFXLEtBQUssZUFDdEQ7SUFDSjtJQUVBLElBQUlKLEdBQUcsQ0FBQyxFQUFFLEtBQUssVUFBVSxDQUFDWixRQUFRLENBQUNZLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUMxQyxNQUFPLElBQUlKLHNCQUFzQkksR0FBRyxDQUFDLEVBQUUsQ0FBQ0ksV0FBVyxLQUFLLGdCQUN0RDtJQUNKO0lBRUEsSUFBSSxDQUFDakIsVUFBVSxDQUFDYSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUU7UUFDdkIsTUFBTyxJQUFJSixzQkFBc0JJLEdBQUcsQ0FBQyxFQUFFLENBQUNJLFdBQVcsS0FBSyxlQUN0RDtJQUNKO0lBRUEsT0FBUUo7QUFDVjtBQUVBLFVBQVU7QUFFVkssT0FBT0MsT0FBTyxHQUFHO0lBRWZuQixZQUFZQTtJQUNaQyxVQUFVQTtJQUVWQyxvQkFBb0JBO0lBQ3BCTyx1QkFBdUJBO0lBRXZCRSxtQkFBbUJBO0lBRW5COzs7Ozs7Ozs7O0dBVUMsR0FDRFMsYUFBYSxTQUFTQSxZQUFZQyxHQUFHO1FBQ25DekIsT0FBTzBCLE1BQU0sQ0FBQ0QsS0FBSztRQUVuQixJQUFJRSxJQUFJekIsTUFBTTBCLFFBQVEsQ0FBQ0gsS0FBSztRQUM1QixPQUFRRSxFQUFFRSxRQUFRLENBQUM7SUFDckI7SUFHQTs7Ozs7OztHQU9DLEdBQ0RDLGFBQWEsU0FBU0EsWUFBWUwsR0FBRztRQUNuQ3pCLE9BQU8wQixNQUFNLENBQUNELEtBQUs7UUFFbkIsSUFBSUUsSUFBSXpCLE1BQU0wQixRQUFRLENBQUNILEtBQUs7UUFDNUIsT0FBUUUsRUFBRUcsV0FBVyxDQUFDLE9BQU9ELFFBQVEsQ0FBQztJQUN4QztJQUVBOzs7O0dBSUMsR0FDREUsZ0JBQWdCLFNBQVNBLGVBQWVDLEdBQUcsRUFBRUMsT0FBTztRQUNsRGpDLE9BQU9rQyxLQUFLLENBQUMsVUFBVSxPQUFRRixLQUFNO1FBRXJDLElBQUlMLElBQUl6QixNQUFNMEIsUUFBUSxDQUFDSSxLQUFLO1FBQzVCTCxFQUFFTSxPQUFPLEdBQUdBO1FBQ1osT0FBUU4sRUFBRUUsUUFBUSxDQUFDO0lBQ3JCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9odHRwLXNpZ25hdHVyZS9saWIvdXRpbHMuanM/YjZiOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxMiBKb3llbnQsIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQtcGx1cycpO1xudmFyIHNzaHBrID0gcmVxdWlyZSgnc3NocGsnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgSEFTSF9BTEdPUyA9IHtcbiAgJ3NoYTEnOiB0cnVlLFxuICAnc2hhMjU2JzogdHJ1ZSxcbiAgJ3NoYTUxMic6IHRydWVcbn07XG5cbnZhciBQS19BTEdPUyA9IHtcbiAgJ3JzYSc6IHRydWUsXG4gICdkc2EnOiB0cnVlLFxuICAnZWNkc2EnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBIdHRwU2lnbmF0dXJlRXJyb3IobWVzc2FnZSwgY2FsbGVyKSB7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBjYWxsZXIgfHwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLm5hbWUgPSBjYWxsZXIubmFtZTtcbn1cbnV0aWwuaW5oZXJpdHMoSHR0cFNpZ25hdHVyZUVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIEludmFsaWRBbGdvcml0aG1FcnJvcihtZXNzYWdlKSB7XG4gIEh0dHBTaWduYXR1cmVFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UsIEludmFsaWRBbGdvcml0aG1FcnJvcik7XG59XG51dGlsLmluaGVyaXRzKEludmFsaWRBbGdvcml0aG1FcnJvciwgSHR0cFNpZ25hdHVyZUVycm9yKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gIHZhciBhbGcgPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuXG4gIGlmIChhbGcubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgKG5ldyBJbnZhbGlkQWxnb3JpdGhtRXJyb3IoYWxnWzBdLnRvVXBwZXJDYXNlKCkgKyAnIGlzIG5vdCBhICcgK1xuICAgICAgJ3ZhbGlkIGFsZ29yaXRobScpKTtcbiAgfVxuXG4gIGlmIChhbGdbMF0gIT09ICdobWFjJyAmJiAhUEtfQUxHT1NbYWxnWzBdXSkge1xuICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZ1swXS50b1VwcGVyQ2FzZSgpICsgJyB0eXBlIGtleXMgJyArXG4gICAgICAnYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XG4gIH1cblxuICBpZiAoIUhBU0hfQUxHT1NbYWxnWzFdXSkge1xuICAgIHRocm93IChuZXcgSW52YWxpZEFsZ29yaXRobUVycm9yKGFsZ1sxXS50b1VwcGVyQ2FzZSgpICsgJyBpcyBub3QgYSAnICtcbiAgICAgICdzdXBwb3J0ZWQgaGFzaCBhbGdvcml0aG0nKSk7XG4gIH1cblxuICByZXR1cm4gKGFsZyk7XG59XG5cbi8vLy0tLSBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgSEFTSF9BTEdPUzogSEFTSF9BTEdPUyxcbiAgUEtfQUxHT1M6IFBLX0FMR09TLFxuXG4gIEh0dHBTaWduYXR1cmVFcnJvcjogSHR0cFNpZ25hdHVyZUVycm9yLFxuICBJbnZhbGlkQWxnb3JpdGhtRXJyb3I6IEludmFsaWRBbGdvcml0aG1FcnJvcixcblxuICB2YWxpZGF0ZUFsZ29yaXRobTogdmFsaWRhdGVBbGdvcml0aG0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIE9wZW5TU0ggcHVibGljIGtleSAocnNhIG9ubHkpIHRvIGEgUEtDUyM4IFBFTSBmaWxlLlxuICAgKlxuICAgKiBUaGUgaW50ZW50IG9mIHRoaXMgbW9kdWxlIGlzIHRvIGludGVyb3BlcmF0ZSB3aXRoIE9wZW5TU0wgb25seSxcbiAgICogc3BlY2lmaWNhbGx5IHRoZSBub2RlIGNyeXB0byBtb2R1bGUncyBgdmVyaWZ5YCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgYW4gT3BlblNTSCBwdWJsaWMga2V5LlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFBFTSBlbmNvZGVkIGZvcm0gb2YgdGhlIFJTQSBwdWJsaWMga2V5LlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBpbnB1dC5cbiAgICogQHRocm93cyB7RXJyb3J9IG9uIGludmFsaWQgc3NoIGtleSBmb3JtYXR0ZWQgZGF0YS5cbiAgICovXG4gIHNzaEtleVRvUEVNOiBmdW5jdGlvbiBzc2hLZXlUb1BFTShrZXkpIHtcbiAgICBhc3NlcnQuc3RyaW5nKGtleSwgJ3NzaF9rZXknKTtcblxuICAgIHZhciBrID0gc3NocGsucGFyc2VLZXkoa2V5LCAnc3NoJyk7XG4gICAgcmV0dXJuIChrLnRvU3RyaW5nKCdwZW0nKSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIE9wZW5TU0ggZmluZ2VycHJpbnQgZnJvbSBhbiBzc2ggcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBhbiBPcGVuU1NIIHB1YmxpYyBrZXkuXG4gICAqIEByZXR1cm4ge1N0cmluZ30ga2V5IGZpbmdlcnByaW50LlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IG9uIGJhZCBpbnB1dC5cbiAgICogQHRocm93cyB7RXJyb3J9IGlmIHdoYXQgeW91IHBhc3NlZCBkb2Vzbid0IGxvb2sgbGlrZSBhbiBzc2ggcHVibGljIGtleS5cbiAgICovXG4gIGZpbmdlcnByaW50OiBmdW5jdGlvbiBmaW5nZXJwcmludChrZXkpIHtcbiAgICBhc3NlcnQuc3RyaW5nKGtleSwgJ3NzaF9rZXknKTtcblxuICAgIHZhciBrID0gc3NocGsucGFyc2VLZXkoa2V5LCAnc3NoJyk7XG4gICAgcmV0dXJuIChrLmZpbmdlcnByaW50KCdtZDUnKS50b1N0cmluZygnaGV4JykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFBLR0NTIzggUEVNIGZpbGUgdG8gYW4gT3BlblNTSCBwdWJsaWMga2V5IChyc2EpXG4gICAqXG4gICAqIFRoZSByZXZlcnNlIG9mIHRoZSBhYm92ZSBmdW5jdGlvbi5cbiAgICovXG4gIHBlbVRvUnNhU1NIS2V5OiBmdW5jdGlvbiBwZW1Ub1JzYVNTSEtleShwZW0sIGNvbW1lbnQpIHtcbiAgICBhc3NlcnQuZXF1YWwoJ3N0cmluZycsIHR5cGVvZiAocGVtKSwgJ3R5cGVvZiBwZW0nKTtcblxuICAgIHZhciBrID0gc3NocGsucGFyc2VLZXkocGVtLCAncGVtJyk7XG4gICAgay5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gKGsudG9TdHJpbmcoJ3NzaCcpKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwic3NocGsiLCJ1dGlsIiwiSEFTSF9BTEdPUyIsIlBLX0FMR09TIiwiSHR0cFNpZ25hdHVyZUVycm9yIiwibWVzc2FnZSIsImNhbGxlciIsIkVycm9yIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJuYW1lIiwiaW5oZXJpdHMiLCJJbnZhbGlkQWxnb3JpdGhtRXJyb3IiLCJjYWxsIiwidmFsaWRhdGVBbGdvcml0aG0iLCJhbGdvcml0aG0iLCJhbGciLCJ0b0xvd2VyQ2FzZSIsInNwbGl0IiwibGVuZ3RoIiwidG9VcHBlckNhc2UiLCJtb2R1bGUiLCJleHBvcnRzIiwic3NoS2V5VG9QRU0iLCJrZXkiLCJzdHJpbmciLCJrIiwicGFyc2VLZXkiLCJ0b1N0cmluZyIsImZpbmdlcnByaW50IiwicGVtVG9Sc2FTU0hLZXkiLCJwZW0iLCJjb21tZW50IiwiZXF1YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/http-signature/lib/verify.js":
/*!***************************************************!*\
  !*** ./node_modules/http-signature/lib/verify.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright 2015 Joyent, Inc.\nvar assert = __webpack_require__(/*! assert-plus */ \"(rsc)/./node_modules/assert-plus/assert.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar sshpk = __webpack_require__(/*! sshpk */ \"(rsc)/./node_modules/sshpk/lib/index.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/http-signature/lib/utils.js\");\nvar HASH_ALGOS = utils.HASH_ALGOS;\nvar PK_ALGOS = utils.PK_ALGOS;\nvar InvalidAlgorithmError = utils.InvalidAlgorithmError;\nvar HttpSignatureError = utils.HttpSignatureError;\nvar validateAlgorithm = utils.validateAlgorithm;\n///--- Exported API\nmodule.exports = {\n    /**\n   * Verify RSA/DSA signature against public key.  You are expected to pass in\n   * an object that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} pubkey RSA/DSA private key PEM.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   * @throws {InvalidAlgorithmError}\n   */ verifySignature: function verifySignature(parsedSignature, pubkey) {\n        assert.object(parsedSignature, \"parsedSignature\");\n        if (typeof pubkey === \"string\" || Buffer.isBuffer(pubkey)) pubkey = sshpk.parseKey(pubkey);\n        assert.ok(sshpk.Key.isKey(pubkey, [\n            1,\n            1\n        ]), \"pubkey must be a sshpk.Key\");\n        var alg = validateAlgorithm(parsedSignature.algorithm);\n        if (alg[0] === \"hmac\" || alg[0] !== pubkey.type) return false;\n        var v = pubkey.createVerify(alg[1]);\n        v.update(parsedSignature.signingString);\n        return v.verify(parsedSignature.params.signature, \"base64\");\n    },\n    /**\n   * Verify HMAC against shared secret.  You are expected to pass in an object\n   * that was returned from `parse()`.\n   *\n   * @param {Object} parsedSignature the object you got from `parse`.\n   * @param {String} secret HMAC shared secret.\n   * @return {Boolean} true if valid, false otherwise.\n   * @throws {TypeError} if you pass in bad arguments.\n   * @throws {InvalidAlgorithmError}\n   */ verifyHMAC: function verifyHMAC(parsedSignature, secret) {\n        assert.object(parsedSignature, \"parsedHMAC\");\n        assert.string(secret, \"secret\");\n        var alg = validateAlgorithm(parsedSignature.algorithm);\n        if (alg[0] !== \"hmac\") return false;\n        var hashAlg = alg[1].toUpperCase();\n        var hmac = crypto.createHmac(hashAlg, secret);\n        hmac.update(parsedSignature.signingString);\n        /*\n     * Now double-hash to avoid leaking timing information - there's\n     * no easy constant-time compare in JS, so we use this approach\n     * instead. See for more info:\n     * https://www.isecpartners.com/blog/2011/february/double-hmac-\n     * verification.aspx\n     */ var h1 = crypto.createHmac(hashAlg, secret);\n        h1.update(hmac.digest());\n        h1 = h1.digest();\n        var h2 = crypto.createHmac(hashAlg, secret);\n        h2.update(new Buffer(parsedSignature.params.signature, \"base64\"));\n        h2 = h2.digest();\n        /* Node 0.8 returns strings from .digest(). */ if (typeof h1 === \"string\") return h1 === h2;\n        /* And node 0.10 lacks the .equals() method on Buffers. */ if (Buffer.isBuffer(h1) && !h1.equals) return h1.toString(\"binary\") === h2.toString(\"binary\");\n        return h1.equals(h2);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaHR0cC1zaWduYXR1cmUvbGliL3ZlcmlmeS5qcyIsIm1hcHBpbmdzIjoiQUFBQSw4QkFBOEI7QUFFOUIsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUM7QUFFcEIsSUFBSUksYUFBYUQsTUFBTUMsVUFBVTtBQUNqQyxJQUFJQyxXQUFXRixNQUFNRSxRQUFRO0FBQzdCLElBQUlDLHdCQUF3QkgsTUFBTUcscUJBQXFCO0FBQ3ZELElBQUlDLHFCQUFxQkosTUFBTUksa0JBQWtCO0FBQ2pELElBQUlDLG9CQUFvQkwsTUFBTUssaUJBQWlCO0FBRS9DLG1CQUFtQjtBQUVuQkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2Y7Ozs7Ozs7OztHQVNDLEdBQ0RDLGlCQUFpQixTQUFTQSxnQkFBZ0JDLGVBQWUsRUFBRUMsTUFBTTtRQUMvRGQsT0FBT2UsTUFBTSxDQUFDRixpQkFBaUI7UUFDL0IsSUFBSSxPQUFRQyxXQUFZLFlBQVlFLE9BQU9DLFFBQVEsQ0FBQ0gsU0FDbERBLFNBQVNYLE1BQU1lLFFBQVEsQ0FBQ0o7UUFDMUJkLE9BQU9tQixFQUFFLENBQUNoQixNQUFNaUIsR0FBRyxDQUFDQyxLQUFLLENBQUNQLFFBQVE7WUFBQztZQUFHO1NBQUUsR0FBRztRQUUzQyxJQUFJUSxNQUFNYixrQkFBa0JJLGdCQUFnQlUsU0FBUztRQUNyRCxJQUFJRCxHQUFHLENBQUMsRUFBRSxLQUFLLFVBQVVBLEdBQUcsQ0FBQyxFQUFFLEtBQUtSLE9BQU9VLElBQUksRUFDN0MsT0FBUTtRQUVWLElBQUlDLElBQUlYLE9BQU9ZLFlBQVksQ0FBQ0osR0FBRyxDQUFDLEVBQUU7UUFDbENHLEVBQUVFLE1BQU0sQ0FBQ2QsZ0JBQWdCZSxhQUFhO1FBQ3RDLE9BQVFILEVBQUVJLE1BQU0sQ0FBQ2hCLGdCQUFnQmlCLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFO0lBQ3JEO0lBRUE7Ozs7Ozs7OztHQVNDLEdBQ0RDLFlBQVksU0FBU0EsV0FBV25CLGVBQWUsRUFBRW9CLE1BQU07UUFDckRqQyxPQUFPZSxNQUFNLENBQUNGLGlCQUFpQjtRQUMvQmIsT0FBT2tDLE1BQU0sQ0FBQ0QsUUFBUTtRQUV0QixJQUFJWCxNQUFNYixrQkFBa0JJLGdCQUFnQlUsU0FBUztRQUNyRCxJQUFJRCxHQUFHLENBQUMsRUFBRSxLQUFLLFFBQ2IsT0FBUTtRQUVWLElBQUlhLFVBQVViLEdBQUcsQ0FBQyxFQUFFLENBQUNjLFdBQVc7UUFFaEMsSUFBSUMsT0FBT25DLE9BQU9vQyxVQUFVLENBQUNILFNBQVNGO1FBQ3RDSSxLQUFLVixNQUFNLENBQUNkLGdCQUFnQmUsYUFBYTtRQUV6Qzs7Ozs7O0tBTUMsR0FDRCxJQUFJVyxLQUFLckMsT0FBT29DLFVBQVUsQ0FBQ0gsU0FBU0Y7UUFDcENNLEdBQUdaLE1BQU0sQ0FBQ1UsS0FBS0csTUFBTTtRQUNyQkQsS0FBS0EsR0FBR0MsTUFBTTtRQUNkLElBQUlDLEtBQUt2QyxPQUFPb0MsVUFBVSxDQUFDSCxTQUFTRjtRQUNwQ1EsR0FBR2QsTUFBTSxDQUFDLElBQUlYLE9BQU9ILGdCQUFnQmlCLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFO1FBQ3ZEVSxLQUFLQSxHQUFHRCxNQUFNO1FBRWQsNENBQTRDLEdBQzVDLElBQUksT0FBUUQsT0FBUSxVQUNsQixPQUFRQSxPQUFPRTtRQUNqQix3REFBd0QsR0FDeEQsSUFBSXpCLE9BQU9DLFFBQVEsQ0FBQ3NCLE9BQU8sQ0FBQ0EsR0FBR0csTUFBTSxFQUNuQyxPQUFRSCxHQUFHSSxRQUFRLENBQUMsY0FBY0YsR0FBR0UsUUFBUSxDQUFDO1FBRWhELE9BQVFKLEdBQUdHLE1BQU0sQ0FBQ0Q7SUFDcEI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2h0dHAtc2lnbmF0dXJlL2xpYi92ZXJpZnkuanM/YzdkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNSBKb3llbnQsIEluYy5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydC1wbHVzJyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG52YXIgc3NocGsgPSByZXF1aXJlKCdzc2hwaycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgSEFTSF9BTEdPUyA9IHV0aWxzLkhBU0hfQUxHT1M7XG52YXIgUEtfQUxHT1MgPSB1dGlscy5QS19BTEdPUztcbnZhciBJbnZhbGlkQWxnb3JpdGhtRXJyb3IgPSB1dGlscy5JbnZhbGlkQWxnb3JpdGhtRXJyb3I7XG52YXIgSHR0cFNpZ25hdHVyZUVycm9yID0gdXRpbHMuSHR0cFNpZ25hdHVyZUVycm9yO1xudmFyIHZhbGlkYXRlQWxnb3JpdGhtID0gdXRpbHMudmFsaWRhdGVBbGdvcml0aG07XG5cbi8vLy0tLSBFeHBvcnRlZCBBUElcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBWZXJpZnkgUlNBL0RTQSBzaWduYXR1cmUgYWdhaW5zdCBwdWJsaWMga2V5LiAgWW91IGFyZSBleHBlY3RlZCB0byBwYXNzIGluXG4gICAqIGFuIG9iamVjdCB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIGBwYXJzZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZFNpZ25hdHVyZSB0aGUgb2JqZWN0IHlvdSBnb3QgZnJvbSBgcGFyc2VgLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHVia2V5IFJTQS9EU0EgcHJpdmF0ZSBrZXkgUEVNLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgeW91IHBhc3MgaW4gYmFkIGFyZ3VtZW50cy5cbiAgICogQHRocm93cyB7SW52YWxpZEFsZ29yaXRobUVycm9yfVxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlOiBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocGFyc2VkU2lnbmF0dXJlLCBwdWJrZXkpIHtcbiAgICBhc3NlcnQub2JqZWN0KHBhcnNlZFNpZ25hdHVyZSwgJ3BhcnNlZFNpZ25hdHVyZScpO1xuICAgIGlmICh0eXBlb2YgKHB1YmtleSkgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihwdWJrZXkpKVxuICAgICAgcHVia2V5ID0gc3NocGsucGFyc2VLZXkocHVia2V5KTtcbiAgICBhc3NlcnQub2soc3NocGsuS2V5LmlzS2V5KHB1YmtleSwgWzEsIDFdKSwgJ3B1YmtleSBtdXN0IGJlIGEgc3NocGsuS2V5Jyk7XG5cbiAgICB2YXIgYWxnID0gdmFsaWRhdGVBbGdvcml0aG0ocGFyc2VkU2lnbmF0dXJlLmFsZ29yaXRobSk7XG4gICAgaWYgKGFsZ1swXSA9PT0gJ2htYWMnIHx8IGFsZ1swXSAhPT0gcHVia2V5LnR5cGUpXG4gICAgICByZXR1cm4gKGZhbHNlKTtcblxuICAgIHZhciB2ID0gcHVia2V5LmNyZWF0ZVZlcmlmeShhbGdbMV0pO1xuICAgIHYudXBkYXRlKHBhcnNlZFNpZ25hdHVyZS5zaWduaW5nU3RyaW5nKTtcbiAgICByZXR1cm4gKHYudmVyaWZ5KHBhcnNlZFNpZ25hdHVyZS5wYXJhbXMuc2lnbmF0dXJlLCAnYmFzZTY0JykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBWZXJpZnkgSE1BQyBhZ2FpbnN0IHNoYXJlZCBzZWNyZXQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHBhc3MgaW4gYW4gb2JqZWN0XG4gICAqIHRoYXQgd2FzIHJldHVybmVkIGZyb20gYHBhcnNlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyc2VkU2lnbmF0dXJlIHRoZSBvYmplY3QgeW91IGdvdCBmcm9tIGBwYXJzZWAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWNyZXQgSE1BQyBzaGFyZWQgc2VjcmV0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgeW91IHBhc3MgaW4gYmFkIGFyZ3VtZW50cy5cbiAgICogQHRocm93cyB7SW52YWxpZEFsZ29yaXRobUVycm9yfVxuICAgKi9cbiAgdmVyaWZ5SE1BQzogZnVuY3Rpb24gdmVyaWZ5SE1BQyhwYXJzZWRTaWduYXR1cmUsIHNlY3JldCkge1xuICAgIGFzc2VydC5vYmplY3QocGFyc2VkU2lnbmF0dXJlLCAncGFyc2VkSE1BQycpO1xuICAgIGFzc2VydC5zdHJpbmcoc2VjcmV0LCAnc2VjcmV0Jyk7XG5cbiAgICB2YXIgYWxnID0gdmFsaWRhdGVBbGdvcml0aG0ocGFyc2VkU2lnbmF0dXJlLmFsZ29yaXRobSk7XG4gICAgaWYgKGFsZ1swXSAhPT0gJ2htYWMnKVxuICAgICAgcmV0dXJuIChmYWxzZSk7XG5cbiAgICB2YXIgaGFzaEFsZyA9IGFsZ1sxXS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgdmFyIGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoQWxnLCBzZWNyZXQpO1xuICAgIGhtYWMudXBkYXRlKHBhcnNlZFNpZ25hdHVyZS5zaWduaW5nU3RyaW5nKTtcblxuICAgIC8qXG4gICAgICogTm93IGRvdWJsZS1oYXNoIHRvIGF2b2lkIGxlYWtpbmcgdGltaW5nIGluZm9ybWF0aW9uIC0gdGhlcmUnc1xuICAgICAqIG5vIGVhc3kgY29uc3RhbnQtdGltZSBjb21wYXJlIGluIEpTLCBzbyB3ZSB1c2UgdGhpcyBhcHByb2FjaFxuICAgICAqIGluc3RlYWQuIFNlZSBmb3IgbW9yZSBpbmZvOlxuICAgICAqIGh0dHBzOi8vd3d3LmlzZWNwYXJ0bmVycy5jb20vYmxvZy8yMDExL2ZlYnJ1YXJ5L2RvdWJsZS1obWFjLVxuICAgICAqIHZlcmlmaWNhdGlvbi5hc3B4XG4gICAgICovXG4gICAgdmFyIGgxID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaEFsZywgc2VjcmV0KTtcbiAgICBoMS51cGRhdGUoaG1hYy5kaWdlc3QoKSk7XG4gICAgaDEgPSBoMS5kaWdlc3QoKTtcbiAgICB2YXIgaDIgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoQWxnLCBzZWNyZXQpO1xuICAgIGgyLnVwZGF0ZShuZXcgQnVmZmVyKHBhcnNlZFNpZ25hdHVyZS5wYXJhbXMuc2lnbmF0dXJlLCAnYmFzZTY0JykpO1xuICAgIGgyID0gaDIuZGlnZXN0KCk7XG5cbiAgICAvKiBOb2RlIDAuOCByZXR1cm5zIHN0cmluZ3MgZnJvbSAuZGlnZXN0KCkuICovXG4gICAgaWYgKHR5cGVvZiAoaDEpID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiAoaDEgPT09IGgyKTtcbiAgICAvKiBBbmQgbm9kZSAwLjEwIGxhY2tzIHRoZSAuZXF1YWxzKCkgbWV0aG9kIG9uIEJ1ZmZlcnMuICovXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihoMSkgJiYgIWgxLmVxdWFscylcbiAgICAgIHJldHVybiAoaDEudG9TdHJpbmcoJ2JpbmFyeScpID09PSBoMi50b1N0cmluZygnYmluYXJ5JykpO1xuXG4gICAgcmV0dXJuIChoMS5lcXVhbHMoaDIpKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJhc3NlcnQiLCJyZXF1aXJlIiwiY3J5cHRvIiwic3NocGsiLCJ1dGlscyIsIkhBU0hfQUxHT1MiLCJQS19BTEdPUyIsIkludmFsaWRBbGdvcml0aG1FcnJvciIsIkh0dHBTaWduYXR1cmVFcnJvciIsInZhbGlkYXRlQWxnb3JpdGhtIiwibW9kdWxlIiwiZXhwb3J0cyIsInZlcmlmeVNpZ25hdHVyZSIsInBhcnNlZFNpZ25hdHVyZSIsInB1YmtleSIsIm9iamVjdCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwicGFyc2VLZXkiLCJvayIsIktleSIsImlzS2V5IiwiYWxnIiwiYWxnb3JpdGhtIiwidHlwZSIsInYiLCJjcmVhdGVWZXJpZnkiLCJ1cGRhdGUiLCJzaWduaW5nU3RyaW5nIiwidmVyaWZ5IiwicGFyYW1zIiwic2lnbmF0dXJlIiwidmVyaWZ5SE1BQyIsInNlY3JldCIsInN0cmluZyIsImhhc2hBbGciLCJ0b1VwcGVyQ2FzZSIsImhtYWMiLCJjcmVhdGVIbWFjIiwiaDEiLCJkaWdlc3QiLCJoMiIsImVxdWFscyIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/http-signature/lib/verify.js\n");

/***/ })

};
;