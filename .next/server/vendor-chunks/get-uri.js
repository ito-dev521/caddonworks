"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-uri";
exports.ids = ["vendor-chunks/get-uri"];
exports.modules = {

/***/ "(rsc)/./node_modules/get-uri/dist/data.js":
/*!*******************************************!*\
  !*** ./node_modules/get-uri/dist/data.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst data_uri_to_buffer_1 = __importDefault(__webpack_require__(/*! data-uri-to-buffer */ \"(rsc)/./node_modules/data-uri-to-buffer/dist/src/index.js\"));\nconst notmodified_1 = __importDefault(__webpack_require__(/*! ./notmodified */ \"(rsc)/./node_modules/get-uri/dist/notmodified.js\"));\nconst debug = debug_1.default(\"get-uri:data\");\nclass DataReadable extends stream_1.Readable {\n    constructor(hash, buf){\n        super();\n        this.push(buf);\n        this.push(null);\n        this.hash = hash;\n    }\n}\n/**\n * Returns a Readable stream from a \"data:\" URI.\n */ function get({ href: uri }, { cache }) {\n    return __awaiter(this, void 0, void 0, function*() {\n        // need to create a SHA1 hash of the URI string, for cacheability checks\n        // in future `getUri()` calls with the same data URI passed in.\n        const shasum = crypto_1.createHash(\"sha1\");\n        shasum.update(uri);\n        const hash = shasum.digest(\"hex\");\n        debug('generated SHA1 hash for \"data:\" URI: %o', hash);\n        // check if the cache is the same \"data:\" URI that was previously passed in.\n        if (cache && cache.hash === hash) {\n            debug(\"got matching cache SHA1 hash: %o\", hash);\n            throw new notmodified_1.default();\n        } else {\n            debug('creating Readable stream from \"data:\" URI buffer');\n            const buf = data_uri_to_buffer_1.default(uri);\n            return new DataReadable(hash, buf);\n        }\n    });\n}\nexports[\"default\"] = get; //# sourceMappingURL=data.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2RhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLElBQUssSUFBSSxJQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFaEIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNbUIsVUFBVU4sZ0JBQWdCTyxtQkFBT0EsQ0FBQyxzREFBTztBQUMvQyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNRyx1QkFBdUJWLGdCQUFnQk8sbUJBQU9BLENBQUMscUZBQW9CO0FBQ3pFLE1BQU1JLGdCQUFnQlgsZ0JBQWdCTyxtQkFBT0EsQ0FBQyx1RUFBZTtBQUM3RCxNQUFNSyxRQUFRTixRQUFRTyxPQUFPLENBQUM7QUFDOUIsTUFBTUMscUJBQXFCTixTQUFTTyxRQUFRO0lBQ3hDQyxZQUFZQyxJQUFJLEVBQUVDLEdBQUcsQ0FBRTtRQUNuQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxJQUFJLENBQUNEO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLENBQUM7UUFDVixJQUFJLENBQUNGLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0csSUFBSSxFQUFFQyxNQUFNQyxHQUFHLEVBQUUsRUFBRSxFQUFFQyxLQUFLLEVBQUU7SUFDakMsT0FBTzFDLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsd0VBQXdFO1FBQ3hFLCtEQUErRDtRQUMvRCxNQUFNMkMsU0FBU2YsU0FBU2dCLFVBQVUsQ0FBQztRQUNuQ0QsT0FBT0UsTUFBTSxDQUFDSjtRQUNkLE1BQU1MLE9BQU9PLE9BQU9HLE1BQU0sQ0FBQztRQUMzQmYsTUFBTSwyQ0FBMkNLO1FBQ2pELDRFQUE0RTtRQUM1RSxJQUFJTSxTQUFTQSxNQUFNTixJQUFJLEtBQUtBLE1BQU07WUFDOUJMLE1BQU0sb0NBQW9DSztZQUMxQyxNQUFNLElBQUlOLGNBQWNFLE9BQU87UUFDbkMsT0FDSztZQUNERCxNQUFNO1lBQ04sTUFBTU0sTUFBTVIscUJBQXFCRyxPQUFPLENBQUNTO1lBQ3pDLE9BQU8sSUFBSVIsYUFBYUcsTUFBTUM7UUFDbEM7SUFDSjtBQUNKO0FBQ0FiLGtCQUFlLEdBQUdlLEtBQ2xCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2dldC11cmkvZGlzdC9kYXRhLmpzPzI2NGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbmNvbnN0IGRhdGFfdXJpX3RvX2J1ZmZlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkYXRhLXVyaS10by1idWZmZXJcIikpO1xuY29uc3Qgbm90bW9kaWZpZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ub3Rtb2RpZmllZFwiKSk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdCgnZ2V0LXVyaTpkYXRhJyk7XG5jbGFzcyBEYXRhUmVhZGFibGUgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgYnVmKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGUgc3RyZWFtIGZyb20gYSBcImRhdGE6XCIgVVJJLlxuICovXG5mdW5jdGlvbiBnZXQoeyBocmVmOiB1cmkgfSwgeyBjYWNoZSB9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjcmVhdGUgYSBTSEExIGhhc2ggb2YgdGhlIFVSSSBzdHJpbmcsIGZvciBjYWNoZWFiaWxpdHkgY2hlY2tzXG4gICAgICAgIC8vIGluIGZ1dHVyZSBgZ2V0VXJpKClgIGNhbGxzIHdpdGggdGhlIHNhbWUgZGF0YSBVUkkgcGFzc2VkIGluLlxuICAgICAgICBjb25zdCBzaGFzdW0gPSBjcnlwdG9fMS5jcmVhdGVIYXNoKCdzaGExJyk7XG4gICAgICAgIHNoYXN1bS51cGRhdGUodXJpKTtcbiAgICAgICAgY29uc3QgaGFzaCA9IHNoYXN1bS5kaWdlc3QoJ2hleCcpO1xuICAgICAgICBkZWJ1ZygnZ2VuZXJhdGVkIFNIQTEgaGFzaCBmb3IgXCJkYXRhOlwiIFVSSTogJW8nLCBoYXNoKTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNhY2hlIGlzIHRoZSBzYW1lIFwiZGF0YTpcIiBVUkkgdGhhdCB3YXMgcHJldmlvdXNseSBwYXNzZWQgaW4uXG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5oYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnZ290IG1hdGNoaW5nIGNhY2hlIFNIQTEgaGFzaDogJW8nLCBoYXNoKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBub3Rtb2RpZmllZF8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKCdjcmVhdGluZyBSZWFkYWJsZSBzdHJlYW0gZnJvbSBcImRhdGE6XCIgVVJJIGJ1ZmZlcicpO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gZGF0YV91cmlfdG9fYnVmZmVyXzEuZGVmYXVsdCh1cmkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRhUmVhZGFibGUoaGFzaCwgYnVmKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImRlYnVnXzEiLCJyZXF1aXJlIiwic3RyZWFtXzEiLCJjcnlwdG9fMSIsImRhdGFfdXJpX3RvX2J1ZmZlcl8xIiwibm90bW9kaWZpZWRfMSIsImRlYnVnIiwiZGVmYXVsdCIsIkRhdGFSZWFkYWJsZSIsIlJlYWRhYmxlIiwiY29uc3RydWN0b3IiLCJoYXNoIiwiYnVmIiwicHVzaCIsImdldCIsImhyZWYiLCJ1cmkiLCJjYWNoZSIsInNoYXN1bSIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/data.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/file.js":
/*!*******************************************!*\
  !*** ./node_modules/get-uri/dist/file.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst fs_extra_1 = __webpack_require__(/*! fs-extra */ \"(rsc)/./node_modules/fs-extra/lib/index.js\");\nconst file_uri_to_path_1 = __importDefault(__webpack_require__(/*! file-uri-to-path */ \"(rsc)/./node_modules/file-uri-to-path/dist/src/index.js\"));\nconst notfound_1 = __importDefault(__webpack_require__(/*! ./notfound */ \"(rsc)/./node_modules/get-uri/dist/notfound.js\"));\nconst notmodified_1 = __importDefault(__webpack_require__(/*! ./notmodified */ \"(rsc)/./node_modules/get-uri/dist/notmodified.js\"));\nconst debug = debug_1.default(\"get-uri:file\");\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n */ function get({ href: uri }, opts) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { cache, flags = \"r\", mode = 438 // =0666\n         } = opts;\n        try {\n            // Convert URI → Path\n            const filepath = file_uri_to_path_1.default(uri);\n            debug(\"Normalized pathname: %o\", filepath);\n            // `open()` first to get a file descriptor and ensure that the file\n            // exists.\n            const fd = yield fs_extra_1.open(filepath, flags, mode);\n            // Now `fstat()` to check the `mtime` and store the stat object for\n            // the cache.\n            const stat = yield fs_extra_1.fstat(fd);\n            // if a `cache` was provided, check if the file has not been modified\n            if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n                throw new notmodified_1.default();\n            }\n            // `fs.ReadStream` takes care of calling `fs.close()` on the\n            // fd after it's done reading\n            // @ts-ignore - `@types/node` doesn't allow `null` as file path :/\n            const rs = fs_1.createReadStream(null, Object.assign(Object.assign({\n                autoClose: true\n            }, opts), {\n                fd\n            }));\n            rs.stat = stat;\n            return rs;\n        } catch (err) {\n            if (err.code === \"ENOENT\") {\n                throw new notfound_1.default();\n            }\n            throw err;\n        }\n    });\n}\nexports[\"default\"] = get;\n// returns `true` if the `mtime` of the 2 stat objects are equal\nfunction isNotModified(prev, curr) {\n    return +prev.mtime === +curr.mtime;\n} //# sourceMappingURL=file.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLElBQUssSUFBSSxJQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFaEIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNbUIsVUFBVU4sZ0JBQWdCTyxtQkFBT0EsQ0FBQyxzREFBTztBQUMvQyxNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3pCLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDREQUFVO0FBQ3JDLE1BQU1HLHFCQUFxQlYsZ0JBQWdCTyxtQkFBT0EsQ0FBQyxpRkFBa0I7QUFDckUsTUFBTUksYUFBYVgsZ0JBQWdCTyxtQkFBT0EsQ0FBQyxpRUFBWTtBQUN2RCxNQUFNSyxnQkFBZ0JaLGdCQUFnQk8sbUJBQU9BLENBQUMsdUVBQWU7QUFDN0QsTUFBTU0sUUFBUVAsUUFBUVEsT0FBTyxDQUFDO0FBQzlCOztDQUVDLEdBQ0QsU0FBU0MsSUFBSSxFQUFFQyxNQUFNQyxHQUFHLEVBQUUsRUFBRUMsSUFBSTtJQUM1QixPQUFPckMsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxNQUFNLEVBQUVzQyxLQUFLLEVBQUVDLFFBQVEsR0FBRyxFQUFFQyxPQUFPLElBQUksUUFBUTtRQUFULEVBQ3BDLEdBQUdIO1FBQ0wsSUFBSTtZQUNBLHFCQUFxQjtZQUNyQixNQUFNSSxXQUFXWixtQkFBbUJJLE9BQU8sQ0FBQ0c7WUFDNUNKLE1BQU0sMkJBQTJCUztZQUNqQyxtRUFBbUU7WUFDbkUsVUFBVTtZQUNWLE1BQU1DLEtBQUssTUFBTWQsV0FBV2UsSUFBSSxDQUFDRixVQUFVRixPQUFPQztZQUNsRCxtRUFBbUU7WUFDbkUsYUFBYTtZQUNiLE1BQU1JLE9BQU8sTUFBTWhCLFdBQVdpQixLQUFLLENBQUNIO1lBQ3BDLHFFQUFxRTtZQUNyRSxJQUFJSixTQUFTQSxNQUFNTSxJQUFJLElBQUlBLFFBQVFFLGNBQWNSLE1BQU1NLElBQUksRUFBRUEsT0FBTztnQkFDaEUsTUFBTSxJQUFJYixjQUFjRSxPQUFPO1lBQ25DO1lBQ0EsNERBQTREO1lBQzVELDZCQUE2QjtZQUM3QixrRUFBa0U7WUFDbEUsTUFBTWMsS0FBS3BCLEtBQUtxQixnQkFBZ0IsQ0FBQyxNQUFNMUIsT0FBTzJCLE1BQU0sQ0FBQzNCLE9BQU8yQixNQUFNLENBQUM7Z0JBQUVDLFdBQVc7WUFBSyxHQUFHYixPQUFPO2dCQUFFSztZQUFHO1lBQ3BHSyxHQUFHSCxJQUFJLEdBQUdBO1lBQ1YsT0FBT0c7UUFDWCxFQUNBLE9BQU9JLEtBQUs7WUFDUixJQUFJQSxJQUFJQyxJQUFJLEtBQUssVUFBVTtnQkFDdkIsTUFBTSxJQUFJdEIsV0FBV0csT0FBTztZQUNoQztZQUNBLE1BQU1rQjtRQUNWO0lBQ0o7QUFDSjtBQUNBM0Isa0JBQWUsR0FBR1U7QUFDbEIsZ0VBQWdFO0FBQ2hFLFNBQVNZLGNBQWNPLElBQUksRUFBRUMsSUFBSTtJQUM3QixPQUFPLENBQUNELEtBQUtFLEtBQUssS0FBSyxDQUFDRCxLQUFLQyxLQUFLO0FBQ3RDLEVBQ0EsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2ZpbGUuanM/NzYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IGZzX2V4dHJhXzEgPSByZXF1aXJlKFwiZnMtZXh0cmFcIik7XG5jb25zdCBmaWxlX3VyaV90b19wYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImZpbGUtdXJpLXRvLXBhdGhcIikpO1xuY29uc3Qgbm90Zm91bmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ub3Rmb3VuZFwiKSk7XG5jb25zdCBub3Rtb2RpZmllZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vdG1vZGlmaWVkXCIpKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdnZXQtdXJpOmZpbGUnKTtcbi8qKlxuICogUmV0dXJucyBhIGBmcy5SZWFkU3RyZWFtYCBpbnN0YW5jZSBmcm9tIGEgXCJmaWxlOlwiIFVSSS5cbiAqL1xuZnVuY3Rpb24gZ2V0KHsgaHJlZjogdXJpIH0sIG9wdHMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCB7IGNhY2hlLCBmbGFncyA9ICdyJywgbW9kZSA9IDQzOCAvLyA9MDY2NlxuICAgICAgICAgfSA9IG9wdHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IFVSSSDihpIgUGF0aFxuICAgICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBmaWxlX3VyaV90b19wYXRoXzEuZGVmYXVsdCh1cmkpO1xuICAgICAgICAgICAgZGVidWcoJ05vcm1hbGl6ZWQgcGF0aG5hbWU6ICVvJywgZmlsZXBhdGgpO1xuICAgICAgICAgICAgLy8gYG9wZW4oKWAgZmlyc3QgdG8gZ2V0IGEgZmlsZSBkZXNjcmlwdG9yIGFuZCBlbnN1cmUgdGhhdCB0aGUgZmlsZVxuICAgICAgICAgICAgLy8gZXhpc3RzLlxuICAgICAgICAgICAgY29uc3QgZmQgPSB5aWVsZCBmc19leHRyYV8xLm9wZW4oZmlsZXBhdGgsIGZsYWdzLCBtb2RlKTtcbiAgICAgICAgICAgIC8vIE5vdyBgZnN0YXQoKWAgdG8gY2hlY2sgdGhlIGBtdGltZWAgYW5kIHN0b3JlIHRoZSBzdGF0IG9iamVjdCBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNvbnN0IHN0YXQgPSB5aWVsZCBmc19leHRyYV8xLmZzdGF0KGZkKTtcbiAgICAgICAgICAgIC8vIGlmIGEgYGNhY2hlYCB3YXMgcHJvdmlkZWQsIGNoZWNrIGlmIHRoZSBmaWxlIGhhcyBub3QgYmVlbiBtb2RpZmllZFxuICAgICAgICAgICAgaWYgKGNhY2hlICYmIGNhY2hlLnN0YXQgJiYgc3RhdCAmJiBpc05vdE1vZGlmaWVkKGNhY2hlLnN0YXQsIHN0YXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5vdG1vZGlmaWVkXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYGZzLlJlYWRTdHJlYW1gIHRha2VzIGNhcmUgb2YgY2FsbGluZyBgZnMuY2xvc2UoKWAgb24gdGhlXG4gICAgICAgICAgICAvLyBmZCBhZnRlciBpdCdzIGRvbmUgcmVhZGluZ1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGBAdHlwZXMvbm9kZWAgZG9lc24ndCBhbGxvdyBgbnVsbGAgYXMgZmlsZSBwYXRoIDovXG4gICAgICAgICAgICBjb25zdCBycyA9IGZzXzEuY3JlYXRlUmVhZFN0cmVhbShudWxsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBhdXRvQ2xvc2U6IHRydWUgfSwgb3B0cyksIHsgZmQgfSkpO1xuICAgICAgICAgICAgcnMuc3RhdCA9IHN0YXQ7XG4gICAgICAgICAgICByZXR1cm4gcnM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBub3Rmb3VuZF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0O1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGBtdGltZWAgb2YgdGhlIDIgc3RhdCBvYmplY3RzIGFyZSBlcXVhbFxuZnVuY3Rpb24gaXNOb3RNb2RpZmllZChwcmV2LCBjdXJyKSB7XG4gICAgcmV0dXJuICtwcmV2Lm10aW1lID09PSArY3Vyci5tdGltZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJkZWJ1Z18xIiwicmVxdWlyZSIsImZzXzEiLCJmc19leHRyYV8xIiwiZmlsZV91cmlfdG9fcGF0aF8xIiwibm90Zm91bmRfMSIsIm5vdG1vZGlmaWVkXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJnZXQiLCJocmVmIiwidXJpIiwib3B0cyIsImNhY2hlIiwiZmxhZ3MiLCJtb2RlIiwiZmlsZXBhdGgiLCJmZCIsIm9wZW4iLCJzdGF0IiwiZnN0YXQiLCJpc05vdE1vZGlmaWVkIiwicnMiLCJjcmVhdGVSZWFkU3RyZWFtIiwiYXNzaWduIiwiYXV0b0Nsb3NlIiwiZXJyIiwiY29kZSIsInByZXYiLCJjdXJyIiwibXRpbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/ftp.js":
/*!******************************************!*\
  !*** ./node_modules/get-uri/dist/ftp.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst once_1 = __importDefault(__webpack_require__(/*! @tootallnate/once */ \"(rsc)/./node_modules/@tootallnate/once/dist/index.js\"));\nconst ftp_1 = __importDefault(__webpack_require__(/*! ftp */ \"(rsc)/./node_modules/ftp/lib/connection.js\"));\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst notfound_1 = __importDefault(__webpack_require__(/*! ./notfound */ \"(rsc)/./node_modules/get-uri/dist/notfound.js\"));\nconst notmodified_1 = __importDefault(__webpack_require__(/*! ./notmodified */ \"(rsc)/./node_modules/get-uri/dist/notmodified.js\"));\nconst debug = debug_1.default(\"get-uri:ftp\");\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */ function get(parsed, opts) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const { cache } = opts;\n        const filepath = parsed.pathname;\n        let lastModified = null;\n        if (!filepath) {\n            throw new TypeError('No \"pathname\"!');\n        }\n        const client = new ftp_1.default();\n        client.once(\"greeting\", (greeting)=>{\n            debug(\"FTP greeting: %o\", greeting);\n        });\n        function onend() {\n            // close the FTP client socket connection\n            client.end();\n        }\n        try {\n            opts.host = parsed.hostname || parsed.host || \"localhost\";\n            opts.port = parseInt(parsed.port || \"0\", 10) || 21;\n            opts.debug = debug;\n            if (parsed.auth) {\n                const [user, password] = parsed.auth.split(\":\");\n                opts.user = user;\n                opts.password = password;\n            }\n            // await cb(_ => client.connect(opts, _));\n            const readyPromise = once_1.default(client, \"ready\");\n            client.connect(opts);\n            yield readyPromise;\n            // first we have to figure out the Last Modified date.\n            // try the MDTM command first, which is an optional extension command.\n            try {\n                lastModified = yield new Promise((resolve, reject)=>{\n                    client.lastMod(filepath, (err, res)=>{\n                        return err ? reject(err) : resolve(res);\n                    });\n                });\n            } catch (err) {\n                // handle the \"file not found\" error code\n                if (err.code === 550) {\n                    throw new notfound_1.default();\n                }\n            }\n            if (!lastModified) {\n                // Try to get the last modified date via the LIST command (uses\n                // more bandwidth, but is more compatible with older FTP servers\n                const list = yield new Promise((resolve, reject)=>{\n                    client.list(path_1.dirname(filepath), (err, res)=>{\n                        return err ? reject(err) : resolve(res);\n                    });\n                });\n                // attempt to find the \"entry\" with a matching \"name\"\n                const name = path_1.basename(filepath);\n                const entry = list.find((e)=>e.name === name);\n                if (entry) {\n                    lastModified = entry.date;\n                }\n            }\n            if (lastModified) {\n                if (isNotModified()) {\n                    throw new notmodified_1.default();\n                }\n            } else {\n                throw new notfound_1.default();\n            }\n            // XXX: a small timeout seemed necessary otherwise FTP servers\n            // were returning empty sockets for the file occasionally\n            // setTimeout(client.get.bind(client, filepath, onfile), 10);\n            const rs = yield new Promise((resolve, reject)=>{\n                client.get(filepath, (err, res)=>{\n                    return err ? reject(err) : resolve(res);\n                });\n            });\n            rs.once(\"end\", onend);\n            rs.lastModified = lastModified;\n            return rs;\n        } catch (err) {\n            client.destroy();\n            throw err;\n        }\n        // called when `lastModified` is set, and a \"cache\" stream was provided\n        function isNotModified() {\n            if (cache && cache.lastModified && lastModified) {\n                return +cache.lastModified === +lastModified;\n            }\n            return false;\n        }\n    });\n}\nexports[\"default\"] = get; //# sourceMappingURL=ftp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2Z0cC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVksSUFBSyxJQUFJLElBQUksQ0FBQ0EsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGtCQUFrQixJQUFLLElBQUksSUFBSSxDQUFDQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVoQixP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QUFPO2dCQUNuQztZQUNKLE9BQ0s7Z0JBQ0QsTUFBTSxJQUFJSCxXQUFXRyxPQUFPO1lBQ2hDO1lBQ0EsOERBQThEO1lBQzlELHlEQUF5RDtZQUN6RCw2REFBNkQ7WUFDN0QsTUFBTW9DLEtBQU0sTUFBTSxJQUFJN0QsUUFBUSxDQUFDRCxTQUFTRTtnQkFDcENpQyxPQUFPUixHQUFHLENBQUNJLFVBQVUsQ0FBQ29CLEtBQUtDO29CQUN2QixPQUFPRCxNQUFNakQsT0FBT2lELE9BQU9uRCxRQUFRb0Q7Z0JBQ3ZDO1lBQ0o7WUFDQVUsR0FBRzFCLElBQUksQ0FBQyxPQUFPRTtZQUNmd0IsR0FBRzdCLFlBQVksR0FBR0E7WUFDbEIsT0FBTzZCO1FBQ1gsRUFDQSxPQUFPWCxLQUFLO1lBQ1JoQixPQUFPNEIsT0FBTztZQUNkLE1BQU1aO1FBQ1Y7UUFDQSx1RUFBdUU7UUFDdkUsU0FBU1U7WUFDTCxJQUFJL0IsU0FBU0EsTUFBTUcsWUFBWSxJQUFJQSxjQUFjO2dCQUM3QyxPQUFPLENBQUNILE1BQU1HLFlBQVksS0FBSyxDQUFDQTtZQUNwQztZQUNBLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQWhCLGtCQUFlLEdBQUdVLEtBQ2xCLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2dldC11cmkvZGlzdC9mdHAuanM/NjkxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25jZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAdG9vdGFsbG5hdGUvb25jZVwiKSk7XG5jb25zdCBmdHBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnRwXCIpKTtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3Qgbm90Zm91bmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9ub3Rmb3VuZFwiKSk7XG5jb25zdCBub3Rtb2RpZmllZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vdG1vZGlmaWVkXCIpKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdnZXQtdXJpOmZ0cCcpO1xuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGUgc3RyZWFtIGZyb20gYW4gXCJmdHA6XCIgVVJJLlxuICovXG5mdW5jdGlvbiBnZXQocGFyc2VkLCBvcHRzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgeyBjYWNoZSB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgZmlsZXBhdGggPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWQgPSBudWxsO1xuICAgICAgICBpZiAoIWZpbGVwYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBcInBhdGhuYW1lXCIhJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGZ0cF8xLmRlZmF1bHQoKTtcbiAgICAgICAgY2xpZW50Lm9uY2UoJ2dyZWV0aW5nJywgKGdyZWV0aW5nKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZygnRlRQIGdyZWV0aW5nOiAlbycsIGdyZWV0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIEZUUCBjbGllbnQgc29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgICAgIGNsaWVudC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3B0cy5ob3N0ID0gcGFyc2VkLmhvc3RuYW1lIHx8IHBhcnNlZC5ob3N0IHx8ICdsb2NhbGhvc3QnO1xuICAgICAgICAgICAgb3B0cy5wb3J0ID0gcGFyc2VJbnQocGFyc2VkLnBvcnQgfHwgJzAnLCAxMCkgfHwgMjE7XG4gICAgICAgICAgICBvcHRzLmRlYnVnID0gZGVidWc7XG4gICAgICAgICAgICBpZiAocGFyc2VkLmF1dGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbdXNlciwgcGFzc3dvcmRdID0gcGFyc2VkLmF1dGguc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICBvcHRzLnVzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICAgIG9wdHMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF3YWl0IGNiKF8gPT4gY2xpZW50LmNvbm5lY3Qob3B0cywgXykpO1xuICAgICAgICAgICAgY29uc3QgcmVhZHlQcm9taXNlID0gb25jZV8xLmRlZmF1bHQoY2xpZW50LCAncmVhZHknKTtcbiAgICAgICAgICAgIGNsaWVudC5jb25uZWN0KG9wdHMpO1xuICAgICAgICAgICAgeWllbGQgcmVhZHlQcm9taXNlO1xuICAgICAgICAgICAgLy8gZmlyc3Qgd2UgaGF2ZSB0byBmaWd1cmUgb3V0IHRoZSBMYXN0IE1vZGlmaWVkIGRhdGUuXG4gICAgICAgICAgICAvLyB0cnkgdGhlIE1EVE0gY29tbWFuZCBmaXJzdCwgd2hpY2ggaXMgYW4gb3B0aW9uYWwgZXh0ZW5zaW9uIGNvbW1hbmQuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZCA9IHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50Lmxhc3RNb2QoZmlsZXBhdGgsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgdGhlIFwiZmlsZSBub3QgZm91bmRcIiBlcnJvciBjb2RlXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSA1NTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5vdGZvdW5kXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCB0aGUgbGFzdCBtb2RpZmllZCBkYXRlIHZpYSB0aGUgTElTVCBjb21tYW5kICh1c2VzXG4gICAgICAgICAgICAgICAgLy8gbW9yZSBiYW5kd2lkdGgsIGJ1dCBpcyBtb3JlIGNvbXBhdGlibGUgd2l0aCBvbGRlciBGVFAgc2VydmVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5saXN0KHBhdGhfMS5kaXJuYW1lKGZpbGVwYXRoKSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZmluZCB0aGUgXCJlbnRyeVwiIHdpdGggYSBtYXRjaGluZyBcIm5hbWVcIlxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwYXRoXzEuYmFzZW5hbWUoZmlsZXBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gbGlzdC5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkID0gZW50cnkuZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm90TW9kaWZpZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbm90bW9kaWZpZWRfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5vdGZvdW5kXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gWFhYOiBhIHNtYWxsIHRpbWVvdXQgc2VlbWVkIG5lY2Vzc2FyeSBvdGhlcndpc2UgRlRQIHNlcnZlcnNcbiAgICAgICAgICAgIC8vIHdlcmUgcmV0dXJuaW5nIGVtcHR5IHNvY2tldHMgZm9yIHRoZSBmaWxlIG9jY2FzaW9uYWxseVxuICAgICAgICAgICAgLy8gc2V0VGltZW91dChjbGllbnQuZ2V0LmJpbmQoY2xpZW50LCBmaWxlcGF0aCwgb25maWxlKSwgMTApO1xuICAgICAgICAgICAgY29uc3QgcnMgPSAoeWllbGQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsaWVudC5nZXQoZmlsZXBhdGgsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBycy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICBycy5sYXN0TW9kaWZpZWQgPSBsYXN0TW9kaWZpZWQ7XG4gICAgICAgICAgICByZXR1cm4gcnM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2xpZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsZWQgd2hlbiBgbGFzdE1vZGlmaWVkYCBpcyBzZXQsIGFuZCBhIFwiY2FjaGVcIiBzdHJlYW0gd2FzIHByb3ZpZGVkXG4gICAgICAgIGZ1bmN0aW9uIGlzTm90TW9kaWZpZWQoKSB7XG4gICAgICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUubGFzdE1vZGlmaWVkICYmIGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiArY2FjaGUubGFzdE1vZGlmaWVkID09PSArbGFzdE1vZGlmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdHAuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJvbmNlXzEiLCJyZXF1aXJlIiwiZnRwXzEiLCJwYXRoXzEiLCJkZWJ1Z18xIiwibm90Zm91bmRfMSIsIm5vdG1vZGlmaWVkXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJnZXQiLCJwYXJzZWQiLCJvcHRzIiwiY2FjaGUiLCJmaWxlcGF0aCIsInBhdGhuYW1lIiwibGFzdE1vZGlmaWVkIiwiVHlwZUVycm9yIiwiY2xpZW50Iiwib25jZSIsImdyZWV0aW5nIiwib25lbmQiLCJlbmQiLCJob3N0IiwiaG9zdG5hbWUiLCJwb3J0IiwicGFyc2VJbnQiLCJhdXRoIiwidXNlciIsInBhc3N3b3JkIiwic3BsaXQiLCJyZWFkeVByb21pc2UiLCJjb25uZWN0IiwibGFzdE1vZCIsImVyciIsInJlcyIsImNvZGUiLCJsaXN0IiwiZGlybmFtZSIsIm5hbWUiLCJiYXNlbmFtZSIsImVudHJ5IiwiZmluZCIsImRhdGUiLCJpc05vdE1vZGlmaWVkIiwicnMiLCJkZXN0cm95Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/ftp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/http-error.js":
/*!*************************************************!*\
  !*** ./node_modules/get-uri/dist/http-error.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst http_1 = __webpack_require__(/*! http */ \"http\");\n/**\n * Error subclass to use when an HTTP application error has occurred.\n */ class HTTPError extends Error {\n    constructor(statusCode, message = http_1.STATUS_CODES[statusCode]){\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.statusCode = statusCode;\n        this.code = `E${String(message).toUpperCase().replace(/\\s+/g, \"\")}`;\n    }\n}\nexports[\"default\"] = HTTPError; //# sourceMappingURL=http-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2h0dHAtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsU0FBU0MsbUJBQU9BLENBQUMsa0JBQU07QUFDN0I7O0NBRUMsR0FDRCxNQUFNQyxrQkFBa0JDO0lBQ3BCQyxZQUFZQyxVQUFVLEVBQUVDLFVBQVVOLE9BQU9PLFlBQVksQ0FBQ0YsV0FBVyxDQUFFO1FBQy9ELEtBQUssQ0FBQ0M7UUFDTlYsT0FBT1ksY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXQyxTQUFTO1FBQ2hELElBQUksQ0FBQ0osVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNLLElBQUksR0FBRyxDQUFDLENBQUMsRUFBRUMsT0FBT0wsU0FDbEJNLFdBQVcsR0FDWEMsT0FBTyxDQUFDLFFBQVEsSUFBSSxDQUFDO0lBQzlCO0FBQ0o7QUFDQWYsa0JBQWUsR0FBR0ksV0FDbEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2h0dHAtZXJyb3IuanM/ZjliNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGh0dHBfMSA9IHJlcXVpcmUoXCJodHRwXCIpO1xuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyB0byB1c2Ugd2hlbiBhbiBIVFRQIGFwcGxpY2F0aW9uIGVycm9yIGhhcyBvY2N1cnJlZC5cbiAqL1xuY2xhc3MgSFRUUEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1c0NvZGUsIG1lc3NhZ2UgPSBodHRwXzEuU1RBVFVTX0NPREVTW3N0YXR1c0NvZGVdKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLmNvZGUgPSBgRSR7U3RyaW5nKG1lc3NhZ2UpXG4gICAgICAgICAgICAudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJycpfWA7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSFRUUEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC1lcnJvci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJodHRwXzEiLCJyZXF1aXJlIiwiSFRUUEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0YXR1c0NvZGUiLCJtZXNzYWdlIiwiU1RBVFVTX0NPREVTIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJjb2RlIiwiU3RyaW5nIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/http-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/http.js":
/*!*******************************************!*\
  !*** ./node_modules/get-uri/dist/http.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst http_1 = __importDefault(__webpack_require__(/*! http */ \"http\"));\nconst https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nconst once_1 = __importDefault(__webpack_require__(/*! @tootallnate/once */ \"(rsc)/./node_modules/@tootallnate/once/dist/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst http_error_1 = __importDefault(__webpack_require__(/*! ./http-error */ \"(rsc)/./node_modules/get-uri/dist/http-error.js\"));\nconst notfound_1 = __importDefault(__webpack_require__(/*! ./notfound */ \"(rsc)/./node_modules/get-uri/dist/notfound.js\"));\nconst notmodified_1 = __importDefault(__webpack_require__(/*! ./notmodified */ \"(rsc)/./node_modules/get-uri/dist/notmodified.js\"));\nconst debug = debug_1.default(\"get-uri:http\");\n/**\n * Returns a Readable stream from an \"http:\" URI.\n */ function get(parsed, opts) {\n    return __awaiter(this, void 0, void 0, function*() {\n        debug(\"GET %o\", parsed.href);\n        const cache = getCache(parsed, opts.cache);\n        // first check the previous Expires and/or Cache-Control headers\n        // of a previous response if a `cache` was provided\n        if (cache && isFresh(cache) && typeof cache.statusCode === \"number\") {\n            // check for a 3xx \"redirect\" status code on the previous cache\n            const type = cache.statusCode / 100 | 0;\n            if (type === 3 && cache.headers.location) {\n                debug(\"cached redirect\");\n                throw new Error(\"TODO: implement cached redirects!\");\n            }\n            // otherwise we assume that it's the destination endpoint,\n            // since there's nowhere else to redirect to\n            throw new notmodified_1.default();\n        }\n        // 5 redirects allowed by default\n        const maxRedirects = typeof opts.maxRedirects === \"number\" ? opts.maxRedirects : 5;\n        debug(\"allowing %o max redirects\", maxRedirects);\n        let mod;\n        if (opts.http) {\n            // the `https` module passed in from the \"http.js\" file\n            mod = opts.http;\n            debug(\"using secure `https` core module\");\n        } else {\n            mod = http_1.default;\n            debug(\"using `http` core module\");\n        }\n        const options = Object.assign(Object.assign({}, opts), parsed);\n        // add \"cache validation\" headers if a `cache` was provided\n        if (cache) {\n            if (!options.headers) {\n                options.headers = {};\n            }\n            const lastModified = cache.headers[\"last-modified\"];\n            if (lastModified) {\n                options.headers[\"If-Modified-Since\"] = lastModified;\n                debug('added \"If-Modified-Since\" request header: %o', lastModified);\n            }\n            const etag = cache.headers.etag;\n            if (etag) {\n                options.headers[\"If-None-Match\"] = etag;\n                debug('added \"If-None-Match\" request header: %o', etag);\n            }\n        }\n        const req = mod.get(options);\n        const res = yield once_1.default(req, \"response\");\n        const code = res.statusCode || 0;\n        // assign a Date to this response for the \"Cache-Control\" delta calculation\n        res.date = Date.now();\n        res.parsed = parsed;\n        debug(\"got %o response status code\", code);\n        // any 2xx response is a \"success\" code\n        let type = code / 100 | 0;\n        // check for a 3xx \"redirect\" status code\n        let location = res.headers.location;\n        if (type === 3 && location) {\n            if (!opts.redirects) opts.redirects = [];\n            let redirects = opts.redirects;\n            if (redirects.length < maxRedirects) {\n                debug('got a \"redirect\" status code with Location: %o', location);\n                // flush this response - we're not going to use it\n                res.resume();\n                // hang on to this Response object for the \"redirects\" Array\n                redirects.push(res);\n                let newUri = url_1.resolve(parsed.href, location);\n                debug(\"resolved redirect URL: %o\", newUri);\n                let left = maxRedirects - redirects.length;\n                debug(\"%o more redirects allowed after this one\", left);\n                // check if redirecting to a different protocol\n                let parsedUrl = url_1.parse(newUri);\n                if (parsedUrl.protocol !== parsed.protocol) {\n                    opts.http = parsedUrl.protocol === \"https:\" ? https_1.default : undefined;\n                }\n                return get(parsedUrl, opts);\n            }\n        }\n        // if we didn't get a 2xx \"success\" status code, then create an Error object\n        if (type !== 2) {\n            res.resume();\n            if (code === 304) {\n                throw new notmodified_1.default();\n            } else if (code === 404) {\n                throw new notfound_1.default();\n            }\n            // other HTTP-level error\n            throw new http_error_1.default(code);\n        }\n        if (opts.redirects) {\n            // store a reference to the \"redirects\" Array on the Response object so that\n            // they can be inspected during a subsequent call to GET the same URI\n            res.redirects = opts.redirects;\n        }\n        return res;\n    });\n}\nexports[\"default\"] = get;\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */ function isFresh(cache) {\n    let fresh = false;\n    let expires = parseInt(cache.headers.expires || \"\", 10);\n    const cacheControl = cache.headers[\"cache-control\"];\n    if (cacheControl) {\n        // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n        debug(\"Cache-Control: %o\", cacheControl);\n        const parts = cacheControl.split(/,\\s*?\\b/);\n        for(let i = 0; i < parts.length; i++){\n            const part = parts[i];\n            const subparts = part.split(\"=\");\n            const name = subparts[0];\n            switch(name){\n                case \"max-age\":\n                    expires = (cache.date || 0) + parseInt(subparts[1], 10) * 1000;\n                    fresh = Date.now() < expires;\n                    if (fresh) {\n                        debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n                    }\n                    return fresh;\n                case \"must-revalidate\":\n                    break;\n                case \"no-cache\":\n                case \"no-store\":\n                    debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n                    return false;\n                default:\n                    break;\n            }\n        }\n    } else if (expires) {\n        // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n        debug(\"Expires: %o\", expires);\n        fresh = Date.now() < expires;\n        if (fresh) {\n            debug('cache is \"fresh\" due to previous Expires response header');\n        }\n        return fresh;\n    }\n    return false;\n}\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */ function getCache(parsed, cache) {\n    if (cache) {\n        if (cache.parsed && cache.parsed.href === parsed.href) {\n            return cache;\n        }\n        if (cache.redirects) {\n            for(let i = 0; i < cache.redirects.length; i++){\n                const c = getCache(parsed, cache.redirects[i]);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n    }\n    return null;\n} //# sourceMappingURL=http.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLElBQUssSUFBSSxJQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFaEIs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QUFTN0IsU0FBU0osTUFBTSxFQUFFRyxLQUFLO0lBQzNCLElBQUlBLE9BQU87UUFDUCxJQUFJQSxNQUFNSCxNQUFNLElBQUlHLE1BQU1ILE1BQU0sQ0FBQ0UsSUFBSSxLQUFLRixPQUFPRSxJQUFJLEVBQUU7WUFDbkQsT0FBT0M7UUFDWDtRQUNBLElBQUlBLE1BQU1vQixTQUFTLEVBQUU7WUFDakIsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJcEMsTUFBTW9CLFNBQVMsQ0FBQ0MsTUFBTSxFQUFFZSxJQUFLO2dCQUM3QyxNQUFNSSxJQUFJdkMsU0FBU0osUUFBUUcsTUFBTW9CLFNBQVMsQ0FBQ2dCLEVBQUU7Z0JBQzdDLElBQUlJLEdBQUc7b0JBQ0gsT0FBT0E7Z0JBQ1g7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPO0FBQ1gsRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9nZXQtdXJpL2Rpc3QvaHR0cC5qcz83YzIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBodHRwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImh0dHBcIikpO1xuY29uc3QgaHR0cHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cHNcIikpO1xuY29uc3Qgb25jZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAdG9vdGFsbG5hdGUvb25jZVwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBodHRwX2Vycm9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaHR0cC1lcnJvclwiKSk7XG5jb25zdCBub3Rmb3VuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25vdGZvdW5kXCIpKTtcbmNvbnN0IG5vdG1vZGlmaWVkXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm90bW9kaWZpZWRcIikpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQoJ2dldC11cmk6aHR0cCcpO1xuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGUgc3RyZWFtIGZyb20gYW4gXCJodHRwOlwiIFVSSS5cbiAqL1xuZnVuY3Rpb24gZ2V0KHBhcnNlZCwgb3B0cykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGRlYnVnKCdHRVQgJW8nLCBwYXJzZWQuaHJlZik7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gZ2V0Q2FjaGUocGFyc2VkLCBvcHRzLmNhY2hlKTtcbiAgICAgICAgLy8gZmlyc3QgY2hlY2sgdGhlIHByZXZpb3VzIEV4cGlyZXMgYW5kL29yIENhY2hlLUNvbnRyb2wgaGVhZGVyc1xuICAgICAgICAvLyBvZiBhIHByZXZpb3VzIHJlc3BvbnNlIGlmIGEgYGNhY2hlYCB3YXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKGNhY2hlICYmIGlzRnJlc2goY2FjaGUpICYmIHR5cGVvZiBjYWNoZS5zdGF0dXNDb2RlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgM3h4IFwicmVkaXJlY3RcIiBzdGF0dXMgY29kZSBvbiB0aGUgcHJldmlvdXMgY2FjaGVcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAoY2FjaGUuc3RhdHVzQ29kZSAvIDEwMCkgfCAwO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDMgJiYgY2FjaGUuaGVhZGVycy5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdjYWNoZWQgcmVkaXJlY3QnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RPRE86IGltcGxlbWVudCBjYWNoZWQgcmVkaXJlY3RzIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGRlc3RpbmF0aW9uIGVuZHBvaW50LFxuICAgICAgICAgICAgLy8gc2luY2UgdGhlcmUncyBub3doZXJlIGVsc2UgdG8gcmVkaXJlY3QgdG9cbiAgICAgICAgICAgIHRocm93IG5ldyBub3Rtb2RpZmllZF8xLmRlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA1IHJlZGlyZWN0cyBhbGxvd2VkIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgbWF4UmVkaXJlY3RzID0gdHlwZW9mIG9wdHMubWF4UmVkaXJlY3RzID09PSAnbnVtYmVyJyA/IG9wdHMubWF4UmVkaXJlY3RzIDogNTtcbiAgICAgICAgZGVidWcoJ2FsbG93aW5nICVvIG1heCByZWRpcmVjdHMnLCBtYXhSZWRpcmVjdHMpO1xuICAgICAgICBsZXQgbW9kO1xuICAgICAgICBpZiAob3B0cy5odHRwKSB7XG4gICAgICAgICAgICAvLyB0aGUgYGh0dHBzYCBtb2R1bGUgcGFzc2VkIGluIGZyb20gdGhlIFwiaHR0cC5qc1wiIGZpbGVcbiAgICAgICAgICAgIG1vZCA9IG9wdHMuaHR0cDtcbiAgICAgICAgICAgIGRlYnVnKCd1c2luZyBzZWN1cmUgYGh0dHBzYCBjb3JlIG1vZHVsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kID0gaHR0cF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICBkZWJ1ZygndXNpbmcgYGh0dHBgIGNvcmUgbW9kdWxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHBhcnNlZCk7XG4gICAgICAgIC8vIGFkZCBcImNhY2hlIHZhbGlkYXRpb25cIiBoZWFkZXJzIGlmIGEgYGNhY2hlYCB3YXMgcHJvdmlkZWRcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdE1vZGlmaWVkID0gY2FjaGUuaGVhZGVyc1snbGFzdC1tb2RpZmllZCddO1xuICAgICAgICAgICAgaWYgKGxhc3RNb2RpZmllZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1snSWYtTW9kaWZpZWQtU2luY2UnXSA9IGxhc3RNb2RpZmllZDtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnYWRkZWQgXCJJZi1Nb2RpZmllZC1TaW5jZVwiIHJlcXVlc3QgaGVhZGVyOiAlbycsIGxhc3RNb2RpZmllZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldGFnID0gY2FjaGUuaGVhZGVycy5ldGFnO1xuICAgICAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ0lmLU5vbmUtTWF0Y2gnXSA9IGV0YWc7XG4gICAgICAgICAgICAgICAgZGVidWcoJ2FkZGVkIFwiSWYtTm9uZS1NYXRjaFwiIHJlcXVlc3QgaGVhZGVyOiAlbycsIGV0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcSA9IG1vZC5nZXQob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIG9uY2VfMS5kZWZhdWx0KHJlcSwgJ3Jlc3BvbnNlJyk7XG4gICAgICAgIGNvbnN0IGNvZGUgPSByZXMuc3RhdHVzQ29kZSB8fCAwO1xuICAgICAgICAvLyBhc3NpZ24gYSBEYXRlIHRvIHRoaXMgcmVzcG9uc2UgZm9yIHRoZSBcIkNhY2hlLUNvbnRyb2xcIiBkZWx0YSBjYWxjdWxhdGlvblxuICAgICAgICByZXMuZGF0ZSA9IERhdGUubm93KCk7XG4gICAgICAgIHJlcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIGRlYnVnKCdnb3QgJW8gcmVzcG9uc2Ugc3RhdHVzIGNvZGUnLCBjb2RlKTtcbiAgICAgICAgLy8gYW55IDJ4eCByZXNwb25zZSBpcyBhIFwic3VjY2Vzc1wiIGNvZGVcbiAgICAgICAgbGV0IHR5cGUgPSAoY29kZSAvIDEwMCkgfCAwO1xuICAgICAgICAvLyBjaGVjayBmb3IgYSAzeHggXCJyZWRpcmVjdFwiIHN0YXR1cyBjb2RlXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICBpZiAodHlwZSA9PT0gMyAmJiBsb2NhdGlvbikge1xuICAgICAgICAgICAgaWYgKCFvcHRzLnJlZGlyZWN0cylcbiAgICAgICAgICAgICAgICBvcHRzLnJlZGlyZWN0cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHJlZGlyZWN0cyA9IG9wdHMucmVkaXJlY3RzO1xuICAgICAgICAgICAgaWYgKHJlZGlyZWN0cy5sZW5ndGggPCBtYXhSZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnZ290IGEgXCJyZWRpcmVjdFwiIHN0YXR1cyBjb2RlIHdpdGggTG9jYXRpb246ICVvJywgbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIGZsdXNoIHRoaXMgcmVzcG9uc2UgLSB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0XG4gICAgICAgICAgICAgICAgcmVzLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIC8vIGhhbmcgb24gdG8gdGhpcyBSZXNwb25zZSBvYmplY3QgZm9yIHRoZSBcInJlZGlyZWN0c1wiIEFycmF5XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RzLnB1c2gocmVzKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3VXJpID0gdXJsXzEucmVzb2x2ZShwYXJzZWQuaHJlZiwgbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGRlYnVnKCdyZXNvbHZlZCByZWRpcmVjdCBVUkw6ICVvJywgbmV3VXJpKTtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IG1heFJlZGlyZWN0cyAtIHJlZGlyZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZGVidWcoJyVvIG1vcmUgcmVkaXJlY3RzIGFsbG93ZWQgYWZ0ZXIgdGhpcyBvbmUnLCBsZWZ0KTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiByZWRpcmVjdGluZyB0byBhIGRpZmZlcmVudCBwcm90b2NvbFxuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRVcmwgPSB1cmxfMS5wYXJzZShuZXdVcmkpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09IHBhcnNlZC5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmh0dHAgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonID8gaHR0cHNfMS5kZWZhdWx0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHBhcnNlZFVybCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIDJ4eCBcInN1Y2Nlc3NcIiBzdGF0dXMgY29kZSwgdGhlbiBjcmVhdGUgYW4gRXJyb3Igb2JqZWN0XG4gICAgICAgIGlmICh0eXBlICE9PSAyKSB7XG4gICAgICAgICAgICByZXMucmVzdW1lKCk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gMzA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5vdG1vZGlmaWVkXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IG5vdGZvdW5kXzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXIgSFRUUC1sZXZlbCBlcnJvclxuICAgICAgICAgICAgdGhyb3cgbmV3IGh0dHBfZXJyb3JfMS5kZWZhdWx0KGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJlZGlyZWN0cykge1xuICAgICAgICAgICAgLy8gc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIFwicmVkaXJlY3RzXCIgQXJyYXkgb24gdGhlIFJlc3BvbnNlIG9iamVjdCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB0aGV5IGNhbiBiZSBpbnNwZWN0ZWQgZHVyaW5nIGEgc3Vic2VxdWVudCBjYWxsIHRvIEdFVCB0aGUgc2FtZSBVUklcbiAgICAgICAgICAgIHJlcy5yZWRpcmVjdHMgPSBvcHRzLnJlZGlyZWN0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0O1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvdmlkZWQgY2FjaGUncyBcImZyZXNobmVzc1wiIGlzIHZhbGlkLiBUaGF0IGlzLCBlaXRoZXJcbiAqIHRoZSBDYWNoZS1Db250cm9sIGhlYWRlciBvciBFeHBpcmVzIGhlYWRlciB2YWx1ZXMgYXJlIHN0aWxsIHdpdGhpbiB0aGUgYWxsb3dlZFxuICogdGltZSBwZXJpb2QuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0ZyZXNoKGNhY2hlKSB7XG4gICAgbGV0IGZyZXNoID0gZmFsc2U7XG4gICAgbGV0IGV4cGlyZXMgPSBwYXJzZUludChjYWNoZS5oZWFkZXJzLmV4cGlyZXMgfHwgJycsIDEwKTtcbiAgICBjb25zdCBjYWNoZUNvbnRyb2wgPSBjYWNoZS5oZWFkZXJzWydjYWNoZS1jb250cm9sJ107XG4gICAgaWYgKGNhY2hlQ29udHJvbCkge1xuICAgICAgICAvLyBmb3IgQ2FjaGUtQ29udHJvbCBydWxlcywgc2VlOiBodHRwOi8vd3d3Lm1ub3QubmV0L2NhY2hlX2RvY3MvI0NBQ0hFLUNPTlRST0xcbiAgICAgICAgZGVidWcoJ0NhY2hlLUNvbnRyb2w6ICVvJywgY2FjaGVDb250cm9sKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBjYWNoZUNvbnRyb2wuc3BsaXQoLyxcXHMqP1xcYi8pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBjb25zdCBzdWJwYXJ0cyA9IHBhcnQuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdWJwYXJ0c1swXTtcbiAgICAgICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21heC1hZ2UnOlxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gKGNhY2hlLmRhdGUgfHwgMCkgKyBwYXJzZUludChzdWJwYXJ0c1sxXSwgMTApICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgZnJlc2ggPSBEYXRlLm5vdygpIDwgZXhwaXJlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnY2FjaGUgaXMgXCJmcmVzaFwiIGR1ZSB0byBwcmV2aW91cyAlbyBDYWNoZS1Db250cm9sIHBhcmFtJywgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyZXNoO1xuICAgICAgICAgICAgICAgIGNhc2UgJ211c3QtcmV2YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFhYWDogd2hhdCB3ZSBzdXBwb3NlZCB0byBkbyBoZXJlP1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduby1jYWNoZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbm8tc3RvcmUnOlxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZygnY2FjaGUgaXMgXCJzdGFsZVwiIGR1ZSB0byBleHBsaWNpdCAlbyBDYWNoZS1Db250cm9sIHBhcmFtJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgdW5rbm93biBjYWNoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChleHBpcmVzKSB7XG4gICAgICAgIC8vIGZvciBFeHBpcmVzIHJ1bGVzLCBzZWU6IGh0dHA6Ly93d3cubW5vdC5uZXQvY2FjaGVfZG9jcy8jRVhQSVJFU1xuICAgICAgICBkZWJ1ZygnRXhwaXJlczogJW8nLCBleHBpcmVzKTtcbiAgICAgICAgZnJlc2ggPSBEYXRlLm5vdygpIDwgZXhwaXJlcztcbiAgICAgICAgaWYgKGZyZXNoKSB7XG4gICAgICAgICAgICBkZWJ1ZygnY2FjaGUgaXMgXCJmcmVzaFwiIGR1ZSB0byBwcmV2aW91cyBFeHBpcmVzIHJlc3BvbnNlIGhlYWRlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmVzaDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXR1cm4gYSBwcmV2aW91cyBSZXNwb25zZSBvYmplY3QgZnJvbSBhIHByZXZpb3VzIEdFVCBjYWxsIHRvIHRoZVxuICogc2FtZSBVUkkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENhY2hlKHBhcnNlZCwgY2FjaGUpIHtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKGNhY2hlLnBhcnNlZCAmJiBjYWNoZS5wYXJzZWQuaHJlZiA9PT0gcGFyc2VkLmhyZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGUucmVkaXJlY3RzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLnJlZGlyZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRDYWNoZShwYXJzZWQsIGNhY2hlLnJlZGlyZWN0c1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImh0dHBfMSIsInJlcXVpcmUiLCJodHRwc18xIiwib25jZV8xIiwiZGVidWdfMSIsInVybF8xIiwiaHR0cF9lcnJvcl8xIiwibm90Zm91bmRfMSIsIm5vdG1vZGlmaWVkXzEiLCJkZWJ1ZyIsImRlZmF1bHQiLCJnZXQiLCJwYXJzZWQiLCJvcHRzIiwiaHJlZiIsImNhY2hlIiwiZ2V0Q2FjaGUiLCJpc0ZyZXNoIiwic3RhdHVzQ29kZSIsInR5cGUiLCJoZWFkZXJzIiwibG9jYXRpb24iLCJFcnJvciIsIm1heFJlZGlyZWN0cyIsImh0dHAiLCJvcHRpb25zIiwiYXNzaWduIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInJlcSIsInJlcyIsImNvZGUiLCJkYXRlIiwiRGF0ZSIsIm5vdyIsInJlZGlyZWN0cyIsImxlbmd0aCIsInJlc3VtZSIsInB1c2giLCJuZXdVcmkiLCJsZWZ0IiwicGFyc2VkVXJsIiwicGFyc2UiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImZyZXNoIiwiZXhwaXJlcyIsInBhcnNlSW50IiwiY2FjaGVDb250cm9sIiwicGFydHMiLCJzcGxpdCIsImkiLCJwYXJ0Iiwic3VicGFydHMiLCJuYW1lIiwiYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/http.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/https.js":
/*!********************************************!*\
  !*** ./node_modules/get-uri/dist/https.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst https_1 = __importDefault(__webpack_require__(/*! https */ \"https\"));\nconst http_1 = __importDefault(__webpack_require__(/*! ./http */ \"(rsc)/./node_modules/get-uri/dist/http.js\"));\n/**\n * Returns a Readable stream from an \"https:\" URI.\n */ function get(parsed, opts) {\n    return http_1.default(parsed, Object.assign(Object.assign({}, opts), {\n        http: https_1.default\n    }));\n}\nexports[\"default\"] = get; //# sourceMappingURL=https.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2h0dHBzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVUCxnQkFBZ0JRLG1CQUFPQSxDQUFDLG9CQUFPO0FBQy9DLE1BQU1DLFNBQVNULGdCQUFnQlEsbUJBQU9BLENBQUMseURBQVE7QUFDL0M7O0NBRUMsR0FDRCxTQUFTRSxJQUFJQyxNQUFNLEVBQUVDLElBQUk7SUFDckIsT0FBT0gsT0FBT0ksT0FBTyxDQUFDRixRQUFRUixPQUFPVyxNQUFNLENBQUNYLE9BQU9XLE1BQU0sQ0FBQyxDQUFDLEdBQUdGLE9BQU87UUFBRUcsTUFBTVIsUUFBUU0sT0FBTztJQUFDO0FBQ2pHO0FBQ0FSLGtCQUFlLEdBQUdLLEtBQ2xCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL2dldC11cmkvZGlzdC9odHRwcy5qcz9iMzViIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaHR0cHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHR0cHNcIikpO1xuY29uc3QgaHR0cF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2h0dHBcIikpO1xuLyoqXG4gKiBSZXR1cm5zIGEgUmVhZGFibGUgc3RyZWFtIGZyb20gYW4gXCJodHRwczpcIiBVUkkuXG4gKi9cbmZ1bmN0aW9uIGdldChwYXJzZWQsIG9wdHMpIHtcbiAgICByZXR1cm4gaHR0cF8xLmRlZmF1bHQocGFyc2VkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdHMpLCB7IGh0dHA6IGh0dHBzXzEuZGVmYXVsdCB9KSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1odHRwcy5qcy5tYXAiXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaHR0cHNfMSIsInJlcXVpcmUiLCJodHRwXzEiLCJnZXQiLCJwYXJzZWQiLCJvcHRzIiwiZGVmYXVsdCIsImFzc2lnbiIsImh0dHAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/https.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/get-uri/dist/index.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\n// Built-in protocols\nconst data_1 = __importDefault(__webpack_require__(/*! ./data */ \"(rsc)/./node_modules/get-uri/dist/data.js\"));\nconst file_1 = __importDefault(__webpack_require__(/*! ./file */ \"(rsc)/./node_modules/get-uri/dist/file.js\"));\nconst ftp_1 = __importDefault(__webpack_require__(/*! ./ftp */ \"(rsc)/./node_modules/get-uri/dist/ftp.js\"));\nconst http_1 = __importDefault(__webpack_require__(/*! ./http */ \"(rsc)/./node_modules/get-uri/dist/http.js\"));\nconst https_1 = __importDefault(__webpack_require__(/*! ./https */ \"(rsc)/./node_modules/get-uri/dist/https.js\"));\nconst debug = debug_1.default(\"get-uri\");\nfunction getUri(uri, opts, fn) {\n    const p = new Promise((resolve, reject)=>{\n        debug(\"getUri(%o)\", uri);\n        if (typeof opts === \"function\") {\n            fn = opts;\n            opts = undefined;\n        }\n        if (!uri) {\n            reject(new TypeError('Must pass in a URI to \"get\"'));\n            return;\n        }\n        const parsed = url_1.parse(uri);\n        // Strip trailing `:`\n        const protocol = (parsed.protocol || \"\").replace(/:$/, \"\");\n        if (!protocol) {\n            reject(new TypeError(`URI does not contain a protocol: ${uri}`));\n            return;\n        }\n        const getter = getUri.protocols[protocol];\n        if (typeof getter !== \"function\") {\n            throw new TypeError(`Unsupported protocol \"${protocol}\" specified in URI: ${uri}`);\n        }\n        resolve(getter(parsed, opts || {}));\n    });\n    if (typeof fn === \"function\") {\n        p.then((rtn)=>fn(null, rtn), (err)=>fn(err));\n    } else {\n        return p;\n    }\n}\n(function(getUri) {\n    getUri.protocols = {\n        data: data_1.default,\n        file: file_1.default,\n        ftp: ftp_1.default,\n        http: http_1.default,\n        https: https_1.default\n    };\n})(getUri || (getUri = {}));\nmodule.exports = getUri; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLElBQUssSUFBSSxJQUFJLENBQUNBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBLE1BQU1FLFVBQVVILGdCQUFnQkksbUJBQU9BLENBQUMsc0RBQU87QUFDL0MsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IscUJBQXFCO0FBQ3JCLE1BQU1FLFNBQVNOLGdCQUFnQkksbUJBQU9BLENBQUMseURBQVE7QUFDL0MsTUFBTUcsU0FBU1AsZ0JBQWdCSSxtQkFBT0EsQ0FBQyx5REFBUTtBQUMvQyxNQUFNSSxRQUFRUixnQkFBZ0JJLG1CQUFPQSxDQUFDLHVEQUFPO0FBQzdDLE1BQU1LLFNBQVNULGdCQUFnQkksbUJBQU9BLENBQUMseURBQVE7QUFDL0MsTUFBTU0sVUFBVVYsZ0JBQWdCSSxtQkFBT0EsQ0FBQywyREFBUztBQUNqRCxNQUFNTyxRQUFRUixRQUFRUyxPQUFPLENBQUM7QUFDOUIsU0FBU0MsT0FBT0MsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEVBQUU7SUFDekIsTUFBTUMsSUFBSSxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzVCVCxNQUFNLGNBQWNHO1FBQ3BCLElBQUksT0FBT0MsU0FBUyxZQUFZO1lBQzVCQyxLQUFLRDtZQUNMQSxPQUFPTTtRQUNYO1FBQ0EsSUFBSSxDQUFDUCxLQUFLO1lBQ05NLE9BQU8sSUFBSUUsVUFBVTtZQUNyQjtRQUNKO1FBQ0EsTUFBTUMsU0FBU2xCLE1BQU1tQixLQUFLLENBQUNWO1FBQzNCLHFCQUFxQjtRQUNyQixNQUFNVyxXQUFXLENBQUNGLE9BQU9FLFFBQVEsSUFBSSxFQUFDLEVBQUdDLE9BQU8sQ0FBQyxNQUFNO1FBQ3ZELElBQUksQ0FBQ0QsVUFBVTtZQUNYTCxPQUFPLElBQUlFLFVBQVUsQ0FBQyxpQ0FBaUMsRUFBRVIsSUFBSSxDQUFDO1lBQzlEO1FBQ0o7UUFDQSxNQUFNYSxTQUFTZCxPQUFPZSxTQUFTLENBQUNILFNBQVM7UUFDekMsSUFBSSxPQUFPRSxXQUFXLFlBQVk7WUFDOUIsTUFBTSxJQUFJTCxVQUFVLENBQUMsc0JBQXNCLEVBQUVHLFNBQVMsb0JBQW9CLEVBQUVYLElBQUksQ0FBQztRQUNyRjtRQUNBSyxRQUFRUSxPQUFPSixRQUFRUixRQUFRLENBQUM7SUFDcEM7SUFDQSxJQUFJLE9BQU9DLE9BQU8sWUFBWTtRQUMxQkMsRUFBRVksSUFBSSxDQUFDQyxDQUFBQSxNQUFPZCxHQUFHLE1BQU1jLE1BQU1DLENBQUFBLE1BQU9mLEdBQUdlO0lBQzNDLE9BQ0s7UUFDRCxPQUFPZDtJQUNYO0FBQ0o7QUFDQyxVQUFVSixNQUFNO0lBQ2JBLE9BQU9lLFNBQVMsR0FBRztRQUNmSSxNQUFNMUIsT0FBT00sT0FBTztRQUNwQnFCLE1BQU0xQixPQUFPSyxPQUFPO1FBQ3BCc0IsS0FBSzFCLE1BQU1JLE9BQU87UUFDbEJ1QixNQUFNMUIsT0FBT0csT0FBTztRQUNwQndCLE9BQU8xQixRQUFRRSxPQUFPO0lBQzFCO0FBQ0osR0FBR0MsVUFBV0EsQ0FBQUEsU0FBUyxDQUFDO0FBQ3hCd0IsT0FBT0MsT0FBTyxHQUFHekIsUUFDakIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L2luZGV4LmpzPzA5ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG4vLyBCdWlsdC1pbiBwcm90b2NvbHNcbmNvbnN0IGRhdGFfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kYXRhXCIpKTtcbmNvbnN0IGZpbGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9maWxlXCIpKTtcbmNvbnN0IGZ0cF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Z0cFwiKSk7XG5jb25zdCBodHRwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vaHR0cFwiKSk7XG5jb25zdCBodHRwc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2h0dHBzXCIpKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdnZXQtdXJpJyk7XG5mdW5jdGlvbiBnZXRVcmkodXJpLCBvcHRzLCBmbikge1xuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGRlYnVnKCdnZXRVcmkoJW8pJywgdXJpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmbiA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXJpKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTXVzdCBwYXNzIGluIGEgVVJJIHRvIFwiZ2V0XCInKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkID0gdXJsXzEucGFyc2UodXJpKTtcbiAgICAgICAgLy8gU3RyaXAgdHJhaWxpbmcgYDpgXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gKHBhcnNlZC5wcm90b2NvbCB8fCAnJykucmVwbGFjZSgvOiQvLCAnJyk7XG4gICAgICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKGBVUkkgZG9lcyBub3QgY29udGFpbiBhIHByb3RvY29sOiAke3VyaX1gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2V0dGVyID0gZ2V0VXJpLnByb3RvY29sc1twcm90b2NvbF07XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0dGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCBwcm90b2NvbCBcIiR7cHJvdG9jb2x9XCIgc3BlY2lmaWVkIGluIFVSSTogJHt1cml9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShnZXR0ZXIocGFyc2VkLCBvcHRzIHx8IHt9KSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwLnRoZW4ocnRuID0+IGZuKG51bGwsIHJ0biksIGVyciA9PiBmbihlcnIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbn1cbihmdW5jdGlvbiAoZ2V0VXJpKSB7XG4gICAgZ2V0VXJpLnByb3RvY29scyA9IHtcbiAgICAgICAgZGF0YTogZGF0YV8xLmRlZmF1bHQsXG4gICAgICAgIGZpbGU6IGZpbGVfMS5kZWZhdWx0LFxuICAgICAgICBmdHA6IGZ0cF8xLmRlZmF1bHQsXG4gICAgICAgIGh0dHA6IGh0dHBfMS5kZWZhdWx0LFxuICAgICAgICBodHRwczogaHR0cHNfMS5kZWZhdWx0XG4gICAgfTtcbn0pKGdldFVyaSB8fCAoZ2V0VXJpID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gZ2V0VXJpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJkZWJ1Z18xIiwicmVxdWlyZSIsInVybF8xIiwiZGF0YV8xIiwiZmlsZV8xIiwiZnRwXzEiLCJodHRwXzEiLCJodHRwc18xIiwiZGVidWciLCJkZWZhdWx0IiwiZ2V0VXJpIiwidXJpIiwib3B0cyIsImZuIiwicCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwicGFyc2VkIiwicGFyc2UiLCJwcm90b2NvbCIsInJlcGxhY2UiLCJnZXR0ZXIiLCJwcm90b2NvbHMiLCJ0aGVuIiwicnRuIiwiZXJyIiwiZGF0YSIsImZpbGUiLCJmdHAiLCJodHRwIiwiaHR0cHMiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/notfound.js":
/*!***********************************************!*\
  !*** ./node_modules/get-uri/dist/notfound.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * Error subclass to use when the source does not exist at the specified endpoint.\n *\n * @param {String} message optional \"message\" property to set\n * @api protected\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass NotFoundError extends Error {\n    constructor(message){\n        super(message || \"File does not exist at the specified endpoint\");\n        this.code = \"ENOTFOUND\";\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports[\"default\"] = NotFoundError; //# sourceMappingURL=notfound.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L25vdGZvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7O0NBS0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsc0JBQXNCQztJQUN4QkMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsV0FBVztRQUNqQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaUixPQUFPUyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVdDLFNBQVM7SUFDcEQ7QUFDSjtBQUNBUixrQkFBZSxHQUFHRSxlQUNsQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9nZXQtdXJpL2Rpc3Qvbm90Zm91bmQuanM/NzJmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgdG8gdXNlIHdoZW4gdGhlIHNvdXJjZSBkb2VzIG5vdCBleGlzdCBhdCB0aGUgc3BlY2lmaWVkIGVuZHBvaW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIG9wdGlvbmFsIFwibWVzc2FnZVwiIHByb3BlcnR5IHRvIHNldFxuICogQGFwaSBwcm90ZWN0ZWRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ0ZpbGUgZG9lcyBub3QgZXhpc3QgYXQgdGhlIHNwZWNpZmllZCBlbmRwb2ludCcpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRU5PVEZPVU5EJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBOb3RGb3VuZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90Zm91bmQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTm90Rm91bmRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/notfound.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/get-uri/dist/notmodified.js":
/*!**************************************************!*\
  !*** ./node_modules/get-uri/dist/notmodified.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Error subclass to use when the source has not been modified.\n *\n * @param {String} message optional \"message\" property to set\n * @api protected\n */ class NotModifiedError extends Error {\n    constructor(message){\n        super(message || 'Source has not been modified since the provied \"cache\", re-use previous results');\n        this.code = \"ENOTMODIFIED\";\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports[\"default\"] = NotModifiedError; //# sourceMappingURL=notmodified.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ2V0LXVyaS9kaXN0L25vdG1vZGlmaWVkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdEOzs7OztDQUtDLEdBQ0QsTUFBTUMseUJBQXlCQztJQUMzQkMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsV0FDRjtRQUNKLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1pSLE9BQU9TLGNBQWMsQ0FBQyxJQUFJLEVBQUUsV0FBV0MsU0FBUztJQUNwRDtBQUNKO0FBQ0FSLGtCQUFlLEdBQUdFLGtCQUNsQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9nZXQtdXJpL2Rpc3Qvbm90bW9kaWZpZWQuanM/N2YyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgdG8gdXNlIHdoZW4gdGhlIHNvdXJjZSBoYXMgbm90IGJlZW4gbW9kaWZpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2Ugb3B0aW9uYWwgXCJtZXNzYWdlXCIgcHJvcGVydHkgdG8gc2V0XG4gKiBAYXBpIHByb3RlY3RlZFxuICovXG5jbGFzcyBOb3RNb2RpZmllZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSB8fFxuICAgICAgICAgICAgJ1NvdXJjZSBoYXMgbm90IGJlZW4gbW9kaWZpZWQgc2luY2UgdGhlIHByb3ZpZWQgXCJjYWNoZVwiLCByZS11c2UgcHJldmlvdXMgcmVzdWx0cycpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRU5PVE1PRElGSUVEJztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBOb3RNb2RpZmllZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90bW9kaWZpZWQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiTm90TW9kaWZpZWRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/get-uri/dist/notmodified.js\n");

/***/ })

};
;