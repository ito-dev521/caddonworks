"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pac-proxy-agent";
exports.ids = ["vendor-chunks/pac-proxy-agent"];
exports.modules = {

/***/ "(rsc)/./node_modules/pac-proxy-agent/dist/agent.js":
/*!****************************************************!*\
  !*** ./node_modules/pac-proxy-agent/dist/agent.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst net_1 = __importDefault(__webpack_require__(/*! net */ \"net\"));\nconst tls_1 = __importDefault(__webpack_require__(/*! tls */ \"tls\"));\nconst once_1 = __importDefault(__webpack_require__(/*! @tootallnate/once */ \"(rsc)/./node_modules/@tootallnate/once/dist/index.js\"));\nconst crypto_1 = __importDefault(__webpack_require__(/*! crypto */ \"crypto\"));\nconst get_uri_1 = __importDefault(__webpack_require__(/*! get-uri */ \"(rsc)/./node_modules/get-uri/dist/index.js\"));\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst raw_body_1 = __importDefault(__webpack_require__(/*! raw-body */ \"(rsc)/./node_modules/raw-body/index.js\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst http_proxy_agent_1 = __webpack_require__(/*! http-proxy-agent */ \"(rsc)/./node_modules/http-proxy-agent/dist/index.js\");\nconst https_proxy_agent_1 = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\");\nconst socks_proxy_agent_1 = __webpack_require__(/*! socks-proxy-agent */ \"(rsc)/./node_modules/socks-proxy-agent/dist/index.js\");\nconst pac_resolver_1 = __importDefault(__webpack_require__(/*! pac-resolver */ \"(rsc)/./node_modules/pac-resolver/dist/index.js\"));\nconst agent_base_1 = __webpack_require__(/*! agent-base */ \"(rsc)/./node_modules/agent-base/dist/src/index.js\");\nconst debug = debug_1.default(\"pac-proxy-agent\");\n/**\n * The `PacProxyAgent` class.\n *\n * A few different \"protocol\" modes are supported (supported protocols are\n * backed by the `get-uri` module):\n *\n *   - \"pac+data\", \"data\" - refers to an embedded \"data:\" URI\n *   - \"pac+file\", \"file\" - refers to a local file\n *   - \"pac+ftp\", \"ftp\" - refers to a file located on an FTP server\n *   - \"pac+http\", \"http\" - refers to an HTTP endpoint\n *   - \"pac+https\", \"https\" - refers to an HTTPS endpoint\n *\n * @api public\n */ class PacProxyAgent extends agent_base_1.Agent {\n    constructor(uri, opts = {}){\n        super(opts);\n        this.clearResolverPromise = ()=>{\n            this.resolverPromise = undefined;\n        };\n        debug(\"Creating PacProxyAgent with URI %o and options %o\", uri, opts);\n        // Strip the \"pac+\" prefix\n        this.uri = uri.replace(/^pac\\+/i, \"\");\n        this.opts = Object.assign({}, opts);\n        this.cache = undefined;\n        this.resolver = undefined;\n        this.resolverHash = \"\";\n        this.resolverPromise = undefined;\n        // For `PacResolver`\n        if (!this.opts.filename) {\n            this.opts.filename = uri;\n        }\n    }\n    /**\n     * Loads the PAC proxy file from the source if necessary, and returns\n     * a generated `FindProxyForURL()` resolver function to use.\n     *\n     * @api private\n     */ getResolver() {\n        if (!this.resolverPromise) {\n            this.resolverPromise = this.loadResolver();\n            this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);\n        }\n        return this.resolverPromise;\n    }\n    loadResolver() {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                // (Re)load the contents of the PAC file URI\n                const code = yield this.loadPacFile();\n                // Create a sha1 hash of the JS code\n                const hash = crypto_1.default.createHash(\"sha1\").update(code).digest(\"hex\");\n                if (this.resolver && this.resolverHash === hash) {\n                    debug(\"Same sha1 hash for code - contents have not changed, reusing previous proxy resolver\");\n                    return this.resolver;\n                }\n                // Cache the resolver\n                debug(\"Creating new proxy resolver instance\");\n                this.resolver = pac_resolver_1.default(code, this.opts);\n                // Store that sha1 hash for future comparison purposes\n                this.resolverHash = hash;\n                return this.resolver;\n            } catch (err) {\n                if (this.resolver && err.code === \"ENOTMODIFIED\") {\n                    debug(\"Got ENOTMODIFIED response, reusing previous proxy resolver\");\n                    return this.resolver;\n                }\n                throw err;\n            }\n        });\n    }\n    /**\n     * Loads the contents of the PAC proxy file.\n     *\n     * @api private\n     */ loadPacFile() {\n        return __awaiter(this, void 0, void 0, function*() {\n            debug(\"Loading PAC file: %o\", this.uri);\n            const rs = yield get_uri_1.default(this.uri, {\n                cache: this.cache\n            });\n            debug(\"Got `Readable` instance for URI\");\n            this.cache = rs;\n            const buf = yield raw_body_1.default(rs);\n            debug(\"Read %o byte PAC file from URI\", buf.length);\n            return buf.toString(\"utf8\");\n        });\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a new HTTP request.\n     *\n     * @api protected\n     */ callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { secureEndpoint } = opts;\n            // First, get a generated `FindProxyForURL()` function,\n            // either cached or retrieved from the source\n            const resolver = yield this.getResolver();\n            // Calculate the `url` parameter\n            const defaultPort = secureEndpoint ? 443 : 80;\n            let path = req.path;\n            let search = null;\n            const firstQuestion = path.indexOf(\"?\");\n            if (firstQuestion !== -1) {\n                search = path.substring(firstQuestion);\n                path = path.substring(0, firstQuestion);\n            }\n            const urlOpts = Object.assign(Object.assign({}, opts), {\n                protocol: secureEndpoint ? \"https:\" : \"http:\",\n                pathname: path,\n                search,\n                // need to use `hostname` instead of `host` otherwise `port` is ignored\n                hostname: opts.host,\n                host: null,\n                href: null,\n                // set `port` to null when it is the protocol default port (80 / 443)\n                port: defaultPort === opts.port ? null : opts.port\n            });\n            const url = url_1.format(urlOpts);\n            debug(\"url: %o\", url);\n            let result = yield resolver(url);\n            // Default to \"DIRECT\" if a falsey value was returned (or nothing)\n            if (!result) {\n                result = \"DIRECT\";\n            }\n            const proxies = String(result).trim().split(/\\s*;\\s*/g).filter(Boolean);\n            if (this.opts.fallbackToDirect && !proxies.includes(\"DIRECT\")) {\n                proxies.push(\"DIRECT\");\n            }\n            for (const proxy of proxies){\n                let agent = null;\n                let socket = null;\n                const [type, target] = proxy.split(/\\s+/);\n                debug(\"Attempting to use proxy: %o\", proxy);\n                if (type === \"DIRECT\") {\n                    // Direct connection to the destination endpoint\n                    socket = secureEndpoint ? tls_1.default.connect(opts) : net_1.default.connect(opts);\n                } else if (type === \"SOCKS\" || type === \"SOCKS5\") {\n                    // Use a SOCKSv5h proxy\n                    agent = new socks_proxy_agent_1.SocksProxyAgent(`socks://${target}`);\n                } else if (type === \"SOCKS4\") {\n                    // Use a SOCKSv4a proxy\n                    agent = new socks_proxy_agent_1.SocksProxyAgent(`socks4a://${target}`);\n                } else if (type === \"PROXY\" || type === \"HTTP\" || type === \"HTTPS\") {\n                    // Use an HTTP or HTTPS proxy\n                    // http://dev.chromium.org/developers/design-documents/secure-web-proxy\n                    const proxyURL = `${type === \"HTTPS\" ? \"https\" : \"http\"}://${target}`;\n                    const proxyOpts = Object.assign(Object.assign({}, this.opts), url_1.parse(proxyURL));\n                    if (secureEndpoint) {\n                        agent = new https_proxy_agent_1.HttpsProxyAgent(proxyOpts);\n                    } else {\n                        agent = new http_proxy_agent_1.HttpProxyAgent(proxyOpts);\n                    }\n                }\n                try {\n                    if (socket) {\n                        // \"DIRECT\" connection, wait for connection confirmation\n                        yield once_1.default(socket, \"connect\");\n                        req.emit(\"proxy\", {\n                            proxy,\n                            socket\n                        });\n                        return socket;\n                    }\n                    if (agent) {\n                        const s = yield agent.callback(req, opts);\n                        req.emit(\"proxy\", {\n                            proxy,\n                            socket: s\n                        });\n                        return s;\n                    }\n                    throw new Error(`Could not determine proxy type for: ${proxy}`);\n                } catch (err) {\n                    debug(\"Got error for proxy %o: %o\", proxy, err);\n                    req.emit(\"proxy\", {\n                        proxy,\n                        error: err\n                    });\n                }\n            }\n            throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);\n        });\n    }\n}\nexports[\"default\"] = PacProxyAgent; //# sourceMappingURL=agent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGFjLXByb3h5LWFnZW50L2Rpc3QvYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLElBQUssSUFBSSxJQUFJLENBQUNBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2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QUFFO3dCQUNyQyxPQUFPQTtvQkFDWDtvQkFDQSxNQUFNLElBQUlDLE1BQU0sQ0FBQyxvQ0FBb0MsRUFBRWQsTUFBTSxDQUFDO2dCQUNsRSxFQUNBLE9BQU9oQyxLQUFLO29CQUNSeEIsTUFBTSw4QkFBOEJ3RCxPQUFPaEM7b0JBQzNDTSxJQUFJc0MsSUFBSSxDQUFDLFNBQVM7d0JBQUVaO3dCQUFPZSxPQUFPL0M7b0JBQUk7Z0JBQzFDO1lBQ0o7WUFDQSxNQUFNLElBQUk4QyxNQUFNLENBQUMsb0RBQW9ELEVBQUVFLEtBQUtDLFNBQVMsQ0FBQzFCLFNBQVMsQ0FBQztRQUNwRztJQUNKO0FBQ0o7QUFDQTlELGtCQUFlLEdBQUdpQixlQUNsQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9wYWMtcHJveHktYWdlbnQvZGlzdC9hZ2VudC5qcz8xYzEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBuZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibmV0XCIpKTtcbmNvbnN0IHRsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ0bHNcIikpO1xuY29uc3Qgb25jZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAdG9vdGFsbG5hdGUvb25jZVwiKSk7XG5jb25zdCBjcnlwdG9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvXCIpKTtcbmNvbnN0IGdldF91cmlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZ2V0LXVyaVwiKSk7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCByYXdfYm9keV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyYXctYm9keVwiKSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBodHRwX3Byb3h5X2FnZW50XzEgPSByZXF1aXJlKFwiaHR0cC1wcm94eS1hZ2VudFwiKTtcbmNvbnN0IGh0dHBzX3Byb3h5X2FnZW50XzEgPSByZXF1aXJlKFwiaHR0cHMtcHJveHktYWdlbnRcIik7XG5jb25zdCBzb2Nrc19wcm94eV9hZ2VudF8xID0gcmVxdWlyZShcInNvY2tzLXByb3h5LWFnZW50XCIpO1xuY29uc3QgcGFjX3Jlc29sdmVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhYy1yZXNvbHZlclwiKSk7XG5jb25zdCBhZ2VudF9iYXNlXzEgPSByZXF1aXJlKFwiYWdlbnQtYmFzZVwiKTtcbmNvbnN0IGRlYnVnID0gZGVidWdfMS5kZWZhdWx0KCdwYWMtcHJveHktYWdlbnQnKTtcbi8qKlxuICogVGhlIGBQYWNQcm94eUFnZW50YCBjbGFzcy5cbiAqXG4gKiBBIGZldyBkaWZmZXJlbnQgXCJwcm90b2NvbFwiIG1vZGVzIGFyZSBzdXBwb3J0ZWQgKHN1cHBvcnRlZCBwcm90b2NvbHMgYXJlXG4gKiBiYWNrZWQgYnkgdGhlIGBnZXQtdXJpYCBtb2R1bGUpOlxuICpcbiAqICAgLSBcInBhYytkYXRhXCIsIFwiZGF0YVwiIC0gcmVmZXJzIHRvIGFuIGVtYmVkZGVkIFwiZGF0YTpcIiBVUklcbiAqICAgLSBcInBhYytmaWxlXCIsIFwiZmlsZVwiIC0gcmVmZXJzIHRvIGEgbG9jYWwgZmlsZVxuICogICAtIFwicGFjK2Z0cFwiLCBcImZ0cFwiIC0gcmVmZXJzIHRvIGEgZmlsZSBsb2NhdGVkIG9uIGFuIEZUUCBzZXJ2ZXJcbiAqICAgLSBcInBhYytodHRwXCIsIFwiaHR0cFwiIC0gcmVmZXJzIHRvIGFuIEhUVFAgZW5kcG9pbnRcbiAqICAgLSBcInBhYytodHRwc1wiLCBcImh0dHBzXCIgLSByZWZlcnMgdG8gYW4gSFRUUFMgZW5kcG9pbnRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5jbGFzcyBQYWNQcm94eUFnZW50IGV4dGVuZHMgYWdlbnRfYmFzZV8xLkFnZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgdGhpcy5jbGVhclJlc29sdmVyUHJvbWlzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBkZWJ1ZygnQ3JlYXRpbmcgUGFjUHJveHlBZ2VudCB3aXRoIFVSSSAlbyBhbmQgb3B0aW9ucyAlbycsIHVyaSwgb3B0cyk7XG4gICAgICAgIC8vIFN0cmlwIHRoZSBcInBhYytcIiBwcmVmaXhcbiAgICAgICAgdGhpcy51cmkgPSB1cmkucmVwbGFjZSgvXnBhY1xcKy9pLCAnJyk7XG4gICAgICAgIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICAgICAgICB0aGlzLmNhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc29sdmVySGFzaCA9ICcnO1xuICAgICAgICB0aGlzLnJlc29sdmVyUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRm9yIGBQYWNSZXNvbHZlcmBcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuZmlsZW5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5maWxlbmFtZSA9IHVyaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgUEFDIHByb3h5IGZpbGUgZnJvbSB0aGUgc291cmNlIGlmIG5lY2Vzc2FyeSwgYW5kIHJldHVybnNcbiAgICAgKiBhIGdlbmVyYXRlZCBgRmluZFByb3h5Rm9yVVJMKClgIHJlc29sdmVyIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFJlc29sdmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZXJQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVyUHJvbWlzZSA9IHRoaXMubG9hZFJlc29sdmVyKCk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVyUHJvbWlzZS50aGVuKHRoaXMuY2xlYXJSZXNvbHZlclByb21pc2UsIHRoaXMuY2xlYXJSZXNvbHZlclByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVyUHJvbWlzZTtcbiAgICB9XG4gICAgbG9hZFJlc29sdmVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyAoUmUpbG9hZCB0aGUgY29udGVudHMgb2YgdGhlIFBBQyBmaWxlIFVSSVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB5aWVsZCB0aGlzLmxvYWRQYWNGaWxlKCk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2hhMSBoYXNoIG9mIHRoZSBKUyBjb2RlXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGNyeXB0b18xLmRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLmNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlKGNvZGUpXG4gICAgICAgICAgICAgICAgICAgIC5kaWdlc3QoJ2hleCcpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVyICYmIHRoaXMucmVzb2x2ZXJIYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdTYW1lIHNoYTEgaGFzaCBmb3IgY29kZSAtIGNvbnRlbnRzIGhhdmUgbm90IGNoYW5nZWQsIHJldXNpbmcgcHJldmlvdXMgcHJveHkgcmVzb2x2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXNvbHZlclxuICAgICAgICAgICAgICAgIGRlYnVnKCdDcmVhdGluZyBuZXcgcHJveHkgcmVzb2x2ZXIgaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVyID0gcGFjX3Jlc29sdmVyXzEuZGVmYXVsdChjb2RlLCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoYXQgc2hhMSBoYXNoIGZvciBmdXR1cmUgY29tcGFyaXNvbiBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJIYXNoID0gaGFzaDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlciAmJiBlcnIuY29kZSA9PT0gJ0VOT1RNT0RJRklFRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoJ0dvdCBFTk9UTU9ESUZJRUQgcmVzcG9uc2UsIHJldXNpbmcgcHJldmlvdXMgcHJveHkgcmVzb2x2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBjb250ZW50cyBvZiB0aGUgUEFDIHByb3h5IGZpbGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBsb2FkUGFjRmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGRlYnVnKCdMb2FkaW5nIFBBQyBmaWxlOiAlbycsIHRoaXMudXJpKTtcbiAgICAgICAgICAgIGNvbnN0IHJzID0geWllbGQgZ2V0X3VyaV8xLmRlZmF1bHQodGhpcy51cmksIHsgY2FjaGU6IHRoaXMuY2FjaGUgfSk7XG4gICAgICAgICAgICBkZWJ1ZygnR290IGBSZWFkYWJsZWAgaW5zdGFuY2UgZm9yIFVSSScpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZSA9IHJzO1xuICAgICAgICAgICAgY29uc3QgYnVmID0geWllbGQgcmF3X2JvZHlfMS5kZWZhdWx0KHJzKTtcbiAgICAgICAgICAgIGRlYnVnKCdSZWFkICVvIGJ5dGUgUEFDIGZpbGUgZnJvbSBVUkknLCBidWYubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBub2RlLWNvcmUgSFRUUCBjbGllbnQgbGlicmFyeSBpcyBjcmVhdGluZyBhIG5ldyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNhbGxiYWNrKHJlcSwgb3B0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzZWN1cmVFbmRwb2ludCB9ID0gb3B0cztcbiAgICAgICAgICAgIC8vIEZpcnN0LCBnZXQgYSBnZW5lcmF0ZWQgYEZpbmRQcm94eUZvclVSTCgpYCBmdW5jdGlvbixcbiAgICAgICAgICAgIC8vIGVpdGhlciBjYWNoZWQgb3IgcmV0cmlldmVkIGZyb20gdGhlIHNvdXJjZVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKCk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGB1cmxgIHBhcmFtZXRlclxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFBvcnQgPSBzZWN1cmVFbmRwb2ludCA/IDQ0MyA6IDgwO1xuICAgICAgICAgICAgbGV0IHBhdGggPSByZXEucGF0aDtcbiAgICAgICAgICAgIGxldCBzZWFyY2ggPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RRdWVzdGlvbiA9IHBhdGguaW5kZXhPZignPycpO1xuICAgICAgICAgICAgaWYgKGZpcnN0UXVlc3Rpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoID0gcGF0aC5zdWJzdHJpbmcoZmlyc3RRdWVzdGlvbik7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDAsIGZpcnN0UXVlc3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXJsT3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgcHJvdG9jb2w6IHNlY3VyZUVuZHBvaW50ID8gJ2h0dHBzOicgOiAnaHR0cDonLCBwYXRobmFtZTogcGF0aCwgc2VhcmNoLCBcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHVzZSBgaG9zdG5hbWVgIGluc3RlYWQgb2YgYGhvc3RgIG90aGVyd2lzZSBgcG9ydGAgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGhvc3RuYW1lOiBvcHRzLmhvc3QsIGhvc3Q6IG51bGwsIGhyZWY6IG51bGwsIFxuICAgICAgICAgICAgICAgIC8vIHNldCBgcG9ydGAgdG8gbnVsbCB3aGVuIGl0IGlzIHRoZSBwcm90b2NvbCBkZWZhdWx0IHBvcnQgKDgwIC8gNDQzKVxuICAgICAgICAgICAgICAgIHBvcnQ6IGRlZmF1bHRQb3J0ID09PSBvcHRzLnBvcnQgPyBudWxsIDogb3B0cy5wb3J0IH0pO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdXJsXzEuZm9ybWF0KHVybE9wdHMpO1xuICAgICAgICAgICAgZGVidWcoJ3VybDogJW8nLCB1cmwpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHlpZWxkIHJlc29sdmVyKHVybCk7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIFwiRElSRUNUXCIgaWYgYSBmYWxzZXkgdmFsdWUgd2FzIHJldHVybmVkIChvciBub3RoaW5nKVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnRElSRUNUJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3hpZXMgPSBTdHJpbmcocmVzdWx0KVxuICAgICAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgICAgICAuc3BsaXQoL1xccyo7XFxzKi9nKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmZhbGxiYWNrVG9EaXJlY3QgJiYgIXByb3hpZXMuaW5jbHVkZXMoJ0RJUkVDVCcpKSB7XG4gICAgICAgICAgICAgICAgcHJveGllcy5wdXNoKCdESVJFQ1QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJveHkgb2YgcHJveGllcykge1xuICAgICAgICAgICAgICAgIGxldCBhZ2VudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IHNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgW3R5cGUsIHRhcmdldF0gPSBwcm94eS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgIGRlYnVnKCdBdHRlbXB0aW5nIHRvIHVzZSBwcm94eTogJW8nLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdESVJFQ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERpcmVjdCBjb25uZWN0aW9uIHRvIHRoZSBkZXN0aW5hdGlvbiBlbmRwb2ludFxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQgPSBzZWN1cmVFbmRwb2ludCA/IHRsc18xLmRlZmF1bHQuY29ubmVjdChvcHRzKSA6IG5ldF8xLmRlZmF1bHQuY29ubmVjdChvcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ1NPQ0tTJyB8fCB0eXBlID09PSAnU09DS1M1Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBTT0NLU3Y1aCBwcm94eVxuICAgICAgICAgICAgICAgICAgICBhZ2VudCA9IG5ldyBzb2Nrc19wcm94eV9hZ2VudF8xLlNvY2tzUHJveHlBZ2VudChgc29ja3M6Ly8ke3RhcmdldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ1NPQ0tTNCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgU09DS1N2NGEgcHJveHlcbiAgICAgICAgICAgICAgICAgICAgYWdlbnQgPSBuZXcgc29ja3NfcHJveHlfYWdlbnRfMS5Tb2Nrc1Byb3h5QWdlbnQoYHNvY2tzNGE6Ly8ke3RhcmdldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ1BST1hZJyB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnSFRUUCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9PT0gJ0hUVFBTJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYW4gSFRUUCBvciBIVFRQUyBwcm94eVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vZGV2LmNocm9taXVtLm9yZy9kZXZlbG9wZXJzL2Rlc2lnbi1kb2N1bWVudHMvc2VjdXJlLXdlYi1wcm94eVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm94eVVSTCA9IGAke3R5cGUgPT09ICdIVFRQUycgPyAnaHR0cHMnIDogJ2h0dHAnfTovLyR7dGFyZ2V0fWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5T3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKSwgdXJsXzEucGFyc2UocHJveHlVUkwpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3VyZUVuZHBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VudCA9IG5ldyBodHRwc19wcm94eV9hZ2VudF8xLkh0dHBzUHJveHlBZ2VudChwcm94eU9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlbnQgPSBuZXcgaHR0cF9wcm94eV9hZ2VudF8xLkh0dHBQcm94eUFnZW50KHByb3h5T3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gXCJESVJFQ1RcIiBjb25uZWN0aW9uLCB3YWl0IGZvciBjb25uZWN0aW9uIGNvbmZpcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgb25jZV8xLmRlZmF1bHQoc29ja2V0LCAnY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmVtaXQoJ3Byb3h5JywgeyBwcm94eSwgc29ja2V0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWdlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSB5aWVsZCBhZ2VudC5jYWxsYmFjayhyZXEsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmVtaXQoJ3Byb3h5JywgeyBwcm94eSwgc29ja2V0OiBzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZGV0ZXJtaW5lIHByb3h5IHR5cGUgZm9yOiAke3Byb3h5fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKCdHb3QgZXJyb3IgZm9yIHByb3h5ICVvOiAlbycsIHByb3h5LCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXEuZW1pdCgncHJveHknLCB7IHByb3h5LCBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGVzdGFibGlzaCBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHByb3hpZXM6ICR7SlNPTi5zdHJpbmdpZnkocHJveGllcyl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBhY1Byb3h5QWdlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZ2VudC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIm5ldF8xIiwicmVxdWlyZSIsInRsc18xIiwib25jZV8xIiwiY3J5cHRvXzEiLCJnZXRfdXJpXzEiLCJkZWJ1Z18xIiwicmF3X2JvZHlfMSIsInVybF8xIiwiaHR0cF9wcm94eV9hZ2VudF8xIiwiaHR0cHNfcHJveHlfYWdlbnRfMSIsInNvY2tzX3Byb3h5X2FnZW50XzEiLCJwYWNfcmVzb2x2ZXJfMSIsImFnZW50X2Jhc2VfMSIsImRlYnVnIiwiZGVmYXVsdCIsIlBhY1Byb3h5QWdlbnQiLCJBZ2VudCIsImNvbnN0cnVjdG9yIiwidXJpIiwib3B0cyIsImNsZWFyUmVzb2x2ZXJQcm9taXNlIiwicmVzb2x2ZXJQcm9taXNlIiwidW5kZWZpbmVkIiwicmVwbGFjZSIsImFzc2lnbiIsImNhY2hlIiwicmVzb2x2ZXIiLCJyZXNvbHZlckhhc2giLCJmaWxlbmFtZSIsImdldFJlc29sdmVyIiwibG9hZFJlc29sdmVyIiwiY29kZSIsImxvYWRQYWNGaWxlIiwiaGFzaCIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJlcnIiLCJycyIsImJ1ZiIsImxlbmd0aCIsInRvU3RyaW5nIiwiY2FsbGJhY2siLCJyZXEiLCJzZWN1cmVFbmRwb2ludCIsImRlZmF1bHRQb3J0IiwicGF0aCIsInNlYXJjaCIsImZpcnN0UXVlc3Rpb24iLCJpbmRleE9mIiwic3Vic3RyaW5nIiwidXJsT3B0cyIsInByb3RvY29sIiwicGF0aG5hbWUiLCJob3N0bmFtZSIsImhvc3QiLCJocmVmIiwicG9ydCIsInVybCIsImZvcm1hdCIsInByb3hpZXMiLCJTdHJpbmciLCJ0cmltIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiZmFsbGJhY2tUb0RpcmVjdCIsImluY2x1ZGVzIiwicHVzaCIsInByb3h5IiwiYWdlbnQiLCJzb2NrZXQiLCJ0eXBlIiwidGFyZ2V0IiwiY29ubmVjdCIsIlNvY2tzUHJveHlBZ2VudCIsInByb3h5VVJMIiwicHJveHlPcHRzIiwicGFyc2UiLCJIdHRwc1Byb3h5QWdlbnQiLCJIdHRwUHJveHlBZ2VudCIsImVtaXQiLCJzIiwiRXJyb3IiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pac-proxy-agent/dist/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/pac-proxy-agent/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/pac-proxy-agent/dist/index.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nvar __importDefault = this && this.__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nconst get_uri_1 = __importDefault(__webpack_require__(/*! get-uri */ \"(rsc)/./node_modules/get-uri/dist/index.js\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst agent_1 = __importDefault(__webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/pac-proxy-agent/dist/agent.js\"));\nfunction createPacProxyAgent(uri, opts) {\n    // was an options object passed in first?\n    if (typeof uri === \"object\") {\n        opts = uri;\n        // result of a url.parse() call?\n        if (opts.href) {\n            if (opts.path && !opts.pathname) {\n                opts.pathname = opts.path;\n            }\n            opts.slashes = true;\n            uri = url_1.format(opts);\n        } else {\n            uri = opts.uri;\n        }\n    }\n    if (!opts) {\n        opts = {};\n    }\n    if (typeof uri !== \"string\") {\n        throw new TypeError(\"a PAC file URI must be specified!\");\n    }\n    return new agent_1.default(uri, opts);\n}\n(function(createPacProxyAgent) {\n    createPacProxyAgent.PacProxyAgent = agent_1.default;\n    /**\n     * Supported \"protocols\". Delegates out to the `get-uri` module.\n     */ createPacProxyAgent.protocols = Object.keys(get_uri_1.default.protocols);\n    createPacProxyAgent.prototype = agent_1.default.prototype;\n})(createPacProxyAgent || (createPacProxyAgent = {}));\nmodule.exports = createPacProxyAgent; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGFjLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0EsTUFBTUUsWUFBWUgsZ0JBQWdCSSxtQkFBT0EsQ0FBQywyREFBUztBQUNuRCxNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRSxVQUFVTixnQkFBZ0JJLG1CQUFPQSxDQUFDLG1FQUFTO0FBQ2pELFNBQVNHLG9CQUFvQkMsR0FBRyxFQUFFQyxJQUFJO0lBQ2xDLHlDQUF5QztJQUN6QyxJQUFJLE9BQU9ELFFBQVEsVUFBVTtRQUN6QkMsT0FBT0Q7UUFDUCxnQ0FBZ0M7UUFDaEMsSUFBSUMsS0FBS0MsSUFBSSxFQUFFO1lBQ1gsSUFBSUQsS0FBS0UsSUFBSSxJQUFJLENBQUNGLEtBQUtHLFFBQVEsRUFBRTtnQkFDN0JILEtBQUtHLFFBQVEsR0FBR0gsS0FBS0UsSUFBSTtZQUM3QjtZQUNBRixLQUFLSSxPQUFPLEdBQUc7WUFDZkwsTUFBTUgsTUFBTVMsTUFBTSxDQUFDTDtRQUN2QixPQUNLO1lBQ0RELE1BQU1DLEtBQUtELEdBQUc7UUFDbEI7SUFDSjtJQUNBLElBQUksQ0FBQ0MsTUFBTTtRQUNQQSxPQUFPLENBQUM7SUFDWjtJQUNBLElBQUksT0FBT0QsUUFBUSxVQUFVO1FBQ3pCLE1BQU0sSUFBSU8sVUFBVTtJQUN4QjtJQUNBLE9BQU8sSUFBSVQsUUFBUVUsT0FBTyxDQUFDUixLQUFLQztBQUNwQztBQUNDLFVBQVVGLG1CQUFtQjtJQUMxQkEsb0JBQW9CVSxhQUFhLEdBQUdYLFFBQVFVLE9BQU87SUFDbkQ7O0tBRUMsR0FDRFQsb0JBQW9CVyxTQUFTLEdBQUdDLE9BQU9DLElBQUksQ0FBQ2pCLFVBQVVhLE9BQU8sQ0FBQ0UsU0FBUztJQUN2RVgsb0JBQW9CYyxTQUFTLEdBQUdmLFFBQVFVLE9BQU8sQ0FBQ0ssU0FBUztBQUM3RCxHQUFHZCx1QkFBd0JBLENBQUFBLHNCQUFzQixDQUFDO0FBQ2xEZSxPQUFPQyxPQUFPLEdBQUdoQixxQkFDakIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvcGFjLXByb3h5LWFnZW50L2Rpc3QvaW5kZXguanM/ZjJmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmNvbnN0IGdldF91cmlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZ2V0LXVyaVwiKSk7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBhZ2VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FnZW50XCIpKTtcbmZ1bmN0aW9uIGNyZWF0ZVBhY1Byb3h5QWdlbnQodXJpLCBvcHRzKSB7XG4gICAgLy8gd2FzIGFuIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCBpbiBmaXJzdD9cbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgLy8gcmVzdWx0IG9mIGEgdXJsLnBhcnNlKCkgY2FsbD9cbiAgICAgICAgaWYgKG9wdHMuaHJlZikge1xuICAgICAgICAgICAgaWYgKG9wdHMucGF0aCAmJiAhb3B0cy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIG9wdHMucGF0aG5hbWUgPSBvcHRzLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRzLnNsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgdXJpID0gdXJsXzEuZm9ybWF0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJpID0gb3B0cy51cmk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUEFDIGZpbGUgVVJJIG11c3QgYmUgc3BlY2lmaWVkIScpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGFnZW50XzEuZGVmYXVsdCh1cmksIG9wdHMpO1xufVxuKGZ1bmN0aW9uIChjcmVhdGVQYWNQcm94eUFnZW50KSB7XG4gICAgY3JlYXRlUGFjUHJveHlBZ2VudC5QYWNQcm94eUFnZW50ID0gYWdlbnRfMS5kZWZhdWx0O1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRlZCBcInByb3RvY29sc1wiLiBEZWxlZ2F0ZXMgb3V0IHRvIHRoZSBgZ2V0LXVyaWAgbW9kdWxlLlxuICAgICAqL1xuICAgIGNyZWF0ZVBhY1Byb3h5QWdlbnQucHJvdG9jb2xzID0gT2JqZWN0LmtleXMoZ2V0X3VyaV8xLmRlZmF1bHQucHJvdG9jb2xzKTtcbiAgICBjcmVhdGVQYWNQcm94eUFnZW50LnByb3RvdHlwZSA9IGFnZW50XzEuZGVmYXVsdC5wcm90b3R5cGU7XG59KShjcmVhdGVQYWNQcm94eUFnZW50IHx8IChjcmVhdGVQYWNQcm94eUFnZW50ID0ge30pKTtcbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUGFjUHJveHlBZ2VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiZ2V0X3VyaV8xIiwicmVxdWlyZSIsInVybF8xIiwiYWdlbnRfMSIsImNyZWF0ZVBhY1Byb3h5QWdlbnQiLCJ1cmkiLCJvcHRzIiwiaHJlZiIsInBhdGgiLCJwYXRobmFtZSIsInNsYXNoZXMiLCJmb3JtYXQiLCJUeXBlRXJyb3IiLCJkZWZhdWx0IiwiUGFjUHJveHlBZ2VudCIsInByb3RvY29scyIsIk9iamVjdCIsImtleXMiLCJwcm90b3R5cGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pac-proxy-agent/dist/index.js\n");

/***/ })

};
;