"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/merge-options";
exports.ids = ["vendor-chunks/merge-options"];
exports.modules = {

/***/ "(rsc)/./node_modules/merge-options/index.js":
/*!*********************************************!*\
  !*** ./node_modules/merge-options/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\nconst isOptionObject = __webpack_require__(/*! is-plain-obj */ \"(rsc)/./node_modules/is-plain-obj/index.js\");\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst propIsEnumerable = Object.propertyIsEnumerable;\nconst defineProperty = (obj, name, value)=>Object.defineProperty(obj, name, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n    });\nconst globalThis = this;\nconst defaultMergeOpts = {\n    concatArrays: false\n};\nconst getEnumerableOwnPropertyKeys = (value)=>{\n    const keys = [];\n    for(const key in value){\n        if (hasOwnProperty.call(value, key)) {\n            keys.push(key);\n        }\n    }\n    /* istanbul ignore else  */ if (Object.getOwnPropertySymbols) {\n        const symbols = Object.getOwnPropertySymbols(value);\n        for(let i = 0; i < symbols.length; i++){\n            if (propIsEnumerable.call(value, symbols[i])) {\n                keys.push(symbols[i]);\n            }\n        }\n    }\n    return keys;\n};\nfunction clone(value) {\n    if (Array.isArray(value)) {\n        return cloneArray(value);\n    }\n    if (isOptionObject(value)) {\n        return cloneOptionObject(value);\n    }\n    return value;\n}\nfunction cloneArray(array) {\n    const result = array.slice(0, 0);\n    getEnumerableOwnPropertyKeys(array).forEach((key)=>{\n        defineProperty(result, key, clone(array[key]));\n    });\n    return result;\n}\nfunction cloneOptionObject(obj) {\n    const result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};\n    getEnumerableOwnPropertyKeys(obj).forEach((key)=>{\n        defineProperty(result, key, clone(obj[key]));\n    });\n    return result;\n}\n/**\n * @param merged {already cloned}\n * @return {cloned Object}\n */ const mergeKeys = (merged, source, keys, mergeOpts)=>{\n    keys.forEach((key)=>{\n        // Do not recurse into prototype chain of merged\n        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {\n            defineProperty(merged, key, merge(merged[key], source[key], mergeOpts));\n        } else {\n            defineProperty(merged, key, clone(source[key]));\n        }\n    });\n    return merged;\n};\n/**\n * @param merged {already cloned}\n * @return {cloned Object}\n *\n * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)\n */ const concatArrays = (merged, source, mergeOpts)=>{\n    let result = merged.slice(0, 0);\n    let resultIndex = 0;\n    [\n        merged,\n        source\n    ].forEach((array)=>{\n        const indices = [];\n        // `result.concat(array)` with cloning\n        for(let k = 0; k < array.length; k++){\n            if (!hasOwnProperty.call(array, k)) {\n                continue;\n            }\n            indices.push(String(k));\n            if (array === merged) {\n                // Already cloned\n                defineProperty(result, resultIndex++, array[k]);\n            } else {\n                defineProperty(result, resultIndex++, clone(array[k]));\n            }\n        }\n        // Merge non-index keys\n        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key)=>{\n            return indices.indexOf(key) === -1;\n        }), mergeOpts);\n    });\n    return result;\n};\n/**\n * @param merged {already cloned}\n * @return {cloned Object}\n */ function merge(merged, source, mergeOpts) {\n    if (mergeOpts.concatArrays && Array.isArray(merged) && Array.isArray(source)) {\n        return concatArrays(merged, source, mergeOpts);\n    }\n    if (!isOptionObject(source) || !isOptionObject(merged)) {\n        return clone(source);\n    }\n    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), mergeOpts);\n}\nmodule.exports = function() {\n    const mergeOpts = merge(clone(defaultMergeOpts), this !== globalThis && this || {}, defaultMergeOpts);\n    let merged = {\n        foobar: {}\n    };\n    for(let i = 0; i < arguments.length; i++){\n        const option = arguments[i];\n        if (option === undefined) {\n            continue;\n        }\n        if (!isOptionObject(option)) {\n            throw new TypeError(\"`\" + option + \"` is not an Option Object\");\n        }\n        merged = merge(merged, {\n            foobar: option\n        }, mergeOpts);\n    }\n    return merged.foobar;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWVyZ2Utb3B0aW9ucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGlCQUFpQkMsbUJBQU9BLENBQUM7QUFFL0IsTUFBTUMsaUJBQWlCQyxPQUFPQyxTQUFTLENBQUNGLGNBQWM7QUFDdEQsTUFBTUcsbUJBQW1CRixPQUFPRyxvQkFBb0I7QUFDcEQsTUFBTUMsaUJBQWlCLENBQUNDLEtBQUtDLE1BQU1DLFFBQVVQLE9BQU9JLGNBQWMsQ0FBQ0MsS0FBS0MsTUFBTTtRQUM3RUM7UUFDQUMsVUFBVTtRQUNWQyxZQUFZO1FBQ1pDLGNBQWM7SUFDZjtBQUVBLE1BQU1DLGFBQWEsSUFBSTtBQUN2QixNQUFNQyxtQkFBbUI7SUFDeEJDLGNBQWM7QUFDZjtBQUVBLE1BQU1DLCtCQUErQlAsQ0FBQUE7SUFDcEMsTUFBTVEsT0FBTyxFQUFFO0lBRWYsSUFBSyxNQUFNQyxPQUFPVCxNQUFPO1FBQ3hCLElBQUlSLGVBQWVrQixJQUFJLENBQUNWLE9BQU9TLE1BQU07WUFDcENELEtBQUtHLElBQUksQ0FBQ0Y7UUFDWDtJQUNEO0lBRUEseUJBQXlCLEdBQ3pCLElBQUloQixPQUFPbUIscUJBQXFCLEVBQUU7UUFDakMsTUFBTUMsVUFBVXBCLE9BQU9tQixxQkFBcUIsQ0FBQ1o7UUFFN0MsSUFBSyxJQUFJYyxJQUFJLEdBQUdBLElBQUlELFFBQVFFLE1BQU0sRUFBRUQsSUFBSztZQUN4QyxJQUFJbkIsaUJBQWlCZSxJQUFJLENBQUNWLE9BQU9hLE9BQU8sQ0FBQ0MsRUFBRSxHQUFHO2dCQUM3Q04sS0FBS0csSUFBSSxDQUFDRSxPQUFPLENBQUNDLEVBQUU7WUFDckI7UUFDRDtJQUNEO0lBRUEsT0FBT047QUFDUjtBQUVBLFNBQVNRLE1BQU1oQixLQUFLO0lBQ25CLElBQUlpQixNQUFNQyxPQUFPLENBQUNsQixRQUFRO1FBQ3pCLE9BQU9tQixXQUFXbkI7SUFDbkI7SUFFQSxJQUFJVixlQUFlVSxRQUFRO1FBQzFCLE9BQU9v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O1FBQUNZLFFBQVEsQ0FBQztJQUFDO0lBRXhCLElBQUssSUFBSTFCLElBQUksR0FBR0EsSUFBSTJCLFVBQVUxQixNQUFNLEVBQUVELElBQUs7UUFDMUMsTUFBTTRCLFNBQVNELFNBQVMsQ0FBQzNCLEVBQUU7UUFFM0IsSUFBSTRCLFdBQVdDLFdBQVc7WUFDekI7UUFDRDtRQUVBLElBQUksQ0FBQ3JELGVBQWVvRCxTQUFTO1lBQzVCLE1BQU0sSUFBSUUsVUFBVSxNQUFNRixTQUFTO1FBQ3BDO1FBRUFkLFNBQVNHLE1BQU1ILFFBQVE7WUFBQ1ksUUFBUUU7UUFBTSxHQUFHWjtJQUMxQztJQUVBLE9BQU9GLE9BQU9ZLE1BQU07QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9tZXJnZS1vcHRpb25zL2luZGV4LmpzP2EyNDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgaXNPcHRpb25PYmplY3QgPSByZXF1aXJlKCdpcy1wbGFpbi1vYmonKTtcblxuY29uc3QgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuY29uc3QgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbmNvbnN0IGRlZmluZVByb3BlcnR5ID0gKG9iaiwgbmFtZSwgdmFsdWUpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcblx0dmFsdWUsXG5cdHdyaXRhYmxlOiB0cnVlLFxuXHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBnbG9iYWxUaGlzID0gdGhpcztcbmNvbnN0IGRlZmF1bHRNZXJnZU9wdHMgPSB7XG5cdGNvbmNhdEFycmF5czogZmFsc2Vcbn07XG5cbmNvbnN0IGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMgPSB2YWx1ZSA9PiB7XG5cdGNvbnN0IGtleXMgPSBbXTtcblxuXHRmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdGtleXMucHVzaChzeW1ib2xzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ga2V5cztcbn07XG5cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG5cdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdHJldHVybiBjbG9uZUFycmF5KHZhbHVlKTtcblx0fVxuXG5cdGlmIChpc09wdGlvbk9iamVjdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gY2xvbmVPcHRpb25PYmplY3QodmFsdWUpO1xuXHR9XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5KGFycmF5KSB7XG5cdGNvbnN0IHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIDApO1xuXG5cdGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUoYXJyYXlba2V5XSkpO1xuXHR9KTtcblxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjbG9uZU9wdGlvbk9iamVjdChvYmopIHtcblx0Y29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDoge307XG5cblx0Z2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcblx0XHRkZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgY2xvbmUob2JqW2tleV0pKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbWVyZ2VkIHthbHJlYWR5IGNsb25lZH1cbiAqIEByZXR1cm4ge2Nsb25lZCBPYmplY3R9XG4gKi9cbmNvbnN0IG1lcmdlS2V5cyA9IChtZXJnZWQsIHNvdXJjZSwga2V5cywgbWVyZ2VPcHRzKSA9PiB7XG5cdGtleXMuZm9yRWFjaChrZXkgPT4ge1xuXHRcdC8vIERvIG5vdCByZWN1cnNlIGludG8gcHJvdG90eXBlIGNoYWluIG9mIG1lcmdlZFxuXHRcdGlmIChrZXkgaW4gbWVyZ2VkICYmIG1lcmdlZFtrZXldICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobWVyZ2VkKSkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkobWVyZ2VkLCBrZXksIG1lcmdlKG1lcmdlZFtrZXldLCBzb3VyY2Vba2V5XSwgbWVyZ2VPcHRzKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZVByb3BlcnR5KG1lcmdlZCwga2V5LCBjbG9uZShzb3VyY2Vba2V5XSkpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIG1lcmdlZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIG1lcmdlZCB7YWxyZWFkeSBjbG9uZWR9XG4gKiBAcmV0dXJuIHtjbG9uZWQgT2JqZWN0fVxuICpcbiAqIHNlZSBbQXJyYXkucHJvdG90eXBlLmNvbmNhdCAoIC4uLmFyZ3VtZW50cyApXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdClcbiAqL1xuY29uc3QgY29uY2F0QXJyYXlzID0gKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpID0+IHtcblx0bGV0IHJlc3VsdCA9IG1lcmdlZC5zbGljZSgwLCAwKTtcblx0bGV0IHJlc3VsdEluZGV4ID0gMDtcblxuXHRbbWVyZ2VkLCBzb3VyY2VdLmZvckVhY2goYXJyYXkgPT4ge1xuXHRcdGNvbnN0IGluZGljZXMgPSBbXTtcblxuXHRcdC8vIGByZXN1bHQuY29uY2F0KGFycmF5KWAgd2l0aCBjbG9uaW5nXG5cdFx0Zm9yIChsZXQgayA9IDA7IGsgPCBhcnJheS5sZW5ndGg7IGsrKykge1xuXHRcdFx0aWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBrKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0aW5kaWNlcy5wdXNoKFN0cmluZyhrKSk7XG5cblx0XHRcdGlmIChhcnJheSA9PT0gbWVyZ2VkKSB7XG5cdFx0XHRcdC8vIEFscmVhZHkgY2xvbmVkXG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KHJlc3VsdCwgcmVzdWx0SW5kZXgrKywgYXJyYXlba10pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkocmVzdWx0LCByZXN1bHRJbmRleCsrLCBjbG9uZShhcnJheVtrXSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE1lcmdlIG5vbi1pbmRleCBrZXlzXG5cdFx0cmVzdWx0ID0gbWVyZ2VLZXlzKHJlc3VsdCwgYXJyYXksIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eUtleXMoYXJyYXkpLmZpbHRlcihrZXkgPT4ge1xuXHRcdFx0cmV0dXJuIGluZGljZXMuaW5kZXhPZihrZXkpID09PSAtMTtcblx0XHR9KSwgbWVyZ2VPcHRzKTtcblx0fSk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIG1lcmdlZCB7YWxyZWFkeSBjbG9uZWR9XG4gKiBAcmV0dXJuIHtjbG9uZWQgT2JqZWN0fVxuICovXG5mdW5jdGlvbiBtZXJnZShtZXJnZWQsIHNvdXJjZSwgbWVyZ2VPcHRzKSB7XG5cdGlmIChtZXJnZU9wdHMuY29uY2F0QXJyYXlzICYmIEFycmF5LmlzQXJyYXkobWVyZ2VkKSAmJiBBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcblx0XHRyZXR1cm4gY29uY2F0QXJyYXlzKG1lcmdlZCwgc291cmNlLCBtZXJnZU9wdHMpO1xuXHR9XG5cblx0aWYgKCFpc09wdGlvbk9iamVjdChzb3VyY2UpIHx8ICFpc09wdGlvbk9iamVjdChtZXJnZWQpKSB7XG5cdFx0cmV0dXJuIGNsb25lKHNvdXJjZSk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VLZXlzKG1lcmdlZCwgc291cmNlLCBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlLZXlzKHNvdXJjZSksIG1lcmdlT3B0cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBtZXJnZU9wdHMgPSBtZXJnZShjbG9uZShkZWZhdWx0TWVyZ2VPcHRzKSwgKHRoaXMgIT09IGdsb2JhbFRoaXMgJiYgdGhpcykgfHwge30sIGRlZmF1bHRNZXJnZU9wdHMpO1xuXHRsZXQgbWVyZ2VkID0ge2Zvb2Jhcjoge319O1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qgb3B0aW9uID0gYXJndW1lbnRzW2ldO1xuXG5cdFx0aWYgKG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIWlzT3B0aW9uT2JqZWN0KG9wdGlvbikpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2AnICsgb3B0aW9uICsgJ2AgaXMgbm90IGFuIE9wdGlvbiBPYmplY3QnKTtcblx0XHR9XG5cblx0XHRtZXJnZWQgPSBtZXJnZShtZXJnZWQsIHtmb29iYXI6IG9wdGlvbn0sIG1lcmdlT3B0cyk7XG5cdH1cblxuXHRyZXR1cm4gbWVyZ2VkLmZvb2Jhcjtcbn07XG4iXSwibmFtZXMiOlsiaXNPcHRpb25PYmplY3QiLCJyZXF1aXJlIiwiaGFzT3duUHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsIm5hbWUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImdsb2JhbFRoaXMiLCJkZWZhdWx0TWVyZ2VPcHRzIiwiY29uY2F0QXJyYXlzIiwiZ2V0RW51bWVyYWJsZU93blByb3BlcnR5S2V5cyIsImtleXMiLCJrZXkiLCJjYWxsIiwicHVzaCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJpIiwibGVuZ3RoIiwiY2xvbmUiLCJBcnJheSIsImlzQXJyYXkiLCJjbG9uZUFycmF5IiwiY2xvbmVPcHRpb25PYmplY3QiLCJhcnJheSIsInJlc3VsdCIsInNsaWNlIiwiZm9yRWFjaCIsImdldFByb3RvdHlwZU9mIiwiY3JlYXRlIiwibWVyZ2VLZXlzIiwibWVyZ2VkIiwic291cmNlIiwibWVyZ2VPcHRzIiwibWVyZ2UiLCJyZXN1bHRJbmRleCIsImluZGljZXMiLCJrIiwiU3RyaW5nIiwiZmlsdGVyIiwiaW5kZXhPZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJmb29iYXIiLCJhcmd1bWVudHMiLCJvcHRpb24iLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/merge-options/index.js\n");

/***/ })

};
;