/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/escodegen";
exports.ids = ["vendor-chunks/escodegen"];
exports.modules = {

/***/ "(rsc)/./node_modules/escodegen/escodegen.js":
/*!*********************************************!*\
  !*** ./node_modules/escodegen/escodegen.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>\n  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>\n  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>\n  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>\n  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>\n  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>\n  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/ /*global exports:true, require:true, global:true*/ (function() {\n    \"use strict\";\n    var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;\n    estraverse = __webpack_require__(/*! estraverse */ \"(rsc)/./node_modules/escodegen/node_modules/estraverse/estraverse.js\");\n    esutils = __webpack_require__(/*! esutils */ \"(rsc)/./node_modules/esutils/lib/utils.js\");\n    Syntax = estraverse.Syntax;\n    // Generation is done by generateExpression.\n    function isExpression(node) {\n        return CodeGenerator.Expression.hasOwnProperty(node.type);\n    }\n    // Generation is done by generateStatement.\n    function isStatement(node) {\n        return CodeGenerator.Statement.hasOwnProperty(node.type);\n    }\n    Precedence = {\n        Sequence: 0,\n        Yield: 1,\n        Assignment: 1,\n        Conditional: 2,\n        ArrowFunction: 2,\n        LogicalOR: 3,\n        LogicalAND: 4,\n        BitwiseOR: 5,\n        BitwiseXOR: 6,\n        BitwiseAND: 7,\n        Equality: 8,\n        Relational: 9,\n        BitwiseSHIFT: 10,\n        Additive: 11,\n        Multiplicative: 12,\n        Exponentiation: 13,\n        Await: 14,\n        Unary: 14,\n        Postfix: 15,\n        Call: 16,\n        New: 17,\n        TaggedTemplate: 18,\n        Member: 19,\n        Primary: 20\n    };\n    BinaryPrecedence = {\n        \"||\": Precedence.LogicalOR,\n        \"&&\": Precedence.LogicalAND,\n        \"|\": Precedence.BitwiseOR,\n        \"^\": Precedence.BitwiseXOR,\n        \"&\": Precedence.BitwiseAND,\n        \"==\": Precedence.Equality,\n        \"!=\": Precedence.Equality,\n        \"===\": Precedence.Equality,\n        \"!==\": Precedence.Equality,\n        \"is\": Precedence.Equality,\n        \"isnt\": Precedence.Equality,\n        \"<\": Precedence.Relational,\n        \">\": Precedence.Relational,\n        \"<=\": Precedence.Relational,\n        \">=\": Precedence.Relational,\n        \"in\": Precedence.Relational,\n        \"instanceof\": Precedence.Relational,\n        \"<<\": Precedence.BitwiseSHIFT,\n        \">>\": Precedence.BitwiseSHIFT,\n        \">>>\": Precedence.BitwiseSHIFT,\n        \"+\": Precedence.Additive,\n        \"-\": Precedence.Additive,\n        \"*\": Precedence.Multiplicative,\n        \"%\": Precedence.Multiplicative,\n        \"/\": Precedence.Multiplicative,\n        \"**\": Precedence.Exponentiation\n    };\n    //Flags\n    var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5;\n    //Expression flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_ALLOW_CALL\n    // F_ALLOW_UNPARATH_NEW\n    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;\n    //Statement flag sets\n    //NOTE: Flag order:\n    // F_ALLOW_IN\n    // F_FUNC_BODY\n    // F_DIRECTIVE_CTX\n    // F_SEMICOLON_OPT\n    var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0x00, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;\n    function getDefaultOptions() {\n        // default options\n        return {\n            indent: null,\n            base: null,\n            parse: null,\n            comment: false,\n            format: {\n                indent: {\n                    style: \"    \",\n                    base: 0,\n                    adjustMultilineComment: false\n                },\n                newline: \"\\n\",\n                space: \" \",\n                json: false,\n                renumber: false,\n                hexadecimal: false,\n                quotes: \"single\",\n                escapeless: false,\n                compact: false,\n                parentheses: true,\n                semicolons: true,\n                safeConcatenation: false,\n                preserveBlankLines: false\n            },\n            moz: {\n                comprehensionExpressionStartsWithAssignment: false,\n                starlessGenerator: false\n            },\n            sourceMap: null,\n            sourceMapRoot: null,\n            sourceMapWithCode: false,\n            directive: false,\n            raw: true,\n            verbatim: null,\n            sourceCode: null\n        };\n    }\n    function stringRepeat(str, num) {\n        var result = \"\";\n        for(num |= 0; num > 0; num >>>= 1, str += str){\n            if (num & 1) {\n                result += str;\n            }\n        }\n        return result;\n    }\n    function hasLineTerminator(str) {\n        return /[\\r\\n]/g.test(str);\n    }\n    function endsWithLineTerminator(str) {\n        var len = str.length;\n        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));\n    }\n    function merge(target, override) {\n        var key;\n        for(key in override){\n            if (override.hasOwnProperty(key)) {\n                target[key] = override[key];\n            }\n        }\n        return target;\n    }\n    function updateDeeply(target, override) {\n        var key, val;\n        function isHashObject(target) {\n            return typeof target === \"object\" && target instanceof Object && !(target instanceof RegExp);\n        }\n        for(key in override){\n            if (override.hasOwnProperty(key)) {\n                val = override[key];\n                if (isHashObject(val)) {\n                    if (isHashObject(target[key])) {\n                        updateDeeply(target[key], val);\n                    } else {\n                        target[key] = updateDeeply({}, val);\n                    }\n                } else {\n                    target[key] = val;\n                }\n            }\n        }\n        return target;\n    }\n    function generateNumber(value) {\n        var result, point, temp, exponent, pos;\n        if (value !== value) {\n            throw new Error(\"Numeric literal whose value is NaN\");\n        }\n        if (value < 0 || value === 0 && 1 / value < 0) {\n            throw new Error(\"Numeric literal whose value is negative\");\n        }\n        if (value === 1 / 0) {\n            return json ? \"null\" : renumber ? \"1e400\" : \"1e+400\";\n        }\n        result = \"\" + value;\n        if (!renumber || result.length < 3) {\n            return result;\n        }\n        point = result.indexOf(\".\");\n        if (!json && result.charCodeAt(0) === 0x30 /* 0 */  && point === 1) {\n            point = 0;\n            result = result.slice(1);\n        }\n        temp = result;\n        result = result.replace(\"e+\", \"e\");\n        exponent = 0;\n        if ((pos = temp.indexOf(\"e\")) > 0) {\n            exponent = +temp.slice(pos + 1);\n            temp = temp.slice(0, pos);\n        }\n        if (point >= 0) {\n            exponent -= temp.length - point - 1;\n            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + \"\";\n        }\n        pos = 0;\n        while(temp.charCodeAt(temp.length + pos - 1) === 0x30 /* 0 */ ){\n            --pos;\n        }\n        if (pos !== 0) {\n            exponent -= pos;\n            temp = temp.slice(0, pos);\n        }\n        if (exponent !== 0) {\n            temp += \"e\" + exponent;\n        }\n        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = \"0x\" + value.toString(16)).length < result.length) && +temp === value) {\n            result = temp;\n        }\n        return result;\n    }\n    // Generate valid RegExp expression.\n    // This function is based on https://github.com/Constellation/iv Engine\n    function escapeRegExpCharacter(ch, previousIsBackslash) {\n        // not handling '\\' and handling \\u2028 or \\u2029 to unicode escape sequence\n        if ((ch & ~1) === 0x2028) {\n            return (previousIsBackslash ? \"u\" : \"\\\\u\") + (ch === 0x2028 ? \"2028\" : \"2029\");\n        } else if (ch === 10 || ch === 13) {\n            return (previousIsBackslash ? \"\" : \"\\\\\") + (ch === 10 ? \"n\" : \"r\");\n        }\n        return String.fromCharCode(ch);\n    }\n    function generateRegExp(reg) {\n        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;\n        result = reg.toString();\n        if (reg.source) {\n            // extract flag from toString result\n            match = result.match(/\\/([^/]*)$/);\n            if (!match) {\n                return result;\n            }\n            flags = match[1];\n            result = \"\";\n            characterInBrack = false;\n            previousIsBackslash = false;\n            for(i = 0, iz = reg.source.length; i < iz; ++i){\n                ch = reg.source.charCodeAt(i);\n                if (!previousIsBackslash) {\n                    if (characterInBrack) {\n                        if (ch === 93) {\n                            characterInBrack = false;\n                        }\n                    } else {\n                        if (ch === 47) {\n                            result += \"\\\\\";\n                        } else if (ch === 91) {\n                            characterInBrack = true;\n                        }\n                    }\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    previousIsBackslash = ch === 92; // \\\n                } else {\n                    // if new RegExp(\"\\\\\\n') is provided, create /\\n/\n                    result += escapeRegExpCharacter(ch, previousIsBackslash);\n                    // prevent like /\\\\[/]/\n                    previousIsBackslash = false;\n                }\n            }\n            return \"/\" + result + \"/\" + flags;\n        }\n        return result;\n    }\n    function escapeAllowedCharacter(code, next) {\n        var hex;\n        if (code === 0x08 /* \\b */ ) {\n            return \"\\\\b\";\n        }\n        if (code === 0x0C /* \\f */ ) {\n            return \"\\\\f\";\n        }\n        if (code === 0x09 /* \\t */ ) {\n            return \"\\\\t\";\n        }\n        hex = code.toString(16).toUpperCase();\n        if (json || code > 0xFF) {\n            return \"\\\\u\" + \"0000\".slice(hex.length) + hex;\n        } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {\n            return \"\\\\0\";\n        } else if (code === 0x000B /* \\v */ ) {\n            return \"\\\\x0B\";\n        } else {\n            return \"\\\\x\" + \"00\".slice(hex.length) + hex;\n        }\n    }\n    function escapeDisallowedCharacter(code) {\n        if (code === 0x5C /* \\ */ ) {\n            return \"\\\\\\\\\";\n        }\n        if (code === 0x0A /* \\n */ ) {\n            return \"\\\\n\";\n        }\n        if (code === 0x0D /* \\r */ ) {\n            return \"\\\\r\";\n        }\n        if (code === 0x2028) {\n            return \"\\\\u2028\";\n        }\n        if (code === 0x2029) {\n            return \"\\\\u2029\";\n        }\n        throw new Error(\"Incorrectly classified character\");\n    }\n    function escapeDirective(str) {\n        var i, iz, code, quote;\n        quote = quotes === \"double\" ? '\"' : \"'\";\n        for(i = 0, iz = str.length; i < iz; ++i){\n            code = str.charCodeAt(i);\n            if (code === 0x27 /* ' */ ) {\n                quote = '\"';\n                break;\n            } else if (code === 0x22 /* \" */ ) {\n                quote = \"'\";\n                break;\n            } else if (code === 0x5C /* \\ */ ) {\n                ++i;\n            }\n        }\n        return quote + str + quote;\n    }\n    function escapeString(str) {\n        var result = \"\", i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;\n        for(i = 0, len = str.length; i < len; ++i){\n            code = str.charCodeAt(i);\n            if (code === 0x27 /* ' */ ) {\n                ++singleQuotes;\n            } else if (code === 0x22 /* \" */ ) {\n                ++doubleQuotes;\n            } else if (code === 0x2F /* / */  && json) {\n                result += \"\\\\\";\n            } else if (esutils.code.isLineTerminator(code) || code === 0x5C /* \\ */ ) {\n                result += escapeDisallowedCharacter(code);\n                continue;\n            } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20 /* SP */  || !json && !escapeless && (code < 0x20 /* SP */  || code > 0x7E /* ~ */ ))) {\n                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));\n                continue;\n            }\n            result += String.fromCharCode(code);\n        }\n        single = !(quotes === \"double\" || quotes === \"auto\" && doubleQuotes < singleQuotes);\n        quote = single ? \"'\" : '\"';\n        if (!(single ? singleQuotes : doubleQuotes)) {\n            return quote + result + quote;\n        }\n        str = result;\n        result = quote;\n        for(i = 0, len = str.length; i < len; ++i){\n            code = str.charCodeAt(i);\n            if (code === 0x27 /* ' */  && single || code === 0x22 /* \" */  && !single) {\n                result += \"\\\\\";\n            }\n            result += String.fromCharCode(code);\n        }\n        return result + quote;\n    }\n    /**\n     * flatten an array to a string, where the array can contain\n     * either strings or nested arrays\n     */ function flattenToString(arr) {\n        var i, iz, elem, result = \"\";\n        for(i = 0, iz = arr.length; i < iz; ++i){\n            elem = arr[i];\n            result += Array.isArray(elem) ? flattenToString(elem) : elem;\n        }\n        return result;\n    }\n    /**\n     * convert generated to a SourceNode when source maps are enabled.\n     */ function toSourceNodeWhenNeeded(generated, node) {\n        if (!sourceMap) {\n            // with no source maps, generated is either an\n            // array or a string.  if an array, flatten it.\n            // if a string, just return it\n            if (Array.isArray(generated)) {\n                return flattenToString(generated);\n            } else {\n                return generated;\n            }\n        }\n        if (node == null) {\n            if (generated instanceof SourceNode) {\n                return generated;\n            } else {\n                node = {};\n            }\n        }\n        if (node.loc == null) {\n            return new SourceNode(null, null, sourceMap, generated, node.name || null);\n        }\n        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);\n    }\n    function noEmptySpace() {\n        return space ? space : \" \";\n    }\n    function join(left, right) {\n        var leftSource, rightSource, leftCharCode, rightCharCode;\n        leftSource = toSourceNodeWhenNeeded(left).toString();\n        if (leftSource.length === 0) {\n            return [\n                right\n            ];\n        }\n        rightSource = toSourceNodeWhenNeeded(right).toString();\n        if (rightSource.length === 0) {\n            return [\n                left\n            ];\n        }\n        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n        rightCharCode = rightSource.charCodeAt(0);\n        if ((leftCharCode === 0x2B /* + */  || leftCharCode === 0x2D /* - */ ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F /* / */  && rightCharCode === 0x69 /* i */ ) {\n            return [\n                left,\n                noEmptySpace(),\n                right\n            ];\n        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {\n            return [\n                left,\n                right\n            ];\n        }\n        return [\n            left,\n            space,\n            right\n        ];\n    }\n    function addIndent(stmt) {\n        return [\n            base,\n            stmt\n        ];\n    }\n    function withIndent(fn) {\n        var previousBase;\n        previousBase = base;\n        base += indent;\n        fn(base);\n        base = previousBase;\n    }\n    function calculateSpaces(str) {\n        var i;\n        for(i = str.length - 1; i >= 0; --i){\n            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {\n                break;\n            }\n        }\n        return str.length - 1 - i;\n    }\n    function adjustMultilineComment(value, specialBase) {\n        var array, i, len, line, j, spaces, previousBase, sn;\n        array = value.split(/\\r\\n|[\\r\\n]/);\n        spaces = Number.MAX_VALUE;\n        // first line doesn't have indentation\n        for(i = 1, len = array.length; i < len; ++i){\n            line = array[i];\n            j = 0;\n            while(j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))){\n                ++j;\n            }\n            if (spaces > j) {\n                spaces = j;\n            }\n        }\n        if (typeof specialBase !== \"undefined\") {\n            // pattern like\n            // {\n            //   var t = 20;  /*\n            //                 * this is comment\n            //                 */\n            // }\n            previousBase = base;\n            if (array[1][spaces] === \"*\") {\n                specialBase += \" \";\n            }\n            base = specialBase;\n        } else {\n            if (spaces & 1) {\n                // /*\n                //  *\n                //  */\n                // If spaces are odd number, above pattern is considered.\n                // We waste 1 space.\n                --spaces;\n            }\n            previousBase = base;\n        }\n        for(i = 1, len = array.length; i < len; ++i){\n            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));\n            array[i] = sourceMap ? sn.join(\"\") : sn;\n        }\n        base = previousBase;\n        return array.join(\"\\n\");\n    }\n    function generateComment(comment, specialBase) {\n        if (comment.type === \"Line\") {\n            if (endsWithLineTerminator(comment.value)) {\n                return \"//\" + comment.value;\n            } else {\n                // Always use LineTerminator\n                var result = \"//\" + comment.value;\n                if (!preserveBlankLines) {\n                    result += \"\\n\";\n                }\n                return result;\n            }\n        }\n        if (extra.format.indent.adjustMultilineComment && /[\\n\\r]/.test(comment.value)) {\n            return adjustMultilineComment(\"/*\" + comment.value + \"*/\", specialBase);\n        }\n        return \"/*\" + comment.value + \"*/\";\n    }\n    function addComments(stmt, result) {\n        var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;\n        if (stmt.leadingComments && stmt.leadingComments.length > 0) {\n            save = result;\n            if (preserveBlankLines) {\n                comment = stmt.leadingComments[0];\n                result = [];\n                extRange = comment.extendedRange;\n                range = comment.range;\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat(\"\\n\", count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n                prevRange = range;\n                for(i = 1, len = stmt.leadingComments.length; i < len; i++){\n                    comment = stmt.leadingComments[i];\n                    range = comment.range;\n                    infix = sourceCode.substring(prevRange[1], range[0]);\n                    count = (infix.match(/\\n/g) || []).length;\n                    result.push(stringRepeat(\"\\n\", count));\n                    result.push(addIndent(generateComment(comment)));\n                    prevRange = range;\n                }\n                suffix = sourceCode.substring(range[1], extRange[1]);\n                count = (suffix.match(/\\n/g) || []).length;\n                result.push(stringRepeat(\"\\n\", count));\n            } else {\n                comment = stmt.leadingComments[0];\n                result = [];\n                if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {\n                    result.push(\"\\n\");\n                }\n                result.push(generateComment(comment));\n                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(\"\\n\");\n                }\n                for(i = 1, len = stmt.leadingComments.length; i < len; ++i){\n                    comment = stmt.leadingComments[i];\n                    fragment = [\n                        generateComment(comment)\n                    ];\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        fragment.push(\"\\n\");\n                    }\n                    result.push(addIndent(fragment));\n                }\n            }\n            result.push(addIndent(save));\n        }\n        if (stmt.trailingComments) {\n            if (preserveBlankLines) {\n                comment = stmt.trailingComments[0];\n                extRange = comment.extendedRange;\n                range = comment.range;\n                prefix = sourceCode.substring(extRange[0], range[0]);\n                count = (prefix.match(/\\n/g) || []).length;\n                if (count > 0) {\n                    result.push(stringRepeat(\"\\n\", count));\n                    result.push(addIndent(generateComment(comment)));\n                } else {\n                    result.push(prefix);\n                    result.push(generateComment(comment));\n                }\n            } else {\n                tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n                specialBase = stringRepeat(\" \", calculateSpaces(toSourceNodeWhenNeeded([\n                    base,\n                    result,\n                    indent\n                ]).toString()));\n                for(i = 0, len = stmt.trailingComments.length; i < len; ++i){\n                    comment = stmt.trailingComments[i];\n                    if (tailingToStatement) {\n                        // We assume target like following script\n                        //\n                        // var t = 20;  /**\n                        //               * This is comment of t\n                        //               */\n                        if (i === 0) {\n                            // first case\n                            result = [\n                                result,\n                                indent\n                            ];\n                        } else {\n                            result = [\n                                result,\n                                specialBase\n                            ];\n                        }\n                        result.push(generateComment(comment, specialBase));\n                    } else {\n                        result = [\n                            result,\n                            addIndent(generateComment(comment))\n                        ];\n                    }\n                    if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result = [\n                            result,\n                            \"\\n\"\n                        ];\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    function generateBlankLines(start, end, result) {\n        var j, newlineCount = 0;\n        for(j = start; j < end; j++){\n            if (sourceCode[j] === \"\\n\") {\n                newlineCount++;\n            }\n        }\n        for(j = 1; j < newlineCount; j++){\n            result.push(newline);\n        }\n    }\n    function parenthesize(text, current, should) {\n        if (current < should) {\n            return [\n                \"(\",\n                text,\n                \")\"\n            ];\n        }\n        return text;\n    }\n    function generateVerbatimString(string) {\n        var i, iz, result;\n        result = string.split(/\\r\\n|\\n/);\n        for(i = 1, iz = result.length; i < iz; i++){\n            result[i] = newline + base + result[i];\n        }\n        return result;\n    }\n    function generateVerbatim(expr, precedence) {\n        var verbatim, result, prec;\n        verbatim = expr[extra.verbatim];\n        if (typeof verbatim === \"string\") {\n            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);\n        } else {\n            // verbatim is object\n            result = generateVerbatimString(verbatim.content);\n            prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;\n            result = parenthesize(result, prec, precedence);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    }\n    function CodeGenerator() {}\n    // Helpers.\n    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {\n        var result, noLeadingComment, that = this;\n        noLeadingComment = !extra.comment || !stmt.leadingComments;\n        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {\n            return [\n                space,\n                this.generateStatement(stmt, flags)\n            ];\n        }\n        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {\n            return \";\";\n        }\n        withIndent(function() {\n            result = [\n                newline,\n                addIndent(that.generateStatement(stmt, flags))\n            ];\n        });\n        return result;\n    };\n    CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {\n        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());\n        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {\n            return [\n                result,\n                space\n            ];\n        }\n        if (ends) {\n            return [\n                result,\n                base\n            ];\n        }\n        return [\n            result,\n            newline,\n            base\n        ];\n    };\n    function generateIdentifier(node) {\n        return toSourceNodeWhenNeeded(node.name, node);\n    }\n    function generateAsyncPrefix(node, spaceRequired) {\n        return node.async ? \"async\" + (spaceRequired ? noEmptySpace() : space) : \"\";\n    }\n    function generateStarSuffix(node) {\n        var isGenerator = node.generator && !extra.moz.starlessGenerator;\n        return isGenerator ? \"*\" + space : \"\";\n    }\n    function generateMethodPrefix(prop) {\n        var func = prop.value, prefix = \"\";\n        if (func.async) {\n            prefix += generateAsyncPrefix(func, !prop.computed);\n        }\n        if (func.generator) {\n            // avoid space before method name\n            prefix += generateStarSuffix(func) ? \"*\" : \"\";\n        }\n        return prefix;\n    }\n    CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {\n        if (node.type === Syntax.Identifier) {\n            return generateIdentifier(node);\n        }\n        return this.generateExpression(node, precedence, flags);\n    };\n    CodeGenerator.prototype.generateFunctionParams = function(node) {\n        var i, iz, result, hasDefault;\n        hasDefault = false;\n        if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {\n            // arg => { } case\n            result = [\n                generateAsyncPrefix(node, true),\n                generateIdentifier(node.params[0])\n            ];\n        } else {\n            result = node.type === Syntax.ArrowFunctionExpression ? [\n                generateAsyncPrefix(node, false)\n            ] : [];\n            result.push(\"(\");\n            if (node.defaults) {\n                hasDefault = true;\n            }\n            for(i = 0, iz = node.params.length; i < iz; ++i){\n                if (hasDefault && node.defaults[i]) {\n                    // Handle default values.\n                    result.push(this.generateAssignment(node.params[i], node.defaults[i], \"=\", Precedence.Assignment, E_TTT));\n                } else {\n                    result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));\n                }\n                if (i + 1 < iz) {\n                    result.push(\",\" + space);\n                }\n            }\n            if (node.rest) {\n                if (node.params.length) {\n                    result.push(\",\" + space);\n                }\n                result.push(\"...\");\n                result.push(generateIdentifier(node.rest));\n            }\n            result.push(\")\");\n        }\n        return result;\n    };\n    CodeGenerator.prototype.generateFunctionBody = function(node) {\n        var result, expr;\n        result = this.generateFunctionParams(node);\n        if (node.type === Syntax.ArrowFunctionExpression) {\n            result.push(space);\n            result.push(\"=>\");\n        }\n        if (node.expression) {\n            result.push(space);\n            expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);\n            if (expr.toString().charAt(0) === \"{\") {\n                expr = [\n                    \"(\",\n                    expr,\n                    \")\"\n                ];\n            }\n            result.push(expr);\n        } else {\n            result.push(this.maybeBlock(node.body, S_TTFF));\n        }\n        return result;\n    };\n    CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {\n        var result = [\n            \"for\" + (stmt.await ? noEmptySpace() + \"await\" : \"\") + space + \"(\"\n        ], that = this;\n        withIndent(function() {\n            if (stmt.left.type === Syntax.VariableDeclaration) {\n                withIndent(function() {\n                    result.push(stmt.left.kind + noEmptySpace());\n                    result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));\n                });\n            } else {\n                result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));\n            }\n            result = join(result, operator);\n            result = [\n                join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)),\n                \")\"\n            ];\n        });\n        result.push(this.maybeBlock(stmt.body, flags));\n        return result;\n    };\n    CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {\n        var result = [];\n        if (computed) {\n            result.push(\"[\");\n        }\n        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));\n        if (computed) {\n            result.push(\"]\");\n        }\n        return result;\n    };\n    CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {\n        if (Precedence.Assignment < precedence) {\n            flags |= F_ALLOW_IN;\n        }\n        return parenthesize([\n            this.generateExpression(left, Precedence.Call, flags),\n            space + operator + space,\n            this.generateExpression(right, Precedence.Assignment, flags)\n        ], Precedence.Assignment, precedence);\n    };\n    CodeGenerator.prototype.semicolon = function(flags) {\n        if (!semicolons && flags & F_SEMICOLON_OPT) {\n            return \"\";\n        }\n        return \";\";\n    };\n    // Statements.\n    CodeGenerator.Statement = {\n        BlockStatement: function(stmt, flags) {\n            var range, content, result = [\n                \"{\",\n                newline\n            ], that = this;\n            withIndent(function() {\n                // handle functions without any code\n                if (stmt.body.length === 0 && preserveBlankLines) {\n                    range = stmt.range;\n                    if (range[1] - range[0] > 2) {\n                        content = sourceCode.substring(range[0] + 1, range[1] - 1);\n                        if (content[0] === \"\\n\") {\n                            result = [\n                                \"{\"\n                            ];\n                        }\n                        result.push(content);\n                    }\n                }\n                var i, iz, fragment, bodyFlags;\n                bodyFlags = S_TFFF;\n                if (flags & F_FUNC_BODY) {\n                    bodyFlags |= F_DIRECTIVE_CTX;\n                }\n                for(i = 0, iz = stmt.body.length; i < iz; ++i){\n                    if (preserveBlankLines) {\n                        // handle spaces before the first line\n                        if (i === 0) {\n                            if (stmt.body[0].leadingComments) {\n                                range = stmt.body[0].leadingComments[0].extendedRange;\n                                content = sourceCode.substring(range[0], range[1]);\n                                if (content[0] === \"\\n\") {\n                                    result = [\n                                        \"{\"\n                                    ];\n                                }\n                            }\n                            if (!stmt.body[0].leadingComments) {\n                                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);\n                            }\n                        }\n                        // handle spaces between lines\n                        if (i > 0) {\n                            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                            }\n                        }\n                    }\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    if (stmt.body[i].leadingComments && preserveBlankLines) {\n                        fragment = that.generateStatement(stmt.body[i], bodyFlags);\n                    } else {\n                        fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));\n                    }\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        if (preserveBlankLines && i < iz - 1) {\n                            // don't add a new line if there are leading coments\n                            // in the next statement\n                            if (!stmt.body[i + 1].leadingComments) {\n                                result.push(newline);\n                            }\n                        } else {\n                            result.push(newline);\n                        }\n                    }\n                    if (preserveBlankLines) {\n                        // handle spaces after the last line\n                        if (i === iz - 1) {\n                            if (!stmt.body[i].trailingComments) {\n                                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                            }\n                        }\n                    }\n                }\n            });\n            result.push(addIndent(\"}\"));\n            return result;\n        },\n        BreakStatement: function(stmt, flags) {\n            if (stmt.label) {\n                return \"break \" + stmt.label.name + this.semicolon(flags);\n            }\n            return \"break\" + this.semicolon(flags);\n        },\n        ContinueStatement: function(stmt, flags) {\n            if (stmt.label) {\n                return \"continue \" + stmt.label.name + this.semicolon(flags);\n            }\n            return \"continue\" + this.semicolon(flags);\n        },\n        ClassBody: function(stmt, flags) {\n            var result = [\n                \"{\",\n                newline\n            ], that = this;\n            withIndent(function(indent) {\n                var i, iz;\n                for(i = 0, iz = stmt.body.length; i < iz; ++i){\n                    result.push(indent);\n                    result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(newline);\n                    }\n                }\n            });\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push(\"}\");\n            return result;\n        },\n        ClassDeclaration: function(stmt, flags) {\n            var result, fragment;\n            result = [\n                \"class\"\n            ];\n            if (stmt.id) {\n                result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));\n            }\n            if (stmt.superClass) {\n                fragment = join(\"extends\", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(stmt.body, S_TFFT));\n            return result;\n        },\n        DirectiveStatement: function(stmt, flags) {\n            if (extra.raw && stmt.raw) {\n                return stmt.raw + this.semicolon(flags);\n            }\n            return escapeDirective(stmt.directive) + this.semicolon(flags);\n        },\n        DoWhileStatement: function(stmt, flags) {\n            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.\n            var result = join(\"do\", this.maybeBlock(stmt.body, S_TFFF));\n            result = this.maybeBlockSuffix(stmt.body, result);\n            return join(result, [\n                \"while\" + space + \"(\",\n                this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                \")\" + this.semicolon(flags)\n            ]);\n        },\n        CatchClause: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                var guard;\n                if (stmt.param) {\n                    result = [\n                        \"catch\" + space + \"(\",\n                        that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),\n                        \")\"\n                    ];\n                    if (stmt.guard) {\n                        guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);\n                        result.splice(2, 0, \" if \", guard);\n                    }\n                } else {\n                    result = [\n                        \"catch\"\n                    ];\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, S_TFFF));\n            return result;\n        },\n        DebuggerStatement: function(stmt, flags) {\n            return \"debugger\" + this.semicolon(flags);\n        },\n        EmptyStatement: function(stmt, flags) {\n            return \";\";\n        },\n        ExportDefaultDeclaration: function(stmt, flags) {\n            var result = [\n                \"export\"\n            ], bodyFlags;\n            bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n            // export default HoistableDeclaration[Default]\n            // export default AssignmentExpression[In] ;\n            result = join(result, \"default\");\n            if (isStatement(stmt.declaration)) {\n                result = join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            } else {\n                result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));\n            }\n            return result;\n        },\n        ExportNamedDeclaration: function(stmt, flags) {\n            var result = [\n                \"export\"\n            ], bodyFlags, that = this;\n            bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;\n            // export VariableStatement\n            // export Declaration[Default]\n            if (stmt.declaration) {\n                return join(result, this.generateStatement(stmt.declaration, bodyFlags));\n            }\n            // export ExportClause[NoReference] FromClause ;\n            // export ExportClause ;\n            if (stmt.specifiers) {\n                if (stmt.specifiers.length === 0) {\n                    result = join(result, \"{\" + space + \"}\");\n                } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {\n                    result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));\n                } else {\n                    result = join(result, \"{\");\n                    withIndent(function(indent) {\n                        var i, iz;\n                        result.push(newline);\n                        for(i = 0, iz = stmt.specifiers.length; i < iz; ++i){\n                            result.push(indent);\n                            result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                            if (i + 1 < iz) {\n                                result.push(\",\" + newline);\n                            }\n                        }\n                    });\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                        result.push(newline);\n                    }\n                    result.push(base + \"}\");\n                }\n                if (stmt.source) {\n                    result = join(result, [\n                        \"from\" + space,\n                        // ModuleSpecifier\n                        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                        this.semicolon(flags)\n                    ]);\n                } else {\n                    result.push(this.semicolon(flags));\n                }\n            }\n            return result;\n        },\n        ExportAllDeclaration: function(stmt, flags) {\n            // export * FromClause ;\n            return [\n                \"export\" + space,\n                \"*\" + space,\n                \"from\" + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ];\n        },\n        ExpressionStatement: function(stmt, flags) {\n            var result, fragment;\n            function isClassPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 5) !== \"class\") {\n                    return false;\n                }\n                code = fragment.charCodeAt(5);\n                return code === 0x7B /* '{' */  || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);\n            }\n            function isFunctionPrefixed(fragment) {\n                var code;\n                if (fragment.slice(0, 8) !== \"function\") {\n                    return false;\n                }\n                code = fragment.charCodeAt(8);\n                return code === 0x28 /* '(' */  || esutils.code.isWhiteSpace(code) || code === 0x2A /* '*' */  || esutils.code.isLineTerminator(code);\n            }\n            function isAsyncPrefixed(fragment) {\n                var code, i, iz;\n                if (fragment.slice(0, 5) !== \"async\") {\n                    return false;\n                }\n                if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {\n                    return false;\n                }\n                for(i = 6, iz = fragment.length; i < iz; ++i){\n                    if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {\n                        break;\n                    }\n                }\n                if (i === iz) {\n                    return false;\n                }\n                if (fragment.slice(i, i + 8) !== \"function\") {\n                    return false;\n                }\n                code = fragment.charCodeAt(i + 8);\n                return code === 0x28 /* '(' */  || esutils.code.isWhiteSpace(code) || code === 0x2A /* '*' */  || esutils.code.isLineTerminator(code);\n            }\n            result = [\n                this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)\n            ];\n            // 12.4 '{', 'function', 'class' is not allowed in this position.\n            // wrap expression with parentheses\n            fragment = toSourceNodeWhenNeeded(result).toString();\n            if (fragment.charCodeAt(0) === 0x7B /* '{' */  || // ObjectExpression\n            isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === \"string\") {\n                result = [\n                    \"(\",\n                    result,\n                    \")\" + this.semicolon(flags)\n                ];\n            } else {\n                result.push(this.semicolon(flags));\n            }\n            return result;\n        },\n        ImportDeclaration: function(stmt, flags) {\n            // ES6: 15.2.1 valid import declarations:\n            //     - import ImportClause FromClause ;\n            //     - import ModuleSpecifier ;\n            var result, cursor, that = this;\n            // If no ImportClause is present,\n            // this should be `import ModuleSpecifier` so skip `from`\n            // ModuleSpecifier is StringLiteral.\n            if (stmt.specifiers.length === 0) {\n                // import ModuleSpecifier ;\n                return [\n                    \"import\",\n                    space,\n                    // ModuleSpecifier\n                    this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                    this.semicolon(flags)\n                ];\n            }\n            // import ImportClause FromClause ;\n            result = [\n                \"import\"\n            ];\n            cursor = 0;\n            // ImportedBinding\n            if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {\n                result = join(result, [\n                    this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                ]);\n                ++cursor;\n            }\n            if (stmt.specifiers[cursor]) {\n                if (cursor !== 0) {\n                    result.push(\",\");\n                }\n                if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {\n                    // NameSpaceImport\n                    result = join(result, [\n                        space,\n                        this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)\n                    ]);\n                } else {\n                    // NamedImports\n                    result.push(space + \"{\");\n                    if (stmt.specifiers.length - cursor === 1) {\n                        // import { ... } from \"...\";\n                        result.push(space);\n                        result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));\n                        result.push(space + \"}\" + space);\n                    } else {\n                        // import {\n                        //    ...,\n                        //    ...,\n                        // } from \"...\";\n                        withIndent(function(indent) {\n                            var i, iz;\n                            result.push(newline);\n                            for(i = cursor, iz = stmt.specifiers.length; i < iz; ++i){\n                                result.push(indent);\n                                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));\n                                if (i + 1 < iz) {\n                                    result.push(\",\" + newline);\n                                }\n                            }\n                        });\n                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                            result.push(newline);\n                        }\n                        result.push(base + \"}\" + space);\n                    }\n                }\n            }\n            result = join(result, [\n                \"from\" + space,\n                // ModuleSpecifier\n                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),\n                this.semicolon(flags)\n            ]);\n            return result;\n        },\n        VariableDeclarator: function(stmt, flags) {\n            var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;\n            if (stmt.init) {\n                return [\n                    this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),\n                    space,\n                    \"=\",\n                    space,\n                    this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)\n                ];\n            }\n            return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);\n        },\n        VariableDeclaration: function(stmt, flags) {\n            // VariableDeclarator is typed as Statement,\n            // but joined with comma (not LineTerminator).\n            // So if comment is attached to target node, we should specialize.\n            var result, i, iz, node, bodyFlags, that = this;\n            result = [\n                stmt.kind\n            ];\n            bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;\n            function block() {\n                node = stmt.declarations[0];\n                if (extra.comment && node.leadingComments) {\n                    result.push(\"\\n\");\n                    result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                } else {\n                    result.push(noEmptySpace());\n                    result.push(that.generateStatement(node, bodyFlags));\n                }\n                for(i = 1, iz = stmt.declarations.length; i < iz; ++i){\n                    node = stmt.declarations[i];\n                    if (extra.comment && node.leadingComments) {\n                        result.push(\",\" + newline);\n                        result.push(addIndent(that.generateStatement(node, bodyFlags)));\n                    } else {\n                        result.push(\",\" + space);\n                        result.push(that.generateStatement(node, bodyFlags));\n                    }\n                }\n            }\n            if (stmt.declarations.length > 1) {\n                withIndent(block);\n            } else {\n                block();\n            }\n            result.push(this.semicolon(flags));\n            return result;\n        },\n        ThrowStatement: function(stmt, flags) {\n            return [\n                join(\"throw\", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),\n                this.semicolon(flags)\n            ];\n        },\n        TryStatement: function(stmt, flags) {\n            var result, i, iz, guardedHandlers;\n            result = [\n                \"try\",\n                this.maybeBlock(stmt.block, S_TFFF)\n            ];\n            result = this.maybeBlockSuffix(stmt.block, result);\n            if (stmt.handlers) {\n                // old interface\n                for(i = 0, iz = stmt.handlers.length; i < iz; ++i){\n                    result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(stmt.handlers[i].body, result);\n                    }\n                }\n            } else {\n                guardedHandlers = stmt.guardedHandlers || [];\n                for(i = 0, iz = guardedHandlers.length; i < iz; ++i){\n                    result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));\n                    if (stmt.finalizer || i + 1 !== iz) {\n                        result = this.maybeBlockSuffix(guardedHandlers[i].body, result);\n                    }\n                }\n                // new interface\n                if (stmt.handler) {\n                    if (Array.isArray(stmt.handler)) {\n                        for(i = 0, iz = stmt.handler.length; i < iz; ++i){\n                            result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));\n                            if (stmt.finalizer || i + 1 !== iz) {\n                                result = this.maybeBlockSuffix(stmt.handler[i].body, result);\n                            }\n                        }\n                    } else {\n                        result = join(result, this.generateStatement(stmt.handler, S_TFFF));\n                        if (stmt.finalizer) {\n                            result = this.maybeBlockSuffix(stmt.handler.body, result);\n                        }\n                    }\n                }\n            }\n            if (stmt.finalizer) {\n                result = join(result, [\n                    \"finally\",\n                    this.maybeBlock(stmt.finalizer, S_TFFF)\n                ]);\n            }\n            return result;\n        },\n        SwitchStatement: function(stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function() {\n                result = [\n                    \"switch\" + space + \"(\",\n                    that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),\n                    \")\" + space + \"{\" + newline\n                ];\n            });\n            if (stmt.cases) {\n                bodyFlags = S_TFFF;\n                for(i = 0, iz = stmt.cases.length; i < iz; ++i){\n                    if (i === iz - 1) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));\n                    result.push(fragment);\n                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            }\n            result.push(addIndent(\"}\"));\n            return result;\n        },\n        SwitchCase: function(stmt, flags) {\n            var result, fragment, i, iz, bodyFlags, that = this;\n            withIndent(function() {\n                if (stmt.test) {\n                    result = [\n                        join(\"case\", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),\n                        \":\"\n                    ];\n                } else {\n                    result = [\n                        \"default:\"\n                    ];\n                }\n                i = 0;\n                iz = stmt.consequent.length;\n                if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {\n                    fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);\n                    result.push(fragment);\n                    i = 1;\n                }\n                if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                    result.push(newline);\n                }\n                bodyFlags = S_TFFF;\n                for(; i < iz; ++i){\n                    if (i === iz - 1 && flags & F_SEMICOLON_OPT) {\n                        bodyFlags |= F_SEMICOLON_OPT;\n                    }\n                    fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));\n                    result.push(fragment);\n                    if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                        result.push(newline);\n                    }\n                }\n            });\n            return result;\n        },\n        IfStatement: function(stmt, flags) {\n            var result, bodyFlags, semicolonOptional, that = this;\n            withIndent(function() {\n                result = [\n                    \"if\" + space + \"(\",\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    \")\"\n                ];\n            });\n            semicolonOptional = flags & F_SEMICOLON_OPT;\n            bodyFlags = S_TFFF;\n            if (semicolonOptional) {\n                bodyFlags |= F_SEMICOLON_OPT;\n            }\n            if (stmt.alternate) {\n                result.push(this.maybeBlock(stmt.consequent, S_TFFF));\n                result = this.maybeBlockSuffix(stmt.consequent, result);\n                if (stmt.alternate.type === Syntax.IfStatement) {\n                    result = join(result, [\n                        \"else \",\n                        this.generateStatement(stmt.alternate, bodyFlags)\n                    ]);\n                } else {\n                    result = join(result, join(\"else\", this.maybeBlock(stmt.alternate, bodyFlags)));\n                }\n            } else {\n                result.push(this.maybeBlock(stmt.consequent, bodyFlags));\n            }\n            return result;\n        },\n        ForStatement: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                result = [\n                    \"for\" + space + \"(\"\n                ];\n                if (stmt.init) {\n                    if (stmt.init.type === Syntax.VariableDeclaration) {\n                        result.push(that.generateStatement(stmt.init, S_FFFF));\n                    } else {\n                        // F_ALLOW_IN becomes false.\n                        result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));\n                        result.push(\";\");\n                    }\n                } else {\n                    result.push(\";\");\n                }\n                if (stmt.test) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));\n                    result.push(\";\");\n                } else {\n                    result.push(\";\");\n                }\n                if (stmt.update) {\n                    result.push(space);\n                    result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));\n                    result.push(\")\");\n                } else {\n                    result.push(\")\");\n                }\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n        ForInStatement: function(stmt, flags) {\n            return this.generateIterationForStatement(\"in\", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n        ForOfStatement: function(stmt, flags) {\n            return this.generateIterationForStatement(\"of\", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);\n        },\n        LabeledStatement: function(stmt, flags) {\n            return [\n                stmt.label.name + \":\",\n                this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)\n            ];\n        },\n        Program: function(stmt, flags) {\n            var result, fragment, i, iz, bodyFlags;\n            iz = stmt.body.length;\n            result = [\n                safeConcatenation && iz > 0 ? \"\\n\" : \"\"\n            ];\n            bodyFlags = S_TFTF;\n            for(i = 0; i < iz; ++i){\n                if (!safeConcatenation && i === iz - 1) {\n                    bodyFlags |= F_SEMICOLON_OPT;\n                }\n                if (preserveBlankLines) {\n                    // handle spaces before the first line\n                    if (i === 0) {\n                        if (!stmt.body[0].leadingComments) {\n                            generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);\n                        }\n                    }\n                    // handle spaces between lines\n                    if (i > 0) {\n                        if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {\n                            generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);\n                        }\n                    }\n                }\n                fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));\n                result.push(fragment);\n                if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    if (preserveBlankLines) {\n                        if (!stmt.body[i + 1].leadingComments) {\n                            result.push(newline);\n                        }\n                    } else {\n                        result.push(newline);\n                    }\n                }\n                if (preserveBlankLines) {\n                    // handle spaces after the last line\n                    if (i === iz - 1) {\n                        if (!stmt.body[i].trailingComments) {\n                            generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);\n                        }\n                    }\n                }\n            }\n            return result;\n        },\n        FunctionDeclaration: function(stmt, flags) {\n            return [\n                generateAsyncPrefix(stmt, true),\n                \"function\",\n                generateStarSuffix(stmt) || noEmptySpace(),\n                stmt.id ? generateIdentifier(stmt.id) : \"\",\n                this.generateFunctionBody(stmt)\n            ];\n        },\n        ReturnStatement: function(stmt, flags) {\n            if (stmt.argument) {\n                return [\n                    join(\"return\", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)),\n                    this.semicolon(flags)\n                ];\n            }\n            return [\n                \"return\" + this.semicolon(flags)\n            ];\n        },\n        WhileStatement: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                result = [\n                    \"while\" + space + \"(\",\n                    that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),\n                    \")\"\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        },\n        WithStatement: function(stmt, flags) {\n            var result, that = this;\n            withIndent(function() {\n                result = [\n                    \"with\" + space + \"(\",\n                    that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),\n                    \")\"\n                ];\n            });\n            result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));\n            return result;\n        }\n    };\n    merge(CodeGenerator.prototype, CodeGenerator.Statement);\n    // Expressions.\n    CodeGenerator.Expression = {\n        SequenceExpression: function(expr, precedence, flags) {\n            var result, i, iz;\n            if (Precedence.Sequence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            result = [];\n            for(i = 0, iz = expr.expressions.length; i < iz; ++i){\n                result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));\n                if (i + 1 < iz) {\n                    result.push(\",\" + space);\n                }\n            }\n            return parenthesize(result, Precedence.Sequence, precedence);\n        },\n        AssignmentExpression: function(expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);\n        },\n        ArrowFunctionExpression: function(expr, precedence, flags) {\n            return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);\n        },\n        ConditionalExpression: function(expr, precedence, flags) {\n            if (Precedence.Conditional < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            return parenthesize([\n                this.generateExpression(expr.test, Precedence.LogicalOR, flags),\n                space + \"?\" + space,\n                this.generateExpression(expr.consequent, Precedence.Assignment, flags),\n                space + \":\" + space,\n                this.generateExpression(expr.alternate, Precedence.Assignment, flags)\n            ], Precedence.Conditional, precedence);\n        },\n        LogicalExpression: function(expr, precedence, flags) {\n            return this.BinaryExpression(expr, precedence, flags);\n        },\n        BinaryExpression: function(expr, precedence, flags) {\n            var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;\n            currentPrecedence = BinaryPrecedence[expr.operator];\n            leftPrecedence = expr.operator === \"**\" ? Precedence.Postfix : currentPrecedence;\n            rightPrecedence = expr.operator === \"**\" ? currentPrecedence : currentPrecedence + 1;\n            if (currentPrecedence < precedence) {\n                flags |= F_ALLOW_IN;\n            }\n            fragment = this.generateExpression(expr.left, leftPrecedence, flags);\n            leftSource = fragment.toString();\n            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */  && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {\n                result = [\n                    fragment,\n                    noEmptySpace(),\n                    expr.operator\n                ];\n            } else {\n                result = join(fragment, expr.operator);\n            }\n            fragment = this.generateExpression(expr.right, rightPrecedence, flags);\n            if (expr.operator === \"/\" && fragment.toString().charAt(0) === \"/\" || expr.operator.slice(-1) === \"<\" && fragment.toString().slice(0, 3) === \"!--\") {\n                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start\n                result.push(noEmptySpace());\n                result.push(fragment);\n            } else {\n                result = join(result, fragment);\n            }\n            if (expr.operator === \"in\" && !(flags & F_ALLOW_IN)) {\n                return [\n                    \"(\",\n                    result,\n                    \")\"\n                ];\n            }\n            return parenthesize(result, currentPrecedence, precedence);\n        },\n        CallExpression: function(expr, precedence, flags) {\n            var result, i, iz;\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [\n                this.generateExpression(expr.callee, Precedence.Call, E_TTF)\n            ];\n            result.push(\"(\");\n            for(i = 0, iz = expr[\"arguments\"].length; i < iz; ++i){\n                result.push(this.generateExpression(expr[\"arguments\"][i], Precedence.Assignment, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(\",\" + space);\n                }\n            }\n            result.push(\")\");\n            if (!(flags & F_ALLOW_CALL)) {\n                return [\n                    \"(\",\n                    result,\n                    \")\"\n                ];\n            }\n            return parenthesize(result, Precedence.Call, precedence);\n        },\n        NewExpression: function(expr, precedence, flags) {\n            var result, length, i, iz, itemFlags;\n            length = expr[\"arguments\"].length;\n            // F_ALLOW_CALL becomes false.\n            // F_ALLOW_UNPARATH_NEW may become false.\n            itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;\n            result = join(\"new\", this.generateExpression(expr.callee, Precedence.New, itemFlags));\n            if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {\n                result.push(\"(\");\n                for(i = 0, iz = length; i < iz; ++i){\n                    result.push(this.generateExpression(expr[\"arguments\"][i], Precedence.Assignment, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(\",\" + space);\n                    }\n                }\n                result.push(\")\");\n            }\n            return parenthesize(result, Precedence.New, precedence);\n        },\n        MemberExpression: function(expr, precedence, flags) {\n            var result, fragment;\n            // F_ALLOW_UNPARATH_NEW becomes false.\n            result = [\n                this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)\n            ];\n            if (expr.computed) {\n                result.push(\"[\");\n                result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));\n                result.push(\"]\");\n            } else {\n                if (expr.object.type === Syntax.Literal && typeof expr.object.value === \"number\") {\n                    fragment = toSourceNodeWhenNeeded(result).toString();\n                    // When the following conditions are all true,\n                    //   1. No floating point\n                    //   2. Don't have exponents\n                    //   3. The last character is a decimal digit\n                    //   4. Not hexadecimal OR octal number literal\n                    // we should add a floating point.\n                    if (fragment.indexOf(\".\") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48 // '0'\n                    )) {\n                        result.push(\" \");\n                    }\n                }\n                result.push(\".\");\n                result.push(generateIdentifier(expr.property));\n            }\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n        MetaProperty: function(expr, precedence, flags) {\n            var result;\n            result = [];\n            result.push(typeof expr.meta === \"string\" ? expr.meta : generateIdentifier(expr.meta));\n            result.push(\".\");\n            result.push(typeof expr.property === \"string\" ? expr.property : generateIdentifier(expr.property));\n            return parenthesize(result, Precedence.Member, precedence);\n        },\n        UnaryExpression: function(expr, precedence, flags) {\n            var result, fragment, rightCharCode, leftSource, leftCharCode;\n            fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);\n            if (space === \"\") {\n                result = join(expr.operator, fragment);\n            } else {\n                result = [\n                    expr.operator\n                ];\n                if (expr.operator.length > 2) {\n                    // delete, void, typeof\n                    // get `typeof []`, not `typeof[]`\n                    result = join(result, fragment);\n                } else {\n                    // Prevent inserting spaces between operator and argument if it is unnecessary\n                    // like, `!cond`\n                    leftSource = toSourceNodeWhenNeeded(result).toString();\n                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);\n                    rightCharCode = fragment.toString().charCodeAt(0);\n                    if ((leftCharCode === 0x2B /* + */  || leftCharCode === 0x2D /* - */ ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {\n                        result.push(noEmptySpace());\n                        result.push(fragment);\n                    } else {\n                        result.push(fragment);\n                    }\n                }\n            }\n            return parenthesize(result, Precedence.Unary, precedence);\n        },\n        YieldExpression: function(expr, precedence, flags) {\n            var result;\n            if (expr.delegate) {\n                result = \"yield*\";\n            } else {\n                result = \"yield\";\n            }\n            if (expr.argument) {\n                result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));\n            }\n            return parenthesize(result, Precedence.Yield, precedence);\n        },\n        AwaitExpression: function(expr, precedence, flags) {\n            var result = join(expr.all ? \"await*\" : \"await\", this.generateExpression(expr.argument, Precedence.Await, E_TTT));\n            return parenthesize(result, Precedence.Await, precedence);\n        },\n        UpdateExpression: function(expr, precedence, flags) {\n            if (expr.prefix) {\n                return parenthesize([\n                    expr.operator,\n                    this.generateExpression(expr.argument, Precedence.Unary, E_TTT)\n                ], Precedence.Unary, precedence);\n            }\n            return parenthesize([\n                this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),\n                expr.operator\n            ], Precedence.Postfix, precedence);\n        },\n        FunctionExpression: function(expr, precedence, flags) {\n            var result = [\n                generateAsyncPrefix(expr, true),\n                \"function\"\n            ];\n            if (expr.id) {\n                result.push(generateStarSuffix(expr) || noEmptySpace());\n                result.push(generateIdentifier(expr.id));\n            } else {\n                result.push(generateStarSuffix(expr) || space);\n            }\n            result.push(this.generateFunctionBody(expr));\n            return result;\n        },\n        ArrayPattern: function(expr, precedence, flags) {\n            return this.ArrayExpression(expr, precedence, flags, true);\n        },\n        ArrayExpression: function(expr, precedence, flags, isPattern) {\n            var result, multiline, that = this;\n            if (!expr.elements.length) {\n                return \"[]\";\n            }\n            multiline = isPattern ? false : expr.elements.length > 1;\n            result = [\n                \"[\",\n                multiline ? newline : \"\"\n            ];\n            withIndent(function(indent) {\n                var i, iz;\n                for(i = 0, iz = expr.elements.length; i < iz; ++i){\n                    if (!expr.elements[i]) {\n                        if (multiline) {\n                            result.push(indent);\n                        }\n                        if (i + 1 === iz) {\n                            result.push(\",\");\n                        }\n                    } else {\n                        result.push(multiline ? indent : \"\");\n                        result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));\n                    }\n                    if (i + 1 < iz) {\n                        result.push(\",\" + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : \"\");\n            result.push(\"]\");\n            return result;\n        },\n        RestElement: function(expr, precedence, flags) {\n            return \"...\" + this.generatePattern(expr.argument);\n        },\n        ClassExpression: function(expr, precedence, flags) {\n            var result, fragment;\n            result = [\n                \"class\"\n            ];\n            if (expr.id) {\n                result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));\n            }\n            if (expr.superClass) {\n                fragment = join(\"extends\", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));\n                result = join(result, fragment);\n            }\n            result.push(space);\n            result.push(this.generateStatement(expr.body, S_TFFT));\n            return result;\n        },\n        MethodDefinition: function(expr, precedence, flags) {\n            var result, fragment;\n            if (expr[\"static\"]) {\n                result = [\n                    \"static\" + space\n                ];\n            } else {\n                result = [];\n            }\n            if (expr.kind === \"get\" || expr.kind === \"set\") {\n                fragment = [\n                    join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),\n                    this.generateFunctionBody(expr.value)\n                ];\n            } else {\n                fragment = [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return join(result, fragment);\n        },\n        Property: function(expr, precedence, flags) {\n            if (expr.kind === \"get\" || expr.kind === \"set\") {\n                return [\n                    expr.kind,\n                    noEmptySpace(),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            if (expr.shorthand) {\n                if (expr.value.type === \"AssignmentPattern\") {\n                    return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);\n                }\n                return this.generatePropertyKey(expr.key, expr.computed);\n            }\n            if (expr.method) {\n                return [\n                    generateMethodPrefix(expr),\n                    this.generatePropertyKey(expr.key, expr.computed),\n                    this.generateFunctionBody(expr.value)\n                ];\n            }\n            return [\n                this.generatePropertyKey(expr.key, expr.computed),\n                \":\" + space,\n                this.generateExpression(expr.value, Precedence.Assignment, E_TTT)\n            ];\n        },\n        ObjectExpression: function(expr, precedence, flags) {\n            var multiline, result, fragment, that = this;\n            if (!expr.properties.length) {\n                return \"{}\";\n            }\n            multiline = expr.properties.length > 1;\n            withIndent(function() {\n                fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);\n            });\n            if (!multiline) {\n                // issues 4\n                // Do not transform from\n                //   dejavu.Class.declare({\n                //       method2: function () {}\n                //   });\n                // to\n                //   dejavu.Class.declare({method2: function () {\n                //       }});\n                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {\n                    return [\n                        \"{\",\n                        space,\n                        fragment,\n                        space,\n                        \"}\"\n                    ];\n                }\n            }\n            withIndent(function(indent) {\n                var i, iz;\n                result = [\n                    \"{\",\n                    newline,\n                    indent,\n                    fragment\n                ];\n                if (multiline) {\n                    result.push(\",\" + newline);\n                    for(i = 1, iz = expr.properties.length; i < iz; ++i){\n                        result.push(indent);\n                        result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                        if (i + 1 < iz) {\n                            result.push(\",\" + newline);\n                        }\n                    }\n                }\n            });\n            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(base);\n            result.push(\"}\");\n            return result;\n        },\n        AssignmentPattern: function(expr, precedence, flags) {\n            return this.generateAssignment(expr.left, expr.right, \"=\", precedence, flags);\n        },\n        ObjectPattern: function(expr, precedence, flags) {\n            var result, i, iz, multiline, property, that = this;\n            if (!expr.properties.length) {\n                return \"{}\";\n            }\n            multiline = false;\n            if (expr.properties.length === 1) {\n                property = expr.properties[0];\n                if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {\n                    multiline = true;\n                }\n            } else {\n                for(i = 0, iz = expr.properties.length; i < iz; ++i){\n                    property = expr.properties[i];\n                    if (property.type === Syntax.Property && !property.shorthand) {\n                        multiline = true;\n                        break;\n                    }\n                }\n            }\n            result = [\n                \"{\",\n                multiline ? newline : \"\"\n            ];\n            withIndent(function(indent) {\n                var i, iz;\n                for(i = 0, iz = expr.properties.length; i < iz; ++i){\n                    result.push(multiline ? indent : \"\");\n                    result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));\n                    if (i + 1 < iz) {\n                        result.push(\",\" + (multiline ? newline : space));\n                    }\n                }\n            });\n            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {\n                result.push(newline);\n            }\n            result.push(multiline ? base : \"\");\n            result.push(\"}\");\n            return result;\n        },\n        ThisExpression: function(expr, precedence, flags) {\n            return \"this\";\n        },\n        Super: function(expr, precedence, flags) {\n            return \"super\";\n        },\n        Identifier: function(expr, precedence, flags) {\n            return generateIdentifier(expr);\n        },\n        ImportDefaultSpecifier: function(expr, precedence, flags) {\n            return generateIdentifier(expr.id || expr.local);\n        },\n        ImportNamespaceSpecifier: function(expr, precedence, flags) {\n            var result = [\n                \"*\"\n            ];\n            var id = expr.id || expr.local;\n            if (id) {\n                result.push(space + \"as\" + noEmptySpace() + generateIdentifier(id));\n            }\n            return result;\n        },\n        ImportSpecifier: function(expr, precedence, flags) {\n            var imported = expr.imported;\n            var result = [\n                imported.name\n            ];\n            var local = expr.local;\n            if (local && local.name !== imported.name) {\n                result.push(noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(local));\n            }\n            return result;\n        },\n        ExportSpecifier: function(expr, precedence, flags) {\n            var local = expr.local;\n            var result = [\n                local.name\n            ];\n            var exported = expr.exported;\n            if (exported && exported.name !== local.name) {\n                result.push(noEmptySpace() + \"as\" + noEmptySpace() + generateIdentifier(exported));\n            }\n            return result;\n        },\n        Literal: function(expr, precedence, flags) {\n            var raw;\n            if (expr.hasOwnProperty(\"raw\") && parse && extra.raw) {\n                try {\n                    raw = parse(expr.raw).body[0].expression;\n                    if (raw.type === Syntax.Literal) {\n                        if (raw.value === expr.value) {\n                            return expr.raw;\n                        }\n                    }\n                } catch (e) {\n                // not use raw property\n                }\n            }\n            if (expr.regex) {\n                return \"/\" + expr.regex.pattern + \"/\" + expr.regex.flags;\n            }\n            if (expr.value === null) {\n                return \"null\";\n            }\n            if (typeof expr.value === \"string\") {\n                return escapeString(expr.value);\n            }\n            if (typeof expr.value === \"number\") {\n                return generateNumber(expr.value);\n            }\n            if (typeof expr.value === \"boolean\") {\n                return expr.value ? \"true\" : \"false\";\n            }\n            return generateRegExp(expr.value);\n        },\n        GeneratorExpression: function(expr, precedence, flags) {\n            return this.ComprehensionExpression(expr, precedence, flags);\n        },\n        ComprehensionExpression: function(expr, precedence, flags) {\n            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]\n            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6\n            var result, i, iz, fragment, that = this;\n            result = expr.type === Syntax.GeneratorExpression ? [\n                \"(\"\n            ] : [\n                \"[\"\n            ];\n            if (extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result.push(fragment);\n            }\n            if (expr.blocks) {\n                withIndent(function() {\n                    for(i = 0, iz = expr.blocks.length; i < iz; ++i){\n                        fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);\n                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {\n                            result = join(result, fragment);\n                        } else {\n                            result.push(fragment);\n                        }\n                    }\n                });\n            }\n            if (expr.filter) {\n                result = join(result, \"if\" + space);\n                fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);\n                result = join(result, [\n                    \"(\",\n                    fragment,\n                    \")\"\n                ]);\n            }\n            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {\n                fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);\n                result = join(result, fragment);\n            }\n            result.push(expr.type === Syntax.GeneratorExpression ? \")\" : \"]\");\n            return result;\n        },\n        ComprehensionBlock: function(expr, precedence, flags) {\n            var fragment;\n            if (expr.left.type === Syntax.VariableDeclaration) {\n                fragment = [\n                    expr.left.kind,\n                    noEmptySpace(),\n                    this.generateStatement(expr.left.declarations[0], S_FFFF)\n                ];\n            } else {\n                fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);\n            }\n            fragment = join(fragment, expr.of ? \"of\" : \"in\");\n            fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));\n            return [\n                \"for\" + space + \"(\",\n                fragment,\n                \")\"\n            ];\n        },\n        SpreadElement: function(expr, precedence, flags) {\n            return [\n                \"...\",\n                this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)\n            ];\n        },\n        TaggedTemplateExpression: function(expr, precedence, flags) {\n            var itemFlags = E_TTF;\n            if (!(flags & F_ALLOW_CALL)) {\n                itemFlags = E_TFF;\n            }\n            var result = [\n                this.generateExpression(expr.tag, Precedence.Call, itemFlags),\n                this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)\n            ];\n            return parenthesize(result, Precedence.TaggedTemplate, precedence);\n        },\n        TemplateElement: function(expr, precedence, flags) {\n            // Don't use \"cooked\". Since tagged template can use raw template\n            // representation. So if we do so, it breaks the script semantics.\n            return expr.value.raw;\n        },\n        TemplateLiteral: function(expr, precedence, flags) {\n            var result, i, iz;\n            result = [\n                \"`\"\n            ];\n            for(i = 0, iz = expr.quasis.length; i < iz; ++i){\n                result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));\n                if (i + 1 < iz) {\n                    result.push(\"${\" + space);\n                    result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));\n                    result.push(space + \"}\");\n                }\n            }\n            result.push(\"`\");\n            return result;\n        },\n        ModuleSpecifier: function(expr, precedence, flags) {\n            return this.Literal(expr, precedence, flags);\n        },\n        ImportExpression: function(expr, precedence, flag) {\n            return parenthesize([\n                \"import(\",\n                this.generateExpression(expr.source, Precedence.Assignment, E_TTT),\n                \")\"\n            ], Precedence.Call, precedence);\n        }\n    };\n    merge(CodeGenerator.prototype, CodeGenerator.Expression);\n    CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {\n        var result, type;\n        type = expr.type || Syntax.Property;\n        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {\n            return generateVerbatim(expr, precedence);\n        }\n        result = this[type](expr, precedence, flags);\n        if (extra.comment) {\n            result = addComments(expr, result);\n        }\n        return toSourceNodeWhenNeeded(result, expr);\n    };\n    CodeGenerator.prototype.generateStatement = function(stmt, flags) {\n        var result, fragment;\n        result = this[stmt.type](stmt, flags);\n        // Attach comments\n        if (extra.comment) {\n            result = addComments(stmt, result);\n        }\n        fragment = toSourceNodeWhenNeeded(result).toString();\n        if (stmt.type === Syntax.Program && !safeConcatenation && newline === \"\" && fragment.charAt(fragment.length - 1) === \"\\n\") {\n            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\\s+$/, \"\") : fragment.replace(/\\s+$/, \"\");\n        }\n        return toSourceNodeWhenNeeded(result, stmt);\n    };\n    function generateInternal(node) {\n        var codegen;\n        codegen = new CodeGenerator();\n        if (isStatement(node)) {\n            return codegen.generateStatement(node, S_TFFF);\n        }\n        if (isExpression(node)) {\n            return codegen.generateExpression(node, Precedence.Sequence, E_TTT);\n        }\n        throw new Error(\"Unknown node type: \" + node.type);\n    }\n    function generate(node, options) {\n        var defaultOptions = getDefaultOptions(), result, pair;\n        if (options != null) {\n            // Obsolete options\n            //\n            //   `options.indent`\n            //   `options.base`\n            //\n            // Instead of them, we can use `option.format.indent`.\n            if (typeof options.indent === \"string\") {\n                defaultOptions.format.indent.style = options.indent;\n            }\n            if (typeof options.base === \"number\") {\n                defaultOptions.format.indent.base = options.base;\n            }\n            options = updateDeeply(defaultOptions, options);\n            indent = options.format.indent.style;\n            if (typeof options.base === \"string\") {\n                base = options.base;\n            } else {\n                base = stringRepeat(indent, options.format.indent.base);\n            }\n        } else {\n            options = defaultOptions;\n            indent = options.format.indent.style;\n            base = stringRepeat(indent, options.format.indent.base);\n        }\n        json = options.format.json;\n        renumber = options.format.renumber;\n        hexadecimal = json ? false : options.format.hexadecimal;\n        quotes = json ? \"double\" : options.format.quotes;\n        escapeless = options.format.escapeless;\n        newline = options.format.newline;\n        space = options.format.space;\n        if (options.format.compact) {\n            newline = space = indent = base = \"\";\n        }\n        parentheses = options.format.parentheses;\n        semicolons = options.format.semicolons;\n        safeConcatenation = options.format.safeConcatenation;\n        directive = options.directive;\n        parse = json ? null : options.parse;\n        sourceMap = options.sourceMap;\n        sourceCode = options.sourceCode;\n        preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;\n        extra = options;\n        if (sourceMap) {\n            if (!exports.browser) {\n                // We assume environment is node.js\n                // And prevent from including source-map by browserify\n                SourceNode = (__webpack_require__(/*! source-map */ \"(rsc)/./node_modules/source-map/source-map.js\").SourceNode);\n            } else {\n                SourceNode = global.sourceMap.SourceNode;\n            }\n        }\n        result = generateInternal(node);\n        if (!sourceMap) {\n            pair = {\n                code: result.toString(),\n                map: null\n            };\n            return options.sourceMapWithCode ? pair : pair.code;\n        }\n        pair = result.toStringWithSourceMap({\n            file: options.file,\n            sourceRoot: options.sourceMapRoot\n        });\n        if (options.sourceContent) {\n            pair.map.setSourceContent(options.sourceMap, options.sourceContent);\n        }\n        if (options.sourceMapWithCode) {\n            return pair;\n        }\n        return pair.map.toString();\n    }\n    FORMAT_MINIFY = {\n        indent: {\n            style: \"\",\n            base: 0\n        },\n        renumber: true,\n        hexadecimal: true,\n        quotes: \"auto\",\n        escapeless: true,\n        compact: true,\n        parentheses: false,\n        semicolons: false\n    };\n    FORMAT_DEFAULTS = getDefaultOptions().format;\n    exports.version = __webpack_require__(/*! ./package.json */ \"(rsc)/./node_modules/escodegen/package.json\").version;\n    exports.generate = generate;\n    exports.attachComments = estraverse.attachComments;\n    exports.Precedence = updateDeeply({}, Precedence);\n    exports.browser = false;\n    exports.FORMAT_MINIFY = FORMAT_MINIFY;\n    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;\n})(); /* vim: set sw=4 ts=4 et tw=80 : */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL2VzY29kZWdlbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBLEdBRUEsZ0RBQWdELEdBQy9DO0lBQ0c7SUFFQSxJQUFJQSxRQUNBQyxZQUNBQyxrQkFDQUMsWUFDQUMsWUFDQUMsU0FDQUMsTUFDQUMsUUFDQUMsTUFDQUMsVUFDQUMsYUFDQUMsUUFDQUMsWUFDQUMsU0FDQUMsT0FDQUMsYUFDQUMsWUFDQUMsbUJBQ0FDLFdBQ0FDLE9BQ0FDLE9BQ0FDLFdBQ0FDLFlBQ0FDLG9CQUNBQyxlQUNBQztJQUVKckIsYUFBYXNCLG1CQUFPQSxDQUFDO0lBQ3JCckIsVUFBVXFCLG1CQUFPQSxDQUFDO0lBRWxCMUIsU0FBU0ksV0FBV0osTUFBTTtJQUUxQiw0Q0FBNEM7SUFDNUMsU0FBUzJCLGFBQWFDLElBQUk7UUFDdEIsT0FBT0MsY0FBY0MsVUFBVSxDQUFDQyxjQUFjLENBQUNILEtBQUtJLElBQUk7SUFDNUQ7SUFFQSwyQ0FBMkM7SUFDM0MsU0FBU0MsWUFBWUwsSUFBSTtRQUNyQixPQUFPQyxjQUFjSyxTQUFTLENBQUNILGNBQWMsQ0FBQ0gsS0FBS0ksSUFBSTtJQUMzRDtJQUVBL0IsYUFBYTtRQUNUa0MsVUFBVTtRQUNWQyxPQUFPO1FBQ1BDLFlBQVk7UUFDWkMsYUFBYTtRQUNiQyxlQUFlO1FBQ2ZDLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxXQUFXO1FBQ1hDLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsY0FBYztRQUNkQyxVQUFVO1FBQ1ZDLGdCQUFnQjtRQUNoQkMsZ0JBQWdCO1FBQ2hCQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsU0FBUztRQUNUQyxNQUFNO1FBQ05DLEtBQUs7UUFDTEMsZ0JBQWdCO1FBQ2hCQyxRQUFRO1FBQ1JDLFNBQVM7SUFDYjtJQUVBeEQsbUJBQW1CO1FBQ2YsTUFBTUQsV0FBV3VDLFNBQVM7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UVEsSUFBSTtZQUNsQkMsWUFBWVQsUUFBUTVTLGFBQWE7UUFDckM7UUFFQSxJQUFJNFMsUUFBUVUsYUFBYSxFQUFFO1lBQ3ZCUixLQUFLSSxHQUFHLENBQUNLLGdCQUFnQixDQUFDWCxRQUFRNVcsU0FBUyxFQUNqQjRXLFFBQVFVLGFBQWE7UUFDbkQ7UUFFQSxJQUFJVixRQUFRM1MsaUJBQWlCLEVBQUU7WUFDM0IsT0FBTzZTO1FBQ1g7UUFFQSxPQUFPQSxLQUFLSSxHQUFHLENBQUM3USxRQUFRO0lBQzVCO0lBRUFsRyxnQkFBZ0I7UUFDWmpCLFFBQVE7WUFDSndFLE9BQU87WUFDUHpFLE1BQU07UUFDVjtRQUNBRyxVQUFVO1FBQ1ZDLGFBQWE7UUFDYkMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pxRSxTQUFTO1FBQ1RsRSxhQUFhO1FBQ2JDLFlBQVk7SUFDaEI7SUFFQVMsa0JBQWtCbUQsb0JBQW9CRSxNQUFNO0lBRTVDc1Qsa0hBQW1EO0lBQ25EQSxnQkFBZ0IsR0FBR0o7SUFDbkJJLHNCQUFzQixHQUFHaFksV0FBVzBZLGNBQWM7SUFDbERWLGtCQUFrQixHQUFHM1IsYUFBYSxDQUFDLEdBQUd4RztJQUN0Q21ZLGVBQWUsR0FBRztJQUNsQkEscUJBQXFCLEdBQUc1VztJQUN4QjRXLHVCQUF1QixHQUFHM1c7QUFDOUIsTUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vZXNjb2RlZ2VuLmpzP2QzMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTQgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgSW5ndmFyIFN0ZXBhbnlhbiA8bWVAcnJldmVyc2VyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDE0IEl2YW4gTmlrdWxpbiA8aWZhYWFuQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTMgTWljaGFlbCBGaWNhcnJhIDxlc2NvZGVnZW4uY29weXJpZ2h0QG1pY2hhZWwuZmljYXJyYS5tZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyLTIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIElyYWtsaSBHb3phbGlzaHZpbGkgPHJmb2JpY0BnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBSb2JlcnQgR3VzdC1CYXJkb24gPGRvbmF0ZUByb2JlcnQuZ3VzdC1iYXJkb24ub3JnPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9obiBGcmVlbWFuIDxqZnJlZW1hbjA4QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExLTIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLypnbG9iYWwgZXhwb3J0czp0cnVlLCByZXF1aXJlOnRydWUsIGdsb2JhbDp0cnVlKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFN5bnRheCxcbiAgICAgICAgUHJlY2VkZW5jZSxcbiAgICAgICAgQmluYXJ5UHJlY2VkZW5jZSxcbiAgICAgICAgU291cmNlTm9kZSxcbiAgICAgICAgZXN0cmF2ZXJzZSxcbiAgICAgICAgZXN1dGlscyxcbiAgICAgICAgYmFzZSxcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBqc29uLFxuICAgICAgICByZW51bWJlcixcbiAgICAgICAgaGV4YWRlY2ltYWwsXG4gICAgICAgIHF1b3RlcyxcbiAgICAgICAgZXNjYXBlbGVzcyxcbiAgICAgICAgbmV3bGluZSxcbiAgICAgICAgc3BhY2UsXG4gICAgICAgIHBhcmVudGhlc2VzLFxuICAgICAgICBzZW1pY29sb25zLFxuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbixcbiAgICAgICAgZGlyZWN0aXZlLFxuICAgICAgICBleHRyYSxcbiAgICAgICAgcGFyc2UsXG4gICAgICAgIHNvdXJjZU1hcCxcbiAgICAgICAgc291cmNlQ29kZSxcbiAgICAgICAgcHJlc2VydmVCbGFua0xpbmVzLFxuICAgICAgICBGT1JNQVRfTUlOSUZZLFxuICAgICAgICBGT1JNQVRfREVGQVVMVFM7XG5cbiAgICBlc3RyYXZlcnNlID0gcmVxdWlyZSgnZXN0cmF2ZXJzZScpO1xuICAgIGVzdXRpbHMgPSByZXF1aXJlKCdlc3V0aWxzJyk7XG5cbiAgICBTeW50YXggPSBlc3RyYXZlcnNlLlN5bnRheDtcblxuICAgIC8vIEdlbmVyYXRpb24gaXMgZG9uZSBieSBnZW5lcmF0ZUV4cHJlc3Npb24uXG4gICAgZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIENvZGVHZW5lcmF0b3IuRXhwcmVzc2lvbi5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRpb24gaXMgZG9uZSBieSBnZW5lcmF0ZVN0YXRlbWVudC5cbiAgICBmdW5jdGlvbiBpc1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIHJldHVybiBDb2RlR2VuZXJhdG9yLlN0YXRlbWVudC5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpO1xuICAgIH1cblxuICAgIFByZWNlZGVuY2UgPSB7XG4gICAgICAgIFNlcXVlbmNlOiAwLFxuICAgICAgICBZaWVsZDogMSxcbiAgICAgICAgQXNzaWdubWVudDogMSxcbiAgICAgICAgQ29uZGl0aW9uYWw6IDIsXG4gICAgICAgIEFycm93RnVuY3Rpb246IDIsXG4gICAgICAgIExvZ2ljYWxPUjogMyxcbiAgICAgICAgTG9naWNhbEFORDogNCxcbiAgICAgICAgQml0d2lzZU9SOiA1LFxuICAgICAgICBCaXR3aXNlWE9SOiA2LFxuICAgICAgICBCaXR3aXNlQU5EOiA3LFxuICAgICAgICBFcXVhbGl0eTogOCxcbiAgICAgICAgUmVsYXRpb25hbDogOSxcbiAgICAgICAgQml0d2lzZVNISUZUOiAxMCxcbiAgICAgICAgQWRkaXRpdmU6IDExLFxuICAgICAgICBNdWx0aXBsaWNhdGl2ZTogMTIsXG4gICAgICAgIEV4cG9uZW50aWF0aW9uOiAxMyxcbiAgICAgICAgQXdhaXQ6IDE0LFxuICAgICAgICBVbmFyeTogMTQsXG4gICAgICAgIFBvc3RmaXg6IDE1LFxuICAgICAgICBDYWxsOiAxNixcbiAgICAgICAgTmV3OiAxNyxcbiAgICAgICAgVGFnZ2VkVGVtcGxhdGU6IDE4LFxuICAgICAgICBNZW1iZXI6IDE5LFxuICAgICAgICBQcmltYXJ5OiAyMFxuICAgIH07XG5cbiAgICBCaW5hcnlQcmVjZWRlbmNlID0ge1xuICAgICAgICAnfHwnOiBQcmVjZWRlbmNlLkxvZ2ljYWxPUixcbiAgICAgICAgJyYmJzogUHJlY2VkZW5jZS5Mb2dpY2FsQU5ELFxuICAgICAgICAnfCc6IFByZWNlZGVuY2UuQml0d2lzZU9SLFxuICAgICAgICAnXic6IFByZWNlZGVuY2UuQml0d2lzZVhPUixcbiAgICAgICAgJyYnOiBQcmVjZWRlbmNlLkJpdHdpc2VBTkQsXG4gICAgICAgICc9PSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICchPSc6IFByZWNlZGVuY2UuRXF1YWxpdHksXG4gICAgICAgICc9PT0nOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnIT09JzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJ2lzJzogUHJlY2VkZW5jZS5FcXVhbGl0eSxcbiAgICAgICAgJ2lzbnQnOiBQcmVjZWRlbmNlLkVxdWFsaXR5LFxuICAgICAgICAnPCc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJz4nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICc8PSc6IFByZWNlZGVuY2UuUmVsYXRpb25hbCxcbiAgICAgICAgJz49JzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnaW4nOiBQcmVjZWRlbmNlLlJlbGF0aW9uYWwsXG4gICAgICAgICdpbnN0YW5jZW9mJzogUHJlY2VkZW5jZS5SZWxhdGlvbmFsLFxuICAgICAgICAnPDwnOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJz4+JzogUHJlY2VkZW5jZS5CaXR3aXNlU0hJRlQsXG4gICAgICAgICc+Pj4nOiBQcmVjZWRlbmNlLkJpdHdpc2VTSElGVCxcbiAgICAgICAgJysnOiBQcmVjZWRlbmNlLkFkZGl0aXZlLFxuICAgICAgICAnLSc6IFByZWNlZGVuY2UuQWRkaXRpdmUsXG4gICAgICAgICcqJzogUHJlY2VkZW5jZS5NdWx0aXBsaWNhdGl2ZSxcbiAgICAgICAgJyUnOiBQcmVjZWRlbmNlLk11bHRpcGxpY2F0aXZlLFxuICAgICAgICAnLyc6IFByZWNlZGVuY2UuTXVsdGlwbGljYXRpdmUsXG4gICAgICAgICcqKic6IFByZWNlZGVuY2UuRXhwb25lbnRpYXRpb25cbiAgICB9O1xuXG4gICAgLy9GbGFnc1xuICAgIHZhciBGX0FMTE9XX0lOID0gMSxcbiAgICAgICAgRl9BTExPV19DQUxMID0gMSA8PCAxLFxuICAgICAgICBGX0FMTE9XX1VOUEFSQVRIX05FVyA9IDEgPDwgMixcbiAgICAgICAgRl9GVU5DX0JPRFkgPSAxIDw8IDMsXG4gICAgICAgIEZfRElSRUNUSVZFX0NUWCA9IDEgPDwgNCxcbiAgICAgICAgRl9TRU1JQ09MT05fT1BUID0gMSA8PCA1O1xuXG4gICAgLy9FeHByZXNzaW9uIGZsYWcgc2V0c1xuICAgIC8vTk9URTogRmxhZyBvcmRlcjpcbiAgICAvLyBGX0FMTE9XX0lOXG4gICAgLy8gRl9BTExPV19DQUxMXG4gICAgLy8gRl9BTExPV19VTlBBUkFUSF9ORVdcbiAgICB2YXIgRV9GVFQgPSBGX0FMTE9XX0NBTEwgfCBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9UVEYgPSBGX0FMTE9XX0lOIHwgRl9BTExPV19DQUxMLFxuICAgICAgICBFX1RUVCA9IEZfQUxMT1dfSU4gfCBGX0FMTE9XX0NBTEwgfCBGX0FMTE9XX1VOUEFSQVRIX05FVyxcbiAgICAgICAgRV9URkYgPSBGX0FMTE9XX0lOLFxuICAgICAgICBFX0ZGVCA9IEZfQUxMT1dfVU5QQVJBVEhfTkVXLFxuICAgICAgICBFX1RGVCA9IEZfQUxMT1dfSU4gfCBGX0FMTE9XX1VOUEFSQVRIX05FVztcblxuICAgIC8vU3RhdGVtZW50IGZsYWcgc2V0c1xuICAgIC8vTk9URTogRmxhZyBvcmRlcjpcbiAgICAvLyBGX0FMTE9XX0lOXG4gICAgLy8gRl9GVU5DX0JPRFlcbiAgICAvLyBGX0RJUkVDVElWRV9DVFhcbiAgICAvLyBGX1NFTUlDT0xPTl9PUFRcbiAgICB2YXIgU19URkZGID0gRl9BTExPV19JTixcbiAgICAgICAgU19URkZUID0gRl9BTExPV19JTiB8IEZfU0VNSUNPTE9OX09QVCxcbiAgICAgICAgU19GRkZGID0gMHgwMCxcbiAgICAgICAgU19URlRGID0gRl9BTExPV19JTiB8IEZfRElSRUNUSVZFX0NUWCxcbiAgICAgICAgU19UVEZGID0gRl9BTExPV19JTiB8IEZfRlVOQ19CT0RZO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgICAgICAgYmFzZTogbnVsbCxcbiAgICAgICAgICAgIHBhcnNlOiBudWxsLFxuICAgICAgICAgICAgY29tbWVudDogZmFsc2UsXG4gICAgICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICcgICAgJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZTogMCxcbiAgICAgICAgICAgICAgICAgICAgYWRqdXN0TXVsdGlsaW5lQ29tbWVudDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld2xpbmU6ICdcXG4nLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAnICcsXG4gICAgICAgICAgICAgICAganNvbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVudW1iZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGhleGFkZWNpbWFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdW90ZXM6ICdzaW5nbGUnLFxuICAgICAgICAgICAgICAgIGVzY2FwZWxlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcmVudGhlc2VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNlbWljb2xvbnM6IHRydWUsXG4gICAgICAgICAgICAgICAgc2FmZUNvbmNhdGVuYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlQmxhbmtMaW5lczogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3o6IHtcbiAgICAgICAgICAgICAgICBjb21wcmVoZW5zaW9uRXhwcmVzc2lvblN0YXJ0c1dpdGhBc3NpZ25tZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGFybGVzc0dlbmVyYXRvcjogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IG51bGwsXG4gICAgICAgICAgICBzb3VyY2VNYXBSb290OiBudWxsLFxuICAgICAgICAgICAgc291cmNlTWFwV2l0aENvZGU6IGZhbHNlLFxuICAgICAgICAgICAgZGlyZWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgICAgIHZlcmJhdGltOiBudWxsLFxuICAgICAgICAgICAgc291cmNlQ29kZTogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1JlcGVhdChzdHIsIG51bSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgZm9yIChudW0gfD0gMDsgbnVtID4gMDsgbnVtID4+Pj0gMSwgc3RyICs9IHN0cikge1xuICAgICAgICAgICAgaWYgKG51bSAmIDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNMaW5lVGVybWluYXRvcihzdHIpIHtcbiAgICAgICAgcmV0dXJuICgvW1xcclxcbl0vZykudGVzdChzdHIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZHNXaXRoTGluZVRlcm1pbmF0b3Ioc3RyKSB7XG4gICAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuICYmIGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gb3ZlcnJpZGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZXBseSh0YXJnZXQsIG92ZXJyaWRlKSB7XG4gICAgICAgIHZhciBrZXksIHZhbDtcblxuICAgICAgICBmdW5jdGlvbiBpc0hhc2hPYmplY3QodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0ICYmICEodGFyZ2V0IGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IG92ZXJyaWRlW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGlzSGFzaE9iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hhc2hPYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEZWVwbHkodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHVwZGF0ZURlZXBseSh7fSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHBvaW50LCB0ZW1wLCBleHBvbmVudCwgcG9zO1xuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnVtZXJpYyBsaXRlcmFsIHdob3NlIHZhbHVlIGlzIE5hTicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWVyaWMgbGl0ZXJhbCB3aG9zZSB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAxIC8gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb24gPyAnbnVsbCcgOiByZW51bWJlciA/ICcxZTQwMCcgOiAnMWUrNDAwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9ICcnICsgdmFsdWU7XG4gICAgICAgIGlmICghcmVudW1iZXIgfHwgcmVzdWx0Lmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBwb2ludCA9IHJlc3VsdC5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmICghanNvbiAmJiByZXN1bHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzMCAgLyogMCAqLyAmJiBwb2ludCA9PT0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSAwO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXAgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKCdlKycsICdlJyk7XG4gICAgICAgIGV4cG9uZW50ID0gMDtcbiAgICAgICAgaWYgKChwb3MgPSB0ZW1wLmluZGV4T2YoJ2UnKSkgPiAwKSB7XG4gICAgICAgICAgICBleHBvbmVudCA9ICt0ZW1wLnNsaWNlKHBvcyArIDEpO1xuICAgICAgICAgICAgdGVtcCA9IHRlbXAuc2xpY2UoMCwgcG9zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnQgPj0gMCkge1xuICAgICAgICAgICAgZXhwb25lbnQgLT0gdGVtcC5sZW5ndGggLSBwb2ludCAtIDE7XG4gICAgICAgICAgICB0ZW1wID0gKyh0ZW1wLnNsaWNlKDAsIHBvaW50KSArIHRlbXAuc2xpY2UocG9pbnQgKyAxKSkgKyAnJztcbiAgICAgICAgfVxuICAgICAgICBwb3MgPSAwO1xuICAgICAgICB3aGlsZSAodGVtcC5jaGFyQ29kZUF0KHRlbXAubGVuZ3RoICsgcG9zIC0gMSkgPT09IDB4MzAgIC8qIDAgKi8pIHtcbiAgICAgICAgICAgIC0tcG9zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgIT09IDApIHtcbiAgICAgICAgICAgIGV4cG9uZW50IC09IHBvcztcbiAgICAgICAgICAgIHRlbXAgPSB0ZW1wLnNsaWNlKDAsIHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9uZW50ICE9PSAwKSB7XG4gICAgICAgICAgICB0ZW1wICs9ICdlJyArIGV4cG9uZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGVtcC5sZW5ndGggPCByZXN1bHQubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIChoZXhhZGVjaW1hbCAmJiB2YWx1ZSA+IDFlMTIgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlICYmICh0ZW1wID0gJzB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSkubGVuZ3RoIDwgcmVzdWx0Lmxlbmd0aCkpICYmXG4gICAgICAgICAgICAgICAgK3RlbXAgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSB2YWxpZCBSZWdFeHAgZXhwcmVzc2lvbi5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9Db25zdGVsbGF0aW9uL2l2IEVuZ2luZVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwQ2hhcmFjdGVyKGNoLCBwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgIC8vIG5vdCBoYW5kbGluZyAnXFwnIGFuZCBoYW5kbGluZyBcXHUyMDI4IG9yIFxcdTIwMjkgdG8gdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKChjaCAmIH4xKSA9PT0gMHgyMDI4KSB7XG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAndScgOiAnXFxcXHUnKSArICgoY2ggPT09IDB4MjAyOCkgPyAnMjAyOCcgOiAnMjAyOScpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAxMCB8fCBjaCA9PT0gMTMpIHsgIC8vIFxcbiwgXFxyXG4gICAgICAgICAgICByZXR1cm4gKHByZXZpb3VzSXNCYWNrc2xhc2ggPyAnJyA6ICdcXFxcJykgKyAoKGNoID09PSAxMCkgPyAnbicgOiAncicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVJlZ0V4cChyZWcpIHtcbiAgICAgICAgdmFyIG1hdGNoLCByZXN1bHQsIGZsYWdzLCBpLCBpeiwgY2gsIGNoYXJhY3RlckluQnJhY2ssIHByZXZpb3VzSXNCYWNrc2xhc2g7XG5cbiAgICAgICAgcmVzdWx0ID0gcmVnLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHJlZy5zb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIGV4dHJhY3QgZmxhZyBmcm9tIHRvU3RyaW5nIHJlc3VsdFxuICAgICAgICAgICAgbWF0Y2ggPSByZXN1bHQubWF0Y2goL1xcLyhbXi9dKikkLyk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmxhZ3MgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgICAgICAgICBjaGFyYWN0ZXJJbkJyYWNrID0gZmFsc2U7XG4gICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IHJlZy5zb3VyY2UubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIGNoID0gcmVnLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c0lzQmFja3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyYWN0ZXJJbkJyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09IDkzKSB7ICAvLyBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVySW5CcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSA0NykgeyAgLy8gL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSA5MSkgeyAgLy8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckluQnJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXIoY2gsIHByZXZpb3VzSXNCYWNrc2xhc2gpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0lzQmFja3NsYXNoID0gY2ggPT09IDkyOyAgLy8gXFxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBuZXcgUmVnRXhwKFwiXFxcXFxcbicpIGlzIHByb3ZpZGVkLCBjcmVhdGUgL1xcbi9cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZVJlZ0V4cENoYXJhY3RlcihjaCwgcHJldmlvdXNJc0JhY2tzbGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgbGlrZSAvXFxcXFsvXS9cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNJc0JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuICcvJyArIHJlc3VsdCArICcvJyArIGZsYWdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVBbGxvd2VkQ2hhcmFjdGVyKGNvZGUsIG5leHQpIHtcbiAgICAgICAgdmFyIGhleDtcblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwOCAgLyogXFxiICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxiJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDBDICAvKiBcXGYgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXGYnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MDkgIC8qIFxcdCAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdCc7XG4gICAgICAgIH1cblxuICAgICAgICBoZXggPSBjb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoanNvbiB8fCBjb2RlID4gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdScgKyAnMDAwMCcuc2xpY2UoaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDAwICYmICFlc3V0aWxzLmNvZGUuaXNEZWNpbWFsRGlnaXQobmV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXDAnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwQiAgLyogXFx2ICovKSB7IC8vICdcXHYnXG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx4MEInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxceCcgKyAnMDAnLnNsaWNlKGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlRGlzYWxsb3dlZENoYXJhY3Rlcihjb2RlKSB7XG4gICAgICAgIGlmIChjb2RlID09PSAweDVDICAvKiBcXCAqLykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcXFxcXCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gMHgwQSAgLyogXFxuICovKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFxuJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSAweDBEICAvKiBcXHIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MjAyOCkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjgnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MjAyOSkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjknO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3RseSBjbGFzc2lmaWVkIGNoYXJhY3RlcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVzY2FwZURpcmVjdGl2ZShzdHIpIHtcbiAgICAgICAgdmFyIGksIGl6LCBjb2RlLCBxdW90ZTtcblxuICAgICAgICBxdW90ZSA9IHF1b3RlcyA9PT0gJ2RvdWJsZScgPyAnXCInIDogJ1xcJyc7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RyLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAweDI3ICAvKiAnICovKSB7XG4gICAgICAgICAgICAgICAgcXVvdGUgPSAnXCInO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIyICAvKiBcIiAqLykge1xuICAgICAgICAgICAgICAgIHF1b3RlID0gJ1xcJyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgIC8qIFxcICovKSB7XG4gICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1b3RlICsgc3RyICsgcXVvdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJycsIGksIGxlbiwgY29kZSwgc2luZ2xlUXVvdGVzID0gMCwgZG91YmxlUXVvdGVzID0gMCwgc2luZ2xlLCBxdW90ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAweDI3ICAvKiAnICovKSB7XG4gICAgICAgICAgICAgICAgKytzaW5nbGVRdW90ZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgIC8qIFwiICovKSB7XG4gICAgICAgICAgICAgICAgKytkb3VibGVRdW90ZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MkYgIC8qIC8gKi8gJiYganNvbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxcXCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpIHx8IGNvZGUgPT09IDB4NUMgIC8qIFxcICovKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIoY29kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShjb2RlKSAmJiAoanNvbiAmJiBjb2RlIDwgMHgyMCAgLyogU1AgKi8gfHwgIWpzb24gJiYgIWVzY2FwZWxlc3MgJiYgKGNvZGUgPCAweDIwICAvKiBTUCAqLyB8fCBjb2RlID4gMHg3RSAgLyogfiAqLykpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGVzY2FwZUFsbG93ZWRDaGFyYWN0ZXIoY29kZSwgc3RyLmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2luZ2xlID0gIShxdW90ZXMgPT09ICdkb3VibGUnIHx8IChxdW90ZXMgPT09ICdhdXRvJyAmJiBkb3VibGVRdW90ZXMgPCBzaW5nbGVRdW90ZXMpKTtcbiAgICAgICAgcXVvdGUgPSBzaW5nbGUgPyAnXFwnJyA6ICdcIic7XG5cbiAgICAgICAgaWYgKCEoc2luZ2xlID8gc2luZ2xlUXVvdGVzIDogZG91YmxlUXVvdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlICsgcmVzdWx0ICsgcXVvdGU7XG4gICAgICAgIH1cblxuICAgICAgICBzdHIgPSByZXN1bHQ7XG4gICAgICAgIHJlc3VsdCA9IHF1b3RlO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKChjb2RlID09PSAweDI3ICAvKiAnICovICYmIHNpbmdsZSkgfHwgKGNvZGUgPT09IDB4MjIgIC8qIFwiICovICYmICFzaW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHF1b3RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZsYXR0ZW4gYW4gYXJyYXkgdG8gYSBzdHJpbmcsIHdoZXJlIHRoZSBhcnJheSBjYW4gY29udGFpblxuICAgICAqIGVpdGhlciBzdHJpbmdzIG9yIG5lc3RlZCBhcnJheXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuVG9TdHJpbmcoYXJyKSB7XG4gICAgICAgIHZhciBpLCBpeiwgZWxlbSwgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gYXJyLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGVsZW0gPSBhcnJbaV07XG4gICAgICAgICAgICByZXN1bHQgKz0gQXJyYXkuaXNBcnJheShlbGVtKSA/IGZsYXR0ZW5Ub1N0cmluZyhlbGVtKSA6IGVsZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGdlbmVyYXRlZCB0byBhIFNvdXJjZU5vZGUgd2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGdlbmVyYXRlZCwgbm9kZSkge1xuICAgICAgICBpZiAoIXNvdXJjZU1hcCkge1xuICAgICAgICAgICAgLy8gd2l0aCBubyBzb3VyY2UgbWFwcywgZ2VuZXJhdGVkIGlzIGVpdGhlciBhblxuICAgICAgICAgICAgLy8gYXJyYXkgb3IgYSBzdHJpbmcuICBpZiBhbiBhcnJheSwgZmxhdHRlbiBpdC5cbiAgICAgICAgICAgIC8vIGlmIGEgc3RyaW5nLCBqdXN0IHJldHVybiBpdFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VuZXJhdGVkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVG9TdHJpbmcoZ2VuZXJhdGVkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkIGluc3RhbmNlb2YgU291cmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5sb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIHNvdXJjZU1hcCwgZ2VuZXJhdGVkLCBub2RlLm5hbWUgfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VOb2RlKG5vZGUubG9jLnN0YXJ0LmxpbmUsIG5vZGUubG9jLnN0YXJ0LmNvbHVtbiwgKHNvdXJjZU1hcCA9PT0gdHJ1ZSA/IG5vZGUubG9jLnNvdXJjZSB8fCBudWxsIDogc291cmNlTWFwKSwgZ2VuZXJhdGVkLCBub2RlLm5hbWUgfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9FbXB0eVNwYWNlKCkge1xuICAgICAgICByZXR1cm4gKHNwYWNlKSA/IHNwYWNlIDogJyAnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGpvaW4obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgdmFyIGxlZnRTb3VyY2UsXG4gICAgICAgICAgICByaWdodFNvdXJjZSxcbiAgICAgICAgICAgIGxlZnRDaGFyQ29kZSxcbiAgICAgICAgICAgIHJpZ2h0Q2hhckNvZGU7XG5cbiAgICAgICAgbGVmdFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQobGVmdCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGxlZnRTb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW3JpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJpZ2h0U291cmNlID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyaWdodCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHJpZ2h0U291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlZnRDaGFyQ29kZSA9IGxlZnRTb3VyY2UuY2hhckNvZGVBdChsZWZ0U291cmNlLmxlbmd0aCAtIDEpO1xuICAgICAgICByaWdodENoYXJDb2RlID0gcmlnaHRTb3VyY2UuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBpZiAoKGxlZnRDaGFyQ29kZSA9PT0gMHgyQiAgLyogKyAqLyB8fCBsZWZ0Q2hhckNvZGUgPT09IDB4MkQgIC8qIC0gKi8pICYmIGxlZnRDaGFyQ29kZSA9PT0gcmlnaHRDaGFyQ29kZSB8fFxuICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUobGVmdENoYXJDb2RlKSAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShyaWdodENoYXJDb2RlKSB8fFxuICAgICAgICAgICAgbGVmdENoYXJDb2RlID09PSAweDJGICAvKiAvICovICYmIHJpZ2h0Q2hhckNvZGUgPT09IDB4NjkgIC8qIGkgKi8pIHsgLy8gaW5maXggd29yZCBvcGVyYXRvcnMgYWxsIHN0YXJ0IHdpdGggYGlgXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIG5vRW1wdHlTcGFjZSgpLCByaWdodF07XG4gICAgICAgIH0gZWxzZSBpZiAoZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShsZWZ0Q2hhckNvZGUpIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGxlZnRDaGFyQ29kZSkgfHxcbiAgICAgICAgICAgICAgICBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKHJpZ2h0Q2hhckNvZGUpIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKHJpZ2h0Q2hhckNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2xlZnQsIHNwYWNlLCByaWdodF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkSW5kZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIFtiYXNlLCBzdG10XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3aXRoSW5kZW50KGZuKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0Jhc2U7XG4gICAgICAgIHByZXZpb3VzQmFzZSA9IGJhc2U7XG4gICAgICAgIGJhc2UgKz0gaW5kZW50O1xuICAgICAgICBmbihiYXNlKTtcbiAgICAgICAgYmFzZSA9IHByZXZpb3VzQmFzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVTcGFjZXMoc3RyKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihzdHIuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0ci5sZW5ndGggLSAxKSAtIGk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRqdXN0TXVsdGlsaW5lQ29tbWVudCh2YWx1ZSwgc3BlY2lhbEJhc2UpIHtcbiAgICAgICAgdmFyIGFycmF5LCBpLCBsZW4sIGxpbmUsIGosIHNwYWNlcywgcHJldmlvdXNCYXNlLCBzbjtcblxuICAgICAgICBhcnJheSA9IHZhbHVlLnNwbGl0KC9cXHJcXG58W1xcclxcbl0vKTtcbiAgICAgICAgc3BhY2VzID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICAvLyBmaXJzdCBsaW5lIGRvZXNuJ3QgaGF2ZSBpbmRlbnRhdGlvblxuICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgbGluZSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaiA8IGxpbmUubGVuZ3RoICYmIGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UobGluZS5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICsrajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGFjZXMgPiBqKSB7XG4gICAgICAgICAgICAgICAgc3BhY2VzID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlY2lhbEJhc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBwYXR0ZXJuIGxpa2VcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICAgdmFyIHQgPSAyMDsgIC8qXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgKiB0aGlzIGlzIGNvbW1lbnRcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcHJldmlvdXNCYXNlID0gYmFzZTtcbiAgICAgICAgICAgIGlmIChhcnJheVsxXVtzcGFjZXNdID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsQmFzZSArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlID0gc3BlY2lhbEJhc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3BhY2VzICYgMSkge1xuICAgICAgICAgICAgICAgIC8vIC8qXG4gICAgICAgICAgICAgICAgLy8gICpcbiAgICAgICAgICAgICAgICAvLyAgKi9cbiAgICAgICAgICAgICAgICAvLyBJZiBzcGFjZXMgYXJlIG9kZCBudW1iZXIsIGFib3ZlIHBhdHRlcm4gaXMgY29uc2lkZXJlZC5cbiAgICAgICAgICAgICAgICAvLyBXZSB3YXN0ZSAxIHNwYWNlLlxuICAgICAgICAgICAgICAgIC0tc3BhY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXNCYXNlID0gYmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDEsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBzbiA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQoYWRkSW5kZW50KGFycmF5W2ldLnNsaWNlKHNwYWNlcykpKTtcbiAgICAgICAgICAgIGFycmF5W2ldID0gc291cmNlTWFwID8gc24uam9pbignJykgOiBzbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2UgPSBwcmV2aW91c0Jhc2U7XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlQ29tbWVudChjb21tZW50LCBzcGVjaWFsQmFzZSkge1xuICAgICAgICBpZiAoY29tbWVudC50eXBlID09PSAnTGluZScpIHtcbiAgICAgICAgICAgIGlmIChlbmRzV2l0aExpbmVUZXJtaW5hdG9yKGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcvLycgKyBjb21tZW50LnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNlIExpbmVUZXJtaW5hdG9yXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICcvLycgKyBjb21tZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghcHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmEuZm9ybWF0LmluZGVudC5hZGp1c3RNdWx0aWxpbmVDb21tZW50ICYmIC9bXFxuXFxyXS8udGVzdChjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkanVzdE11bHRpbGluZUNvbW1lbnQoJy8qJyArIGNvbW1lbnQudmFsdWUgKyAnKi8nLCBzcGVjaWFsQmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcvKicgKyBjb21tZW50LnZhbHVlICsgJyovJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDb21tZW50cyhzdG10LCByZXN1bHQpIHtcbiAgICAgICAgdmFyIGksIGxlbiwgY29tbWVudCwgc2F2ZSwgdGFpbGluZ1RvU3RhdGVtZW50LCBzcGVjaWFsQmFzZSwgZnJhZ21lbnQsXG4gICAgICAgICAgICBleHRSYW5nZSwgcmFuZ2UsIHByZXZSYW5nZSwgcHJlZml4LCBpbmZpeCwgc3VmZml4LCBjb3VudDtcblxuICAgICAgICBpZiAoc3RtdC5sZWFkaW5nQ29tbWVudHMgJiYgc3RtdC5sZWFkaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgc2F2ZSA9IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1swXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGV4dFJhbmdlID0gY29tbWVudC5leHRlbmRlZFJhbmdlO1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tbWVudC5yYW5nZTtcblxuICAgICAgICAgICAgICAgIHByZWZpeCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKGV4dFJhbmdlWzBdLCByYW5nZVswXSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSAocHJlZml4Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0cmluZ1JlcGVhdCgnXFxuJywgY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KGdlbmVyYXRlQ29tbWVudChjb21tZW50KSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldlJhbmdlID0gcmFuZ2U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBzdG10LmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gY29tbWVudC5yYW5nZTtcblxuICAgICAgICAgICAgICAgICAgICBpbmZpeCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKHByZXZSYW5nZVsxXSwgcmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgICAgICBjb3VudCA9IChpbmZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0cmluZ1JlcGVhdCgnXFxuJywgY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KGdlbmVyYXRlQ29tbWVudChjb21tZW50KSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHNvdXJjZUNvZGUuc3Vic3RyaW5nKHJhbmdlWzFdLCBleHRSYW5nZVsxXSk7XG4gICAgICAgICAgICAgICAgY291bnQgPSAoc3VmZml4Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzdHJpbmdSZXBlYXQoJ1xcbicsIGNvdW50KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LmxlYWRpbmdDb21tZW50c1swXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc2FmZUNvbmNhdGVuYXRpb24gJiYgc3RtdC50eXBlID09PSBTeW50YXguUHJvZ3JhbSAmJiBzdG10LmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVDb21tZW50KGNvbW1lbnQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBzdG10LmxlYWRpbmdDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gc3RtdC5sZWFkaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gW2dlbmVyYXRlQ29tbWVudChjb21tZW50KV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KGZyYWdtZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoc2F2ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0bXQudHJhaWxpbmdDb21tZW50cykge1xuXG4gICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHN0bXQudHJhaWxpbmdDb21tZW50c1swXTtcbiAgICAgICAgICAgICAgICBleHRSYW5nZSA9IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZTtcbiAgICAgICAgICAgICAgICByYW5nZSA9IGNvbW1lbnQucmFuZ2U7XG5cbiAgICAgICAgICAgICAgICBwcmVmaXggPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhleHRSYW5nZVswXSwgcmFuZ2VbMF0pO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gKHByZWZpeC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHN0cmluZ1JlcGVhdCgnXFxuJywgY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KGdlbmVyYXRlQ29tbWVudChjb21tZW50KSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlQ29tbWVudChjb21tZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWlsaW5nVG9TdGF0ZW1lbnQgPSAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgc3BlY2lhbEJhc2UgPSBzdHJpbmdSZXBlYXQoJyAnLCBjYWxjdWxhdGVTcGFjZXModG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChbYmFzZSwgcmVzdWx0LCBpbmRlbnRdKS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RtdC50cmFpbGluZ0NvbW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBzdG10LnRyYWlsaW5nQ29tbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWlsaW5nVG9TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0YXJnZXQgbGlrZSBmb2xsb3dpbmcgc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHQgPSAyMDsgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAqIFRoaXMgaXMgY29tbWVudCBvZiB0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcnN0IGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBpbmRlbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbcmVzdWx0LCBzcGVjaWFsQmFzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCwgc3BlY2lhbEJhc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIGFkZEluZGVudChnZW5lcmF0ZUNvbW1lbnQoY29tbWVudCkpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gbGVuIC0gMSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtyZXN1bHQsICdcXG4nXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVCbGFua0xpbmVzKHN0YXJ0LCBlbmQsIHJlc3VsdCkge1xuICAgICAgICB2YXIgaiwgbmV3bGluZUNvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGogPSBzdGFydDsgaiA8IGVuZDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlQ29kZVtqXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBuZXdsaW5lQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBuZXdsaW5lQ291bnQ7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRoZXNpemUodGV4dCwgY3VycmVudCwgc2hvdWxkKSB7XG4gICAgICAgIGlmIChjdXJyZW50IDwgc2hvdWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gWycoJywgdGV4dCwgJyknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlcmJhdGltU3RyaW5nKHN0cmluZykge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0ID0gc3RyaW5nLnNwbGl0KC9cXHJcXG58XFxuLyk7XG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gcmVzdWx0Lmxlbmd0aDsgaSA8IGl6OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IG5ld2xpbmUgKyBiYXNlICsgcmVzdWx0W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVWZXJiYXRpbShleHByLCBwcmVjZWRlbmNlKSB7XG4gICAgICAgIHZhciB2ZXJiYXRpbSwgcmVzdWx0LCBwcmVjO1xuICAgICAgICB2ZXJiYXRpbSA9IGV4cHJbZXh0cmEudmVyYmF0aW1dO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmVyYmF0aW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUoZ2VuZXJhdGVWZXJiYXRpbVN0cmluZyh2ZXJiYXRpbSksIFByZWNlZGVuY2UuU2VxdWVuY2UsIHByZWNlZGVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdmVyYmF0aW0gaXMgb2JqZWN0XG4gICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVZlcmJhdGltU3RyaW5nKHZlcmJhdGltLmNvbnRlbnQpO1xuICAgICAgICAgICAgcHJlYyA9ICh2ZXJiYXRpbS5wcmVjZWRlbmNlICE9IG51bGwpID8gdmVyYmF0aW0ucHJlY2VkZW5jZSA6IFByZWNlZGVuY2UuU2VxdWVuY2U7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJlbnRoZXNpemUocmVzdWx0LCBwcmVjLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCwgZXhwcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ29kZUdlbmVyYXRvcigpIHtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzLlxuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUubWF5YmVCbG9jayA9IGZ1bmN0aW9uKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQsIG5vTGVhZGluZ0NvbW1lbnQsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIG5vTGVhZGluZ0NvbW1lbnQgPSAhZXh0cmEuY29tbWVudCB8fCAhc3RtdC5sZWFkaW5nQ29tbWVudHM7XG5cbiAgICAgICAgaWYgKHN0bXQudHlwZSA9PT0gU3ludGF4LkJsb2NrU3RhdGVtZW50ICYmIG5vTGVhZGluZ0NvbW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbc3BhY2UsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdCwgZmxhZ3MpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG10LnR5cGUgPT09IFN5bnRheC5FbXB0eVN0YXRlbWVudCAmJiBub0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICB9XG5cbiAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgbmV3bGluZSxcbiAgICAgICAgICAgICAgICBhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LCBmbGFncykpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5tYXliZUJsb2NrU3VmZml4ID0gZnVuY3Rpb24gKHN0bXQsIHJlc3VsdCkge1xuICAgICAgICB2YXIgZW5kcyA9IGVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguQmxvY2tTdGF0ZW1lbnQgJiYgKCFleHRyYS5jb21tZW50IHx8ICFzdG10LmxlYWRpbmdDb21tZW50cykgJiYgIWVuZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0LCBzcGFjZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbcmVzdWx0LCBiYXNlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3Jlc3VsdCwgbmV3bGluZSwgYmFzZV07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSWRlbnRpZmllcihub2RlKSB7XG4gICAgICAgIHJldHVybiB0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKG5vZGUubmFtZSwgbm9kZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVBc3luY1ByZWZpeChub2RlLCBzcGFjZVJlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBub2RlLmFzeW5jID8gJ2FzeW5jJyArIChzcGFjZVJlcXVpcmVkID8gbm9FbXB0eVNwYWNlKCkgOiBzcGFjZSkgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVN0YXJTdWZmaXgobm9kZSkge1xuICAgICAgICB2YXIgaXNHZW5lcmF0b3IgPSBub2RlLmdlbmVyYXRvciAmJiAhZXh0cmEubW96LnN0YXJsZXNzR2VuZXJhdG9yO1xuICAgICAgICByZXR1cm4gaXNHZW5lcmF0b3IgPyAnKicgKyBzcGFjZSA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTWV0aG9kUHJlZml4KHByb3ApIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBwcm9wLnZhbHVlLCBwcmVmaXggPSAnJztcbiAgICAgICAgaWYgKGZ1bmMuYXN5bmMpIHtcbiAgICAgICAgICAgIHByZWZpeCArPSBnZW5lcmF0ZUFzeW5jUHJlZml4KGZ1bmMsICFwcm9wLmNvbXB1dGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuYy5nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIC8vIGF2b2lkIHNwYWNlIGJlZm9yZSBtZXRob2QgbmFtZVxuICAgICAgICAgICAgcHJlZml4ICs9IGdlbmVyYXRlU3RhclN1ZmZpeChmdW5jKSA/ICcqJyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmVmaXg7XG4gICAgfVxuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVQYXR0ZXJuID0gZnVuY3Rpb24gKG5vZGUsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVJZGVudGlmaWVyKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgaSwgaXosIHJlc3VsdCwgaGFzRGVmYXVsdDtcblxuICAgICAgICBoYXNEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uICYmXG4gICAgICAgICAgICAgICAgIW5vZGUucmVzdCAmJiAoIW5vZGUuZGVmYXVsdHMgfHwgbm9kZS5kZWZhdWx0cy5sZW5ndGggPT09IDApICYmXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmIG5vZGUucGFyYW1zWzBdLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBhcmcgPT4geyB9IGNhc2VcbiAgICAgICAgICAgIHJlc3VsdCA9IFtnZW5lcmF0ZUFzeW5jUHJlZml4KG5vZGUsIHRydWUpLCBnZW5lcmF0ZUlkZW50aWZpZXIobm9kZS5wYXJhbXNbMF0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uID8gW2dlbmVyYXRlQXN5bmNQcmVmaXgobm9kZSwgZmFsc2UpXSA6IFtdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgIGlmIChub2RlLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaGFzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IG5vZGUucGFyYW1zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRGVmYXVsdCAmJiBub2RlLmRlZmF1bHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUFzc2lnbm1lbnQobm9kZS5wYXJhbXNbaV0sIG5vZGUuZGVmYXVsdHNbaV0sICc9JywgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVQYXR0ZXJuKG5vZGUucGFyYW1zW2ldLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnJlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJy4uLicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihub2RlLnJlc3QpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgZXhwcjtcblxuICAgICAgICByZXN1bHQgPSB0aGlzLmdlbmVyYXRlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnPT4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIGV4cHIgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLmJvZHksIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpO1xuICAgICAgICAgICAgaWYgKGV4cHIudG9TdHJpbmcoKS5jaGFyQXQoMCkgPT09ICd7Jykge1xuICAgICAgICAgICAgICAgIGV4cHIgPSBbJygnLCBleHByLCAnKSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhwcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2sobm9kZS5ib2R5LCBTX1RURkYpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlSXRlcmF0aW9uRm9yU3RhdGVtZW50ID0gZnVuY3Rpb24gKG9wZXJhdG9yLCBzdG10LCBmbGFncykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gWydmb3InICsgKHN0bXQuYXdhaXQgPyBub0VtcHR5U3BhY2UoKSArICdhd2FpdCcgOiAnJykgKyBzcGFjZSArICcoJ10sIHRoYXQgPSB0aGlzO1xuICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzdG10LmxlZnQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3RtdC5sZWZ0LmtpbmQgKyBub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5sZWZ0LmRlY2xhcmF0aW9uc1swXSwgU19GRkZGKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQubGVmdCwgUHJlY2VkZW5jZS5DYWxsLCBFX1RUVCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgb3BlcmF0b3IpO1xuICAgICAgICAgICAgcmVzdWx0ID0gW2pvaW4oXG4gICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQucmlnaHQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICApLCAnKSddO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuYm9keSwgZmxhZ3MpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVQcm9wZXJ0eUtleSA9IGZ1bmN0aW9uIChleHByLCBjb21wdXRlZCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKGNvbXB1dGVkKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnWycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwciwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuXG4gICAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIENvZGVHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlQXNzaWdubWVudCA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgb3BlcmF0b3IsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIGlmIChQcmVjZWRlbmNlLkFzc2lnbm1lbnQgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihsZWZ0LCBQcmVjZWRlbmNlLkNhbGwsIGZsYWdzKSxcbiAgICAgICAgICAgICAgICBzcGFjZSArIG9wZXJhdG9yICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24ocmlnaHQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LFxuICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBDb2RlR2VuZXJhdG9yLnByb3RvdHlwZS5zZW1pY29sb24gPSBmdW5jdGlvbiAoZmxhZ3MpIHtcbiAgICAgICAgaWYgKCFzZW1pY29sb25zICYmIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc7JztcbiAgICB9O1xuXG4gICAgLy8gU3RhdGVtZW50cy5cblxuICAgIENvZGVHZW5lcmF0b3IuU3RhdGVtZW50ID0ge1xuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSwgY29udGVudCwgcmVzdWx0ID0gWyd7JywgbmV3bGluZV0sIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgZnVuY3Rpb25zIHdpdGhvdXQgYW55IGNvZGVcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5ib2R5Lmxlbmd0aCA9PT0gMCAmJiBwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzdG10LnJhbmdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VbMV0gLSByYW5nZVswXSA+IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVswXSArIDEsIHJhbmdlWzFdIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbJ3snXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGksIGl6LCBmcmFnbWVudCwgYm9keUZsYWdzO1xuICAgICAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZGRjtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBGX0ZVTkNfQk9EWSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9ESVJFQ1RJVkVfQ1RYO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlcnZlQmxhbmtMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZWZvcmUgdGhlIGZpcnN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzdG10LmJvZHlbMF0ubGVhZGluZ0NvbW1lbnRzWzBdLmV4dGVuZGVkUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBzb3VyY2VDb2RlLnN1YnN0cmluZyhyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsneyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5WzBdLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5yYW5nZVswXSwgc3RtdC5ib2R5WzBdLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZXR3ZWVuIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpIC0gMV0udHJhaWxpbmdDb21tZW50cyAgJiYgIXN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVCbGFua0xpbmVzKHN0bXQuYm9keVtpIC0gMV0ucmFuZ2VbMV0sIHN0bXQuYm9keVtpXS5yYW5nZVswXSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaXogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5RmxhZ3MgfD0gRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMgJiYgcHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5W2ldLCBib2R5RmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMgJiYgaSA8IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBhIG5ldyBsaW5lIGlmIHRoZXJlIGFyZSBsZWFkaW5nIGNvbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbmV4dCBzdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpICsgMV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BhY2VzIGFmdGVyIHRoZSBsYXN0IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpXS50cmFpbGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQmxhbmtMaW5lcyhzdG10LmJvZHlbaV0ucmFuZ2VbMV0sIHN0bXQucmFuZ2VbMV0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCgnfScpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQubGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2JyZWFrICcgKyBzdG10LmxhYmVsLm5hbWUgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2JyZWFrJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICBpZiAoc3RtdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY29udGludWUgJyArIHN0bXQubGFiZWwubmFtZSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnY29udGludWUnICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzQm9keTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAneycsIG5ld2xpbmVdLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmJvZHkubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmJvZHlbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgID0gWydjbGFzcyddO1xuICAgICAgICAgICAgaWYgKHN0bXQuaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5pZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LnN1cGVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oJ2V4dGVuZHMnLCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnN1cGVyQ2xhc3MsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5ib2R5LCBTX1RGRlQpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRGlyZWN0aXZlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHRyYS5yYXcgJiYgc3RtdC5yYXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RtdC5yYXcgKyB0aGlzLnNlbWljb2xvbihmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRGlyZWN0aXZlKHN0bXQuZGlyZWN0aXZlKSArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBEb1doaWxlU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgYGRvIDQyIHdoaWxlIChjb25kKWAgaXMgU3ludGF4IEVycm9yLiBXZSBuZWVkIHNlbWljb2xvbi5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKCdkbycsIHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIFNfVEZGRikpO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICd3aGlsZScgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAnKScgKyB0aGlzLnNlbWljb2xvbihmbGFncylcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIENhdGNoQ2xhdXNlOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGd1YXJkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0bXQucGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhdGNoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5wYXJhbSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZ3VhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGd1YXJkID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5ndWFyZCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNwbGljZSgyLCAwLCAnIGlmICcsIGd1YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnY2F0Y2gnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RlYnVnZ2VyJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBFbXB0eVN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJzsnO1xuICAgICAgICB9LFxuXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAnZXhwb3J0JyBdLCBib2R5RmxhZ3M7XG5cbiAgICAgICAgICAgIGJvZHlGbGFncyA9IChmbGFncyAmIEZfU0VNSUNPTE9OX09QVCkgPyBTX1RGRlQgOiBTX1RGRkY7XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IEhvaXN0YWJsZURlY2xhcmF0aW9uW0RlZmF1bHRdXG4gICAgICAgICAgICAvLyBleHBvcnQgZGVmYXVsdCBBc3NpZ25tZW50RXhwcmVzc2lvbltJbl0gO1xuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdkZWZhdWx0Jyk7XG4gICAgICAgICAgICBpZiAoaXNTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmRlY2xhcmF0aW9uLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuZGVjbGFyYXRpb24sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRXhwb3J0TmFtZWREZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyAnZXhwb3J0JyBdLCBib2R5RmxhZ3MsIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBib2R5RmxhZ3MgPSAoZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpID8gU19URkZUIDogU19URkZGO1xuXG4gICAgICAgICAgICAvLyBleHBvcnQgVmFyaWFibGVTdGF0ZW1lbnRcbiAgICAgICAgICAgIC8vIGV4cG9ydCBEZWNsYXJhdGlvbltEZWZhdWx0XVxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5kZWNsYXJhdGlvbiwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4cG9ydCBFeHBvcnRDbGF1c2VbTm9SZWZlcmVuY2VdIEZyb21DbGF1c2UgO1xuICAgICAgICAgICAgLy8gZXhwb3J0IEV4cG9ydENsYXVzZSA7XG4gICAgICAgICAgICBpZiAoc3RtdC5zcGVjaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICd7JyArIHNwYWNlICsgJ30nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0bXQuc3BlY2lmaWVyc1swXS50eXBlID09PSBTeW50YXguRXhwb3J0QmF0Y2hTcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1swXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgJ3snKTtcbiAgICAgICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5zcGVjaWZpZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tpXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChiYXNlICsgJ30nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmcm9tJyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9kdWxlU3BlY2lmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuc2VtaWNvbG9uKGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRBbGxEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBleHBvcnQgKiBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2V4cG9ydCcgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAnKicgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0NsYXNzUHJlZml4ZWQoZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuc2xpY2UoMCwgNSkgIT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdCg1KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZSA9PT0gMHg3QiAgLyogJ3snICovIHx8IGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY29kZSkgfHwgZXN1dGlscy5jb2RlLmlzTGluZVRlcm1pbmF0b3IoY29kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb25QcmVmaXhlZChmcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlO1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZSgwLCA4KSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvZGUgPSBmcmFnbWVudC5jaGFyQ29kZUF0KDgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlID09PSAweDI4IC8qICcoJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGNvZGUgPT09IDB4MkEgIC8qICcqJyAqLyB8fCBlc3V0aWxzLmNvZGUuaXNMaW5lVGVybWluYXRvcihjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaXNBc3luY1ByZWZpeGVkKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUsIGksIGl6O1xuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZSgwLCA1KSAhPT0gJ2FzeW5jJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZXN1dGlscy5jb2RlLmlzV2hpdGVTcGFjZShmcmFnbWVudC5jaGFyQ29kZUF0KDUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDYsIGl6ID0gZnJhZ21lbnQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoZnJhZ21lbnQuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5zbGljZShpLCBpICsgOCkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlID0gZnJhZ21lbnQuY2hhckNvZGVBdChpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvZGUgPT09IDB4MjggLyogJygnICovIHx8IGVzdXRpbHMuY29kZS5pc1doaXRlU3BhY2UoY29kZSkgfHwgY29kZSA9PT0gMHgyQSAgLyogJyonICovIHx8IGVzdXRpbHMuY29kZS5pc0xpbmVUZXJtaW5hdG9yKGNvZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5leHByZXNzaW9uLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCldO1xuICAgICAgICAgICAgLy8gMTIuNCAneycsICdmdW5jdGlvbicsICdjbGFzcycgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBwb3NpdGlvbi5cbiAgICAgICAgICAgIC8vIHdyYXAgZXhwcmVzc2lvbiB3aXRoIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4N0IgIC8qICd7JyAqLyB8fCAgLy8gT2JqZWN0RXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBpc0NsYXNzUHJlZml4ZWQoZnJhZ21lbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb25QcmVmaXhlZChmcmFnbWVudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgaXNBc3luY1ByZWZpeGVkKGZyYWdtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZGlyZWN0aXZlICYmIChmbGFncyAmIEZfRElSRUNUSVZFX0NUWCkgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFN5bnRheC5MaXRlcmFsICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnKCcsIHJlc3VsdCwgJyknICsgdGhpcy5zZW1pY29sb24oZmxhZ3MpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgLy8gRVM2OiAxNS4yLjEgdmFsaWQgaW1wb3J0IGRlY2xhcmF0aW9uczpcbiAgICAgICAgICAgIC8vICAgICAtIGltcG9ydCBJbXBvcnRDbGF1c2UgRnJvbUNsYXVzZSA7XG4gICAgICAgICAgICAvLyAgICAgLSBpbXBvcnQgTW9kdWxlU3BlY2lmaWVyIDtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGN1cnNvciwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIElmIG5vIEltcG9ydENsYXVzZSBpcyBwcmVzZW50LFxuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgYGltcG9ydCBNb2R1bGVTcGVjaWZpZXJgIHNvIHNraXAgYGZyb21gXG4gICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXIgaXMgU3RyaW5nTGl0ZXJhbC5cbiAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaW1wb3J0IE1vZHVsZVNwZWNpZmllciA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgJ2ltcG9ydCcsXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5zb3VyY2UsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmxhZ3MpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW1wb3J0IEltcG9ydENsYXVzZSBGcm9tQ2xhdXNlIDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAnaW1wb3J0J1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGN1cnNvciA9IDA7XG5cbiAgICAgICAgICAgIC8vIEltcG9ydGVkQmluZGluZ1xuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLnR5cGUgPT09IFN5bnRheC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICArK2N1cnNvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnNwZWNpZmllcnNbY3Vyc29yXS50eXBlID09PSBTeW50YXguSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5hbWVTcGFjZUltcG9ydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuc3BlY2lmaWVyc1tjdXJzb3JdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmFtZWRJbXBvcnRzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlICsgJ3snKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKHN0bXQuc3BlY2lmaWVycy5sZW5ndGggLSBjdXJzb3IpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbXBvcnQgeyAuLi4gfSBmcm9tIFwiLi4uXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbY3Vyc29yXSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNwYWNlICsgJ30nICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1wb3J0IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIC4uLixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZnJvbSBcIi4uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IGN1cnNvciwgaXogPSBzdG10LnNwZWNpZmllcnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNwZWNpZmllcnNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYmFzZSArICd9JyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIFtcbiAgICAgICAgICAgICAgICAnZnJvbScgKyBzcGFjZSxcbiAgICAgICAgICAgICAgICAvLyBNb2R1bGVTcGVjaWZpZXJcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnNvdXJjZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uKGZsYWdzKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUZsYWdzID0gKGZsYWdzICYgRl9BTExPV19JTikgPyBFX1RUVCA6IEVfRlRUO1xuICAgICAgICAgICAgaWYgKHN0bXQuaW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaWQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgaXRlbUZsYWdzKSxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICc9JyxcbiAgICAgICAgICAgICAgICAgICAgc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaW5pdCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBpdGVtRmxhZ3MpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUGF0dGVybihzdG10LmlkLCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIGl0ZW1GbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZURlY2xhcmF0b3IgaXMgdHlwZWQgYXMgU3RhdGVtZW50LFxuICAgICAgICAgICAgLy8gYnV0IGpvaW5lZCB3aXRoIGNvbW1hIChub3QgTGluZVRlcm1pbmF0b3IpLlxuICAgICAgICAgICAgLy8gU28gaWYgY29tbWVudCBpcyBhdHRhY2hlZCB0byB0YXJnZXQgbm9kZSwgd2Ugc2hvdWxkIHNwZWNpYWxpemUuXG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgbm9kZSwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgcmVzdWx0ID0gWyBzdG10LmtpbmQgXTtcblxuICAgICAgICAgICAgYm9keUZsYWdzID0gKGZsYWdzICYgRl9BTExPV19JTikgPyBTX1RGRkYgOiBTX0ZGRkY7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBzdG10LmRlY2xhcmF0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmEuY29tbWVudCAmJiBub2RlLmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFkZEluZGVudCh0aGF0LmdlbmVyYXRlU3RhdGVtZW50KG5vZGUsIGJvZHlGbGFncykpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaXogPSBzdG10LmRlY2xhcmF0aW9ucy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBzdG10LmRlY2xhcmF0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQgJiYgbm9kZS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYWRkSW5kZW50KHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgYm9keUZsYWdzKSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJywnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZVN0YXRlbWVudChub2RlLCBib2R5RmxhZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0bXQuZGVjbGFyYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGJsb2NrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmxvY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5zZW1pY29sb24oZmxhZ3MpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaHJvd1N0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gW2pvaW4oXG4gICAgICAgICAgICAgICAgJ3Rocm93JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmFyZ3VtZW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICksIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgVHJ5U3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6LCBndWFyZGVkSGFuZGxlcnM7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IFsndHJ5JywgdGhpcy5tYXliZUJsb2NrKHN0bXQuYmxvY2ssIFNfVEZGRildO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KHN0bXQuYmxvY2ssIHJlc3VsdCk7XG5cbiAgICAgICAgICAgIGlmIChzdG10LmhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgLy8gb2xkIGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc3RtdC5oYW5kbGVycy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlcnNbaV0sIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RtdC5maW5hbGl6ZXIgfHwgaSArIDEgIT09IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyc1tpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBndWFyZGVkSGFuZGxlcnMgPSBzdG10Lmd1YXJkZWRIYW5kbGVycyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZ3VhcmRlZEhhbmRsZXJzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoZ3VhcmRlZEhhbmRsZXJzW2ldLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXliZUJsb2NrU3VmZml4KGd1YXJkZWRIYW5kbGVyc1tpXS5ib2R5LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gbmV3IGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGlmIChzdG10LmhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RtdC5oYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmhhbmRsZXIubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuaGFuZGxlcltpXSwgU19URkZGKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0bXQuZmluYWxpemVyIHx8IGkgKyAxICE9PSBpeikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heWJlQmxvY2tTdWZmaXgoc3RtdC5oYW5kbGVyW2ldLmJvZHksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5oYW5kbGVyLCBTX1RGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmhhbmRsZXIuYm9keSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LmZpbmFsaXplcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbJ2ZpbmFsbHknLCB0aGlzLm1heWJlQmxvY2soc3RtdC5maW5hbGl6ZXIsIFNfVEZGRildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCBpLCBpeiwgYm9keUZsYWdzLCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ3N3aXRjaCcgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC5kaXNjcmltaW5hbnQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSxcbiAgICAgICAgICAgICAgICAgICAgJyknICsgc3BhY2UgKyAneycgKyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0bXQuY2FzZXMpIHtcbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBzdG10LmNhc2VzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGl6IC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGFkZEluZGVudCh0aGlzLmdlbmVyYXRlU3RhdGVtZW50KHN0bXQuY2FzZXNbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChhZGRJbmRlbnQoJ30nKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFN3aXRjaENhc2U6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQsIGksIGl6LCBib2R5RmxhZ3MsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQudGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2luKCdjYXNlJywgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJzonXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gWydkZWZhdWx0OiddO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIGl6ID0gc3RtdC5jb25zZXF1ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaXogJiYgc3RtdC5jb25zZXF1ZW50WzBdLnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnRbMF0sIFNfVEZGRik7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGl6ICYmICFlbmRzV2l0aExpbmVUZXJtaW5hdG9yKHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib2R5RmxhZ3MgPSBTX1RGRkY7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEgJiYgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlGbGFncyB8PSBGX1NFTUlDT0xPTl9PUFQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhhdC5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmNvbnNlcXVlbnRbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSAhPT0gaXogJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChmcmFnbWVudCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIElmU3RhdGVtZW50OiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGJvZHlGbGFncywgc2VtaWNvbG9uT3B0aW9uYWwsIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICAnaWYnICsgc3BhY2UgKyAnKCcsXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQudGVzdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW1pY29sb25PcHRpb25hbCA9IGZsYWdzICYgRl9TRU1JQ09MT05fT1BUO1xuICAgICAgICAgICAgYm9keUZsYWdzID0gU19URkZGO1xuICAgICAgICAgICAgaWYgKHNlbWljb2xvbk9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG10LmFsdGVybmF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmNvbnNlcXVlbnQsIFNfVEZGRikpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF5YmVCbG9ja1N1ZmZpeChzdG10LmNvbnNlcXVlbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0bXQuYWx0ZXJuYXRlLnR5cGUgPT09IFN5bnRheC5JZlN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgWydlbHNlICcsIHRoaXMuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5hbHRlcm5hdGUsIGJvZHlGbGFncyldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgam9pbignZWxzZScsIHRoaXMubWF5YmVCbG9jayhzdG10LmFsdGVybmF0ZSwgYm9keUZsYWdzKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5tYXliZUJsb2NrKHN0bXQuY29uc2VxdWVudCwgYm9keUZsYWdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEZvclN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsnZm9yJyArIHNwYWNlICsgJygnXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RtdC5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG10LmluaXQudHlwZSA9PT0gU3ludGF4LlZhcmlhYmxlRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVTdGF0ZW1lbnQoc3RtdC5pbml0LCBTX0ZGRkYpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZfQUxMT1dfSU4gYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKHN0bXQuaW5pdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9GVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnOycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzdG10LnRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnRlc3QsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCc7Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJzsnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RtdC51cGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LnVwZGF0ZSwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGb3JJblN0YXRlbWVudDogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCgnaW4nLCBzdG10LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJdGVyYXRpb25Gb3JTdGF0ZW1lbnQoJ29mJywgc3RtdCwgZmxhZ3MgJiBGX1NFTUlDT0xPTl9PUFQgPyBTX1RGRlQgOiBTX1RGRkYpO1xuICAgICAgICB9LFxuXG4gICAgICAgIExhYmVsZWRTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtzdG10LmxhYmVsLm5hbWUgKyAnOicsIHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgUHJvZ3JhbTogZnVuY3Rpb24gKHN0bXQsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBmcmFnbWVudCwgaSwgaXosIGJvZHlGbGFncztcbiAgICAgICAgICAgIGl6ID0gc3RtdC5ib2R5Lmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdCA9IFtzYWZlQ29uY2F0ZW5hdGlvbiAmJiBpeiA+IDAgPyAnXFxuJyA6ICcnXTtcbiAgICAgICAgICAgIGJvZHlGbGFncyA9IFNfVEZURjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzYWZlQ29uY2F0ZW5hdGlvbiAmJiBpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUZsYWdzIHw9IEZfU0VNSUNPTE9OX09QVDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBzcGFjZXMgYmVmb3JlIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVswXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5yYW5nZVswXSwgc3RtdC5ib2R5W2ldLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBiZXR3ZWVuIGxpbmVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG10LmJvZHlbaSAtIDFdLnRyYWlsaW5nQ29tbWVudHMgJiYgIXN0bXQuYm9keVtpXS5sZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2kgLSAxXS5yYW5nZVsxXSwgc3RtdC5ib2R5W2ldLnJhbmdlWzBdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBhZGRJbmRlbnQodGhpcy5nZW5lcmF0ZVN0YXRlbWVudChzdG10LmJvZHlbaV0sIGJvZHlGbGFncykpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeiAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VydmVCbGFua0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN0bXQuYm9keVtpICsgMV0ubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUJsYW5rTGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNwYWNlcyBhZnRlciB0aGUgbGFzdCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpeiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3RtdC5ib2R5W2ldLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUJsYW5rTGluZXMoc3RtdC5ib2R5W2ldLnJhbmdlWzFdLCBzdG10LnJhbmdlWzFdLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVBc3luY1ByZWZpeChzdG10LCB0cnVlKSxcbiAgICAgICAgICAgICAgICAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlU3RhclN1ZmZpeChzdG10KSB8fCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICBzdG10LmlkID8gZ2VuZXJhdGVJZGVudGlmaWVyKHN0bXQuaWQpIDogJycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShzdG10KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgaWYgKHN0bXQuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2pvaW4oXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihzdG10LmFyZ3VtZW50LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVClcbiAgICAgICAgICAgICAgICApLCB0aGlzLnNlbWljb2xvbihmbGFncyldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsncmV0dXJuJyArIHRoaXMuc2VtaWNvbG9uKGZsYWdzKV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3aGlsZScgKyBzcGFjZSArICcoJyxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oc3RtdC50ZXN0LCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgICcpJ1xuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMubWF5YmVCbG9jayhzdG10LmJvZHksIGZsYWdzICYgRl9TRU1JQ09MT05fT1BUID8gU19URkZUIDogU19URkZGKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IGZ1bmN0aW9uIChzdG10LCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgICd3aXRoJyArIHNwYWNlICsgJygnLFxuICAgICAgICAgICAgICAgICAgICB0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihzdG10Lm9iamVjdCwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpLFxuICAgICAgICAgICAgICAgICAgICAnKSdcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLm1heWJlQmxvY2soc3RtdC5ib2R5LCBmbGFncyAmIEZfU0VNSUNPTE9OX09QVCA/IFNfVEZGVCA6IFNfVEZGRikpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIG1lcmdlKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBDb2RlR2VuZXJhdG9yLlN0YXRlbWVudCk7XG5cbiAgICAvLyBFeHByZXNzaW9ucy5cblxuICAgIENvZGVHZW5lcmF0b3IuRXhwcmVzc2lvbiA9IHtcblxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICBpZiAoUHJlY2VkZW5jZS5TZXF1ZW5jZSA8IHByZWNlZGVuY2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyB8PSBGX0FMTE9XX0lOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIuZXhwcmVzc2lvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuZXhwcmVzc2lvbnNbaV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQXNzaWdubWVudChleHByLmxlZnQsIGV4cHIucmlnaHQsIGV4cHIub3BlcmF0b3IsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHRoaXMuZ2VuZXJhdGVGdW5jdGlvbkJvZHkoZXhwciksIFByZWNlZGVuY2UuQXJyb3dGdW5jdGlvbiwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChQcmVjZWRlbmNlLkNvbmRpdGlvbmFsIDwgcHJlY2VkZW5jZSkge1xuICAgICAgICAgICAgICAgIGZsYWdzIHw9IEZfQUxMT1dfSU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci50ZXN0LCBQcmVjZWRlbmNlLkxvZ2ljYWxPUiwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArICc/JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmNvbnNlcXVlbnQsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgZmxhZ3MpLFxuICAgICAgICAgICAgICAgICAgICBzcGFjZSArICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFsdGVybmF0ZSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBmbGFncylcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuQ29uZGl0aW9uYWwsXG4gICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CaW5hcnlFeHByZXNzaW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGxlZnRQcmVjZWRlbmNlLCByaWdodFByZWNlZGVuY2UsIGN1cnJlbnRQcmVjZWRlbmNlLCBmcmFnbWVudCwgbGVmdFNvdXJjZTtcbiAgICAgICAgICAgIGN1cnJlbnRQcmVjZWRlbmNlID0gQmluYXJ5UHJlY2VkZW5jZVtleHByLm9wZXJhdG9yXTtcbiAgICAgICAgICAgIGxlZnRQcmVjZWRlbmNlID0gZXhwci5vcGVyYXRvciA9PT0gJyoqJyA/IFByZWNlZGVuY2UuUG9zdGZpeCA6IGN1cnJlbnRQcmVjZWRlbmNlO1xuICAgICAgICAgICAgcmlnaHRQcmVjZWRlbmNlID0gZXhwci5vcGVyYXRvciA9PT0gJyoqJyA/IGN1cnJlbnRQcmVjZWRlbmNlIDogY3VycmVudFByZWNlZGVuY2UgKyAxO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFByZWNlZGVuY2UgPCBwcmVjZWRlbmNlKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gRl9BTExPV19JTjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIGxlZnRQcmVjZWRlbmNlLCBmbGFncyk7XG5cbiAgICAgICAgICAgIGxlZnRTb3VyY2UgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBpZiAobGVmdFNvdXJjZS5jaGFyQ29kZUF0KGxlZnRTb3VyY2UubGVuZ3RoIC0gMSkgPT09IDB4MkYgLyogLyAqLyAmJiBlc3V0aWxzLmNvZGUuaXNJZGVudGlmaWVyUGFydEVTNShleHByLm9wZXJhdG9yLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW2ZyYWdtZW50LCBub0VtcHR5U3BhY2UoKSwgZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub3BlcmF0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIHJpZ2h0UHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoZXhwci5vcGVyYXRvciA9PT0gJy8nICYmIGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAnLycgfHxcbiAgICAgICAgICAgIGV4cHIub3BlcmF0b3Iuc2xpY2UoLTEpID09PSAnPCcgJiYgZnJhZ21lbnQudG9TdHJpbmcoKS5zbGljZSgwLCAzKSA9PT0gJyEtLScpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiAnLycgY29uY2F0cyB3aXRoICcvJyBvciBgPGAgY29uY2F0cyB3aXRoIGAhLS1gLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBjb21tZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9FbXB0eVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsIGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IgPT09ICdpbicgJiYgIShmbGFncyAmIEZfQUxMT1dfSU4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBjdXJyZW50UHJlY2VkZW5jZSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICAvLyBGX0FMTE9XX1VOUEFSQVRIX05FVyBiZWNvbWVzIGZhbHNlLlxuICAgICAgICAgICAgcmVzdWx0ID0gW3RoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuY2FsbGVlLCBQcmVjZWRlbmNlLkNhbGwsIEVfVFRGKV07XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnKCcpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByWydhcmd1bWVudHMnXS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwclsnYXJndW1lbnRzJ11baV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJyknKTtcblxuICAgICAgICAgICAgaWYgKCEoZmxhZ3MgJiBGX0FMTE9XX0NBTEwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsnKCcsIHJlc3VsdCwgJyknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE5ld0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoLCBpLCBpeiwgaXRlbUZsYWdzO1xuICAgICAgICAgICAgbGVuZ3RoID0gZXhwclsnYXJndW1lbnRzJ10ubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBGX0FMTE9XX0NBTEwgYmVjb21lcyBmYWxzZS5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIG1heSBiZWNvbWUgZmFsc2UuXG4gICAgICAgICAgICBpdGVtRmxhZ3MgPSAoZmxhZ3MgJiBGX0FMTE9XX1VOUEFSQVRIX05FVyAmJiAhcGFyZW50aGVzZXMgJiYgbGVuZ3RoID09PSAwKSA/IEVfVEZUIDogRV9URkY7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oXG4gICAgICAgICAgICAgICAgJ25ldycsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUsIFByZWNlZGVuY2UuTmV3LCBpdGVtRmxhZ3MpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIShmbGFncyAmIEZfQUxMT1dfVU5QQVJBVEhfTkVXKSB8fCBwYXJlbnRoZXNlcyB8fCBsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJygnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwclsnYXJndW1lbnRzJ11baV0sIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIHNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5OZXcsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG5cbiAgICAgICAgICAgIC8vIEZfQUxMT1dfVU5QQVJBVEhfTkVXIGJlY29tZXMgZmFsc2UuXG4gICAgICAgICAgICByZXN1bHQgPSBbdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5vYmplY3QsIFByZWNlZGVuY2UuQ2FsbCwgKGZsYWdzICYgRl9BTExPV19DQUxMKSA/IEVfVFRGIDogRV9URkYpXTtcblxuICAgICAgICAgICAgaWYgKGV4cHIuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnWycpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucHJvcGVydHksIFByZWNlZGVuY2UuU2VxdWVuY2UsIGZsYWdzICYgRl9BTExPV19DQUxMID8gRV9UVFQgOiBFX1RGVCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCddJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9iamVjdC50eXBlID09PSBTeW50YXguTGl0ZXJhbCAmJiB0eXBlb2YgZXhwci5vYmplY3QudmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBhbGwgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gICAxLiBObyBmbG9hdGluZyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDIuIERvbid0IGhhdmUgZXhwb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgMy4gVGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgZGVjaW1hbCBkaWdpdFxuICAgICAgICAgICAgICAgICAgICAvLyAgIDQuIE5vdCBoZXhhZGVjaW1hbCBPUiBvY3RhbCBudW1iZXIgbGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgYWRkIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5pbmRleE9mKCcuJykgPCAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIS9bZUV4WF0vLnRlc3QoZnJhZ21lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXN1dGlscy5jb2RlLmlzRGVjaW1hbERpZ2l0KGZyYWdtZW50LmNoYXJDb2RlQXQoZnJhZ21lbnQubGVuZ3RoIC0gMSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmcmFnbWVudC5sZW5ndGggPj0gMiAmJiBmcmFnbWVudC5jaGFyQ29kZUF0KDApID09PSA0OCkgIC8vICcwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdlbmVyYXRlSWRlbnRpZmllcihleHByLnByb3BlcnR5KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTWV0YVByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGVvZiBleHByLm1ldGEgPT09IFwic3RyaW5nXCIgPyBleHByLm1ldGEgOiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5tZXRhKSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnLicpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZW9mIGV4cHIucHJvcGVydHkgPT09IFwic3RyaW5nXCIgPyBleHByLnByb3BlcnR5IDogZ2VuZXJhdGVJZGVudGlmaWVyKGV4cHIucHJvcGVydHkpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLk1lbWJlciwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50LCByaWdodENoYXJDb2RlLCBsZWZ0U291cmNlLCBsZWZ0Q2hhckNvZGU7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuVW5hcnksIEVfVFRUKTtcblxuICAgICAgICAgICAgaWYgKHNwYWNlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4oZXhwci5vcGVyYXRvciwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbZXhwci5vcGVyYXRvcl07XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIub3BlcmF0b3IubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUsIHZvaWQsIHR5cGVvZlxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYHR5cGVvZiBbXWAsIG5vdCBgdHlwZW9mW11gXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBpbnNlcnRpbmcgc3BhY2VzIGJldHdlZW4gb3BlcmF0b3IgYW5kIGFyZ3VtZW50IGlmIGl0IGlzIHVubmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpa2UsIGAhY29uZGBcbiAgICAgICAgICAgICAgICAgICAgbGVmdFNvdXJjZSA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0Q2hhckNvZGUgPSBsZWZ0U291cmNlLmNoYXJDb2RlQXQobGVmdFNvdXJjZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRDaGFyQ29kZSA9IGZyYWdtZW50LnRvU3RyaW5nKCkuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChsZWZ0Q2hhckNvZGUgPT09IDB4MkIgIC8qICsgKi8gfHwgbGVmdENoYXJDb2RlID09PSAweDJEICAvKiAtICovKSAmJiBsZWZ0Q2hhckNvZGUgPT09IHJpZ2h0Q2hhckNvZGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVzdXRpbHMuY29kZS5pc0lkZW50aWZpZXJQYXJ0RVM1KGxlZnRDaGFyQ29kZSkgJiYgZXN1dGlscy5jb2RlLmlzSWRlbnRpZmllclBhcnRFUzUocmlnaHRDaGFyQ29kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5VbmFyeSwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZXhwci5kZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICd5aWVsZConO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAneWllbGQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuYXJndW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuWWllbGQsIEVfVFRUKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKHJlc3VsdCwgUHJlY2VkZW5jZS5ZaWVsZCwgcHJlY2VkZW5jZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBqb2luKFxuICAgICAgICAgICAgICAgIGV4cHIuYWxsID8gJ2F3YWl0KicgOiAnYXdhaXQnLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQsIFByZWNlZGVuY2UuQXdhaXQsIEVfVFRUKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUocmVzdWx0LCBQcmVjZWRlbmNlLkF3YWl0LCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBVcGRhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLnByZWZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHIub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50LCBQcmVjZWRlbmNlLlVuYXJ5LCBFX1RUVClcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgUHJlY2VkZW5jZS5VbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplKFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Qb3N0Zml4LCBFX1RUVCksXG4gICAgICAgICAgICAgICAgICAgIGV4cHIub3BlcmF0b3JcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFByZWNlZGVuY2UuUG9zdGZpeCxcbiAgICAgICAgICAgICAgICBwcmVjZWRlbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlQXN5bmNQcmVmaXgoZXhwciwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChleHByLmlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZ2VuZXJhdGVTdGFyU3VmZml4KGV4cHIpIHx8IG5vRW1wdHlTcGFjZSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChnZW5lcmF0ZVN0YXJTdWZmaXgoZXhwcikgfHwgc3BhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUZ1bmN0aW9uQm9keShleHByKSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5BcnJheUV4cHJlc3Npb24oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MsIHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzLCBpc1BhdHRlcm4pIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIG11bHRpbGluZSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIuZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdWx0aWxpbmUgPSBpc1BhdHRlcm4gPyBmYWxzZSA6IGV4cHIuZWxlbWVudHMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIHJlc3VsdCA9IFsnWycsIG11bHRpbGluZSA/IG5ld2xpbmUgOiAnJ107XG4gICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uIChpbmRlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaXo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHByLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA9PT0gaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5lbGVtZW50c1tpXSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtdWx0aWxpbmUgJiYgIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChtdWx0aWxpbmUgPyBiYXNlIDogJycpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ10nKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgUmVzdEVsZW1lbnQ6IGZ1bmN0aW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4uLicgKyB0aGlzLmdlbmVyYXRlUGF0dGVybihleHByLmFyZ3VtZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBDbGFzc0V4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgZnJhZ21lbnQ7XG4gICAgICAgICAgICByZXN1bHQgPSBbJ2NsYXNzJ107XG4gICAgICAgICAgICBpZiAoZXhwci5pZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmlkLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIuc3VwZXJDbGFzcykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gam9pbignZXh0ZW5kcycsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuc3VwZXJDbGFzcywgUHJlY2VkZW5jZS5VbmFyeSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZVN0YXRlbWVudChleHByLmJvZHksIFNfVEZGVCkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIGZyYWdtZW50O1xuICAgICAgICAgICAgaWYgKGV4cHJbJ3N0YXRpYyddKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gWydzdGF0aWMnICsgc3BhY2VdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IFtcbiAgICAgICAgICAgICAgICAgICAgam9pbihleHByLmtpbmQsIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCkpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFByb3BlcnR5OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHByLmtpbmQgPT09ICdnZXQnIHx8IGV4cHIua2luZCA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBleHByLmtpbmQsIG5vRW1wdHlTcGFjZSgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuc2hvcnRoYW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIudmFsdWUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkFzc2lnbm1lbnRQYXR0ZXJuKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQcm9wZXJ0eUtleShleHByLmtleSwgZXhwci5jb21wdXRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTWV0aG9kUHJlZml4KGV4cHIpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRnVuY3Rpb25Cb2R5KGV4cHIudmFsdWUpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlUHJvcGVydHlLZXkoZXhwci5rZXksIGV4cHIuY29tcHV0ZWQpLFxuICAgICAgICAgICAgICAgICc6JyArIHNwYWNlLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIudmFsdWUsIFByZWNlZGVuY2UuQXNzaWdubWVudCwgRV9UVFQpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIG11bHRpbGluZSwgcmVzdWx0LCBmcmFnbWVudCwgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA+IDE7XG5cbiAgICAgICAgICAgIHdpdGhJbmRlbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzWzBdLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBpc3N1ZXMgNFxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCB0cmFuc2Zvcm0gZnJvbVxuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe1xuICAgICAgICAgICAgICAgIC8vICAgICAgIG1ldGhvZDI6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvLyB0b1xuICAgICAgICAgICAgICAgIC8vICAgZGVqYXZ1LkNsYXNzLmRlY2xhcmUoe21ldGhvZDI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKGZyYWdtZW50KS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWyAneycsIHNwYWNlLCBmcmFnbWVudCwgc3BhY2UsICd9JyBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFsgJ3snLCBuZXdsaW5lLCBpbmRlbnQsIGZyYWdtZW50IF07XG5cbiAgICAgICAgICAgICAgICBpZiAobXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcsJyArIG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBpeiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhhdC5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5wcm9wZXJ0aWVzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgaXopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyBuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWVuZHNXaXRoTGluZVRlcm1pbmF0b3IodG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQpLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChiYXNlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCd9Jyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiBmdW5jdGlvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVBc3NpZ25tZW50KGV4cHIubGVmdCwgZXhwci5yaWdodCwgJz0nLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgT2JqZWN0UGF0dGVybjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0LCBpLCBpeiwgbXVsdGlsaW5lLCBwcm9wZXJ0eSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWV4cHIucHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3t9JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhwci5wcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkudHlwZSA9PT0gU3ludGF4LlByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICYmIHByb3BlcnR5LnZhbHVlLnR5cGUgIT09IFN5bnRheC5JZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gZXhwci5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS50eXBlID09PSBTeW50YXguUHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFwcm9wZXJ0eS5zaG9ydGhhbmRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBbJ3snLCBtdWx0aWxpbmUgPyBuZXdsaW5lIDogJycgXTtcblxuICAgICAgICAgICAgd2l0aEluZGVudChmdW5jdGlvbiAoaW5kZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gZXhwci5wcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobXVsdGlsaW5lID8gaW5kZW50IDogJycpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGF0LmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnByb3BlcnRpZXNbaV0sIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSA8IGl6KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnLCcgKyAobXVsdGlsaW5lID8gbmV3bGluZSA6IHNwYWNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAhZW5kc1dpdGhMaW5lVGVybWluYXRvcih0b1NvdXJjZU5vZGVXaGVuTmVlZGVkKHJlc3VsdCkudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG11bHRpbGluZSA/IGJhc2UgOiAnJyk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgnfScpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBUaGlzRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3RoaXMnO1xuICAgICAgICB9LFxuXG4gICAgICAgIFN1cGVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3VwZXInO1xuICAgICAgICB9LFxuXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlSWRlbnRpZmllcihleHByKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZUlkZW50aWZpZXIoZXhwci5pZCB8fCBleHByLmxvY2FsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFsnKiddO1xuICAgICAgICAgICAgdmFyIGlkID0gZXhwci5pZCB8fCBleHByLmxvY2FsO1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3BhY2UgKyAnYXMnICsgbm9FbXB0eVNwYWNlKCkgKyBnZW5lcmF0ZUlkZW50aWZpZXIoaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBpbXBvcnRlZCA9IGV4cHIuaW1wb3J0ZWQ7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gWyBpbXBvcnRlZC5uYW1lIF07XG4gICAgICAgICAgICB2YXIgbG9jYWwgPSBleHByLmxvY2FsO1xuICAgICAgICAgICAgaWYgKGxvY2FsICYmIGxvY2FsLm5hbWUgIT09IGltcG9ydGVkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub0VtcHR5U3BhY2UoKSArICdhcycgKyBub0VtcHR5U3BhY2UoKSArIGdlbmVyYXRlSWRlbnRpZmllcihsb2NhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBFeHBvcnRTcGVjaWZpZXI6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIGxvY2FsID0gZXhwci5sb2NhbDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbIGxvY2FsLm5hbWUgXTtcbiAgICAgICAgICAgIHZhciBleHBvcnRlZCA9IGV4cHIuZXhwb3J0ZWQ7XG4gICAgICAgICAgICBpZiAoZXhwb3J0ZWQgJiYgZXhwb3J0ZWQubmFtZSAhPT0gbG9jYWwubmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vRW1wdHlTcGFjZSgpICsgJ2FzJyArIG5vRW1wdHlTcGFjZSgpICsgZ2VuZXJhdGVJZGVudGlmaWVyKGV4cG9ydGVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIExpdGVyYWw6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJhdztcbiAgICAgICAgICAgIGlmIChleHByLmhhc093blByb3BlcnR5KCdyYXcnKSAmJiBwYXJzZSAmJiBleHRyYS5yYXcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByYXcgPSBwYXJzZShleHByLnJhdykuYm9keVswXS5leHByZXNzaW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnR5cGUgPT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3LnZhbHVlID09PSBleHByLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIucmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3QgdXNlIHJhdyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIucmVnZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcvJyArIGV4cHIucmVnZXgucGF0dGVybiArICcvJyArIGV4cHIucmVnZXguZmxhZ3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLnZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmcoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVOdW1iZXIoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwci52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHIudmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVSZWdFeHAoZXhwci52YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgR2VuZXJhdG9yRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Db21wcmVoZW5zaW9uRXhwcmVzc2lvbihleHByLCBwcmVjZWRlbmNlLCBmbGFncyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgQ29tcHJlaGVuc2lvbkV4cHJlc3Npb246IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgLy8gR2VuZXJhdG9yRXhwcmVzc2lvbiBzaG91bGQgYmUgcGFyZW50aGVzaXplZCB3aXRoICguLi4pLCBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbiB3aXRoIFsuLi5dXG4gICAgICAgICAgICAvLyBEdWUgdG8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODgzNDY4IHBvc2l0aW9uIG9mIGV4cHIuYm9keSBjYW4gZGlmZmVyIGluIFNwaWRlcm1vbmtleSBhbmQgRVM2XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQsIGksIGl6LCBmcmFnbWVudCwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXN1bHQgPSAoZXhwci50eXBlID09PSBTeW50YXguR2VuZXJhdG9yRXhwcmVzc2lvbikgPyBbJygnXSA6IFsnWyddO1xuXG4gICAgICAgICAgICBpZiAoZXh0cmEubW96LmNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYm9keSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXhwci5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICB3aXRoSW5kZW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLmJsb2Nrcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoYXQuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIuYmxvY2tzW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDAgfHwgZXh0cmEubW96LmNvbXByZWhlbnNpb25FeHByZXNzaW9uU3RhcnRzV2l0aEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBqb2luKHJlc3VsdCwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cHIuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gam9pbihyZXN1bHQsICdpZicgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmZpbHRlciwgUHJlY2VkZW5jZS5TZXF1ZW5jZSwgRV9UVFQpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBbICcoJywgZnJhZ21lbnQsICcpJyBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFleHRyYS5tb3ouY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5ib2R5LCBQcmVjZWRlbmNlLkFzc2lnbm1lbnQsIEVfVFRUKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGpvaW4ocmVzdWx0LCBmcmFnbWVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChleHByLnR5cGUgPT09IFN5bnRheC5HZW5lcmF0b3JFeHByZXNzaW9uKSA/ICcpJyA6ICddJyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIENvbXByZWhlbnNpb25CbG9jazogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQ7XG4gICAgICAgICAgICBpZiAoZXhwci5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIGV4cHIubGVmdC5raW5kLCBub0VtcHR5U3BhY2UoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVN0YXRlbWVudChleHByLmxlZnQuZGVjbGFyYXRpb25zWzBdLCBTX0ZGRkYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmxlZnQsIFByZWNlZGVuY2UuQ2FsbCwgRV9UVFQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oZnJhZ21lbnQsIGV4cHIub2YgPyAnb2YnIDogJ2luJyk7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGpvaW4oZnJhZ21lbnQsIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQsIFByZWNlZGVuY2UuU2VxdWVuY2UsIEVfVFRUKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBbICdmb3InICsgc3BhY2UgKyAnKCcsIGZyYWdtZW50LCAnKScgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBTcHJlYWRFbGVtZW50OiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJy4uLicsXG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudCwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHZhciBpdGVtRmxhZ3MgPSBFX1RURjtcbiAgICAgICAgICAgIGlmICghKGZsYWdzICYgRl9BTExPV19DQUxMKSkge1xuICAgICAgICAgICAgICAgIGl0ZW1GbGFncyA9IEVfVEZGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnRhZywgUHJlY2VkZW5jZS5DYWxsLCBpdGVtRmxhZ3MpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVFeHByZXNzaW9uKGV4cHIucXVhc2ksIFByZWNlZGVuY2UuUHJpbWFyeSwgRV9GRlQpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZShyZXN1bHQsIFByZWNlZGVuY2UuVGFnZ2VkVGVtcGxhdGUsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgICAgICAvLyBEb24ndCB1c2UgXCJjb29rZWRcIi4gU2luY2UgdGFnZ2VkIHRlbXBsYXRlIGNhbiB1c2UgcmF3IHRlbXBsYXRlXG4gICAgICAgICAgICAvLyByZXByZXNlbnRhdGlvbi4gU28gaWYgd2UgZG8gc28sIGl0IGJyZWFrcyB0aGUgc2NyaXB0IHNlbWFudGljcy5cbiAgICAgICAgICAgIHJldHVybiBleHByLnZhbHVlLnJhdztcbiAgICAgICAgfSxcblxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IGZ1bmN0aW9uIChleHByLCBwcmVjZWRlbmNlLCBmbGFncykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCwgaSwgaXo7XG4gICAgICAgICAgICByZXN1bHQgPSBbICdgJyBdO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgaXogPSBleHByLnF1YXNpcy5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5nZW5lcmF0ZUV4cHJlc3Npb24oZXhwci5xdWFzaXNbaV0sIFByZWNlZGVuY2UuUHJpbWFyeSwgRV9UVFQpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPCBpeikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCgnJHsnICsgc3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLmV4cHJlc3Npb25zW2ldLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzcGFjZSArICd9Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goJ2AnKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgTW9kdWxlU3BlY2lmaWVyOiBmdW5jdGlvbiAoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxpdGVyYWwoZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIEltcG9ydEV4cHJlc3Npb246IGZ1bmN0aW9uKGV4cHIsIHByZWNlZGVuY2UsIGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRoZXNpemUoW1xuICAgICAgICAgICAgICAgICdpbXBvcnQoJyxcbiAgICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlRXhwcmVzc2lvbihleHByLnNvdXJjZSwgUHJlY2VkZW5jZS5Bc3NpZ25tZW50LCBFX1RUVCksXG4gICAgICAgICAgICAgICAgJyknXG4gICAgICAgICAgICBdLCBQcmVjZWRlbmNlLkNhbGwsIHByZWNlZGVuY2UpO1xuICAgICAgICB9LFxuXG4gICAgfTtcblxuICAgIG1lcmdlKENvZGVHZW5lcmF0b3IucHJvdG90eXBlLCBDb2RlR2VuZXJhdG9yLkV4cHJlc3Npb24pO1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIsIHByZWNlZGVuY2UsIGZsYWdzKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHR5cGU7XG5cbiAgICAgICAgdHlwZSA9IGV4cHIudHlwZSB8fCBTeW50YXguUHJvcGVydHk7XG5cbiAgICAgICAgaWYgKGV4dHJhLnZlcmJhdGltICYmIGV4cHIuaGFzT3duUHJvcGVydHkoZXh0cmEudmVyYmF0aW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVWZXJiYXRpbShleHByLCBwcmVjZWRlbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbdHlwZV0oZXhwciwgcHJlY2VkZW5jZSwgZmxhZ3MpO1xuXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKGV4cHIsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0LCBleHByKTtcbiAgICB9O1xuXG4gICAgQ29kZUdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVTdGF0ZW1lbnQgPSBmdW5jdGlvbiAoc3RtdCwgZmxhZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICAgIGZyYWdtZW50O1xuXG4gICAgICAgIHJlc3VsdCA9IHRoaXNbc3RtdC50eXBlXShzdG10LCBmbGFncyk7XG5cbiAgICAgICAgLy8gQXR0YWNoIGNvbW1lbnRzXG5cbiAgICAgICAgaWYgKGV4dHJhLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFkZENvbW1lbnRzKHN0bXQsIHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFnbWVudCA9IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc3RtdC50eXBlID09PSBTeW50YXguUHJvZ3JhbSAmJiAhc2FmZUNvbmNhdGVuYXRpb24gJiYgbmV3bGluZSA9PT0gJycgJiYgIGZyYWdtZW50LmNoYXJBdChmcmFnbWVudC5sZW5ndGggLSAxKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNvdXJjZU1hcCA/IHRvU291cmNlTm9kZVdoZW5OZWVkZWQocmVzdWx0KS5yZXBsYWNlUmlnaHQoL1xccyskLywgJycpIDogZnJhZ21lbnQucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9Tb3VyY2VOb2RlV2hlbk5lZWRlZChyZXN1bHQsIHN0bXQpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUludGVybmFsKG5vZGUpIHtcbiAgICAgICAgdmFyIGNvZGVnZW47XG5cbiAgICAgICAgY29kZWdlbiA9IG5ldyBDb2RlR2VuZXJhdG9yKCk7XG4gICAgICAgIGlmIChpc1N0YXRlbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVnZW4uZ2VuZXJhdGVTdGF0ZW1lbnQobm9kZSwgU19URkZGKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuLmdlbmVyYXRlRXhwcmVzc2lvbihub2RlLCBQcmVjZWRlbmNlLlNlcXVlbmNlLCBFX1RUVCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZSB0eXBlOiAnICsgbm9kZS50eXBlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBkZWZhdWx0T3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKCksIHJlc3VsdCwgcGFpcjtcblxuICAgICAgICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPYnNvbGV0ZSBvcHRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBgb3B0aW9ucy5pbmRlbnRgXG4gICAgICAgICAgICAvLyAgIGBvcHRpb25zLmJhc2VgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiB0aGVtLCB3ZSBjYW4gdXNlIGBvcHRpb24uZm9ybWF0LmluZGVudGAuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5kZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuc3R5bGUgPSBvcHRpb25zLmluZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB1cGRhdGVEZWVwbHkoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaW5kZW50ID0gb3B0aW9ucy5mb3JtYXQuaW5kZW50LnN0eWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IG9wdGlvbnMuYmFzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHN0cmluZ1JlcGVhdChpbmRlbnQsIG9wdGlvbnMuZm9ybWF0LmluZGVudC5iYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIGluZGVudCA9IG9wdGlvbnMuZm9ybWF0LmluZGVudC5zdHlsZTtcbiAgICAgICAgICAgIGJhc2UgPSBzdHJpbmdSZXBlYXQoaW5kZW50LCBvcHRpb25zLmZvcm1hdC5pbmRlbnQuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbiA9IG9wdGlvbnMuZm9ybWF0Lmpzb247XG4gICAgICAgIHJlbnVtYmVyID0gb3B0aW9ucy5mb3JtYXQucmVudW1iZXI7XG4gICAgICAgIGhleGFkZWNpbWFsID0ganNvbiA/IGZhbHNlIDogb3B0aW9ucy5mb3JtYXQuaGV4YWRlY2ltYWw7XG4gICAgICAgIHF1b3RlcyA9IGpzb24gPyAnZG91YmxlJyA6IG9wdGlvbnMuZm9ybWF0LnF1b3RlcztcbiAgICAgICAgZXNjYXBlbGVzcyA9IG9wdGlvbnMuZm9ybWF0LmVzY2FwZWxlc3M7XG4gICAgICAgIG5ld2xpbmUgPSBvcHRpb25zLmZvcm1hdC5uZXdsaW5lO1xuICAgICAgICBzcGFjZSA9IG9wdGlvbnMuZm9ybWF0LnNwYWNlO1xuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQuY29tcGFjdCkge1xuICAgICAgICAgICAgbmV3bGluZSA9IHNwYWNlID0gaW5kZW50ID0gYmFzZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudGhlc2VzID0gb3B0aW9ucy5mb3JtYXQucGFyZW50aGVzZXM7XG4gICAgICAgIHNlbWljb2xvbnMgPSBvcHRpb25zLmZvcm1hdC5zZW1pY29sb25zO1xuICAgICAgICBzYWZlQ29uY2F0ZW5hdGlvbiA9IG9wdGlvbnMuZm9ybWF0LnNhZmVDb25jYXRlbmF0aW9uO1xuICAgICAgICBkaXJlY3RpdmUgPSBvcHRpb25zLmRpcmVjdGl2ZTtcbiAgICAgICAgcGFyc2UgPSBqc29uID8gbnVsbCA6IG9wdGlvbnMucGFyc2U7XG4gICAgICAgIHNvdXJjZU1hcCA9IG9wdGlvbnMuc291cmNlTWFwO1xuICAgICAgICBzb3VyY2VDb2RlID0gb3B0aW9ucy5zb3VyY2VDb2RlO1xuICAgICAgICBwcmVzZXJ2ZUJsYW5rTGluZXMgPSBvcHRpb25zLmZvcm1hdC5wcmVzZXJ2ZUJsYW5rTGluZXMgJiYgc291cmNlQ29kZSAhPT0gbnVsbDtcbiAgICAgICAgZXh0cmEgPSBvcHRpb25zO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXApIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5icm93c2VyKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXNzdW1lIGVudmlyb25tZW50IGlzIG5vZGUuanNcbiAgICAgICAgICAgICAgICAvLyBBbmQgcHJldmVudCBmcm9tIGluY2x1ZGluZyBzb3VyY2UtbWFwIGJ5IGJyb3dzZXJpZnlcbiAgICAgICAgICAgICAgICBTb3VyY2VOb2RlID0gcmVxdWlyZSgnc291cmNlLW1hcCcpLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFNvdXJjZU5vZGUgPSBnbG9iYWwuc291cmNlTWFwLlNvdXJjZU5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZUludGVybmFsKG5vZGUpO1xuXG4gICAgICAgIGlmICghc291cmNlTWFwKSB7XG4gICAgICAgICAgICBwYWlyID0ge2NvZGU6IHJlc3VsdC50b1N0cmluZygpLCBtYXA6IG51bGx9O1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc291cmNlTWFwV2l0aENvZGUgPyBwYWlyIDogcGFpci5jb2RlO1xuICAgICAgICB9XG5cblxuICAgICAgICBwYWlyID0gcmVzdWx0LnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XG4gICAgICAgICAgICBmaWxlOiBvcHRpb25zLmZpbGUsXG4gICAgICAgICAgICBzb3VyY2VSb290OiBvcHRpb25zLnNvdXJjZU1hcFJvb3RcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlQ29udGVudCkge1xuICAgICAgICAgICAgcGFpci5tYXAuc2V0U291cmNlQ29udGVudChvcHRpb25zLnNvdXJjZU1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zb3VyY2VDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcFdpdGhDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWlyLm1hcC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIEZPUk1BVF9NSU5JRlkgPSB7XG4gICAgICAgIGluZGVudDoge1xuICAgICAgICAgICAgc3R5bGU6ICcnLFxuICAgICAgICAgICAgYmFzZTogMFxuICAgICAgICB9LFxuICAgICAgICByZW51bWJlcjogdHJ1ZSxcbiAgICAgICAgaGV4YWRlY2ltYWw6IHRydWUsXG4gICAgICAgIHF1b3RlczogJ2F1dG8nLFxuICAgICAgICBlc2NhcGVsZXNzOiB0cnVlLFxuICAgICAgICBjb21wYWN0OiB0cnVlLFxuICAgICAgICBwYXJlbnRoZXNlczogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnM6IGZhbHNlXG4gICAgfTtcblxuICAgIEZPUk1BVF9ERUZBVUxUUyA9IGdldERlZmF1bHRPcHRpb25zKCkuZm9ybWF0O1xuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbiAgICBleHBvcnRzLmF0dGFjaENvbW1lbnRzID0gZXN0cmF2ZXJzZS5hdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlByZWNlZGVuY2UgPSB1cGRhdGVEZWVwbHkoe30sIFByZWNlZGVuY2UpO1xuICAgIGV4cG9ydHMuYnJvd3NlciA9IGZhbHNlO1xuICAgIGV4cG9ydHMuRk9STUFUX01JTklGWSA9IEZPUk1BVF9NSU5JRlk7XG4gICAgZXhwb3J0cy5GT1JNQVRfREVGQVVMVFMgPSBGT1JNQVRfREVGQVVMVFM7XG59KCkpO1xuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJuYW1lcyI6WyJTeW50YXgiLCJQcmVjZWRlbmNlIiwiQmluYXJ5UHJlY2VkZW5jZSIsIlNvdXJjZU5vZGUiLCJlc3RyYXZlcnNlIiwiZXN1dGlscyIsImJhc2UiLCJpbmRlbnQiLCJqc29uIiwicmVudW1iZXIiLCJoZXhhZGVjaW1hbCIsInF1b3RlcyIsImVzY2FwZWxlc3MiLCJuZXdsaW5lIiwic3BhY2UiLCJwYXJlbnRoZXNlcyIsInNlbWljb2xvbnMiLCJzYWZlQ29uY2F0ZW5hdGlvbiIsImRpcmVjdGl2ZSIsImV4dHJhIiwicGFyc2UiLCJzb3VyY2VNYXAiLCJzb3VyY2VDb2RlIiwicHJlc2VydmVCbGFua0xpbmVzIiwiRk9STUFUX01JTklGWSIsIkZPUk1BVF9ERUZBVUxUUyIsInJlcXVpcmUiLCJpc0V4cHJlc3Npb24iLCJub2RlIiwiQ29kZUdlbmVyYXRvciIsIkV4cHJlc3Npb24iLCJoYXNPd25Qcm9wZXJ0eSIsInR5cGUiLCJpc1N0YXRlbWVudCIsIlN0YXRlbWVudCIsIlNlcXVlbmNlIiwiWWllbGQiLCJBc3NpZ25tZW50IiwiQ29uZGl0aW9uYWwiLCJBcnJvd0Z1bmN0aW9uIiwiTG9naWNhbE9SIiwiTG9naWNhbEFORCIsIkJpdHdpc2VPUiIsIkJpdHdpc2VYT1IiLCJCaXR3aXNlQU5EIiwiRXF1YWxpdHkiLCJSZWxhdGlvbmFsIiwiQml0d2lzZVNISUZUIiwiQWRkaXRpdmUiLCJNdWx0aXBsaWNhdGl2ZSIsIkV4cG9uZW50aWF0aW9uIiwiQXdhaXQiLCJVbmFyeSIsIlBvc3RmaXgiLCJDYWxsIiwiTmV3IiwiVGFnZ2VkVGVtcGxhdGUiLCJNZW1iZXIiLCJQcmltYXJ5IiwiRl9BTExPV19JTiIsIkZfQUxMT1dfQ0FMTCIsIkZfQUxMT1dfVU5QQVJBVEhfTkVXIiwiRl9GVU5DX0JPRFkiLCJGX0RJUkVDVElWRV9DVFgiLCJGX1NFTUlDT0xPTl9PUFQiLCJFX0ZUVCIsIkVfVFRGIiwiRV9UVFQiLCJFX1RGRiIsIkVfRkZUIiwiRV9URlQiLCJTX1RGRkYiLCJTX1RGRlQiLCJTX0ZGRkYiLCJTX1RGVEYiLCJTX1RURkYiLCJnZXREZWZhdWx0T3B0aW9ucyIsImNvbW1lbnQiLCJmb3JtYXQiLCJzdHlsZSIsImFkanVzdE11bHRpbGluZUNvbW1lbnQiLCJjb21wYWN0IiwibW96IiwiY29tcHJlaGVuc2lvbkV4cHJlc3Npb25TdGFydHNXaXRoQXNzaWdubWVudCIsInN0YXJsZXNzR2VuZXJhdG9yIiwic291cmNlTWFwUm9vdCIsInNvdXJjZU1hcFdpdGhDb2RlIiwicmF3IiwidmVyYmF0aW0iLCJzdHJpbmdSZXBlYXQiLCJzdHIiLCJudW0iLCJyZXN1bHQiLCJoYXNMaW5lVGVybWluYXRvciIsInRlc3QiLCJlbmRzV2l0aExpbmVUZXJtaW5hdG9yIiwibGVuIiwibGVuZ3RoIiwiY29kZSIsImlzTGluZVRlcm1pbmF0b3IiLCJjaGFyQ29kZUF0IiwibWVyZ2UiLCJ0YXJnZXQiLCJvdmVycmlkZSIsImtleSIsInVwZGF0ZURlZXBseSIsInZhbCIsImlzSGFzaE9iamVjdCIsIk9iamVjdCIsIlJlZ0V4cCIsImdlbmVyYXRlTnVtYmVyIiwidmFsdWUiLCJwb2ludCIsInRlbXAiLCJleHBvbmVudCIsInBvcyIsIkVycm9yIiwiaW5kZXhPZiIsInNsaWNlIiwicmVwbGFjZSIsIk1hdGgiLCJmbG9vciIsInRvU3RyaW5nIiwiZXNjYXBlUmVnRXhwQ2hhcmFjdGVyIiwiY2giLCJwcmV2aW91c0lzQmFja3NsYXNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZ2VuZXJhdGVSZWdFeHAiLCJyZWciLCJtYXRjaCIsImZsYWdzIiwiaSIsIml6IiwiY2hhcmFjdGVySW5CcmFjayIsInNvdXJjZSIsImVzY2FwZUFsbG93ZWRDaGFyYWN0ZXIiLCJuZXh0IiwiaGV4IiwidG9VcHBlckNhc2UiLCJpc0RlY2ltYWxEaWdpdCIsImVzY2FwZURpc2FsbG93ZWRDaGFyYWN0ZXIiLCJlc2NhcGVEaXJlY3RpdmUiLCJxdW90ZSIsImVzY2FwZVN0cmluZyIsInNpbmdsZVF1b3RlcyIsImRvdWJsZVF1b3RlcyIsInNpbmdsZSIsImlzSWRlbnRpZmllclBhcnRFUzUiLCJmbGF0dGVuVG9TdHJpbmciLCJhcnIiLCJlbGVtIiwiQXJyYXkiLCJpc0FycmF5IiwidG9Tb3VyY2VOb2RlV2hlbk5lZWRlZCIsImdlbmVyYXRlZCIsImxvYyIsIm5hbWUiLCJzdGFydCIsImxpbmUiLCJjb2x1bW4iLCJub0VtcHR5U3BhY2UiLCJqb2luIiwibGVmdCIsInJpZ2h0IiwibGVmdFNvdXJjZSIsInJpZ2h0U291cmNlIiwibGVmdENoYXJDb2RlIiwicmlnaHRDaGFyQ29kZSIsImlzV2hpdGVTcGFjZSIsImFkZEluZGVudCIsInN0bXQiLCJ3aXRoSW5kZW50IiwiZm4iLCJwcmV2aW91c0Jhc2UiLCJjYWxjdWxhdGVTcGFjZXMiLCJzcGVjaWFsQmFzZSIsImFycmF5IiwiaiIsInNwYWNlcyIsInNuIiwic3BsaXQiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJnZW5lcmF0ZUNvbW1lbnQiLCJhZGRDb21tZW50cyIsInNhdmUiLCJ0YWlsaW5nVG9TdGF0ZW1lbnQiLCJmcmFnbWVudCIsImV4dFJhbmdlIiwicmFuZ2UiLCJwcmV2UmFuZ2UiLCJwcmVmaXgiLCJpbmZpeCIsInN1ZmZpeCIsImNvdW50IiwibGVhZGluZ0NvbW1lbnRzIiwiZXh0ZW5kZWRSYW5nZSIsInN1YnN0cmluZyIsInB1c2giLCJQcm9ncmFtIiwiYm9keSIsInRyYWlsaW5nQ29tbWVudHMiLCJnZW5lcmF0ZUJsYW5rTGluZXMiLCJlbmQiLCJuZXdsaW5lQ291bnQiLCJwYXJlbnRoZXNpemUiLCJ0ZXh0IiwiY3VycmVudCIsInNob3VsZCIsImdlbmVyYXRlVmVyYmF0aW1TdHJpbmciLCJzdHJpbmciLCJnZW5lcmF0ZVZlcmJhdGltIiwiZXhwciIsInByZWNlZGVuY2UiLCJwcmVjIiwiY29udGVudCIsInByb3RvdHlwZSIsIm1heWJlQmxvY2siLCJub0xlYWRpbmdDb21tZW50IiwidGhhdCIsIkJsb2NrU3RhdGVtZW50IiwiZ2VuZXJhdGVTdGF0ZW1lbnQiLCJFbXB0eVN0YXRlbWVudCIsIm1heWJlQmxvY2tTdWZmaXgiLCJlbmRzIiwiZ2VuZXJhdGVJZGVudGlmaWVyIiwiZ2VuZXJhdGVBc3luY1ByZWZpeCIsInNwYWNlUmVxdWlyZWQiLCJhc3luYyIsImdlbmVyYXRlU3RhclN1ZmZpeCIsImlzR2VuZXJhdG9yIiwiZ2VuZXJhdG9yIiwiZ2VuZXJhdGVNZXRob2RQcmVmaXgiLCJwcm9wIiwiZnVuYyIsImNvbXB1dGVkIiwiZ2VuZXJhdGVQYXR0ZXJuIiwiSWRlbnRpZmllciIsImdlbmVyYXRlRXhwcmVzc2lvbiIsImdlbmVyYXRlRnVuY3Rpb25QYXJhbXMiLCJoYXNEZWZhdWx0IiwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJyZXN0IiwiZGVmYXVsdHMiLCJwYXJhbXMiLCJnZW5lcmF0ZUFzc2lnbm1lbnQiLCJnZW5lcmF0ZUZ1bmN0aW9uQm9keSIsImV4cHJlc3Npb24iLCJjaGFyQXQiLCJnZW5lcmF0ZUl0ZXJhdGlvbkZvclN0YXRlbWVudCIsIm9wZXJhdG9yIiwiYXdhaXQiLCJWYXJpYWJsZURlY2xhcmF0aW9uIiwia2luZCIsImRlY2xhcmF0aW9ucyIsImdlbmVyYXRlUHJvcGVydHlLZXkiLCJzZW1pY29sb24iLCJib2R5RmxhZ3MiLCJCcmVha1N0YXRlbWVudCIsImxhYmVsIiwiQ29udGludWVTdGF0ZW1lbnQiLCJDbGFzc0JvZHkiLCJDbGFzc0RlY2xhcmF0aW9uIiwiaWQiLCJzdXBlckNsYXNzIiwiRGlyZWN0aXZlU3RhdGVtZW50IiwiRG9XaGlsZVN0YXRlbWVudCIsIkNhdGNoQ2xhdXNlIiwiZ3VhcmQiLCJwYXJhbSIsInNwbGljZSIsIkRlYnVnZ2VyU3RhdGVtZW50IiwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIiwiZGVjbGFyYXRpb24iLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIiwic3BlY2lmaWVycyIsIkV4cG9ydEJhdGNoU3BlY2lmaWVyIiwiRXhwb3J0QWxsRGVjbGFyYXRpb24iLCJFeHByZXNzaW9uU3RhdGVtZW50IiwiaXNDbGFzc1ByZWZpeGVkIiwiaXNGdW5jdGlvblByZWZpeGVkIiwiaXNBc3luY1ByZWZpeGVkIiwiTGl0ZXJhbCIsIkltcG9ydERlY2xhcmF0aW9uIiwiY3Vyc29yIiwiSW1wb3J0RGVmYXVsdFNwZWNpZmllciIsIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciIsIlZhcmlhYmxlRGVjbGFyYXRvciIsIml0ZW1GbGFncyIsImluaXQiLCJibG9jayIsIlRocm93U3RhdGVtZW50IiwiYXJndW1lbnQiLCJUcnlTdGF0ZW1lbnQiLCJndWFyZGVkSGFuZGxlcnMiLCJoYW5kbGVycyIsImZpbmFsaXplciIsImhhbmRsZXIiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJkaXNjcmltaW5hbnQiLCJjYXNlcyIsIlN3aXRjaENhc2UiLCJjb25zZXF1ZW50IiwiSWZTdGF0ZW1lbnQiLCJzZW1pY29sb25PcHRpb25hbCIsImFsdGVybmF0ZSIsIkZvclN0YXRlbWVudCIsInVwZGF0ZSIsIkZvckluU3RhdGVtZW50IiwiRm9yT2ZTdGF0ZW1lbnQiLCJMYWJlbGVkU3RhdGVtZW50IiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsIlJldHVyblN0YXRlbWVudCIsIldoaWxlU3RhdGVtZW50IiwiV2l0aFN0YXRlbWVudCIsIm9iamVjdCIsIlNlcXVlbmNlRXhwcmVzc2lvbiIsImV4cHJlc3Npb25zIiwiQXNzaWdubWVudEV4cHJlc3Npb24iLCJDb25kaXRpb25hbEV4cHJlc3Npb24iLCJMb2dpY2FsRXhwcmVzc2lvbiIsIkJpbmFyeUV4cHJlc3Npb24iLCJsZWZ0UHJlY2VkZW5jZSIsInJpZ2h0UHJlY2VkZW5jZSIsImN1cnJlbnRQcmVjZWRlbmNlIiwiQ2FsbEV4cHJlc3Npb24iLCJjYWxsZWUiLCJOZXdFeHByZXNzaW9uIiwiTWVtYmVyRXhwcmVzc2lvbiIsInByb3BlcnR5IiwiTWV0YVByb3BlcnR5IiwibWV0YSIsIlVuYXJ5RXhwcmVzc2lvbiIsIllpZWxkRXhwcmVzc2lvbiIsImRlbGVnYXRlIiwiQXdhaXRFeHByZXNzaW9uIiwiYWxsIiwiVXBkYXRlRXhwcmVzc2lvbiIsIkZ1bmN0aW9uRXhwcmVzc2lvbiIsIkFycmF5UGF0dGVybiIsIkFycmF5RXhwcmVzc2lvbiIsImlzUGF0dGVybiIsIm11bHRpbGluZSIsImVsZW1lbnRzIiwiUmVzdEVsZW1lbnQiLCJDbGFzc0V4cHJlc3Npb24iLCJNZXRob2REZWZpbml0aW9uIiwiUHJvcGVydHkiLCJzaG9ydGhhbmQiLCJBc3NpZ25tZW50UGF0dGVybiIsIm1ldGhvZCIsIk9iamVjdEV4cHJlc3Npb24iLCJwcm9wZXJ0aWVzIiwiT2JqZWN0UGF0dGVybiIsIlRoaXNFeHByZXNzaW9uIiwiU3VwZXIiLCJsb2NhbCIsIkltcG9ydFNwZWNpZmllciIsImltcG9ydGVkIiwiRXhwb3J0U3BlY2lmaWVyIiwiZXhwb3J0ZWQiLCJlIiwicmVnZXgiLCJwYXR0ZXJuIiwiR2VuZXJhdG9yRXhwcmVzc2lvbiIsIkNvbXByZWhlbnNpb25FeHByZXNzaW9uIiwiYmxvY2tzIiwiZmlsdGVyIiwiQ29tcHJlaGVuc2lvbkJsb2NrIiwib2YiLCJTcHJlYWRFbGVtZW50IiwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIiwidGFnIiwicXVhc2kiLCJUZW1wbGF0ZUVsZW1lbnQiLCJUZW1wbGF0ZUxpdGVyYWwiLCJxdWFzaXMiLCJNb2R1bGVTcGVjaWZpZXIiLCJJbXBvcnRFeHByZXNzaW9uIiwiZmxhZyIsInJlcGxhY2VSaWdodCIsImdlbmVyYXRlSW50ZXJuYWwiLCJjb2RlZ2VuIiwiZ2VuZXJhdGUiLCJvcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJwYWlyIiwiZXhwb3J0cyIsImJyb3dzZXIiLCJnbG9iYWwiLCJtYXAiLCJ0b1N0cmluZ1dpdGhTb3VyY2VNYXAiLCJmaWxlIiwic291cmNlUm9vdCIsInNvdXJjZUNvbnRlbnQiLCJzZXRTb3VyY2VDb250ZW50IiwidmVyc2lvbiIsImF0dGFjaENvbW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/escodegen/escodegen.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/escodegen/node_modules/estraverse/estraverse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/escodegen/node_modules/estraverse/estraverse.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/ /*jslint vars:false, bitwise:true*/ /*jshint indent:4*/ /*global exports:true*/ (function clone(exports1) {\n    \"use strict\";\n    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;\n    function deepCopy(obj) {\n        var ret = {}, key, val;\n        for(key in obj){\n            if (obj.hasOwnProperty(key)) {\n                val = obj[key];\n                if (typeof val === \"object\" && val !== null) {\n                    ret[key] = deepCopy(val);\n                } else {\n                    ret[key] = val;\n                }\n            }\n        }\n        return ret;\n    }\n    // based on LLVM libc++ upper_bound / lower_bound\n    // MIT License\n    function upperBound(array, func) {\n        var diff, len, i, current;\n        len = array.length;\n        i = 0;\n        while(len){\n            diff = len >>> 1;\n            current = i + diff;\n            if (func(array[current])) {\n                len = diff;\n            } else {\n                i = current + 1;\n                len -= diff + 1;\n            }\n        }\n        return i;\n    }\n    Syntax = {\n        AssignmentExpression: \"AssignmentExpression\",\n        AssignmentPattern: \"AssignmentPattern\",\n        ArrayExpression: \"ArrayExpression\",\n        ArrayPattern: \"ArrayPattern\",\n        ArrowFunctionExpression: \"ArrowFunctionExpression\",\n        AwaitExpression: \"AwaitExpression\",\n        BlockStatement: \"BlockStatement\",\n        BinaryExpression: \"BinaryExpression\",\n        BreakStatement: \"BreakStatement\",\n        CallExpression: \"CallExpression\",\n        CatchClause: \"CatchClause\",\n        ClassBody: \"ClassBody\",\n        ClassDeclaration: \"ClassDeclaration\",\n        ClassExpression: \"ClassExpression\",\n        ComprehensionBlock: \"ComprehensionBlock\",\n        ComprehensionExpression: \"ComprehensionExpression\",\n        ConditionalExpression: \"ConditionalExpression\",\n        ContinueStatement: \"ContinueStatement\",\n        DebuggerStatement: \"DebuggerStatement\",\n        DirectiveStatement: \"DirectiveStatement\",\n        DoWhileStatement: \"DoWhileStatement\",\n        EmptyStatement: \"EmptyStatement\",\n        ExportAllDeclaration: \"ExportAllDeclaration\",\n        ExportDefaultDeclaration: \"ExportDefaultDeclaration\",\n        ExportNamedDeclaration: \"ExportNamedDeclaration\",\n        ExportSpecifier: \"ExportSpecifier\",\n        ExpressionStatement: \"ExpressionStatement\",\n        ForStatement: \"ForStatement\",\n        ForInStatement: \"ForInStatement\",\n        ForOfStatement: \"ForOfStatement\",\n        FunctionDeclaration: \"FunctionDeclaration\",\n        FunctionExpression: \"FunctionExpression\",\n        GeneratorExpression: \"GeneratorExpression\",\n        Identifier: \"Identifier\",\n        IfStatement: \"IfStatement\",\n        ImportExpression: \"ImportExpression\",\n        ImportDeclaration: \"ImportDeclaration\",\n        ImportDefaultSpecifier: \"ImportDefaultSpecifier\",\n        ImportNamespaceSpecifier: \"ImportNamespaceSpecifier\",\n        ImportSpecifier: \"ImportSpecifier\",\n        Literal: \"Literal\",\n        LabeledStatement: \"LabeledStatement\",\n        LogicalExpression: \"LogicalExpression\",\n        MemberExpression: \"MemberExpression\",\n        MetaProperty: \"MetaProperty\",\n        MethodDefinition: \"MethodDefinition\",\n        ModuleSpecifier: \"ModuleSpecifier\",\n        NewExpression: \"NewExpression\",\n        ObjectExpression: \"ObjectExpression\",\n        ObjectPattern: \"ObjectPattern\",\n        Program: \"Program\",\n        Property: \"Property\",\n        RestElement: \"RestElement\",\n        ReturnStatement: \"ReturnStatement\",\n        SequenceExpression: \"SequenceExpression\",\n        SpreadElement: \"SpreadElement\",\n        Super: \"Super\",\n        SwitchStatement: \"SwitchStatement\",\n        SwitchCase: \"SwitchCase\",\n        TaggedTemplateExpression: \"TaggedTemplateExpression\",\n        TemplateElement: \"TemplateElement\",\n        TemplateLiteral: \"TemplateLiteral\",\n        ThisExpression: \"ThisExpression\",\n        ThrowStatement: \"ThrowStatement\",\n        TryStatement: \"TryStatement\",\n        UnaryExpression: \"UnaryExpression\",\n        UpdateExpression: \"UpdateExpression\",\n        VariableDeclaration: \"VariableDeclaration\",\n        VariableDeclarator: \"VariableDeclarator\",\n        WhileStatement: \"WhileStatement\",\n        WithStatement: \"WithStatement\",\n        YieldExpression: \"YieldExpression\"\n    };\n    VisitorKeys = {\n        AssignmentExpression: [\n            \"left\",\n            \"right\"\n        ],\n        AssignmentPattern: [\n            \"left\",\n            \"right\"\n        ],\n        ArrayExpression: [\n            \"elements\"\n        ],\n        ArrayPattern: [\n            \"elements\"\n        ],\n        ArrowFunctionExpression: [\n            \"params\",\n            \"body\"\n        ],\n        AwaitExpression: [\n            \"argument\"\n        ],\n        BlockStatement: [\n            \"body\"\n        ],\n        BinaryExpression: [\n            \"left\",\n            \"right\"\n        ],\n        BreakStatement: [\n            \"label\"\n        ],\n        CallExpression: [\n            \"callee\",\n            \"arguments\"\n        ],\n        CatchClause: [\n            \"param\",\n            \"body\"\n        ],\n        ClassBody: [\n            \"body\"\n        ],\n        ClassDeclaration: [\n            \"id\",\n            \"superClass\",\n            \"body\"\n        ],\n        ClassExpression: [\n            \"id\",\n            \"superClass\",\n            \"body\"\n        ],\n        ComprehensionBlock: [\n            \"left\",\n            \"right\"\n        ],\n        ComprehensionExpression: [\n            \"blocks\",\n            \"filter\",\n            \"body\"\n        ],\n        ConditionalExpression: [\n            \"test\",\n            \"consequent\",\n            \"alternate\"\n        ],\n        ContinueStatement: [\n            \"label\"\n        ],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: [\n            \"body\",\n            \"test\"\n        ],\n        EmptyStatement: [],\n        ExportAllDeclaration: [\n            \"source\"\n        ],\n        ExportDefaultDeclaration: [\n            \"declaration\"\n        ],\n        ExportNamedDeclaration: [\n            \"declaration\",\n            \"specifiers\",\n            \"source\"\n        ],\n        ExportSpecifier: [\n            \"exported\",\n            \"local\"\n        ],\n        ExpressionStatement: [\n            \"expression\"\n        ],\n        ForStatement: [\n            \"init\",\n            \"test\",\n            \"update\",\n            \"body\"\n        ],\n        ForInStatement: [\n            \"left\",\n            \"right\",\n            \"body\"\n        ],\n        ForOfStatement: [\n            \"left\",\n            \"right\",\n            \"body\"\n        ],\n        FunctionDeclaration: [\n            \"id\",\n            \"params\",\n            \"body\"\n        ],\n        FunctionExpression: [\n            \"id\",\n            \"params\",\n            \"body\"\n        ],\n        GeneratorExpression: [\n            \"blocks\",\n            \"filter\",\n            \"body\"\n        ],\n        Identifier: [],\n        IfStatement: [\n            \"test\",\n            \"consequent\",\n            \"alternate\"\n        ],\n        ImportExpression: [\n            \"source\"\n        ],\n        ImportDeclaration: [\n            \"specifiers\",\n            \"source\"\n        ],\n        ImportDefaultSpecifier: [\n            \"local\"\n        ],\n        ImportNamespaceSpecifier: [\n            \"local\"\n        ],\n        ImportSpecifier: [\n            \"imported\",\n            \"local\"\n        ],\n        Literal: [],\n        LabeledStatement: [\n            \"label\",\n            \"body\"\n        ],\n        LogicalExpression: [\n            \"left\",\n            \"right\"\n        ],\n        MemberExpression: [\n            \"object\",\n            \"property\"\n        ],\n        MetaProperty: [\n            \"meta\",\n            \"property\"\n        ],\n        MethodDefinition: [\n            \"key\",\n            \"value\"\n        ],\n        ModuleSpecifier: [],\n        NewExpression: [\n            \"callee\",\n            \"arguments\"\n        ],\n        ObjectExpression: [\n            \"properties\"\n        ],\n        ObjectPattern: [\n            \"properties\"\n        ],\n        Program: [\n            \"body\"\n        ],\n        Property: [\n            \"key\",\n            \"value\"\n        ],\n        RestElement: [\n            \"argument\"\n        ],\n        ReturnStatement: [\n            \"argument\"\n        ],\n        SequenceExpression: [\n            \"expressions\"\n        ],\n        SpreadElement: [\n            \"argument\"\n        ],\n        Super: [],\n        SwitchStatement: [\n            \"discriminant\",\n            \"cases\"\n        ],\n        SwitchCase: [\n            \"test\",\n            \"consequent\"\n        ],\n        TaggedTemplateExpression: [\n            \"tag\",\n            \"quasi\"\n        ],\n        TemplateElement: [],\n        TemplateLiteral: [\n            \"quasis\",\n            \"expressions\"\n        ],\n        ThisExpression: [],\n        ThrowStatement: [\n            \"argument\"\n        ],\n        TryStatement: [\n            \"block\",\n            \"handler\",\n            \"finalizer\"\n        ],\n        UnaryExpression: [\n            \"argument\"\n        ],\n        UpdateExpression: [\n            \"argument\"\n        ],\n        VariableDeclaration: [\n            \"declarations\"\n        ],\n        VariableDeclarator: [\n            \"id\",\n            \"init\"\n        ],\n        WhileStatement: [\n            \"test\",\n            \"body\"\n        ],\n        WithStatement: [\n            \"object\",\n            \"body\"\n        ],\n        YieldExpression: [\n            \"argument\"\n        ]\n    };\n    // unique id\n    BREAK = {};\n    SKIP = {};\n    REMOVE = {};\n    VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n    };\n    function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n    }\n    Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n    };\n    Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n            this.parent.splice(this.key, 1);\n            return true;\n        } else {\n            this.replace(null);\n            return false;\n        }\n    };\n    function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n    }\n    function Controller() {}\n    // API:\n    // return property path array from root to current node\n    Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n        function addToPath(result, path) {\n            if (Array.isArray(path)) {\n                for(j = 0, jz = path.length; j < jz; ++j){\n                    result.push(path[j]);\n                }\n            } else {\n                result.push(path);\n            }\n        }\n        // root node\n        if (!this.__current.path) {\n            return null;\n        }\n        // first node is sentinel, second node is root element\n        result = [];\n        for(i = 2, iz = this.__leavelist.length; i < iz; ++i){\n            element = this.__leavelist[i];\n            addToPath(result, element.path);\n        }\n        addToPath(result, this.__current.path);\n        return result;\n    };\n    // API:\n    // return type of current node\n    Controller.prototype.type = function() {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n    };\n    // API:\n    // return array of parent elements\n    Controller.prototype.parents = function parents() {\n        var i, iz, result;\n        // first node is sentinel\n        result = [];\n        for(i = 1, iz = this.__leavelist.length; i < iz; ++i){\n            result.push(this.__leavelist[i].node);\n        }\n        return result;\n    };\n    // API:\n    // return current node\n    Controller.prototype.current = function current() {\n        return this.__current.node;\n    };\n    Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n        result = undefined;\n        previous = this.__current;\n        this.__current = element;\n        this.__state = null;\n        if (callback) {\n            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n        this.__current = previous;\n        return result;\n    };\n    // API:\n    // notify control skip / break\n    Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n    };\n    // API:\n    // skip child nodes of current node\n    Controller.prototype.skip = function() {\n        this.notify(SKIP);\n    };\n    // API:\n    // break traversals\n    Controller.prototype[\"break\"] = function() {\n        this.notify(BREAK);\n    };\n    // API:\n    // remove node\n    Controller.prototype.remove = function() {\n        this.notify(REMOVE);\n    };\n    Controller.prototype.__initialize = function(root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n        if (visitor.fallback === \"iteration\") {\n            this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === \"function\") {\n            this.__fallback = visitor.fallback;\n        }\n        this.__keys = VisitorKeys;\n        if (visitor.keys) {\n            this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n    };\n    function isNode(node) {\n        if (node == null) {\n            return false;\n        }\n        return typeof node === \"object\" && typeof node.type === \"string\";\n    }\n    function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && \"properties\" === key;\n    }\n    Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;\n        this.__initialize(root, visitor);\n        sentinel = {};\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n        // initialize\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n        while(worklist.length){\n            element = worklist.pop();\n            if (element === sentinel) {\n                element = leavelist.pop();\n                ret = this.__execute(visitor.leave, element);\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                continue;\n            }\n            if (element.node) {\n                ret = this.__execute(visitor.enter, element);\n                if (this.__state === BREAK || ret === BREAK) {\n                    return;\n                }\n                worklist.push(sentinel);\n                leavelist.push(element);\n                if (this.__state === SKIP || ret === SKIP) {\n                    continue;\n                }\n                node = element.node;\n                nodeType = node.type || element.wrap;\n                candidates = this.__keys[nodeType];\n                if (!candidates) {\n                    if (this.__fallback) {\n                        candidates = this.__fallback(node);\n                    } else {\n                        throw new Error(\"Unknown node type \" + nodeType + \".\");\n                    }\n                }\n                current = candidates.length;\n                while((current -= 1) >= 0){\n                    key = candidates[current];\n                    candidate = node[key];\n                    if (!candidate) {\n                        continue;\n                    }\n                    if (Array.isArray(candidate)) {\n                        current2 = candidate.length;\n                        while((current2 -= 1) >= 0){\n                            if (!candidate[current2]) {\n                                continue;\n                            }\n                            if (isProperty(nodeType, candidates[current])) {\n                                element = new Element(candidate[current2], [\n                                    key,\n                                    current2\n                                ], \"Property\", null);\n                            } else if (isNode(candidate[current2])) {\n                                element = new Element(candidate[current2], [\n                                    key,\n                                    current2\n                                ], null, null);\n                            } else {\n                                continue;\n                            }\n                            worklist.push(element);\n                        }\n                    } else if (isNode(candidate)) {\n                        worklist.push(new Element(candidate, key, null, null));\n                    }\n                }\n            }\n        }\n    };\n    Controller.prototype.replace = function replace(root, visitor) {\n        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;\n        function removeElem(element) {\n            var i, key, nextElem, parent;\n            if (element.ref.remove()) {\n                // When the reference is an element of an array.\n                key = element.ref.key;\n                parent = element.ref.parent;\n                // If removed from array, then decrease following items' keys.\n                i = worklist.length;\n                while(i--){\n                    nextElem = worklist[i];\n                    if (nextElem.ref && nextElem.ref.parent === parent) {\n                        if (nextElem.ref.key < key) {\n                            break;\n                        }\n                        --nextElem.ref.key;\n                    }\n                }\n            }\n        }\n        this.__initialize(root, visitor);\n        sentinel = {};\n        // reference\n        worklist = this.__worklist;\n        leavelist = this.__leavelist;\n        // initialize\n        outer = {\n            root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, \"root\"));\n        worklist.push(element);\n        leavelist.push(element);\n        while(worklist.length){\n            element = worklist.pop();\n            if (element === sentinel) {\n                element = leavelist.pop();\n                target = this.__execute(visitor.leave, element);\n                // node may be replaced with null,\n                // so distinguish between undefined and null in this place\n                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                    // replace\n                    element.ref.replace(target);\n                }\n                if (this.__state === REMOVE || target === REMOVE) {\n                    removeElem(element);\n                }\n                if (this.__state === BREAK || target === BREAK) {\n                    return outer.root;\n                }\n                continue;\n            }\n            target = this.__execute(visitor.enter, element);\n            // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n                // replace\n                element.ref.replace(target);\n                element.node = target;\n            }\n            if (this.__state === REMOVE || target === REMOVE) {\n                removeElem(element);\n                element.node = null;\n            }\n            if (this.__state === BREAK || target === BREAK) {\n                return outer.root;\n            }\n            // node may be null\n            node = element.node;\n            if (!node) {\n                continue;\n            }\n            worklist.push(sentinel);\n            leavelist.push(element);\n            if (this.__state === SKIP || target === SKIP) {\n                continue;\n            }\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n            if (!candidates) {\n                if (this.__fallback) {\n                    candidates = this.__fallback(node);\n                } else {\n                    throw new Error(\"Unknown node type \" + nodeType + \".\");\n                }\n            }\n            current = candidates.length;\n            while((current -= 1) >= 0){\n                key = candidates[current];\n                candidate = node[key];\n                if (!candidate) {\n                    continue;\n                }\n                if (Array.isArray(candidate)) {\n                    current2 = candidate.length;\n                    while((current2 -= 1) >= 0){\n                        if (!candidate[current2]) {\n                            continue;\n                        }\n                        if (isProperty(nodeType, candidates[current])) {\n                            element = new Element(candidate[current2], [\n                                key,\n                                current2\n                            ], \"Property\", new Reference(candidate, current2));\n                        } else if (isNode(candidate[current2])) {\n                            element = new Element(candidate[current2], [\n                                key,\n                                current2\n                            ], null, new Reference(candidate, current2));\n                        } else {\n                            continue;\n                        }\n                        worklist.push(element);\n                    }\n                } else if (isNode(candidate)) {\n                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n                }\n            }\n        }\n        return outer.root;\n    };\n    function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n    }\n    function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n    }\n    function extendCommentRange(comment, tokens) {\n        var target;\n        target = upperBound(tokens, function search(token) {\n            return token.range[0] > comment.range[0];\n        });\n        comment.extendedRange = [\n            comment.range[0],\n            comment.range[1]\n        ];\n        if (target !== tokens.length) {\n            comment.extendedRange[1] = tokens[target].range[0];\n        }\n        target -= 1;\n        if (target >= 0) {\n            comment.extendedRange[0] = tokens[target].range[1];\n        }\n        return comment;\n    }\n    function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [], comment, len, i, cursor;\n        if (!tree.range) {\n            throw new Error(\"attachComments needs range information\");\n        }\n        // tokens array is empty, we attach comments to tree as 'leadingComments'\n        if (!tokens.length) {\n            if (providedComments.length) {\n                for(i = 0, len = providedComments.length; i < len; i += 1){\n                    comment = deepCopy(providedComments[i]);\n                    comment.extendedRange = [\n                        0,\n                        tree.range[0]\n                    ];\n                    comments.push(comment);\n                }\n                tree.leadingComments = comments;\n            }\n            return tree;\n        }\n        for(i = 0, len = providedComments.length; i < len; i += 1){\n            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        }\n        // This is based on John Freeman's implementation.\n        cursor = 0;\n        traverse(tree, {\n            enter: function(node) {\n                var comment;\n                while(cursor < comments.length){\n                    comment = comments[cursor];\n                    if (comment.extendedRange[1] > node.range[0]) {\n                        break;\n                    }\n                    if (comment.extendedRange[1] === node.range[0]) {\n                        if (!node.leadingComments) {\n                            node.leadingComments = [];\n                        }\n                        node.leadingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n        cursor = 0;\n        traverse(tree, {\n            leave: function(node) {\n                var comment;\n                while(cursor < comments.length){\n                    comment = comments[cursor];\n                    if (node.range[1] < comment.extendedRange[0]) {\n                        break;\n                    }\n                    if (node.range[1] === comment.extendedRange[0]) {\n                        if (!node.trailingComments) {\n                            node.trailingComments = [];\n                        }\n                        node.trailingComments.push(comment);\n                        comments.splice(cursor, 1);\n                    } else {\n                        cursor += 1;\n                    }\n                }\n                // already out of owned node\n                if (cursor === comments.length) {\n                    return VisitorOption.Break;\n                }\n                if (comments[cursor].extendedRange[0] > node.range[1]) {\n                    return VisitorOption.Skip;\n                }\n            }\n        });\n        return tree;\n    }\n    exports1.version = (__webpack_require__(/*! ./package.json */ \"(rsc)/./node_modules/escodegen/node_modules/estraverse/package.json\").version);\n    exports1.Syntax = Syntax;\n    exports1.traverse = traverse;\n    exports1.replace = replace;\n    exports1.attachComments = attachComments;\n    exports1.VisitorKeys = VisitorKeys;\n    exports1.VisitorOption = VisitorOption;\n    exports1.Controller = Controller;\n    exports1.cloneEnvironment = function() {\n        return clone({});\n    };\n    return exports1;\n})(exports); /* vim: set sw=4 ts=4 et tw=80 : */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZXNjb2RlZ2VuL25vZGVfbW9kdWxlcy9lc3RyYXZlcnNlL2VzdHJhdmVyc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJBLEdBQ0EsaUNBQWlDLEdBQ2pDLGlCQUFpQixHQUNqQixxQkFBcUIsR0FDcEIsVUFBU0EsTUFBTUMsUUFBTztJQUNuQjtJQUVBLElBQUlDLFFBQ0FDLGVBQ0FDLGFBQ0FDLE9BQ0FDLE1BQ0FDO0lBRUosU0FBU0MsU0FBU0MsR0FBRztRQUNqQixJQUFJQyxNQUFNLENBQUMsR0FBR0MsS0FBS0M7UUFDbkIsSUFBS0QsT0FBT0YsSUFBSztZQUNiLElBQUlBLElBQUlJLGNBQWMsQ0FBQ0YsTUFBTTtnQkFDekJDLE1BQU1ILEdBQUcsQ0FBQ0UsSUFBSTtnQkFDZCxJQUFJLE9BQU9DLFFBQVEsWUFBWUEsUUFBUSxNQUFNO29CQUN6Q0YsR0FBRyxDQUFDQyxJQUFJLEdBQUdILFNBQVNJO2dCQUN4QixPQUFPO29CQUNIRixHQUFHLENBQUNDLElBQUksR0FBR0M7Z0JBQ2Y7WUFDSjtRQUNKO1FBQ0EsT0FBT0Y7SUFDWDtJQUVBLGlEQUFpRDtJQUNqRCxjQUFjO0lBRWQsU0FBU0ksV0FBV0MsS0FBSyxFQUFFQyxJQUFJO1FBQzNCLElBQUlDLE1BQU1DLEtBQUtDLEdBQUdDO1FBRWxCRixNQUFNSCxNQUFNTSxNQUFNO1FBQ2xCRixJQUFJO1FBRUosTUFBT0QsSUFBSztZQUNSRCxPQUFPQyxRQUFRO1lBQ2ZFLFVBQVVELElBQUlGO1lBQ2QsSUFBSUQsS0FBS0QsS0FBSyxDQUFDSyxRQUFRLEdBQUc7Z0JBQ3RCRixNQUFNRDtZQUNWLE9BQU87Z0JBQ0hFLElBQUlDLFVBQVU7Z0JBQ2RGLE9BQU9ELE9BQU87WUFDbEI7UUFDSjtRQUNBLE9BQU9FO0lBQ1g7SUFFQWpCLFNBQVM7UUFDTG9CLHNCQUFzQjtRQUN0QkMsbUJBQW1CO1FBQ25CQyxpQkFBaUI7UUFDakJDLGNBQWM7UUFD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LENBQUMsRUFBRSxFQUFFO3dCQUM1QyxJQUFJLENBQUNsRSxLQUFLeUUsZ0JBQWdCLEVBQUU7NEJBQ3hCekUsS0FBS3lFLGdCQUFnQixHQUFHLEVBQUU7d0JBQzlCO3dCQUNBekUsS0FBS3lFLGdCQUFnQixDQUFDekQsSUFBSSxDQUFDNkM7d0JBQzNCUyxTQUFTbEUsTUFBTSxDQUFDbUUsUUFBUTtvQkFDNUIsT0FBTzt3QkFDSEEsVUFBVTtvQkFDZDtnQkFDSjtnQkFFQSw0QkFBNEI7Z0JBQzVCLElBQUlBLFdBQVdELFNBQVN0SixNQUFNLEVBQUU7b0JBQzVCLE9BQU9sQixjQUFjMkYsS0FBSztnQkFDOUI7Z0JBRUEsSUFBSTZFLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDTCxhQUFhLENBQUMsRUFBRSxHQUFHbEUsS0FBS2lFLEtBQUssQ0FBQyxFQUFFLEVBQUU7b0JBQ25ELE9BQU9uSyxjQUFjNEYsSUFBSTtnQkFDN0I7WUFDSjtRQUNKO1FBRUEsT0FBTzBFO0lBQ1g7SUFFQXhLLFNBQVE4SyxPQUFPLEdBQUdDLDBIQUFpQztJQUNuRC9LLFNBQVFDLE1BQU0sR0FBR0E7SUFDakJELFNBQVFnSixRQUFRLEdBQUdBO0lBQ25CaEosU0FBUW1HLE9BQU8sR0FBR0E7SUFDbEJuRyxTQUFRdUssY0FBYyxHQUFHQTtJQUN6QnZLLFNBQVFHLFdBQVcsR0FBR0E7SUFDdEJILFNBQVFFLGFBQWEsR0FBR0E7SUFDeEJGLFNBQVE2RyxVQUFVLEdBQUdBO0lBQ3JCN0csU0FBUWdMLGdCQUFnQixHQUFHO1FBQWMsT0FBT2pMLE1BQU0sQ0FBQztJQUFJO0lBRTNELE9BQU9DO0FBQ1gsR0FBRUEsVUFDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9lc2NvZGVnZW4vbm9kZV9tb2R1bGVzL2VzdHJhdmVyc2UvZXN0cmF2ZXJzZS5qcz8yNmZiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDEzIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG4vKmpzbGludCB2YXJzOmZhbHNlLCBiaXR3aXNlOnRydWUqL1xuLypqc2hpbnQgaW5kZW50OjQqL1xuLypnbG9iYWwgZXhwb3J0czp0cnVlKi9cbihmdW5jdGlvbiBjbG9uZShleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFN5bnRheCxcbiAgICAgICAgVmlzaXRvck9wdGlvbixcbiAgICAgICAgVmlzaXRvcktleXMsXG4gICAgICAgIEJSRUFLLFxuICAgICAgICBTS0lQLFxuICAgICAgICBSRU1PVkU7XG5cbiAgICBmdW5jdGlvbiBkZWVwQ29weShvYmopIHtcbiAgICAgICAgdmFyIHJldCA9IHt9LCBrZXksIHZhbDtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZGVlcENvcHkodmFsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBiYXNlZCBvbiBMTFZNIGxpYmMrKyB1cHBlcl9ib3VuZCAvIGxvd2VyX2JvdW5kXG4gICAgLy8gTUlUIExpY2Vuc2VcblxuICAgIGZ1bmN0aW9uIHVwcGVyQm91bmQoYXJyYXksIGZ1bmMpIHtcbiAgICAgICAgdmFyIGRpZmYsIGxlbiwgaSwgY3VycmVudDtcblxuICAgICAgICBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsZW4pIHtcbiAgICAgICAgICAgIGRpZmYgPSBsZW4gPj4+IDE7XG4gICAgICAgICAgICBjdXJyZW50ID0gaSArIGRpZmY7XG4gICAgICAgICAgICBpZiAoZnVuYyhhcnJheVtjdXJyZW50XSkpIHtcbiAgICAgICAgICAgICAgICBsZW4gPSBkaWZmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudCArIDE7XG4gICAgICAgICAgICAgICAgbGVuIC09IGRpZmYgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIFN5bnRheCA9IHtcbiAgICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICAgIEFzc2lnbm1lbnRQYXR0ZXJuOiAnQXNzaWdubWVudFBhdHRlcm4nLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgICBBcnJheVBhdHRlcm46ICdBcnJheVBhdHRlcm4nLFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbiAgICAgICAgQXdhaXRFeHByZXNzaW9uOiAnQXdhaXRFeHByZXNzaW9uJywgLy8gQ0FVVElPTjogSXQncyBkZWZlcnJlZCB0byBFUzcuXG4gICAgICAgIEJsb2NrU3RhdGVtZW50OiAnQmxvY2tTdGF0ZW1lbnQnLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICAgIEJyZWFrU3RhdGVtZW50OiAnQnJlYWtTdGF0ZW1lbnQnLFxuICAgICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgICAgQ2F0Y2hDbGF1c2U6ICdDYXRjaENsYXVzZScsXG4gICAgICAgIENsYXNzQm9keTogJ0NsYXNzQm9keScsXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246ICdDbGFzc0RlY2xhcmF0aW9uJyxcbiAgICAgICAgQ2xhc3NFeHByZXNzaW9uOiAnQ2xhc3NFeHByZXNzaW9uJyxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiAnQ29tcHJlaGVuc2lvbkJsb2NrJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogJ0NvbXByZWhlbnNpb25FeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogJ0NvbnRpbnVlU3RhdGVtZW50JyxcbiAgICAgICAgRGVidWdnZXJTdGF0ZW1lbnQ6ICdEZWJ1Z2dlclN0YXRlbWVudCcsXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogJ0RpcmVjdGl2ZVN0YXRlbWVudCcsXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6ICdEb1doaWxlU3RhdGVtZW50JyxcbiAgICAgICAgRW1wdHlTdGF0ZW1lbnQ6ICdFbXB0eVN0YXRlbWVudCcsXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiAnRXhwb3J0QWxsRGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnREZWZhdWx0RGVjbGFyYXRpb246ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicsXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogJ0V4cG9ydFNwZWNpZmllcicsXG4gICAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgRm9yU3RhdGVtZW50OiAnRm9yU3RhdGVtZW50JyxcbiAgICAgICAgRm9ySW5TdGF0ZW1lbnQ6ICdGb3JJblN0YXRlbWVudCcsXG4gICAgICAgIEZvck9mU3RhdGVtZW50OiAnRm9yT2ZTdGF0ZW1lbnQnLFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiAnRnVuY3Rpb25EZWNsYXJhdGlvbicsXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246ICdHZW5lcmF0b3JFeHByZXNzaW9uJywgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICAgIElmU3RhdGVtZW50OiAnSWZTdGF0ZW1lbnQnLFxuICAgICAgICBJbXBvcnRFeHByZXNzaW9uOiAnSW1wb3J0RXhwcmVzc2lvbicsXG4gICAgICAgIEltcG9ydERlY2xhcmF0aW9uOiAnSW1wb3J0RGVjbGFyYXRpb24nLFxuICAgICAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjogJ0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcicsXG4gICAgICAgIEltcG9ydFNwZWNpZmllcjogJ0ltcG9ydFNwZWNpZmllcicsXG4gICAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogJ0xhYmVsZWRTdGF0ZW1lbnQnLFxuICAgICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgICBNZXRhUHJvcGVydHk6ICdNZXRhUHJvcGVydHknLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiAnTWV0aG9kRGVmaW5pdGlvbicsXG4gICAgICAgIE1vZHVsZVNwZWNpZmllcjogJ01vZHVsZVNwZWNpZmllcicsXG4gICAgICAgIE5ld0V4cHJlc3Npb246ICdOZXdFeHByZXNzaW9uJyxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgICBPYmplY3RQYXR0ZXJuOiAnT2JqZWN0UGF0dGVybicsXG4gICAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICAgIFJlc3RFbGVtZW50OiAnUmVzdEVsZW1lbnQnLFxuICAgICAgICBSZXR1cm5TdGF0ZW1lbnQ6ICdSZXR1cm5TdGF0ZW1lbnQnLFxuICAgICAgICBTZXF1ZW5jZUV4cHJlc3Npb246ICdTZXF1ZW5jZUV4cHJlc3Npb24nLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiAnU3ByZWFkRWxlbWVudCcsXG4gICAgICAgIFN1cGVyOiAnU3VwZXInLFxuICAgICAgICBTd2l0Y2hTdGF0ZW1lbnQ6ICdTd2l0Y2hTdGF0ZW1lbnQnLFxuICAgICAgICBTd2l0Y2hDYXNlOiAnU3dpdGNoQ2FzZScsXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogJ1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbicsXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogJ1RlbXBsYXRlRWxlbWVudCcsXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogJ1RlbXBsYXRlTGl0ZXJhbCcsXG4gICAgICAgIFRoaXNFeHByZXNzaW9uOiAnVGhpc0V4cHJlc3Npb24nLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogJ1Rocm93U3RhdGVtZW50JyxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAnVHJ5U3RhdGVtZW50JyxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nLFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiAnVmFyaWFibGVEZWNsYXJhdGlvbicsXG4gICAgICAgIFZhcmlhYmxlRGVjbGFyYXRvcjogJ1ZhcmlhYmxlRGVjbGFyYXRvcicsXG4gICAgICAgIFdoaWxlU3RhdGVtZW50OiAnV2hpbGVTdGF0ZW1lbnQnLFxuICAgICAgICBXaXRoU3RhdGVtZW50OiAnV2l0aFN0YXRlbWVudCcsXG4gICAgICAgIFlpZWxkRXhwcmVzc2lvbjogJ1lpZWxkRXhwcmVzc2lvbidcbiAgICB9O1xuXG4gICAgVmlzaXRvcktleXMgPSB7XG4gICAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IFsnZWxlbWVudHMnXSxcbiAgICAgICAgQXJyYXlQYXR0ZXJuOiBbJ2VsZW1lbnRzJ10sXG4gICAgICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uOiBbJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEF3YWl0RXhwcmVzc2lvbjogWydhcmd1bWVudCddLCAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgQmxvY2tTdGF0ZW1lbnQ6IFsnYm9keSddLFxuICAgICAgICBCaW5hcnlFeHByZXNzaW9uOiBbJ2xlZnQnLCAncmlnaHQnXSxcbiAgICAgICAgQnJlYWtTdGF0ZW1lbnQ6IFsnbGFiZWwnXSxcbiAgICAgICAgQ2FsbEV4cHJlc3Npb246IFsnY2FsbGVlJywgJ2FyZ3VtZW50cyddLFxuICAgICAgICBDYXRjaENsYXVzZTogWydwYXJhbScsICdib2R5J10sXG4gICAgICAgIENsYXNzQm9keTogWydib2R5J10sXG4gICAgICAgIENsYXNzRGVjbGFyYXRpb246IFsnaWQnLCAnc3VwZXJDbGFzcycsICdib2R5J10sXG4gICAgICAgIENsYXNzRXhwcmVzc2lvbjogWydpZCcsICdzdXBlckNsYXNzJywgJ2JvZHknXSxcbiAgICAgICAgQ29tcHJlaGVuc2lvbkJsb2NrOiBbJ2xlZnQnLCAncmlnaHQnXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb21wcmVoZW5zaW9uRXhwcmVzc2lvbjogWydibG9ja3MnLCAnZmlsdGVyJywgJ2JvZHknXSwgIC8vIENBVVRJT046IEl0J3MgZGVmZXJyZWQgdG8gRVM3LlxuICAgICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246IFsndGVzdCcsICdjb25zZXF1ZW50JywgJ2FsdGVybmF0ZSddLFxuICAgICAgICBDb250aW51ZVN0YXRlbWVudDogWydsYWJlbCddLFxuICAgICAgICBEZWJ1Z2dlclN0YXRlbWVudDogW10sXG4gICAgICAgIERpcmVjdGl2ZVN0YXRlbWVudDogW10sXG4gICAgICAgIERvV2hpbGVTdGF0ZW1lbnQ6IFsnYm9keScsICd0ZXN0J10sXG4gICAgICAgIEVtcHR5U3RhdGVtZW50OiBbXSxcbiAgICAgICAgRXhwb3J0QWxsRGVjbGFyYXRpb246IFsnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbiddLFxuICAgICAgICBFeHBvcnROYW1lZERlY2xhcmF0aW9uOiBbJ2RlY2xhcmF0aW9uJywgJ3NwZWNpZmllcnMnLCAnc291cmNlJ10sXG4gICAgICAgIEV4cG9ydFNwZWNpZmllcjogWydleHBvcnRlZCcsICdsb2NhbCddLFxuICAgICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBbJ2V4cHJlc3Npb24nXSxcbiAgICAgICAgRm9yU3RhdGVtZW50OiBbJ2luaXQnLCAndGVzdCcsICd1cGRhdGUnLCAnYm9keSddLFxuICAgICAgICBGb3JJblN0YXRlbWVudDogWydsZWZ0JywgJ3JpZ2h0JywgJ2JvZHknXSxcbiAgICAgICAgRm9yT2ZTdGF0ZW1lbnQ6IFsnbGVmdCcsICdyaWdodCcsICdib2R5J10sXG4gICAgICAgIEZ1bmN0aW9uRGVjbGFyYXRpb246IFsnaWQnLCAncGFyYW1zJywgJ2JvZHknXSxcbiAgICAgICAgRnVuY3Rpb25FeHByZXNzaW9uOiBbJ2lkJywgJ3BhcmFtcycsICdib2R5J10sXG4gICAgICAgIEdlbmVyYXRvckV4cHJlc3Npb246IFsnYmxvY2tzJywgJ2ZpbHRlcicsICdib2R5J10sICAvLyBDQVVUSU9OOiBJdCdzIGRlZmVycmVkIHRvIEVTNy5cbiAgICAgICAgSWRlbnRpZmllcjogW10sXG4gICAgICAgIElmU3RhdGVtZW50OiBbJ3Rlc3QnLCAnY29uc2VxdWVudCcsICdhbHRlcm5hdGUnXSxcbiAgICAgICAgSW1wb3J0RXhwcmVzc2lvbjogWydzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVjbGFyYXRpb246IFsnc3BlY2lmaWVycycsICdzb3VyY2UnXSxcbiAgICAgICAgSW1wb3J0RGVmYXVsdFNwZWNpZmllcjogWydsb2NhbCddLFxuICAgICAgICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFsnbG9jYWwnXSxcbiAgICAgICAgSW1wb3J0U3BlY2lmaWVyOiBbJ2ltcG9ydGVkJywgJ2xvY2FsJ10sXG4gICAgICAgIExpdGVyYWw6IFtdLFxuICAgICAgICBMYWJlbGVkU3RhdGVtZW50OiBbJ2xhYmVsJywgJ2JvZHknXSxcbiAgICAgICAgTG9naWNhbEV4cHJlc3Npb246IFsnbGVmdCcsICdyaWdodCddLFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBbJ29iamVjdCcsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRhUHJvcGVydHk6IFsnbWV0YScsICdwcm9wZXJ0eSddLFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgICBNb2R1bGVTcGVjaWZpZXI6IFtdLFxuICAgICAgICBOZXdFeHByZXNzaW9uOiBbJ2NhbGxlZScsICdhcmd1bWVudHMnXSxcbiAgICAgICAgT2JqZWN0RXhwcmVzc2lvbjogWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgIE9iamVjdFBhdHRlcm46IFsncHJvcGVydGllcyddLFxuICAgICAgICBQcm9ncmFtOiBbJ2JvZHknXSxcbiAgICAgICAgUHJvcGVydHk6IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgIFJlc3RFbGVtZW50OiBbICdhcmd1bWVudCcgXSxcbiAgICAgICAgUmV0dXJuU3RhdGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogWydleHByZXNzaW9ucyddLFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFN1cGVyOiBbXSxcbiAgICAgICAgU3dpdGNoU3RhdGVtZW50OiBbJ2Rpc2NyaW1pbmFudCcsICdjYXNlcyddLFxuICAgICAgICBTd2l0Y2hDYXNlOiBbJ3Rlc3QnLCAnY29uc2VxdWVudCddLFxuICAgICAgICBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb246IFsndGFnJywgJ3F1YXNpJ10sXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogW10sXG4gICAgICAgIFRlbXBsYXRlTGl0ZXJhbDogWydxdWFzaXMnLCAnZXhwcmVzc2lvbnMnXSxcbiAgICAgICAgVGhpc0V4cHJlc3Npb246IFtdLFxuICAgICAgICBUaHJvd1N0YXRlbWVudDogWydhcmd1bWVudCddLFxuICAgICAgICBUcnlTdGF0ZW1lbnQ6IFsnYmxvY2snLCAnaGFuZGxlcicsICdmaW5hbGl6ZXInXSxcbiAgICAgICAgVW5hcnlFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J10sXG4gICAgICAgIFVwZGF0ZUV4cHJlc3Npb246IFsnYXJndW1lbnQnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdGlvbjogWydkZWNsYXJhdGlvbnMnXSxcbiAgICAgICAgVmFyaWFibGVEZWNsYXJhdG9yOiBbJ2lkJywgJ2luaXQnXSxcbiAgICAgICAgV2hpbGVTdGF0ZW1lbnQ6IFsndGVzdCcsICdib2R5J10sXG4gICAgICAgIFdpdGhTdGF0ZW1lbnQ6IFsnb2JqZWN0JywgJ2JvZHknXSxcbiAgICAgICAgWWllbGRFeHByZXNzaW9uOiBbJ2FyZ3VtZW50J11cbiAgICB9O1xuXG4gICAgLy8gdW5pcXVlIGlkXG4gICAgQlJFQUsgPSB7fTtcbiAgICBTS0lQID0ge307XG4gICAgUkVNT1ZFID0ge307XG5cbiAgICBWaXNpdG9yT3B0aW9uID0ge1xuICAgICAgICBCcmVhazogQlJFQUssXG4gICAgICAgIFNraXA6IFNLSVAsXG4gICAgICAgIFJlbW92ZTogUkVNT1ZFXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFJlZmVyZW5jZShwYXJlbnQsIGtleSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShub2RlKSB7XG4gICAgICAgIHRoaXMucGFyZW50W3RoaXMua2V5XSA9IG5vZGU7XG4gICAgfTtcblxuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNwbGljZSh0aGlzLmtleSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBFbGVtZW50KG5vZGUsIHBhdGgsIHdyYXAsIHJlZikge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLndyYXAgPSB3cmFwO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb250cm9sbGVyKCkgeyB9XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gcmV0dXJuIHByb3BlcnR5IHBhdGggYXJyYXkgZnJvbSByb290IHRvIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbiBwYXRoKCkge1xuICAgICAgICB2YXIgaSwgaXosIGosIGp6LCByZXN1bHQsIGVsZW1lbnQ7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkVG9QYXRoKHJlc3VsdCwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqeiA9IHBhdGgubGVuZ3RoOyBqIDwgano7ICsraikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcm9vdCBub2RlXG4gICAgICAgIGlmICghdGhpcy5fX2N1cnJlbnQucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCBub2RlIGlzIHNlbnRpbmVsLCBzZWNvbmQgbm9kZSBpcyByb290IGVsZW1lbnRcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDIsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fX2xlYXZlbGlzdFtpXTtcbiAgICAgICAgICAgIGFkZFRvUGF0aChyZXN1bHQsIGVsZW1lbnQucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9QYXRoKHJlc3VsdCwgdGhpcy5fX2N1cnJlbnQucGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gdHlwZSBvZiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICByZXR1cm4gbm9kZS50eXBlIHx8IHRoaXMuX19jdXJyZW50LndyYXA7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZXR1cm4gYXJyYXkgb2YgcGFyZW50IGVsZW1lbnRzXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucGFyZW50cyA9IGZ1bmN0aW9uIHBhcmVudHMoKSB7XG4gICAgICAgIHZhciBpLCBpeiwgcmVzdWx0O1xuXG4gICAgICAgIC8vIGZpcnN0IG5vZGUgaXMgc2VudGluZWxcbiAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDEsIGl6ID0gdGhpcy5fX2xlYXZlbGlzdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9fbGVhdmVsaXN0W2ldLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIHJldHVybiBjdXJyZW50IG5vZGVcbiAgICBDb250cm9sbGVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdXJyZW50Lm5vZGU7XG4gICAgfTtcblxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLl9fZXhlY3V0ZSA9IGZ1bmN0aW9uIF9fZXhlY3V0ZShjYWxsYmFjaywgZWxlbWVudCkge1xuICAgICAgICB2YXIgcHJldmlvdXMsIHJlc3VsdDtcblxuICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgcHJldmlvdXMgID0gdGhpcy5fX2N1cnJlbnQ7XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gbnVsbDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjay5jYWxsKHRoaXMsIGVsZW1lbnQubm9kZSwgdGhpcy5fX2xlYXZlbGlzdFt0aGlzLl9fbGVhdmVsaXN0Lmxlbmd0aCAtIDFdLm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdXJyZW50ID0gcHJldmlvdXM7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLy8gQVBJOlxuICAgIC8vIG5vdGlmeSBjb250cm9sIHNraXAgLyBicmVha1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeShmbGFnKSB7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IGZsYWc7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyBza2lwIGNoaWxkIG5vZGVzIG9mIGN1cnJlbnQgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm90aWZ5KFNLSVApO1xuICAgIH07XG5cbiAgICAvLyBBUEk6XG4gICAgLy8gYnJlYWsgdHJhdmVyc2Fsc1xuICAgIENvbnRyb2xsZXIucHJvdG90eXBlWydicmVhayddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5vdGlmeShCUkVBSyk7XG4gICAgfTtcblxuICAgIC8vIEFQSTpcbiAgICAvLyByZW1vdmUgbm9kZVxuICAgIENvbnRyb2xsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnkoUkVNT1ZFKTtcbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUuX19pbml0aWFsaXplID0gZnVuY3Rpb24ocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB0aGlzLnZpc2l0b3IgPSB2aXNpdG9yO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLl9fd29ya2xpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fX2xlYXZlbGlzdCA9IFtdO1xuICAgICAgICB0aGlzLl9fY3VycmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX19mYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGlmICh2aXNpdG9yLmZhbGxiYWNrID09PSAnaXRlcmF0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fX2ZhbGxiYWNrID0gT2JqZWN0LmtleXM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZpc2l0b3IuZmFsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX19mYWxsYmFjayA9IHZpc2l0b3IuZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fa2V5cyA9IFZpc2l0b3JLZXlzO1xuICAgICAgICBpZiAodmlzaXRvci5rZXlzKSB7XG4gICAgICAgICAgICB0aGlzLl9fa2V5cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZSh0aGlzLl9fa2V5cyksIHZpc2l0b3Iua2V5cyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGUudHlwZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlVHlwZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAobm9kZVR5cGUgPT09IFN5bnRheC5PYmplY3RFeHByZXNzaW9uIHx8IG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybikgJiYgJ3Byb3BlcnRpZXMnID09PSBrZXk7XG4gICAgfVxuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShyb290LCB2aXNpdG9yKSB7XG4gICAgICAgIHZhciB3b3JrbGlzdCxcbiAgICAgICAgICAgIGxlYXZlbGlzdCxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgY3VycmVudDIsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICAgICAgc2VudGluZWw7XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG51bGwpKTtcbiAgICAgICAgbGVhdmVsaXN0LnB1c2gobmV3IEVsZW1lbnQobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCkpO1xuXG4gICAgICAgIHdoaWxlICh3b3JrbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSB3b3JrbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHNlbnRpbmVsKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGxlYXZlbGlzdC5wb3AoKTtcblxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX19leGVjdXRlKHZpc2l0b3IubGVhdmUsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgcmV0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlKSB7XG5cbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHJldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgICAgIGxlYXZlbGlzdC5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gU0tJUCB8fCByZXQgPT09IFNLSVApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbm9kZSA9IGVsZW1lbnQubm9kZTtcbiAgICAgICAgICAgICAgICBub2RlVHlwZSA9IG5vZGUudHlwZSB8fCBlbGVtZW50LndyYXA7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19rZXlzW25vZGVUeXBlXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHRoaXMuX19mYWxsYmFjayhub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHR5cGUgJyArIG5vZGVUeXBlICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnQgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudDIgLT0gMSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuZGlkYXRlW2N1cnJlbnQyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHkobm9kZVR5cGUsIGNhbmRpZGF0ZXNbY3VycmVudF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOb2RlKGNhbmRpZGF0ZVtjdXJyZW50Ml0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTm9kZShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29udHJvbGxlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgd29ya2xpc3QsXG4gICAgICAgICAgICBsZWF2ZWxpc3QsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbm9kZVR5cGUsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGN1cnJlbnQyLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIHNlbnRpbmVsLFxuICAgICAgICAgICAgb3V0ZXIsXG4gICAgICAgICAgICBrZXk7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRWxlbShlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgbmV4dEVsZW0sXG4gICAgICAgICAgICAgICAgcGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5yZWYucmVtb3ZlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSByZWZlcmVuY2UgaXMgYW4gZWxlbWVudCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICBrZXkgPSBlbGVtZW50LnJlZi5rZXk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5yZWYucGFyZW50O1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgcmVtb3ZlZCBmcm9tIGFycmF5LCB0aGVuIGRlY3JlYXNlIGZvbGxvd2luZyBpdGVtcycga2V5cy5cbiAgICAgICAgICAgICAgICBpID0gd29ya2xpc3QubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsZW0gPSB3b3JrbGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRFbGVtLnJlZiAmJiBuZXh0RWxlbS5yZWYucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICAobmV4dEVsZW0ucmVmLmtleSA8IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLS1uZXh0RWxlbS5yZWYua2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2luaXRpYWxpemUocm9vdCwgdmlzaXRvcik7XG5cbiAgICAgICAgc2VudGluZWwgPSB7fTtcblxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgd29ya2xpc3QgPSB0aGlzLl9fd29ya2xpc3Q7XG4gICAgICAgIGxlYXZlbGlzdCA9IHRoaXMuX19sZWF2ZWxpc3Q7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZVxuICAgICAgICBvdXRlciA9IHtcbiAgICAgICAgICAgIHJvb3Q6IHJvb3RcbiAgICAgICAgfTtcbiAgICAgICAgZWxlbWVudCA9IG5ldyBFbGVtZW50KHJvb3QsIG51bGwsIG51bGwsIG5ldyBSZWZlcmVuY2Uob3V0ZXIsICdyb290JykpO1xuICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBsZWF2ZWxpc3QucHVzaChlbGVtZW50KTtcblxuICAgICAgICB3aGlsZSAod29ya2xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gd29ya2xpc3QucG9wKCk7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50ID09PSBzZW50aW5lbCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBsZWF2ZWxpc3QucG9wKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmxlYXZlLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIG5vZGUgbWF5IGJlIHJlcGxhY2VkIHdpdGggbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBzbyBkaXN0aW5ndWlzaCBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgbnVsbCBpbiB0aGlzIHBsYWNlXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gQlJFQUsgJiYgdGFyZ2V0ICE9PSBTS0lQICYmIHRhcmdldCAhPT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZWYucmVwbGFjZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFJFTU9WRSB8fCB0YXJnZXQgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFbGVtKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IEJSRUFLIHx8IHRhcmdldCA9PT0gQlJFQUspIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyLnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLl9fZXhlY3V0ZSh2aXNpdG9yLmVudGVyLCBlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gbm9kZSBtYXkgYmUgcmVwbGFjZWQgd2l0aCBudWxsLFxuICAgICAgICAgICAgLy8gc28gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgYW5kIG51bGwgaW4gdGhpcyBwbGFjZVxuICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldCAhPT0gQlJFQUsgJiYgdGFyZ2V0ICE9PSBTS0lQICYmIHRhcmdldCAhPT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZVxuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVmLnJlcGxhY2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5vZGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFJFTU9WRSB8fCB0YXJnZXQgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW0oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ub2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19zdGF0ZSA9PT0gQlJFQUsgfHwgdGFyZ2V0ID09PSBCUkVBSykge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRlci5yb290O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBub2RlIG1heSBiZSBudWxsXG4gICAgICAgICAgICBub2RlID0gZWxlbWVudC5ub2RlO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdvcmtsaXN0LnB1c2goc2VudGluZWwpO1xuICAgICAgICAgICAgbGVhdmVsaXN0LnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUgPT09IFNLSVAgfHwgdGFyZ2V0ID09PSBTS0lQKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVUeXBlID0gbm9kZS50eXBlIHx8IGVsZW1lbnQud3JhcDtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fa2V5c1tub2RlVHlwZV07XG4gICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB0aGlzLl9fZmFsbGJhY2sobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG5vZGUgdHlwZSAnICsgbm9kZVR5cGUgKyAnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudCA9IGNhbmRpZGF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50IC09IDEpID49IDApIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBjYW5kaWRhdGVzW2N1cnJlbnRdO1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYW5kaWRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQyID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50MiAtPSAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmRpZGF0ZVtjdXJyZW50Ml0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5KG5vZGVUeXBlLCBjYW5kaWRhdGVzW2N1cnJlbnRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBuZXcgRWxlbWVudChjYW5kaWRhdGVbY3VycmVudDJdLCBba2V5LCBjdXJyZW50Ml0sICdQcm9wZXJ0eScsIG5ldyBSZWZlcmVuY2UoY2FuZGlkYXRlLCBjdXJyZW50MikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlW2N1cnJlbnQyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQoY2FuZGlkYXRlW2N1cnJlbnQyXSwgW2tleSwgY3VycmVudDJdLCBudWxsLCBuZXcgUmVmZXJlbmNlKGNhbmRpZGF0ZSwgY3VycmVudDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc05vZGUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrbGlzdC5wdXNoKG5ldyBFbGVtZW50KGNhbmRpZGF0ZSwga2V5LCBudWxsLCBuZXcgUmVmZXJlbmNlKG5vZGUsIGtleSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0ZXIucm9vdDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJhdmVyc2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnRyYXZlcnNlKHJvb3QsIHZpc2l0b3IpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uocm9vdCwgdmlzaXRvcikge1xuICAgICAgICB2YXIgY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyKCk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLnJlcGxhY2Uocm9vdCwgdmlzaXRvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kQ29tbWVudFJhbmdlKGNvbW1lbnQsIHRva2Vucykge1xuICAgICAgICB2YXIgdGFyZ2V0O1xuXG4gICAgICAgIHRhcmdldCA9IHVwcGVyQm91bmQodG9rZW5zLCBmdW5jdGlvbiBzZWFyY2godG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbi5yYW5nZVswXSA+IGNvbW1lbnQucmFuZ2VbMF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFtjb21tZW50LnJhbmdlWzBdLCBjb21tZW50LnJhbmdlWzFdXTtcblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21tZW50LmV4dGVuZGVkUmFuZ2VbMV0gPSB0b2tlbnNbdGFyZ2V0XS5yYW5nZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCAtPSAxO1xuICAgICAgICBpZiAodGFyZ2V0ID49IDApIHtcbiAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSA9IHRva2Vuc1t0YXJnZXRdLnJhbmdlWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXR0YWNoQ29tbWVudHModHJlZSwgcHJvdmlkZWRDb21tZW50cywgdG9rZW5zKSB7XG4gICAgICAgIC8vIEF0IGZpcnN0LCB3ZSBzaG91bGQgY2FsY3VsYXRlIGV4dGVuZGVkIGNvbW1lbnQgcmFuZ2VzLlxuICAgICAgICB2YXIgY29tbWVudHMgPSBbXSwgY29tbWVudCwgbGVuLCBpLCBjdXJzb3I7XG5cbiAgICAgICAgaWYgKCF0cmVlLnJhbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGFjaENvbW1lbnRzIG5lZWRzIHJhbmdlIGluZm9ybWF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2tlbnMgYXJyYXkgaXMgZW1wdHksIHdlIGF0dGFjaCBjb21tZW50cyB0byB0cmVlIGFzICdsZWFkaW5nQ29tbWVudHMnXG4gICAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVkQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuZXh0ZW5kZWRSYW5nZSA9IFswLCB0cmVlLnJhbmdlWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcHJvdmlkZWRDb21tZW50cy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29tbWVudHMucHVzaChleHRlbmRDb21tZW50UmFuZ2UoZGVlcENvcHkocHJvdmlkZWRDb21tZW50c1tpXSksIHRva2VucykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBiYXNlZCBvbiBKb2huIEZyZWVtYW4ncyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID4gbm9kZS5yYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5leHRlbmRlZFJhbmdlWzFdID09PSBub2RlLnJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY3Vyc29yID0gMDtcbiAgICAgICAgdHJhdmVyc2UodHJlZSwge1xuICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yIDwgY29tbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tjdXJzb3JdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA8IGNvbW1lbnQuZXh0ZW5kZWRSYW5nZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5yYW5nZVsxXSA9PT0gY29tbWVudC5leHRlbmRlZFJhbmdlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cy5zcGxpY2UoY3Vyc29yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBvdXQgb2Ygb3duZWQgbm9kZVxuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IgPT09IGNvbW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5CcmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudHNbY3Vyc29yXS5leHRlbmRlZFJhbmdlWzBdID4gbm9kZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmlzaXRvck9wdGlvbi5Ta2lwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgZXhwb3J0cy52ZXJzaW9uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuICAgIGV4cG9ydHMuU3ludGF4ID0gU3ludGF4O1xuICAgIGV4cG9ydHMudHJhdmVyc2UgPSB0cmF2ZXJzZTtcbiAgICBleHBvcnRzLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGV4cG9ydHMuYXR0YWNoQ29tbWVudHMgPSBhdHRhY2hDb21tZW50cztcbiAgICBleHBvcnRzLlZpc2l0b3JLZXlzID0gVmlzaXRvcktleXM7XG4gICAgZXhwb3J0cy5WaXNpdG9yT3B0aW9uID0gVmlzaXRvck9wdGlvbjtcbiAgICBleHBvcnRzLkNvbnRyb2xsZXIgPSBDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuY2xvbmVFbnZpcm9ubWVudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsb25lKHt9KTsgfTtcblxuICAgIHJldHVybiBleHBvcnRzO1xufShleHBvcnRzKSk7XG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sIm5hbWVzIjpbImNsb25lIiwiZXhwb3J0cyIsIlN5bnRheCIsIlZpc2l0b3JPcHRpb24iLCJWaXNpdG9yS2V5cyIsIkJSRUFLIiwiU0tJUCIsIlJFTU9WRSIsImRlZXBDb3B5Iiwib2JqIiwicmV0Iiwia2V5IiwidmFsIiwiaGFzT3duUHJvcGVydHkiLCJ1cHBlckJvdW5kIiwiYXJyYXkiLCJmdW5jIiwiZGlmZiIsImxlbiIsImkiLCJjdXJyZW50IiwibGVuZ3RoIiwiQXNzaWdubWVudEV4cHJlc3Npb24iLCJBc3NpZ25tZW50UGF0dGVybiIsIkFycmF5RXhwcmVzc2lvbiIsIkFycmF5UGF0dGVybiIsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiwiQXdhaXRFeHByZXNzaW9uIiwiQmxvY2tTdGF0ZW1lbnQiLCJCaW5hcnlFeHByZXNzaW9uIiwiQnJlYWtTdGF0ZW1lbnQiLCJDYWxsRXhwcmVzc2lvbiIsIkNhdGNoQ2xhdXNlIiwiQ2xhc3NCb2R5IiwiQ2xhc3NEZWNsYXJhdGlvbiIsIkNsYXNzRXhwcmVzc2lvbiIsIkNvbXByZWhlbnNpb25CbG9jayIsIkNvbXByZWhlbnNpb25FeHByZXNzaW9uIiwiQ29uZGl0aW9uYWxFeHByZXNzaW9uIiwiQ29udGludWVTdGF0ZW1lbnQiLCJEZWJ1Z2dlclN0YXRlbWVudCIsIkRpcmVjdGl2ZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJFbXB0eVN0YXRlbWVudCIsIkV4cG9ydEFsbERlY2xhcmF0aW9uIiwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIiwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIsIkV4cG9ydFNwZWNpZmllciIsIkV4cHJlc3Npb25TdGF0ZW1lbnQiLCJGb3JTdGF0ZW1lbnQiLCJGb3JJblN0YXRlbWVudCIsIkZvck9mU3RhdGVtZW50IiwiRnVuY3Rpb25EZWNsYXJhdGlvbiIsIkZ1bmN0aW9uRXhwcmVzc2lvbiIsIkdlbmVyYXRvckV4cHJlc3Npb24iLCJJZGVudGlmaWVyIiwiSWZTdGF0ZW1lbnQiLCJJbXBvcnRFeHByZXNzaW9uIiwiSW1wb3J0RGVjbGFyYXRpb24iLCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyIiwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIiwiSW1wb3J0U3BlY2lmaWVyIiwiTGl0ZXJhbCIsIkxhYmVsZWRTdGF0ZW1lbnQiLCJMb2dpY2FsRXhwcmVzc2lvbiIsIk1lbWJlckV4cHJlc3Npb24iLCJNZXRhUHJvcGVydHkiLCJNZXRob2REZWZpbml0aW9uIiwiTW9kdWxlU3BlY2lmaWVyIiwiTmV3RXhwcmVzc2lvbiIsIk9iamVjdEV4cHJlc3Npb24iLCJPYmplY3RQYXR0ZXJuIiwiUHJvZ3JhbSIsIlByb3BlcnR5IiwiUmVzdEVsZW1lbnQiLCJSZXR1cm5TdGF0ZW1lbnQiLCJTZXF1ZW5jZUV4cHJlc3Npb24iLCJTcHJlYWRFbGVtZW50IiwiU3VwZXIiLCJTd2l0Y2hTdGF0ZW1lbnQiLCJTd2l0Y2hDYXNlIiwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIiwiVGVtcGxhdGVFbGVtZW50IiwiVGVtcGxhdGVMaXRlcmFsIiwiVGhpc0V4cHJlc3Npb24iLCJUaHJvd1N0YXRlbWVudCIsIlRyeVN0YXRlbWVudCIsIlVuYXJ5RXhwcmVzc2lvbiIsIlVwZGF0ZUV4cHJlc3Npb24iLCJWYXJpYWJsZURlY2xhcmF0aW9uIiwiVmFyaWFibGVEZWNsYXJhdG9yIiwiV2hpbGVTdGF0ZW1lbnQiLCJXaXRoU3RhdGVtZW50IiwiWWllbGRFeHByZXNzaW9uIiwiQnJlYWsiLCJTa2lwIiwiUmVtb3ZlIiwiUmVmZXJlbmNlIiwicGFyZW50IiwicHJvdG90eXBlIiwicmVwbGFjZSIsIm5vZGUiLCJyZW1vdmUiLCJBcnJheSIsImlzQXJyYXkiLCJzcGxpY2UiLCJFbGVtZW50IiwicGF0aCIsIndyYXAiLCJyZWYiLCJDb250cm9sbGVyIiwiaXoiLCJqIiwianoiLCJyZXN1bHQiLCJlbGVtZW50IiwiYWRkVG9QYXRoIiwicHVzaCIsIl9fY3VycmVudCIsIl9fbGVhdmVsaXN0IiwidHlwZSIsInBhcmVudHMiLCJfX2V4ZWN1dGUiLCJjYWxsYmFjayIsInByZXZpb3VzIiwidW5kZWZpbmVkIiwiX19zdGF0ZSIsImNhbGwiLCJub3RpZnkiLCJmbGFnIiwic2tpcCIsIl9faW5pdGlhbGl6ZSIsInJvb3QiLCJ2aXNpdG9yIiwiX193b3JrbGlzdCIsIl9fZmFsbGJhY2siLCJmYWxsYmFjayIsIk9iamVjdCIsImtleXMiLCJfX2tleXMiLCJhc3NpZ24iLCJjcmVhdGUiLCJpc05vZGUiLCJpc1Byb3BlcnR5Iiwibm9kZVR5cGUiLCJ0cmF2ZXJzZSIsIndvcmtsaXN0IiwibGVhdmVsaXN0IiwiY3VycmVudDIiLCJjYW5kaWRhdGVzIiwiY2FuZGlkYXRlIiwic2VudGluZWwiLCJwb3AiLCJsZWF2ZSIsImVudGVyIiwiRXJyb3IiLCJ0YXJnZXQiLCJvdXRlciIsInJlbW92ZUVsZW0iLCJuZXh0RWxlbSIsImNvbnRyb2xsZXIiLCJleHRlbmRDb21tZW50UmFuZ2UiLCJjb21tZW50IiwidG9rZW5zIiwic2VhcmNoIiwidG9rZW4iLCJyYW5nZSIsImV4dGVuZGVkUmFuZ2UiLCJhdHRhY2hDb21tZW50cyIsInRyZWUiLCJwcm92aWRlZENvbW1lbnRzIiwiY29tbWVudHMiLCJjdXJzb3IiLCJsZWFkaW5nQ29tbWVudHMiLCJ0cmFpbGluZ0NvbW1lbnRzIiwidmVyc2lvbiIsInJlcXVpcmUiLCJjbG9uZUVudmlyb25tZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/escodegen/node_modules/estraverse/estraverse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/escodegen/node_modules/estraverse/package.json":
/*!*********************************************************************!*\
  !*** ./node_modules/escodegen/node_modules/estraverse/package.json ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"estraverse","description":"ECMAScript JS AST traversal functions","homepage":"https://github.com/estools/estraverse","main":"estraverse.js","version":"4.3.0","engines":{"node":">=4.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"http://github.com/Constellation"}],"repository":{"type":"git","url":"http://github.com/estools/estraverse.git"},"devDependencies":{"babel-preset-env":"^1.6.1","babel-register":"^6.3.13","chai":"^2.1.1","espree":"^1.11.0","gulp":"^3.8.10","gulp-bump":"^0.2.2","gulp-filter":"^2.0.0","gulp-git":"^1.0.1","gulp-tag-version":"^1.3.0","jshint":"^2.5.6","mocha":"^2.1.0"},"license":"BSD-2-Clause","scripts":{"test":"npm run-script lint && npm run-script unit-test","lint":"jshint estraverse.js","unit-test":"mocha --compilers js:babel-register"}}');

/***/ }),

/***/ "(rsc)/./node_modules/escodegen/package.json":
/*!*********************************************!*\
  !*** ./node_modules/escodegen/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"escodegen","description":"ECMAScript code generator","homepage":"http://github.com/estools/escodegen","main":"escodegen.js","bin":{"esgenerate":"./bin/esgenerate.js","escodegen":"./bin/escodegen.js"},"files":["LICENSE.BSD","README.md","bin","escodegen.js","package.json"],"version":"1.14.3","engines":{"node":">=4.0"},"maintainers":[{"name":"Yusuke Suzuki","email":"utatane.tea@gmail.com","web":"http://github.com/Constellation"}],"repository":{"type":"git","url":"http://github.com/estools/escodegen.git"},"dependencies":{"estraverse":"^4.2.0","esutils":"^2.0.2","esprima":"^4.0.1","optionator":"^0.8.1"},"optionalDependencies":{"source-map":"~0.6.1"},"devDependencies":{"acorn":"^7.1.0","bluebird":"^3.4.7","bower-registry-client":"^1.0.0","chai":"^3.5.0","commonjs-everywhere":"^0.9.7","gulp":"^3.8.10","gulp-eslint":"^3.0.1","gulp-mocha":"^3.0.1","semver":"^5.1.0"},"license":"BSD-2-Clause","scripts":{"test":"gulp travis","unit-test":"gulp test","lint":"gulp lint","release":"node tools/release.js","build-min":"./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js","build":"./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"}}');

/***/ })

};
;