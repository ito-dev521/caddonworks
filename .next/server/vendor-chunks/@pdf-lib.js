"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pdf-lib";
exports.ids = ["vendor-chunks/@pdf-lib"];
exports.modules = {

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Encoding.js":
/*!*************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Encoding.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encodings: () => (/* binding */ Encodings)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/utils.js\");\n/* harmony import */ var _all_encodings_compressed_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./all-encodings.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json\");\n/* tslint:disable max-classes-per-file */ \n\nvar decompressedEncodings = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.decompressJson)(_all_encodings_compressed_json__WEBPACK_IMPORTED_MODULE_1__);\nvar allUnicodeMappings = JSON.parse(decompressedEncodings);\nvar Encoding = /** @class */ function() {\n    function Encoding(name, unicodeMappings) {\n        var _this = this;\n        this.canEncodeUnicodeCodePoint = function(codePoint) {\n            return codePoint in _this.unicodeMappings;\n        };\n        this.encodeUnicodeCodePoint = function(codePoint) {\n            var mapped = _this.unicodeMappings[codePoint];\n            if (!mapped) {\n                var str = String.fromCharCode(codePoint);\n                var hexCode = \"0x\" + (0,_utils__WEBPACK_IMPORTED_MODULE_0__.padStart)(codePoint.toString(16), 4, \"0\");\n                var msg = _this.name + ' cannot encode \"' + str + '\" (' + hexCode + \")\";\n                throw new Error(msg);\n            }\n            return {\n                code: mapped[0],\n                name: mapped[1]\n            };\n        };\n        this.name = name;\n        this.supportedCodePoints = Object.keys(unicodeMappings).map(Number).sort(function(a, b) {\n            return a - b;\n        });\n        this.unicodeMappings = unicodeMappings;\n    }\n    return Encoding;\n}();\nvar Encodings = {\n    Symbol: new Encoding(\"Symbol\", allUnicodeMappings.symbol),\n    ZapfDingbats: new Encoding(\"ZapfDingbats\", allUnicodeMappings.zapfdingbats),\n    WinAnsi: new Encoding(\"WinAnsi\", allUnicodeMappings.win1252)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvRW5jb2RpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsdUNBQXVDLEdBQ1k7QUFDa0I7QUFDckUsSUFBSUcsd0JBQXdCSCxzREFBY0EsQ0FBQ0UsMkRBQXNCQTtBQUNqRSxJQUFJRSxxQkFBcUJDLEtBQUtDLEtBQUssQ0FBQ0g7QUFDcEMsSUFBSUksV0FBVyxXQUFXLEdBQUk7SUFDMUIsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxlQUFlO1FBQ25DLElBQUlDLFFBQVEsSUFBSTtRQUNoQixJQUFJLENBQUNDLHlCQUF5QixHQUFHLFNBQVVDLFNBQVM7WUFDaEQsT0FBT0EsYUFBYUYsTUFBTUQsZUFBZTtRQUM3QztRQUNBLElBQUksQ0FBQ0ksc0JBQXNCLEdBQUcsU0FBVUQsU0FBUztZQUM3QyxJQUFJRSxTQUFTSixNQUFNRCxlQUFlLENBQUNHLFVBQVU7WUFDN0MsSUFBSSxDQUFDRSxRQUFRO2dCQUNULElBQUlDLE1BQU1DLE9BQU9DLFlBQVksQ0FBQ0w7Z0JBQzlCLElBQUlNLFVBQVUsT0FBT2pCLGdEQUFRQSxDQUFDVyxVQUFVTyxRQUFRLENBQUMsS0FBSyxHQUFHO2dCQUN6RCxJQUFJQyxNQUFNVixNQUFNRixJQUFJLEdBQUcscUJBQXNCTyxNQUFNLFFBQVNHLFVBQVU7Z0JBQ3RFLE1BQU0sSUFBSUcsTUFBTUQ7WUFDcEI7WUFDQSxPQUFPO2dCQUFFRSxNQUFNUixNQUFNLENBQUMsRUFBRTtnQkFBRU4sTUFBTU0sTUFBTSxDQUFDLEVBQUU7WUFBQztRQUM5QztRQUNBLElBQUksQ0FBQ04sSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2UsbUJBQW1CLEdBQUdDLE9BQU9DLElBQUksQ0FBQ2hCLGlCQUNsQ2lCLEdBQUcsQ0FBQ0MsUUFDSkMsSUFBSSxDQUFDLFNBQVVDLENBQUMsRUFBRUMsQ0FBQztZQUFJLE9BQU9ELElBQUlDO1FBQUc7UUFDMUMsSUFBSSxDQUFDckIsZUFBZSxHQUFHQTtJQUMzQjtJQUNBLE9BQU9GO0FBQ1g7QUFDTyxJQUFJd0IsWUFBWTtJQUNuQkMsUUFBUSxJQUFJekIsU0FBUyxVQUFVSCxtQkFBbUI2QixNQUFNO0lBQ3hEQyxjQUFjLElBQUkzQixTQUFTLGdCQUFnQkgsbUJBQW1CK0IsWUFBWTtJQUMxRUMsU0FBUyxJQUFJN0IsU0FBUyxXQUFXSCxtQkFBbUJpQyxPQUFPO0FBQy9ELEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9lcy9FbmNvZGluZy5qcz9mNWNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5pbXBvcnQgeyBkZWNvbXByZXNzSnNvbiwgcGFkU3RhcnQgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBBbGxFbmNvZGluZ3NDb21wcmVzc2VkIGZyb20gJy4vYWxsLWVuY29kaW5ncy5jb21wcmVzc2VkLmpzb24nO1xudmFyIGRlY29tcHJlc3NlZEVuY29kaW5ncyA9IGRlY29tcHJlc3NKc29uKEFsbEVuY29kaW5nc0NvbXByZXNzZWQpO1xudmFyIGFsbFVuaWNvZGVNYXBwaW5ncyA9IEpTT04ucGFyc2UoZGVjb21wcmVzc2VkRW5jb2RpbmdzKTtcbnZhciBFbmNvZGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbmNvZGluZyhuYW1lLCB1bmljb2RlTWFwcGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jYW5FbmNvZGVVbmljb2RlQ29kZVBvaW50ID0gZnVuY3Rpb24gKGNvZGVQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludCBpbiBfdGhpcy51bmljb2RlTWFwcGluZ3M7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5jb2RlVW5pY29kZUNvZGVQb2ludCA9IGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBwZWQgPSBfdGhpcy51bmljb2RlTWFwcGluZ3NbY29kZVBvaW50XTtcbiAgICAgICAgICAgIGlmICghbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgaGV4Q29kZSA9IFwiMHhcIiArIHBhZFN0YXJ0KGNvZGVQb2ludC50b1N0cmluZygxNiksIDQsICcwJyk7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IF90aGlzLm5hbWUgKyBcIiBjYW5ub3QgZW5jb2RlIFxcXCJcIiArIHN0ciArIFwiXFxcIiAoXCIgKyBoZXhDb2RlICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBjb2RlOiBtYXBwZWRbMF0sIG5hbWU6IG1hcHBlZFsxXSB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZENvZGVQb2ludHMgPSBPYmplY3Qua2V5cyh1bmljb2RlTWFwcGluZ3MpXG4gICAgICAgICAgICAubWFwKE51bWJlcilcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgIHRoaXMudW5pY29kZU1hcHBpbmdzID0gdW5pY29kZU1hcHBpbmdzO1xuICAgIH1cbiAgICByZXR1cm4gRW5jb2Rpbmc7XG59KCkpO1xuZXhwb3J0IHZhciBFbmNvZGluZ3MgPSB7XG4gICAgU3ltYm9sOiBuZXcgRW5jb2RpbmcoJ1N5bWJvbCcsIGFsbFVuaWNvZGVNYXBwaW5ncy5zeW1ib2wpLFxuICAgIFphcGZEaW5nYmF0czogbmV3IEVuY29kaW5nKCdaYXBmRGluZ2JhdHMnLCBhbGxVbmljb2RlTWFwcGluZ3MuemFwZmRpbmdiYXRzKSxcbiAgICBXaW5BbnNpOiBuZXcgRW5jb2RpbmcoJ1dpbkFuc2knLCBhbGxVbmljb2RlTWFwcGluZ3Mud2luMTI1MiksXG59O1xuIl0sIm5hbWVzIjpbImRlY29tcHJlc3NKc29uIiwicGFkU3RhcnQiLCJBbGxFbmNvZGluZ3NDb21wcmVzc2VkIiwiZGVjb21wcmVzc2VkRW5jb2RpbmdzIiwiYWxsVW5pY29kZU1hcHBpbmdzIiwiSlNPTiIsInBhcnNlIiwiRW5jb2RpbmciLCJuYW1lIiwidW5pY29kZU1hcHBpbmdzIiwiX3RoaXMiLCJjYW5FbmNvZGVVbmljb2RlQ29kZVBvaW50IiwiY29kZVBvaW50IiwiZW5jb2RlVW5pY29kZUNvZGVQb2ludCIsIm1hcHBlZCIsInN0ciIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImhleENvZGUiLCJ0b1N0cmluZyIsIm1zZyIsIkVycm9yIiwiY29kZSIsInN1cHBvcnRlZENvZGVQb2ludHMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiTnVtYmVyIiwic29ydCIsImEiLCJiIiwiRW5jb2RpbmdzIiwiU3ltYm9sIiwic3ltYm9sIiwiWmFwZkRpbmdiYXRzIiwiemFwZmRpbmdiYXRzIiwiV2luQW5zaSIsIndpbjEyNTIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Encoding.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Font.js":
/*!*********************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Font.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontNames: () => (/* binding */ FontNames)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/utils.js\");\n/* harmony import */ var _Courier_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Courier-Bold.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json\");\n/* harmony import */ var _Courier_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Courier-BoldOblique.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json\");\n/* harmony import */ var _Courier_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Courier-Oblique.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json\");\n/* harmony import */ var _Courier_compressed_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Courier.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json\");\n/* harmony import */ var _Helvetica_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Helvetica-Bold.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json\");\n/* harmony import */ var _Helvetica_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Helvetica-BoldOblique.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json\");\n/* harmony import */ var _Helvetica_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Helvetica-Oblique.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json\");\n/* harmony import */ var _Helvetica_compressed_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Helvetica.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json\");\n/* harmony import */ var _Times_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Times-Bold.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json\");\n/* harmony import */ var _Times_BoldItalic_compressed_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Times-BoldItalic.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json\");\n/* harmony import */ var _Times_Italic_compressed_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Times-Italic.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json\");\n/* harmony import */ var _Times_Roman_compressed_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Times-Roman.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json\");\n/* harmony import */ var _Symbol_compressed_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Symbol.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json\");\n/* harmony import */ var _ZapfDingbats_compressed_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ZapfDingbats.compressed.json */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// prettier-ignore\nvar compressedJsonForFontName = {\n    \"Courier\": _Courier_compressed_json__WEBPACK_IMPORTED_MODULE_4__,\n    \"Courier-Bold\": _Courier_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_1__,\n    \"Courier-Oblique\": _Courier_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_3__,\n    \"Courier-BoldOblique\": _Courier_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_2__,\n    \"Helvetica\": _Helvetica_compressed_json__WEBPACK_IMPORTED_MODULE_8__,\n    \"Helvetica-Bold\": _Helvetica_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_5__,\n    \"Helvetica-Oblique\": _Helvetica_Oblique_compressed_json__WEBPACK_IMPORTED_MODULE_7__,\n    \"Helvetica-BoldOblique\": _Helvetica_BoldOblique_compressed_json__WEBPACK_IMPORTED_MODULE_6__,\n    \"Times-Roman\": _Times_Roman_compressed_json__WEBPACK_IMPORTED_MODULE_12__,\n    \"Times-Bold\": _Times_Bold_compressed_json__WEBPACK_IMPORTED_MODULE_9__,\n    \"Times-Italic\": _Times_Italic_compressed_json__WEBPACK_IMPORTED_MODULE_11__,\n    \"Times-BoldItalic\": _Times_BoldItalic_compressed_json__WEBPACK_IMPORTED_MODULE_10__,\n    \"Symbol\": _Symbol_compressed_json__WEBPACK_IMPORTED_MODULE_13__,\n    \"ZapfDingbats\": _ZapfDingbats_compressed_json__WEBPACK_IMPORTED_MODULE_14__\n};\nvar FontNames;\n(function(FontNames) {\n    FontNames[\"Courier\"] = \"Courier\";\n    FontNames[\"CourierBold\"] = \"Courier-Bold\";\n    FontNames[\"CourierOblique\"] = \"Courier-Oblique\";\n    FontNames[\"CourierBoldOblique\"] = \"Courier-BoldOblique\";\n    FontNames[\"Helvetica\"] = \"Helvetica\";\n    FontNames[\"HelveticaBold\"] = \"Helvetica-Bold\";\n    FontNames[\"HelveticaOblique\"] = \"Helvetica-Oblique\";\n    FontNames[\"HelveticaBoldOblique\"] = \"Helvetica-BoldOblique\";\n    FontNames[\"TimesRoman\"] = \"Times-Roman\";\n    FontNames[\"TimesRomanBold\"] = \"Times-Bold\";\n    FontNames[\"TimesRomanItalic\"] = \"Times-Italic\";\n    FontNames[\"TimesRomanBoldItalic\"] = \"Times-BoldItalic\";\n    FontNames[\"Symbol\"] = \"Symbol\";\n    FontNames[\"ZapfDingbats\"] = \"ZapfDingbats\";\n})(FontNames || (FontNames = {}));\nvar fontCache = {};\nvar Font = /** @class */ function() {\n    function Font() {\n        var _this = this;\n        this.getWidthOfGlyph = function(glyphName) {\n            return _this.CharWidths[glyphName];\n        };\n        this.getXAxisKerningForPair = function(leftGlyphName, rightGlyphName) {\n            return (_this.KernPairXAmounts[leftGlyphName] || {})[rightGlyphName];\n        };\n    }\n    Font.load = function(fontName) {\n        var cachedFont = fontCache[fontName];\n        if (cachedFont) return cachedFont;\n        var json = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.decompressJson)(compressedJsonForFontName[fontName]);\n        var font = Object.assign(new Font(), JSON.parse(json));\n        font.CharWidths = font.CharMetrics.reduce(function(acc, metric) {\n            acc[metric.N] = metric.WX;\n            return acc;\n        }, {});\n        font.KernPairXAmounts = font.KernPairs.reduce(function(acc, _a) {\n            var name1 = _a[0], name2 = _a[1], width = _a[2];\n            if (!acc[name1]) acc[name1] = {};\n            acc[name1][name2] = width;\n            return acc;\n        }, {});\n        fontCache[fontName] = font;\n        return font;\n    };\n    return Font;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvRm9udC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUMwQjtBQUNjO0FBQ1I7QUFDZjtBQUNhO0FBQ2M7QUFDUjtBQUNmO0FBQ0M7QUFDWTtBQUNSO0FBQ0Y7QUFDVDtBQUNZO0FBQ3BFLGtCQUFrQjtBQUNsQixJQUFJZSw0QkFBNEI7SUFDNUIsV0FBV1gscURBQWlCQTtJQUM1QixnQkFBZ0JILDBEQUFxQkE7SUFDckMsbUJBQW1CRSw2REFBd0JBO0lBQzNDLHVCQUF1QkQsaUVBQTRCQTtJQUNuRCxhQUFhTSx1REFBbUJBO0lBQ2hDLGtCQUFrQkgsNERBQXVCQTtJQUN6QyxxQkFBcUJFLCtEQUEwQkE7SUFDL0MseUJBQXlCRCxtRUFBOEJBO0lBQ3ZELGVBQWVNLDBEQUFvQkE7SUFDbkMsY0FBY0gsd0RBQW1CQTtJQUNqQyxnQkFBZ0JFLDJEQUFxQkE7SUFDckMsb0JBQW9CRCwrREFBeUJBO0lBQzdDLFVBQVVHLHFEQUFnQkE7SUFDMUIsZ0JBQWdCQywyREFBc0JBO0FBQzFDO0FBQ08sSUFBSUUsVUFBVTtBQUNwQixVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUMsVUFBVSxHQUFHO0lBQ3ZCQSxTQUFTLENBQUMsY0FBYyxHQUFHO0lBQzNCQSxTQUFTLENBQUMsaUJBQWlCLEdBQUc7SUFDOUJBLFNBQVMsQ0FBQyxxQkFBcUIsR0FBRztJQUNsQ0EsU0FBUyxDQUFDLFlBQVksR0FBRztJQUN6QkEsU0FBUyxDQUFDLGdCQUFnQixHQUFHO0lBQzdCQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7SUFDaENBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRztJQUNwQ0EsU0FBUyxDQUFDLGFBQWEsR0FBRztJQUMxQkEsU0FBUyxDQUFDLGlCQUFpQixHQUFHO0lBQzlCQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7SUFDaENBLFNBQVMsQ0FBQyx1QkFBdUIsR0FBRztJQUNwQ0EsU0FBUyxDQUFDLFNBQVMsR0FBRztJQUN0QkEsU0FBUyxDQUFDLGVBQWUsR0FBRztBQUNoQyxHQUFHQSxhQUFjQSxDQUFBQSxZQUFZLENBQUM7QUFDOUIsSUFBSUMsWUFBWSxDQUFDO0FBQ2pCLElBQUlDLE9BQU8sV0FBVyxHQUFJO0lBQ3RCLFNBQVNBO1FBQ0wsSUFBSUMsUUFBUSxJQUFJO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLFNBQVVDLFNBQVM7WUFDdEMsT0FBT0YsTUFBTUcsVUFBVSxDQUFDRCxVQUFVO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDRSxzQkFBc0IsR0FBRyxTQUFVQyxhQUFhLEVBQUVDLGNBQWM7WUFDakUsT0FBTyxDQUFDTixNQUFNTyxnQkFBZ0IsQ0FBQ0YsY0FBYyxJQUFJLENBQUMsRUFBRSxDQUFDQyxlQUFlO1FBQ3hFO0lBQ0o7SUFDQVAsS0FBS1MsSUFBSSxHQUFHLFNBQVVDLFFBQVE7UUFDMUIsSUFBSUMsYUFBYVosU0FBUyxDQUFDVyxTQUFTO1FBQ3BDLElBQUlDLFlBQ0EsT0FBT0E7UUFDWCxJQUFJQyxPQUFPOUIsc0RBQWNBLENBQUNlLHlCQUF5QixDQUFDYSxTQUFTO1FBQzdELElBQUlHLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQyxJQUFJZixRQUFRZ0IsS0FBS0MsS0FBSyxDQUFDTDtRQUNoREMsS0FBS1QsVUFBVSxHQUFHUyxLQUFLSyxXQUFXLENBQUNDLE1BQU0sQ0FBQyxTQUFVQyxHQUFHLEVBQUVDLE1BQU07WUFDM0RELEdBQUcsQ0FBQ0MsT0FBT0MsQ0FBQyxDQUFDLEdBQUdELE9BQU9FLEVBQUU7WUFDekIsT0FBT0g7UUFDWCxHQUFHLENBQUM7UUFDSlAsS0FBS0wsZ0JBQWdCLEdBQUdLLEtBQUtXLFNBQVMsQ0FBQ0wsTUFBTSxDQUFDLFNBQVVDLEdBQUcsRUFBRUssRUFBRTtZQUMzRCxJQUFJQyxRQUFRRCxFQUFFLENBQUMsRUFBRSxFQUFFRSxRQUFRRixFQUFFLENBQUMsRUFBRSxFQUFFRyxRQUFRSCxFQUFFLENBQUMsRUFBRTtZQUMvQyxJQUFJLENBQUNMLEdBQUcsQ0FBQ00sTUFBTSxFQUNYTixHQUFHLENBQUNNLE1BQU0sR0FBRyxDQUFDO1lBQ2xCTixHQUFHLENBQUNNLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHQztZQUNwQixPQUFPUjtRQUNYLEdBQUcsQ0FBQztRQUNKckIsU0FBUyxDQUFDVyxTQUFTLEdBQUdHO1FBQ3RCLE9BQU9BO0lBQ1g7SUFDQSxPQUFPYjtBQUNYO0FBQ2dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvRm9udC5qcz8wOGVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29tcHJlc3NKc29uIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgQ291cmllckJvbGRDb21wcmVzc2VkIGZyb20gJy4vQ291cmllci1Cb2xkLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgQ291cmllckJvbGRPYmxpcXVlQ29tcHJlc3NlZCBmcm9tICcuL0NvdXJpZXItQm9sZE9ibGlxdWUuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBDb3VyaWVyT2JsaXF1ZUNvbXByZXNzZWQgZnJvbSAnLi9Db3VyaWVyLU9ibGlxdWUuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBDb3VyaWVyQ29tcHJlc3NlZCBmcm9tICcuL0NvdXJpZXIuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBIZWx2ZXRpY2FCb2xkQ29tcHJlc3NlZCBmcm9tICcuL0hlbHZldGljYS1Cb2xkLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgSGVsdmV0aWNhQm9sZE9ibGlxdWVDb21wcmVzc2VkIGZyb20gJy4vSGVsdmV0aWNhLUJvbGRPYmxpcXVlLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgSGVsdmV0aWNhT2JsaXF1ZUNvbXByZXNzZWQgZnJvbSAnLi9IZWx2ZXRpY2EtT2JsaXF1ZS5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IEhlbHZldGljYUNvbXByZXNzZWQgZnJvbSAnLi9IZWx2ZXRpY2EuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBUaW1lc0JvbGRDb21wcmVzc2VkIGZyb20gJy4vVGltZXMtQm9sZC5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IFRpbWVzQm9sZEl0YWxpY0NvbXByZXNzZWQgZnJvbSAnLi9UaW1lcy1Cb2xkSXRhbGljLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgVGltZXNJdGFsaWNDb21wcmVzc2VkIGZyb20gJy4vVGltZXMtSXRhbGljLmNvbXByZXNzZWQuanNvbic7XG5pbXBvcnQgVGltZXNSb21hbkNvbXByZXNzZWQgZnJvbSAnLi9UaW1lcy1Sb21hbi5jb21wcmVzc2VkLmpzb24nO1xuaW1wb3J0IFN5bWJvbENvbXByZXNzZWQgZnJvbSAnLi9TeW1ib2wuY29tcHJlc3NlZC5qc29uJztcbmltcG9ydCBaYXBmRGluZ2JhdHNDb21wcmVzc2VkIGZyb20gJy4vWmFwZkRpbmdiYXRzLmNvbXByZXNzZWQuanNvbic7XG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBjb21wcmVzc2VkSnNvbkZvckZvbnROYW1lID0ge1xuICAgICdDb3VyaWVyJzogQ291cmllckNvbXByZXNzZWQsXG4gICAgJ0NvdXJpZXItQm9sZCc6IENvdXJpZXJCb2xkQ29tcHJlc3NlZCxcbiAgICAnQ291cmllci1PYmxpcXVlJzogQ291cmllck9ibGlxdWVDb21wcmVzc2VkLFxuICAgICdDb3VyaWVyLUJvbGRPYmxpcXVlJzogQ291cmllckJvbGRPYmxpcXVlQ29tcHJlc3NlZCxcbiAgICAnSGVsdmV0aWNhJzogSGVsdmV0aWNhQ29tcHJlc3NlZCxcbiAgICAnSGVsdmV0aWNhLUJvbGQnOiBIZWx2ZXRpY2FCb2xkQ29tcHJlc3NlZCxcbiAgICAnSGVsdmV0aWNhLU9ibGlxdWUnOiBIZWx2ZXRpY2FPYmxpcXVlQ29tcHJlc3NlZCxcbiAgICAnSGVsdmV0aWNhLUJvbGRPYmxpcXVlJzogSGVsdmV0aWNhQm9sZE9ibGlxdWVDb21wcmVzc2VkLFxuICAgICdUaW1lcy1Sb21hbic6IFRpbWVzUm9tYW5Db21wcmVzc2VkLFxuICAgICdUaW1lcy1Cb2xkJzogVGltZXNCb2xkQ29tcHJlc3NlZCxcbiAgICAnVGltZXMtSXRhbGljJzogVGltZXNJdGFsaWNDb21wcmVzc2VkLFxuICAgICdUaW1lcy1Cb2xkSXRhbGljJzogVGltZXNCb2xkSXRhbGljQ29tcHJlc3NlZCxcbiAgICAnU3ltYm9sJzogU3ltYm9sQ29tcHJlc3NlZCxcbiAgICAnWmFwZkRpbmdiYXRzJzogWmFwZkRpbmdiYXRzQ29tcHJlc3NlZCxcbn07XG5leHBvcnQgdmFyIEZvbnROYW1lcztcbihmdW5jdGlvbiAoRm9udE5hbWVzKSB7XG4gICAgRm9udE5hbWVzW1wiQ291cmllclwiXSA9IFwiQ291cmllclwiO1xuICAgIEZvbnROYW1lc1tcIkNvdXJpZXJCb2xkXCJdID0gXCJDb3VyaWVyLUJvbGRcIjtcbiAgICBGb250TmFtZXNbXCJDb3VyaWVyT2JsaXF1ZVwiXSA9IFwiQ291cmllci1PYmxpcXVlXCI7XG4gICAgRm9udE5hbWVzW1wiQ291cmllckJvbGRPYmxpcXVlXCJdID0gXCJDb3VyaWVyLUJvbGRPYmxpcXVlXCI7XG4gICAgRm9udE5hbWVzW1wiSGVsdmV0aWNhXCJdID0gXCJIZWx2ZXRpY2FcIjtcbiAgICBGb250TmFtZXNbXCJIZWx2ZXRpY2FCb2xkXCJdID0gXCJIZWx2ZXRpY2EtQm9sZFwiO1xuICAgIEZvbnROYW1lc1tcIkhlbHZldGljYU9ibGlxdWVcIl0gPSBcIkhlbHZldGljYS1PYmxpcXVlXCI7XG4gICAgRm9udE5hbWVzW1wiSGVsdmV0aWNhQm9sZE9ibGlxdWVcIl0gPSBcIkhlbHZldGljYS1Cb2xkT2JsaXF1ZVwiO1xuICAgIEZvbnROYW1lc1tcIlRpbWVzUm9tYW5cIl0gPSBcIlRpbWVzLVJvbWFuXCI7XG4gICAgRm9udE5hbWVzW1wiVGltZXNSb21hbkJvbGRcIl0gPSBcIlRpbWVzLUJvbGRcIjtcbiAgICBGb250TmFtZXNbXCJUaW1lc1JvbWFuSXRhbGljXCJdID0gXCJUaW1lcy1JdGFsaWNcIjtcbiAgICBGb250TmFtZXNbXCJUaW1lc1JvbWFuQm9sZEl0YWxpY1wiXSA9IFwiVGltZXMtQm9sZEl0YWxpY1wiO1xuICAgIEZvbnROYW1lc1tcIlN5bWJvbFwiXSA9IFwiU3ltYm9sXCI7XG4gICAgRm9udE5hbWVzW1wiWmFwZkRpbmdiYXRzXCJdID0gXCJaYXBmRGluZ2JhdHNcIjtcbn0pKEZvbnROYW1lcyB8fCAoRm9udE5hbWVzID0ge30pKTtcbnZhciBmb250Q2FjaGUgPSB7fTtcbnZhciBGb250ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ2V0V2lkdGhPZkdseXBoID0gZnVuY3Rpb24gKGdseXBoTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLkNoYXJXaWR0aHNbZ2x5cGhOYW1lXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRYQXhpc0tlcm5pbmdGb3JQYWlyID0gZnVuY3Rpb24gKGxlZnRHbHlwaE5hbWUsIHJpZ2h0R2x5cGhOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLktlcm5QYWlyWEFtb3VudHNbbGVmdEdseXBoTmFtZV0gfHwge30pW3JpZ2h0R2x5cGhOYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRm9udC5sb2FkID0gZnVuY3Rpb24gKGZvbnROYW1lKSB7XG4gICAgICAgIHZhciBjYWNoZWRGb250ID0gZm9udENhY2hlW2ZvbnROYW1lXTtcbiAgICAgICAgaWYgKGNhY2hlZEZvbnQpXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkRm9udDtcbiAgICAgICAgdmFyIGpzb24gPSBkZWNvbXByZXNzSnNvbihjb21wcmVzc2VkSnNvbkZvckZvbnROYW1lW2ZvbnROYW1lXSk7XG4gICAgICAgIHZhciBmb250ID0gT2JqZWN0LmFzc2lnbihuZXcgRm9udCgpLCBKU09OLnBhcnNlKGpzb24pKTtcbiAgICAgICAgZm9udC5DaGFyV2lkdGhzID0gZm9udC5DaGFyTWV0cmljcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbWV0cmljKSB7XG4gICAgICAgICAgICBhY2NbbWV0cmljLk5dID0gbWV0cmljLldYO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBmb250Lktlcm5QYWlyWEFtb3VudHMgPSBmb250Lktlcm5QYWlycy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgX2EpIHtcbiAgICAgICAgICAgIHZhciBuYW1lMSA9IF9hWzBdLCBuYW1lMiA9IF9hWzFdLCB3aWR0aCA9IF9hWzJdO1xuICAgICAgICAgICAgaWYgKCFhY2NbbmFtZTFdKVxuICAgICAgICAgICAgICAgIGFjY1tuYW1lMV0gPSB7fTtcbiAgICAgICAgICAgIGFjY1tuYW1lMV1bbmFtZTJdID0gd2lkdGg7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGZvbnRDYWNoZVtmb250TmFtZV0gPSBmb250O1xuICAgICAgICByZXR1cm4gZm9udDtcbiAgICB9O1xuICAgIHJldHVybiBGb250O1xufSgpKTtcbmV4cG9ydCB7IEZvbnQgfTtcbiJdLCJuYW1lcyI6WyJkZWNvbXByZXNzSnNvbiIsIkNvdXJpZXJCb2xkQ29tcHJlc3NlZCIsIkNvdXJpZXJCb2xkT2JsaXF1ZUNvbXByZXNzZWQiLCJDb3VyaWVyT2JsaXF1ZUNvbXByZXNzZWQiLCJDb3VyaWVyQ29tcHJlc3NlZCIsIkhlbHZldGljYUJvbGRDb21wcmVzc2VkIiwiSGVsdmV0aWNhQm9sZE9ibGlxdWVDb21wcmVzc2VkIiwiSGVsdmV0aWNhT2JsaXF1ZUNvbXByZXNzZWQiLCJIZWx2ZXRpY2FDb21wcmVzc2VkIiwiVGltZXNCb2xkQ29tcHJlc3NlZCIsIlRpbWVzQm9sZEl0YWxpY0NvbXByZXNzZWQiLCJUaW1lc0l0YWxpY0NvbXByZXNzZWQiLCJUaW1lc1JvbWFuQ29tcHJlc3NlZCIsIlN5bWJvbENvbXByZXNzZWQiLCJaYXBmRGluZ2JhdHNDb21wcmVzc2VkIiwiY29tcHJlc3NlZEpzb25Gb3JGb250TmFtZSIsIkZvbnROYW1lcyIsImZvbnRDYWNoZSIsIkZvbnQiLCJfdGhpcyIsImdldFdpZHRoT2ZHbHlwaCIsImdseXBoTmFtZSIsIkNoYXJXaWR0aHMiLCJnZXRYQXhpc0tlcm5pbmdGb3JQYWlyIiwibGVmdEdseXBoTmFtZSIsInJpZ2h0R2x5cGhOYW1lIiwiS2VyblBhaXJYQW1vdW50cyIsImxvYWQiLCJmb250TmFtZSIsImNhY2hlZEZvbnQiLCJqc29uIiwiZm9udCIsIk9iamVjdCIsImFzc2lnbiIsIkpTT04iLCJwYXJzZSIsIkNoYXJNZXRyaWNzIiwicmVkdWNlIiwiYWNjIiwibWV0cmljIiwiTiIsIldYIiwiS2VyblBhaXJzIiwiX2EiLCJuYW1lMSIsIm5hbWUyIiwid2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Font.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Encodings: () => (/* reexport safe */ _Encoding__WEBPACK_IMPORTED_MODULE_1__.Encodings),\n/* harmony export */   Font: () => (/* reexport safe */ _Font__WEBPACK_IMPORTED_MODULE_0__.Font),\n/* harmony export */   FontNames: () => (/* reexport safe */ _Font__WEBPACK_IMPORTED_MODULE_0__.FontNames)\n/* harmony export */ });\n/* harmony import */ var _Font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Font */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Font.js\");\n/* harmony import */ var _Encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Encoding */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Encoding.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUI7QUFDSSIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL2VzL2luZGV4LmpzP2E3ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9Gb250JztcbmV4cG9ydCAqIGZyb20gJy4vRW5jb2RpbmcnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/es/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeFromBase64: () => (/* binding */ decodeFromBase64),\n/* harmony export */   decompressJson: () => (/* binding */ decompressJson),\n/* harmony export */   padStart: () => (/* binding */ padStart)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n/*\n * The `chars`, `lookup`, and `decodeFromBase64` members of this file are\n * licensed under the following:\n *\n *     base64-arraybuffer\n *     https://github.com/niklasvh/base64-arraybuffer\n *\n *     Copyright (c) 2012 Niklas von Hertzen\n *     Licensed under the MIT license.\n *\n */ \nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n// Use a lookup table to find the index.\nvar lookup = new Uint8Array(256);\nfor(var i = 0; i < chars.length; i++){\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar decodeFromBase64 = function(base64) {\n    var bufferLength = base64.length * 0.75;\n    var len = base64.length;\n    var i;\n    var p = 0;\n    var encoded1;\n    var encoded2;\n    var encoded3;\n    var encoded4;\n    if (base64[base64.length - 1] === \"=\") {\n        bufferLength--;\n        if (base64[base64.length - 2] === \"=\") {\n            bufferLength--;\n        }\n    }\n    var bytes = new Uint8Array(bufferLength);\n    for(i = 0; i < len; i += 4){\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return bytes;\n};\nvar arrayToString = function(array) {\n    var str = \"\";\n    for(var i = 0; i < array.length; i++){\n        str += String.fromCharCode(array[i]);\n    }\n    return str;\n};\nvar decompressJson = function(compressedJson) {\n    return arrayToString(pako__WEBPACK_IMPORTED_MODULE_0___default().inflate(decodeFromBase64(compressedJson)));\n};\nvar padStart = function(value, length, padChar) {\n    var padding = \"\";\n    for(var idx = 0, len = length - value.length; idx < len; idx++){\n        padding += padChar;\n    }\n    return padding + value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ3VCO0FBQ3hCLElBQUlDLFFBQVE7QUFDWix3Q0FBd0M7QUFDeEMsSUFBSUMsU0FBUyxJQUFJQyxXQUFXO0FBQzVCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxNQUFNSSxNQUFNLEVBQUVELElBQUs7SUFDbkNGLE1BQU0sQ0FBQ0QsTUFBTUssVUFBVSxDQUFDRixHQUFHLEdBQUdBO0FBQ2xDO0FBQ08sSUFBSUcsbUJBQW1CLFNBQVVDLE1BQU07SUFDMUMsSUFBSUMsZUFBZUQsT0FBT0gsTUFBTSxHQUFHO0lBQ25DLElBQUlLLE1BQU1GLE9BQU9ILE1BQU07SUFDdkIsSUFBSUQ7SUFDSixJQUFJTyxJQUFJO0lBQ1IsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJUCxNQUFNLENBQUNBLE9BQU9ILE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSztRQUNuQ0k7UUFDQSxJQUFJRCxNQUFNLENBQUNBLE9BQU9ILE1BQU0sR0FBRyxFQUFFLEtBQUssS0FBSztZQUNuQ0k7UUFDSjtJQUNKO0lBQ0EsSUFBSU8sUUFBUSxJQUFJYixXQUFXTTtJQUMzQixJQUFLTCxJQUFJLEdBQUdBLElBQUlNLEtBQUtOLEtBQUssRUFBRztRQUN6QlEsV0FBV1YsTUFBTSxDQUFDTSxPQUFPRixVQUFVLENBQUNGLEdBQUc7UUFDdkNTLFdBQVdYLE1BQU0sQ0FBQ00sT0FBT0YsVUFBVSxDQUFDRixJQUFJLEdBQUc7UUFDM0NVLFdBQVdaLE1BQU0sQ0FBQ00sT0FBT0YsVUFBVSxDQUFDRixJQUFJLEdBQUc7UUFDM0NXLFdBQVdiLE1BQU0sQ0FBQ00sT0FBT0YsVUFBVSxDQUFDRixJQUFJLEdBQUc7UUFDM0NZLEtBQUssQ0FBQ0wsSUFBSSxHQUFHLFlBQWEsSUFBTUUsWUFBWTtRQUM1Q0csS0FBSyxDQUFDTCxJQUFJLEdBQUcsQ0FBRUUsV0FBVyxFQUFDLEtBQU0sSUFBTUMsWUFBWTtRQUNuREUsS0FBSyxDQUFDTCxJQUFJLEdBQUcsQ0FBRUcsV0FBVyxNQUFNLElBQU1DLFdBQVc7SUFDckQ7SUFDQSxPQUFPQztBQUNYLEVBQUU7QUFDRixJQUFJQyxnQkFBZ0IsU0FBVUMsS0FBSztJQUMvQixJQUFJQyxNQUFNO0lBQ1YsSUFBSyxJQUFJZixJQUFJLEdBQUdBLElBQUljLE1BQU1iLE1BQU0sRUFBRUQsSUFBSztRQUNuQ2UsT0FBT0MsT0FBT0MsWUFBWSxDQUFDSCxLQUFLLENBQUNkLEVBQUU7SUFDdkM7SUFDQSxPQUFPZTtBQUNYO0FBQ08sSUFBSUcsaUJBQWlCLFNBQVVDLGNBQWM7SUFDaEQsT0FBT04sY0FBY2pCLG1EQUFZLENBQUNPLGlCQUFpQmdCO0FBQ3ZELEVBQUU7QUFDSyxJQUFJRSxXQUFXLFNBQVVDLEtBQUssRUFBRXJCLE1BQU0sRUFBRXNCLE9BQU87SUFDbEQsSUFBSUMsVUFBVTtJQUNkLElBQUssSUFBSUMsTUFBTSxHQUFHbkIsTUFBTUwsU0FBU3FCLE1BQU1yQixNQUFNLEVBQUV3QixNQUFNbkIsS0FBS21CLE1BQU87UUFDN0RELFdBQVdEO0lBQ2Y7SUFDQSxPQUFPQyxVQUFVRjtBQUNyQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvZXMvdXRpbHMuanM/MDdmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogVGhlIGBjaGFyc2AsIGBsb29rdXBgLCBhbmQgYGRlY29kZUZyb21CYXNlNjRgIG1lbWJlcnMgb2YgdGhpcyBmaWxlIGFyZVxuICogbGljZW5zZWQgdW5kZXIgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAgICAgYmFzZTY0LWFycmF5YnVmZmVyXG4gKiAgICAgaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHBha28gZnJvbSAncGFrbyc7XG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4vLyBVc2UgYSBsb29rdXAgdGFibGUgdG8gZmluZCB0aGUgaW5kZXguXG52YXIgbG9va3VwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpO1xufVxuZXhwb3J0IHZhciBkZWNvZGVGcm9tQmFzZTY0ID0gZnVuY3Rpb24gKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NTtcbiAgICB2YXIgbGVuID0gYmFzZTY0Lmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGVuY29kZWQxO1xuICAgIHZhciBlbmNvZGVkMjtcbiAgICB2YXIgZW5jb2RlZDM7XG4gICAgdmFyIGVuY29kZWQ0O1xuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgIGVuY29kZWQxID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgZW5jb2RlZDIgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgZW5jb2RlZDMgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDIpXTtcbiAgICAgICAgZW5jb2RlZDQgPSBsb29rdXBbYmFzZTY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn07XG52YXIgYXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn07XG5leHBvcnQgdmFyIGRlY29tcHJlc3NKc29uID0gZnVuY3Rpb24gKGNvbXByZXNzZWRKc29uKSB7XG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmcocGFrby5pbmZsYXRlKGRlY29kZUZyb21CYXNlNjQoY29tcHJlc3NlZEpzb24pKSk7XG59O1xuZXhwb3J0IHZhciBwYWRTdGFydCA9IGZ1bmN0aW9uICh2YWx1ZSwgbGVuZ3RoLCBwYWRDaGFyKSB7XG4gICAgdmFyIHBhZGRpbmcgPSAnJztcbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW4gPSBsZW5ndGggLSB2YWx1ZS5sZW5ndGg7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgICAgcGFkZGluZyArPSBwYWRDaGFyO1xuICAgIH1cbiAgICByZXR1cm4gcGFkZGluZyArIHZhbHVlO1xufTtcbiJdLCJuYW1lcyI6WyJwYWtvIiwiY2hhcnMiLCJsb29rdXAiLCJVaW50OEFycmF5IiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJkZWNvZGVGcm9tQmFzZTY0IiwiYmFzZTY0IiwiYnVmZmVyTGVuZ3RoIiwibGVuIiwicCIsImVuY29kZWQxIiwiZW5jb2RlZDIiLCJlbmNvZGVkMyIsImVuY29kZWQ0IiwiYnl0ZXMiLCJhcnJheVRvU3RyaW5nIiwiYXJyYXkiLCJzdHIiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkZWNvbXByZXNzSnNvbiIsImNvbXByZXNzZWRKc29uIiwiaW5mbGF0ZSIsInBhZFN0YXJ0IiwidmFsdWUiLCJwYWRDaGFyIiwicGFkZGluZyIsImlkeCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/es/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Top level file is just a mixin of submodules & constants\n\nvar assign = (__webpack_require__(/*! ./lib/utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\").assign);\nvar deflate = __webpack_require__(/*! ./lib/deflate */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js\");\nvar inflate = __webpack_require__(/*! ./lib/inflate */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js\");\nvar pako = {};\nassign(pako, deflate, inflate, constants);\nmodule.exports = pako;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsMkRBQTJEO0FBQzNEO0FBRUEsSUFBSUEsU0FBWUMsNElBQW9DO0FBRXBELElBQUlDLFVBQVlELG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlFLFVBQVlGLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlHLFlBQVlILG1CQUFPQSxDQUFDO0FBRXhCLElBQUlJLE9BQU8sQ0FBQztBQUVaTCxPQUFPSyxNQUFNSCxTQUFTQyxTQUFTQztBQUUvQkUsT0FBT0MsT0FBTyxHQUFHRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzPzZiZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVG9wIGxldmVsIGZpbGUgaXMganVzdCBhIG1peGluIG9mIHN1Ym1vZHVsZXMgJiBjb25zdGFudHNcbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiAgICA9IHJlcXVpcmUoJy4vbGliL3V0aWxzL2NvbW1vbicpLmFzc2lnbjtcblxudmFyIGRlZmxhdGUgICA9IHJlcXVpcmUoJy4vbGliL2RlZmxhdGUnKTtcbnZhciBpbmZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9pbmZsYXRlJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9saWIvemxpYi9jb25zdGFudHMnKTtcblxudmFyIHBha28gPSB7fTtcblxuYXNzaWduKHBha28sIGRlZmxhdGUsIGluZmxhdGUsIGNvbnN0YW50cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFrbztcbiJdLCJuYW1lcyI6WyJhc3NpZ24iLCJyZXF1aXJlIiwiZGVmbGF0ZSIsImluZmxhdGUiLCJjb25zdGFudHMiLCJwYWtvIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js\");\nvar toString = Object.prototype.toString;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ var Z_NO_FLUSH = 0;\nvar Z_FINISH = 4;\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_DEFAULT_STRATEGY = 0;\nvar Z_DEFLATED = 8;\n/* ===========================================================================*/ /**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/ /* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/ /**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/ /**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/ /**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/ function Deflate(options) {\n    if (!(this instanceof Deflate)) return new Deflate(options);\n    this.options = utils.assign({\n        level: Z_DEFAULT_COMPRESSION,\n        method: Z_DEFLATED,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n    if (status !== Z_OK) {\n        throw new Error(msg[status]);\n    }\n    if (opt.header) {\n        zlib_deflate.deflateSetHeader(this.strm, opt.header);\n    }\n    if (opt.dictionary) {\n        var dict;\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            // If we need to compress text, change encoding to utf8.\n            dict = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            dict = new Uint8Array(opt.dictionary);\n        } else {\n            dict = opt.dictionary;\n        }\n        status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n        if (status !== Z_OK) {\n            throw new Error(msg[status]);\n        }\n        this._dict_set = true;\n    }\n}\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Deflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var status, _mode;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // If we need to compress text, change encoding to utf8.\n        strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_deflate.deflate(strm, _mode); /* no bad return value */ \n        if (status !== Z_STREAM_END && status !== Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n            if (this.options.to === \"string\") {\n                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n            } else {\n                this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n            }\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n    // Finalize on the last chunk.\n    if (_mode === Z_FINISH) {\n        status = zlib_deflate.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === Z_SYNC_FLUSH) {\n        this.onEnd(Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Deflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Deflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === Z_OK) {\n        if (this.options.to === \"string\") {\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/ function deflate(input, options) {\n    var deflator = new Deflate(options);\n    deflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) {\n        throw deflator.msg || msg[deflator.err];\n    }\n    return deflator.result;\n}\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n}\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/ function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n}\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFHQSxJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUMzQixJQUFJQyxRQUFlRCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJRSxVQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxNQUFlSCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJSSxVQUFlSixtQkFBT0EsQ0FBQztBQUUzQixJQUFJSyxXQUFXQyxPQUFPQyxTQUFTLENBQUNGLFFBQVE7QUFFeEMsOEVBQThFLEdBQzlFLDhFQUE4RSxHQUU5RSxJQUFJRyxhQUFrQjtBQUN0QixJQUFJQyxXQUFrQjtBQUV0QixJQUFJQyxPQUFrQjtBQUN0QixJQUFJQyxlQUFrQjtBQUN0QixJQUFJQyxlQUFrQjtBQUV0QixJQUFJQyx3QkFBd0IsQ0FBQztBQUU3QixJQUFJQyxxQkFBd0I7QUFFNUIsSUFBSUMsYUFBYztBQUVsQiw4RUFBOEUsR0FHOUU7Ozs7OztFQU1FLEdBRUY7Ozs7RUFJRSxHQUVGOzs7Ozs7OztFQVFFLEdBRUY7Ozs7Ozs7RUFPRSxHQUVGOzs7O0VBSUUsR0FHRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0RFLEdBQ0YsU0FBU0MsUUFBUUMsT0FBTztJQUN0QixJQUFJLENBQUUsS0FBSSxZQUFZRCxPQUFNLEdBQUksT0FBTyxJQUFJQSxRQUFRQztJQUVuRCxJQUFJLENBQUNBLE9BQU8sR0FBR2hCLE1BQU1pQixNQUFNLENBQUM7UUFDMUJDLE9BQU9OO1FBQ1BPLFFBQVFMO1FBQ1JNLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxVQUFVO1FBQ1ZDLFVBQVVWO1FBQ1ZXLElBQUk7SUFDTixHQUFHUixXQUFXLENBQUM7SUFFZixJQUFJUyxNQUFNLElBQUksQ0FBQ1QsT0FBTztJQUV0QixJQUFJUyxJQUFJ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V2xCLEtBQUssRUFBRWpDLE9BQU87SUFDaENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QkEsUUFBUVUsR0FBRyxHQUFHO0lBQ2QsT0FBTzhCLFFBQVFQLE9BQU9qQztBQUN4QjtBQUdBOzs7Ozs7O0VBT0UsR0FDRixTQUFTVyxLQUFLc0IsS0FBSyxFQUFFakMsT0FBTztJQUMxQkEsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCQSxRQUFRVyxJQUFJLEdBQUc7SUFDZixPQUFPNkIsUUFBUVAsT0FBT2pDO0FBQ3hCO0FBR0FvRCxlQUFlLEdBQUdyRDtBQUNsQnFELGVBQWUsR0FBR1o7QUFDbEJZLGtCQUFrQixHQUFHRDtBQUNyQkMsWUFBWSxHQUFHekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcz85YWU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgnLi96bGliL2RlZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xuXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG5cbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyoqXG4gKiBjbGFzcyBEZWZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbZGVmbGF0ZV1dLFxuICogW1tkZWZsYXRlUmF3XV0gYW5kIFtbZ3ppcF1dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogRGVmbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbRGVmbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5XG4gKlxuICogQ29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbRGVmbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbRGVmbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tEZWZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pICBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgZGVmbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFlvdSB3aWxsIG5vdCBuZWVkIGl0IGluIHJlYWwgbGlmZSwgYmVjYXVzZSBkZWZsYXRlIGVycm9yc1xuICogYXJlIHBvc3NpYmxlIG9ubHkgb24gd3Jvbmcgb3B0aW9ucyBvciBiYWQgYG9uRGF0YWAgLyBgb25FbmRgXG4gKiBjdXN0b20gaGFuZGxlcnMuXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tEZWZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBEZWZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGRlZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgbGV2ZWxgXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgbWVtTGV2ZWxgXG4gKiAtIGBzdHJhdGVneWBcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGRlZmxhdGVcbiAqIC0gYGd6aXBgIChCb29sZWFuKSAtIGNyZWF0ZSBnemlwIHdyYXBwZXJcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKiAtIGBoZWFkZXJgIChPYmplY3QpIC0gY3VzdG9tIGhlYWRlciBmb3IgZ3ppcFxuICogICAtIGB0ZXh0YCAoQm9vbGVhbikgLSB0cnVlIGlmIGNvbXByZXNzZWQgZGF0YSBiZWxpZXZlZCB0byBiZSB0ZXh0XG4gKiAgIC0gYHRpbWVgIChOdW1iZXIpIC0gbW9kaWZpY2F0aW9uIHRpbWUsIHVuaXggdGltZXN0YW1wXG4gKiAgIC0gYG9zYCAoTnVtYmVyKSAtIG9wZXJhdGlvbiBzeXN0ZW0gY29kZVxuICogICAtIGBleHRyYWAgKEFycmF5KSAtIGFycmF5IG9mIGJ5dGVzIHdpdGggZXh0cmEgZGF0YSAobWF4IDY1NTM2KVxuICogICAtIGBuYW1lYCAoU3RyaW5nKSAtIGZpbGUgbmFtZSAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgY29tbWVudGAgKFN0cmluZykgLSBjb21tZW50IChiaW5hcnkgc3RyaW5nKVxuICogICAtIGBoY3JjYCAoQm9vbGVhbikgLSB0cnVlIGlmIGhlYWRlciBjcmMgc2hvdWxkIGJlIGFkZGVkXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBkZWZsYXRlID0gbmV3IHBha28uRGVmbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogZGVmbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogZGVmbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoZGVmbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGRlZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGRlZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gRGVmbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlKSkgcmV0dXJuIG5ldyBEZWZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgbGV2ZWw6IFpfREVGQVVMVF9DT01QUkVTU0lPTixcbiAgICBtZXRob2Q6IFpfREVGTEFURUQsXG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAxNSxcbiAgICBtZW1MZXZlbDogOCxcbiAgICBzdHJhdGVneTogWl9ERUZBVUxUX1NUUkFURUdZLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+IDApKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmIChvcHQuZ3ppcCAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAxNjtcbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQubGV2ZWwsXG4gICAgb3B0Lm1ldGhvZCxcbiAgICBvcHQud2luZG93Qml0cyxcbiAgICBvcHQubWVtTGV2ZWwsXG4gICAgb3B0LnN0cmF0ZWd5XG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICBpZiAob3B0LmhlYWRlcikge1xuICAgIHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0SGVhZGVyKHRoaXMuc3RybSwgb3B0LmhlYWRlcik7XG4gIH1cblxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICB2YXIgZGljdDtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgICBkaWN0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBkaWN0ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0ID0gb3B0LmRpY3Rpb25hcnk7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdCk7XG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgIH1cblxuICAgIHRoaXMuX2RpY3Rfc2V0ID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhLiBTdHJpbmdzIHdpbGwgYmVcbiAqICAgY29udmVydGVkIHRvIHV0ZjggYnl0ZSBzZXF1ZW5jZS5cbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGRlZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0RlZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IGNvbXByZXNzZWQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tEZWZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tEZWZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogYXJyYXkgZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBaX0ZJTklTSCA6IFpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIElmIHdlIG5lZWQgdG8gY29tcHJlc3MgdGV4dCwgY2hhbmdlIGVuY29kaW5nIHRvIHV0ZjguXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlKHN0cm0sIF9tb2RlKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IFpfRklOSVNIIHx8IF9tb2RlID09PSBaX1NZTkNfRkxVU0gpKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5vbkRhdGEoc3RyaW5ncy5idWYyYmluc3RyaW5nKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IFpfU1RSRUFNX0VORCk7XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBaX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBaX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKFpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBkZWZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBvbmNlIGFmdGVyIHlvdSB0ZWxsIGRlZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5EZWZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGRlZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgZGVmbGF0ZSBvcHRpb25zLlxuICpcbiAqIENvbXByZXNzIGBkYXRhYCB3aXRoIGRlZmxhdGUgYWxnb3JpdGhtIGFuZCBgb3B0aW9uc2AuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gbGV2ZWxcbiAqIC0gd2luZG93Qml0c1xuICogLSBtZW1MZXZlbFxuICogLSBzdHJhdGVneVxuICogLSBkaWN0aW9uYXJ5XG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgXCJiaW5hcnkgc3RyaW5nXCJcbiAqICAgIChlYWNoIGNoYXIgY29kZSBbMC4uMjU1XSlcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgZGF0YSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSk7XG4gKlxuICogY29uc29sZS5sb2cocGFrby5kZWZsYXRlKGRhdGEpKTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgZGVmbGF0b3IgPSBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICBkZWZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoZGVmbGF0b3IuZXJyKSB7IHRocm93IGRlZmxhdG9yLm1zZyB8fCBtc2dbZGVmbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBkZWZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBkZWZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gZGVmbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiBnemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2RlZmxhdGVdXSwgYnV0IGNyZWF0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCBvZlxuICogZGVmbGF0ZSBvbmUuXG4gKiovXG5mdW5jdGlvbiBnemlwKGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmd6aXAgPSB0cnVlO1xuICByZXR1cm4gZGVmbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuZXhwb3J0cy5EZWZsYXRlID0gRGVmbGF0ZTtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVSYXcgPSBkZWZsYXRlUmF3O1xuZXhwb3J0cy5nemlwID0gZ3ppcDtcbiJdLCJuYW1lcyI6WyJ6bGliX2RlZmxhdGUiLCJyZXF1aXJlIiwidXRpbHMiLCJzdHJpbmdzIiwibXNnIiwiWlN0cmVhbSIsInRvU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiWl9OT19GTFVTSCIsIlpfRklOSVNIIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfU1lOQ19GTFVTSCIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIlpfREVGTEFURUQiLCJEZWZsYXRlIiwib3B0aW9ucyIsImFzc2lnbiIsImxldmVsIiwibWV0aG9kIiwiY2h1bmtTaXplIiwid2luZG93Qml0cyIsIm1lbUxldmVsIiwic3RyYXRlZ3kiLCJ0byIsIm9wdCIsInJhdyIsImd6aXAiLCJlcnIiLCJlbmRlZCIsImNodW5rcyIsInN0cm0iLCJhdmFpbF9vdXQiLCJzdGF0dXMiLCJkZWZsYXRlSW5pdDIiLCJFcnJvciIsImhlYWRlciIsImRlZmxhdGVTZXRIZWFkZXIiLCJkaWN0aW9uYXJ5IiwiZGljdCIsInN0cmluZzJidWYiLCJjYWxsIiwiVWludDhBcnJheSIsImRlZmxhdGVTZXREaWN0aW9uYXJ5IiwiX2RpY3Rfc2V0IiwicHVzaCIsImRhdGEiLCJtb2RlIiwiX21vZGUiLCJpbnB1dCIsIm5leHRfaW4iLCJhdmFpbF9pbiIsImxlbmd0aCIsIm91dHB1dCIsIkJ1ZjgiLCJuZXh0X291dCIsImRlZmxhdGUiLCJvbkVuZCIsIm9uRGF0YSIsImJ1ZjJiaW5zdHJpbmciLCJzaHJpbmtCdWYiLCJkZWZsYXRlRW5kIiwiY2h1bmsiLCJyZXN1bHQiLCJqb2luIiwiZmxhdHRlbkNodW5rcyIsImRlZmxhdG9yIiwiZGVmbGF0ZVJhdyIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js\");\nvar c = __webpack_require__(/*! ./zlib/constants */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader = __webpack_require__(/*! ./zlib/gzheader */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js\");\nvar toString = Object.prototype.toString;\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/ /* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/ /**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/ /**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/ /**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/ function Inflate(options) {\n    if (!(this instanceof Inflate)) return new Inflate(options);\n    this.options = utils.assign({\n        chunkSize: 16384,\n        windowBits: 0,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    // Force window size for `raw` data, if not set directly,\n    // because we have no header for autodetect.\n    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n        opt.windowBits = -opt.windowBits;\n        if (opt.windowBits === 0) {\n            opt.windowBits = -15;\n        }\n    }\n    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n        opt.windowBits += 32;\n    }\n    // Gzip header has no info about windows size, we can do autodetect only\n    // for deflate. So, if window size not set, force it to max when gzip possible\n    if (opt.windowBits > 15 && opt.windowBits < 48) {\n        // bit 3 (16) -> gzipped data\n        // bit 4 (32) -> autodetect gzip/deflate\n        if ((opt.windowBits & 15) === 0) {\n            opt.windowBits |= 15;\n        }\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n    if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n    }\n    this.header = new GZheader();\n    zlib_inflate.inflateGetHeader(this.strm, this.header);\n    // Setup dictionary\n    if (opt.dictionary) {\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            opt.dictionary = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            opt.dictionary = new Uint8Array(opt.dictionary);\n        }\n        if (opt.raw) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n            if (status !== c.Z_OK) {\n                throw new Error(msg[status]);\n            }\n        }\n    }\n}\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Inflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var dictionary = this.options.dictionary;\n    var status, _mode;\n    var next_out_utf8, tail, utf8str;\n    // Flag to properly process Z_BUF_ERROR on testing inflate call\n    // when we check that all output data was flushed.\n    var allowBufError = false;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // Only binary strings can be decompressed on practice\n        strm.input = strings.binstring2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */ \n        if (status === c.Z_NEED_DICT && dictionary) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n        }\n        if (status === c.Z_BUF_ERROR && allowBufError === true) {\n            status = c.Z_OK;\n            allowBufError = false;\n        }\n        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.next_out) {\n            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {\n                if (this.options.to === \"string\") {\n                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n                    tail = strm.next_out - next_out_utf8;\n                    utf8str = strings.buf2string(strm.output, next_out_utf8);\n                    // move tail\n                    strm.next_out = tail;\n                    strm.avail_out = chunkSize - tail;\n                    if (tail) {\n                        utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n                    }\n                    this.onData(utf8str);\n                } else {\n                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n                }\n            }\n        }\n        // When no more input data, we should check that internal inflate buffers\n        // are flushed. The only way to do it when avail_out = 0 - run one more\n        // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n        // Here we set flag to process this error properly.\n        //\n        // NOTE. Deflate does not return error in this case and does not needs such\n        // logic.\n        if (strm.avail_in === 0 && strm.avail_out === 0) {\n            allowBufError = true;\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n    if (status === c.Z_STREAM_END) {\n        _mode = c.Z_FINISH;\n    }\n    // Finalize on the last chunk.\n    if (_mode === c.Z_FINISH) {\n        status = zlib_inflate.inflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === c.Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === c.Z_SYNC_FLUSH) {\n        this.onEnd(c.Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Inflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Inflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === c.Z_OK) {\n        if (this.options.to === \"string\") {\n            // Glue & convert here, until we teach pako to send\n            // utf8 aligned strings to onData\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/ function inflate(input, options) {\n    var inflator = new Inflate(options);\n    inflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (inflator.err) {\n        throw inflator.msg || msg[inflator.err];\n    }\n    return inflator.result;\n}\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function inflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return inflate(input, options);\n}\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/ exports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip = inflate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL2luZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFHQSxJQUFJQSxlQUFlQyxtQkFBT0EsQ0FBQztBQUMzQixJQUFJQyxRQUFlRCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJRSxVQUFlRixtQkFBT0EsQ0FBQztBQUMzQixJQUFJRyxJQUFlSCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJSSxNQUFlSixtQkFBT0EsQ0FBQztBQUMzQixJQUFJSyxVQUFlTCxtQkFBT0EsQ0FBQztBQUMzQixJQUFJTSxXQUFlTixtQkFBT0EsQ0FBQztBQUUzQixJQUFJTyxXQUFXQyxPQUFPQyxTQUFTLENBQUNGLFFBQVE7QUFFeEM7Ozs7OztFQU1FLEdBRUY7Ozs7RUFJRSxHQUVGOzs7Ozs7OztFQVFFLEdBRUY7Ozs7O0VBS0UsR0FFRjs7OztFQUlFLEdBR0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF3Q0UsR0FDRixTQUFTRyxRQUFRQyxPQUFPO0lBQ3RCLElBQUksQ0FBRSxLQUFJLFlBQVlELE9BQU0sR0FBSSxPQUFPLElBQUlBLFFBQVFDO0lBRW5ELElBQUksQ0FBQ0EsT0FBTyxHQUFHVixNQUFNVyxNQUFNLENBQUM7UUFDMUJDLFdBQVc7UUFDWEMsWUFBWTtRQUNaQyxJQUFJO0lBQ04sR0FBR0osV0FBVyxDQUFDO0lBRWYsSUFBSUssTUFBTSxJQUFJLENBQUNMLE9BQU87SUFFdEIseURBQXlEO0lBQ3pELDRDQUE0QztJQUM1QyxJQUFJSyxJQUFJQyxHQUFHLElBQUtELElBQUlGLFVBQVUsSUFBSSxLQUFPRSxJQUFJRixVQUFVLEdBQUcsSUFBSztRQUM3REUsSUFBSUYsVUFBVSxHQUFHLENBQUNFLElBQUlGLFVBQVU7UUFDaEMsSUFBSUUsSUFBSUYsVUFBVSxLQUFLLEdBQUc7WUFBRUUsSUFBSUYsVUFBVSxHQUFHLENBQUM7UUFBSTtJQUNwRDtJQUVBLHdGQUF3RjtJQUN4RixJQUFJLElBQUtBLFVBQVUsSUFBSSxLQUFPRSxJQUFJRixVQUFVLEdBQUcsTUFDM0MsQ0FBRUgsQ0FBQUEsV0FBV0EsUUFBUUcsVUFBVSxHQUFHO1FBQ3BDRSxJQUFJRixVQUFVLElBQUk7SUFDcEI7SUFFQSx3RUFBd0U7SUFDeEUsOEVBQThFO0lBQzlFLElBQUksSUFBS0EsVUFBVSxHQUFHLE1BQVFFLElBQUlGLFVBQVUsR0FBRyxJQUFLO1FBQ2xELDZCQUE2QjtRQUM3Qix3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDRSxJQUFJRixVQUFVLEdBQUcsRUFBQyxNQUFPLEdBQUc7WUFDL0JFLElBQUlGLFVBQVUsSUFBSTtRQUNwQjtJQUNGO0lBRUEsSUFBSSxDQUFDSSxHQUFHLEdBQU0sR0FBUSxvQ0FBb0M7SUFDMUQsSUFBSSxDQUFDZCxHQUFHLEdBQU0sSUFBUSxnQkFBZ0I7SUFDdEMsSUFBSSxDQUFDZSxLQUFLLEdBQUksT0FBUSx1Q0FBdUM7SUFDN0QsSUFBSSxDQUFDQyxNQUFNLEdBQUcsRUFBRSxFQUFNLDRCQUE0QjtJQUVsRCxJQUFJLENBQUNDLElBQUksR0FBSyxJQUFJaEI7SUFDbEIsSUFBSSxDQUFDZ0IsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFFdEIsSUFBSUMsU0FBVXhCLGFBQWF5QixZQUFZLENBQ3JDLElBQUksQ0FBQ0gsSUFBSSxFQUNUTCxJQUFJRixVQUFVO0lBR2hCLElBQUlTLFdBQVdwQixFQUFFc0IsSUFBSSxFQUFFO1FBQ3JCLE1BQU0sSUFBSUMsTUFBTXRCLEdBQUcsQ0FBQ21CLE9BQU87SUFDN0I7SUFFQSxJQUFJLENBQUNJLE1BQU0sR0FBRyxJQUFJckI7SUFFbEJQLGFBQWE2QixnQkFBZ0IsQ0FBQyxJQUFJLENBQUNQLElBQUksRUFBRSxJQUFJLENBQUNNLE1BQU07SUFFcEQsbUJBQW1CO0lBQ25CLElBQUlYLElBQUlhLFVBQVUsRUFBRTtRQUNsQix5QkFBeUI7UUFDekIsSUFBSSxPQUFPYixJQUFJYSxVQUFVLEtBQUssVUFBVTtZQUN0Q2IsSUFBSWEsVUFBVSxHQUFHM0IsUUFBUTRCLFVBQVUsQ0FBQ2QsSUFBSWEsVUFBVTtRQUNwRCxPQUFPLElBQUl0QixTQUFTd0IsSUFBSSxDQUFDZixJQUFJYSxVQUFVLE1BQU0sd0JBQXdCO1lBQ25FYixJQUFJYSxVQUFVLEdBQUcsSUFBSUcsV0FBV2hCLElBQUlhLFVBQVU7UUFDaEQ7UUFDQSxJQUFJYixJQUFJQyxHQUFHLEVBQUU7WUFDWE0sU0FBU3hCLGFBQWFrQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUNaLElBQUksRUFBRUwsSUFBSWEsVUFBVTtZQUNwRSxJQUFJTixXQUFXcEIsRUFBRXNCLElBQUksRUFBRTtnQkFDckIsTUFBTSxJQUFJQyxNQUFNdEIsR0FBRyxDQUFDbUIsT0FBTztZQUM3QjtRQUNGO0lBQ0Y7QUFDRjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEyQkUsR0FDRmIsUUFBUUQsU0FBUyxDQUFDeUIsSUFBSSxHQUFHLFNBQVVDLElBQUksRUFBRUMsSUFBSTtJQUMzQyxJQUFJZixPQUFPLElBQUksQ0FBQ0EsSUFBSTtJQUNwQixJQUFJUixZQUFZLElBQUksQ0FBQ0YsT0FBTyxDQUFDRSxTQUFTO0lBQ3RDLElBQUlnQixhQUFhLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ2tCLFVBQVU7SUFDeEMsSUFBSU4sUUFBUWM7SUFDWixJQUFJQyxlQUFlQyxNQUFNQztJQUV6QiwrREFBK0Q7SUFDL0Qsa0RBQWtEO0lBQ2xELElBQUlDLGdCQUFnQjtJQUVwQixJQUFJLElBQUksQ0FBQ3RCLEtBQUssRUFBRTtRQUFFLE9BQU87SUFBTztJQUNoQ2tCLFFBQVEsU0FBVSxDQUFDLENBQUNELE9BQVFBLE9BQVEsU0FBVSxPQUFRakMsRUFBRXVDLFFBQVEsR0FBR3ZDLEVBQUV3QyxVQUFVO0lBRS9FLHlCQUF5QjtJQUN6QixJQUFJLE9BQU9SLFNBQVMsVUFBVTtRQUM1QixzREFBc0Q7UUFDdERkLEtBQUt1QixLQUFLLEdBQUcxQyxRQUFRMkMsYUFBYSxDQUFDVjtJQUNyQyxPQUFPLElBQUk1QixTQUFTd0IsSUFBSSxDQUFDSSxVQUFVLHdCQUF3QjtRQUN6RGQsS0FBS3VCLEtBQUssR0FBRyxJQUFJWixXQUFXRztJQUM5QixPQUFPO1FBQ0xkLEtBQUt1QixLQUFLLEdBQUdUO0lBQ2Y7SUFFQWQsS0FBS3lCLE9BQU8sR0FBRztJQUNmekIsS0FBSzBCLFFBQVEsR0FBRzFCLEtBQUt1QixLQUFLLENBQUNJLE1BQU07SUFFakMsR0FBRztRQUNELElBQUkzQixLQUFLQyxTQUFTLEtBQUssR0FBRztZQUN4QkQsS0FBSzRCLE1BQU0sR0FBRyxJQUFJaEQsTUFBTWlELElBQUksQ0FBQ3JDO1lBQzdCUSxLQUFLOEIsUUFBUSxHQUFHO1lBQ2hCOUIsS0FBS0MsU0FBUyxHQUFHVDtRQUNuQjtRQUVBVSxTQUFTeEIsYUFBYXFELE9BQU8sQ0FBQy9CLE1BQU1sQixFQUFFd0MsVUFBVSxHQUFNLHVCQUF1QjtRQUU3RSxJQUFJcEIsV0FBV3BCLEVBQUVrRCxXQUFXLElBQUl4QixZQUFZO1lBQzFDTixTQUFTeEIsYUFBYWtDLG9CQUFvQixDQUFDLElBQUksQ0FBQ1osSUFBSSxFQUFFUTtRQUN4RDtRQUVBLElBQUlOLFdBQVdwQixFQUFFbUQsV0FBVyxJQUFJYixrQkFBa0IsTUFBTTtZQUN0RGxCLFNBQVNwQixFQUFFc0IsSUFBSTtZQUNmZ0IsZ0JBQWdCO1FBQ2xCO1FBRUEsSUFBSWxCLFdBQVdwQixFQUFFb0QsWUFBWSxJQUFJaEMsV0FBV3BCLEVBQUVzQixJQUFJLEVBQUU7WUFDbEQsSUFBSSxDQUFDK0IsS0FBSyxDQUFDakM7WUFDWCxJQUFJLENBQUNKLEtBQUssR0FBRztZQUNiLE9BQU87UUFDVDtRQUVBLElBQUlFLEtBQUs4QixRQUFRLEVBQUU7WUFDakIsSUFBSTlCLEtBQUtDLFNBQVMsS0FBSyxLQUFLQyxXQUFXcEIsRUFBRW9ELFlBQVksSUFBS2xDLEtBQUswQixRQUFRLEtBQUssS0FBTVYsQ0FBQUEsVUFBVWxDLEVBQUV1QyxRQUFRLElBQUlMLFVBQVVsQyxFQUFFc0QsWUFBWSxHQUFJO2dCQUVwSSxJQUFJLElBQUksQ0FBQzlDLE9BQU8sQ0FBQ0ksRUFBRSxLQUFLLFVBQVU7b0JBRWhDdUIsZ0JBQWdCcEMsUUFBUXdELFVBQVUsQ0FBQ3JDLEtBQUs0QixNQUFNLEVBQUU1QixLQUFLOEIsUUFBUTtvQkFFN0RaLE9BQU9sQixLQUFLOEIsUUFBUSxHQUFHYjtvQkFDdkJFLFVBQVV0QyxRQUFReUQsVUFBVSxDQUFDdEMsS0FBSzRCLE1BQU0sRUFBRVg7b0JBRTFDLFlBQVk7b0JBQ1pqQixLQUFLOEIsUUFBUSxHQUFHWjtvQkFDaEJsQixLQUFLQyxTQUFTLEdBQUdULFlBQVkwQjtvQkFDN0IsSUFBSUEsTUFBTTt3QkFBRXRDLE1BQU0yRCxRQUFRLENBQUN2QyxLQUFLNEIsTUFBTSxFQUFFNUIsS0FBSzRCLE1BQU0sRUFBRVgsZUFBZUMsTUFBTTtvQkFBSTtvQkFFOUUsSUFBSSxDQUFDc0IsTUFBTSxDQUFDckI7Z0JBRWQsT0FBTztvQkFDTCxJQUFJLENBQUNxQixNQUFNLENBQUM1RCxNQUFNNkQsU0FBUyxDQUFDekMsS0FBSzRCLE1BQU0sRUFBRTVCLEtBQUs4QixRQUFRO2dCQUN4RDtZQUNGO1FBQ0Y7UUFFQSx5RUFBeUU7UUFDekUsdUVBQXVFO1FBQ3ZFLDJFQUEyRTtRQUMzRSxtREFBbUQ7UUFDbkQsRUFBRTtRQUNGLDJFQUEyRTtRQUMzRSxTQUFTO1FBQ1QsSUFBSTlCLEtBQUswQixRQUFRLEtBQUssS0FBSzFCLEtBQUtDLFNBQVMsS0FBSyxHQUFHO1lBQy9DbUIsZ0JBQWdCO1FBQ2xCO0lBRUYsUUFBUyxDQUFDcEIsS0FBSzBCLFFBQVEsR0FBRyxLQUFLMUIsS0FBS0MsU0FBUyxLQUFLLE1BQU1DLFdBQVdwQixFQUFFb0QsWUFBWSxFQUFFO0lBRW5GLElBQUloQyxXQUFXcEIsRUFBRW9ELFlBQVksRUFBRTtRQUM3QmxCLFFBQVFsQyxFQUFFdUMsUUFBUTtJQUNwQjtJQUVBLDhCQUE4QjtJQUM5QixJQUFJTCxVQUFVbEMsRUFBRXVDLFFBQVEsRUFBRTtRQUN4Qm5CLFNBQVN4QixhQUFhZ0UsVUFBVSxDQUFDLElBQUksQ0FBQzFDLElBQUk7UUFDMUMsSUFBSSxDQUFDbUMsS0FBSyxDQUFDakM7UUFDWCxJQUFJLENBQUNKLEtBQUssR0FBRztRQUNiLE9BQU9JLFdBQVdwQixFQUFFc0IsSUFBSTtJQUMxQjtJQUVBLDRDQUE0QztJQUM1QyxJQUFJWSxVQUFVbEMsRUFBRXNELFlBQVksRUFBRTtRQUM1QixJQUFJLENBQUNELEtBQUssQ0FBQ3JELEVBQUVzQixJQUFJO1FBQ2pCSixLQUFLQyxTQUFTLEdBQUc7UUFDakIsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBR0E7Ozs7Ozs7O0VBUUUsR0FDRlosUUFBUUQsU0FBUyxDQUFDb0QsTUFBTSxHQUFHLFNBQVVHLEtBQUs7SUFDeEMsSUFBSSxDQUFDNUMsTUFBTSxDQUFDYyxJQUFJLENBQUM4QjtBQUNuQjtBQUdBOzs7Ozs7Ozs7RUFTRSxHQUNGdEQsUUFBUUQsU0FBUyxDQUFDK0MsS0FBSyxHQUFHLFNBQVVqQyxNQUFNO0lBQ3hDLG9CQUFvQjtJQUNwQixJQUFJQSxXQUFXcEIsRUFBRXNCLElBQUksRUFBRTtRQUNyQixJQUFJLElBQUksQ0FBQ2QsT0FBTyxDQUFDSSxFQUFFLEtBQUssVUFBVTtZQUNoQyxtREFBbUQ7WUFDbkQsaUNBQWlDO1lBQ2pDLElBQUksQ0FBQ2tELE1BQU0sR0FBRyxJQUFJLENBQUM3QyxNQUFNLENBQUM4QyxJQUFJLENBQUM7UUFDakMsT0FBTztZQUNMLElBQUksQ0FBQ0QsTUFBTSxHQUFHaEUsTUFBTWtFLGFBQWEsQ0FBQyxJQUFJLENBQUMvQyxNQUFNO1FBQy9DO0lBQ0Y7SUFDQSxJQUFJLENBQUNBLE1BQU0sR0FBRyxFQUFFO0lBQ2hCLElBQUksQ0FBQ0YsR0FBRyxHQUFHSztJQUNYLElBQUksQ0FBQ25CLEdBQUcsR0FBRyxJQUFJLENBQUNpQixJQUFJLENBQUNqQixHQUFHO0FBQzFCO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0NFLEdBQ0YsU0FBU2dELFFBQVFSLEtBQUssRUFBRWpDLE9BQU87SUFDN0IsSUFBSXlELFdBQVcsSUFBSTFELFFBQVFDO0lBRTNCeUQsU0FBU2xDLElBQUksQ0FBQ1UsT0FBTztJQUVyQiw4REFBOEQ7SUFDOUQsSUFBSXdCLFNBQVNsRCxHQUFHLEVBQUU7UUFBRSxNQUFNa0QsU0FBU2hFLEdBQUcsSUFBSUEsR0FBRyxDQUFDZ0UsU0FBU2xELEdBQUcsQ0FBQztJQUFFO0lBRTdELE9BQU9rRCxTQUFTSCxNQUFNO0FBQ3hCO0FBR0E7Ozs7Ozs7RUFPRSxHQUNGLFNBQVNJLFdBQVd6QixLQUFLLEVBQUVqQyxPQUFPO0lBQ2hDQSxVQUFVQSxXQUFXLENBQUM7SUFDdEJBLFFBQVFNLEdBQUcsR0FBRztJQUNkLE9BQU9tQyxRQUFRUixPQUFPakM7QUFDeEI7QUFHQTs7Ozs7OztFQU9FLEdBR0YyRCxlQUFlLEdBQUc1RDtBQUNsQjRELGVBQWUsR0FBR2xCO0FBQ2xCa0Isa0JBQWtCLEdBQUdEO0FBQ3JCQyxjQUFjLEdBQUlsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzP2MyNTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGRlbi5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLnJlc3VsdCAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICpcbiAqIFVuY29tcHJlc3NlZCByZXN1bHQsIGdlbmVyYXRlZCBieSBkZWZhdWx0IFtbSW5mbGF0ZSNvbkRhdGFdXVxuICogYW5kIFtbSW5mbGF0ZSNvbkVuZF1dIGhhbmRsZXJzLiBGaWxsZWQgYWZ0ZXIgeW91IHB1c2ggbGFzdCBjaHVua1xuICogKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoIGBaX0ZJTklTSGAgLyBgdHJ1ZWAgcGFyYW0pIG9yIGlmIHlvdVxuICogcHVzaCBhIGNodW5rIHdpdGggZXhwbGljaXQgZmx1c2ggKGNhbGwgW1tJbmZsYXRlI3B1c2hdXSB3aXRoXG4gKiBgWl9TWU5DX0ZMVVNIYCBwYXJhbSkuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5lcnIgLT4gTnVtYmVyXG4gKlxuICogRXJyb3IgY29kZSBhZnRlciBpbmZsYXRlIGZpbmlzaGVkLiAwIChaX09LKSBvbiBzdWNjZXNzLlxuICogU2hvdWxkIGJlIGNoZWNrZWQgaWYgYnJva2VuIGRhdGEgcG9zc2libGUuXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5tc2cgLT4gU3RyaW5nXG4gKlxuICogRXJyb3IgbWVzc2FnZSwgaWYgW1tJbmZsYXRlLmVycl1dICE9IDBcbiAqKi9cblxuXG4vKipcbiAqIG5ldyBJbmZsYXRlKG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIENyZWF0ZXMgbmV3IGluZmxhdG9yIGluc3RhbmNlIHdpdGggc3BlY2lmaWVkIHBhcmFtcy4gVGhyb3dzIGV4Y2VwdGlvblxuICogb24gYmFkIHBhcmFtcy4gU3VwcG9ydGVkIG9wdGlvbnM6XG4gKlxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYGRpY3Rpb25hcnlgXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlc2UuXG4gKlxuICogQWRkaXRpb25hbCBvcHRpb25zLCBmb3IgaW50ZXJuYWwgbmVlZHM6XG4gKlxuICogLSBgY2h1bmtTaXplYCAtIHNpemUgb2YgZ2VuZXJhdGVkIGRhdGEgY2h1bmtzICgxNksgYnkgZGVmYXVsdClcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gZG8gcmF3IGluZmxhdGVcbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgd2hlbiBubyBvcHRpb25zIHNldCwgYXV0b2RldGVjdCBkZWZsYXRlL2d6aXAgZGF0YSBmb3JtYXQgdmlhXG4gKiB3cmFwcGVyIGhlYWRlci5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgY2h1bmsxID0gVWludDhBcnJheShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIGNodW5rMiA9IFVpbnQ4QXJyYXkoWzEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5XSk7XG4gKlxuICogdmFyIGluZmxhdGUgPSBuZXcgcGFrby5JbmZsYXRlKHsgbGV2ZWw6IDN9KTtcbiAqXG4gKiBpbmZsYXRlLnB1c2goY2h1bmsxLCBmYWxzZSk7XG4gKiBpbmZsYXRlLnB1c2goY2h1bmsyLCB0cnVlKTsgIC8vIHRydWUgLT4gbGFzdCBjaHVua1xuICpcbiAqIGlmIChpbmZsYXRlLmVycikgeyB0aHJvdyBuZXcgRXJyb3IoaW5mbGF0ZS5lcnIpOyB9XG4gKlxuICogY29uc29sZS5sb2coaW5mbGF0ZS5yZXN1bHQpO1xuICogYGBgXG4gKiovXG5mdW5jdGlvbiBJbmZsYXRlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gdXRpbHMuYXNzaWduKHtcbiAgICBjaHVua1NpemU6IDE2Mzg0LFxuICAgIHdpbmRvd0JpdHM6IDAsXG4gICAgdG86ICcnXG4gIH0sIG9wdGlvbnMgfHwge30pO1xuXG4gIHZhciBvcHQgPSB0aGlzLm9wdGlvbnM7XG5cbiAgLy8gRm9yY2Ugd2luZG93IHNpemUgZm9yIGByYXdgIGRhdGEsIGlmIG5vdCBzZXQgZGlyZWN0bHksXG4gIC8vIGJlY2F1c2Ugd2UgaGF2ZSBubyBoZWFkZXIgZm9yIGF1dG9kZXRlY3QuXG4gIGlmIChvcHQucmF3ICYmIChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikpIHtcbiAgICBvcHQud2luZG93Qml0cyA9IC1vcHQud2luZG93Qml0cztcbiAgICBpZiAob3B0LndpbmRvd0JpdHMgPT09IDApIHsgb3B0LndpbmRvd0JpdHMgPSAtMTU7IH1cbiAgfVxuXG4gIC8vIElmIGB3aW5kb3dCaXRzYCBub3QgZGVmaW5lZCAoYW5kIG1vZGUgbm90IHJhdykgLSBzZXQgYXV0b2RldGVjdCBmbGFnIGZvciBnemlwL2RlZmxhdGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+PSAwKSAmJiAob3B0LndpbmRvd0JpdHMgPCAxNikgJiZcbiAgICAgICEob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvd0JpdHMpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMzI7XG4gIH1cblxuICAvLyBHemlwIGhlYWRlciBoYXMgbm8gaW5mbyBhYm91dCB3aW5kb3dzIHNpemUsIHdlIGNhbiBkbyBhdXRvZGV0ZWN0IG9ubHlcbiAgLy8gZm9yIGRlZmxhdGUuIFNvLCBpZiB3aW5kb3cgc2l6ZSBub3Qgc2V0LCBmb3JjZSBpdCB0byBtYXggd2hlbiBnemlwIHBvc3NpYmxlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPiAxNSkgJiYgKG9wdC53aW5kb3dCaXRzIDwgNDgpKSB7XG4gICAgLy8gYml0IDMgKDE2KSAtPiBnemlwcGVkIGRhdGFcbiAgICAvLyBiaXQgNCAoMzIpIC0+IGF1dG9kZXRlY3QgZ3ppcC9kZWZsYXRlXG4gICAgaWYgKChvcHQud2luZG93Qml0cyAmIDE1KSA9PT0gMCkge1xuICAgICAgb3B0LndpbmRvd0JpdHMgfD0gMTU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lcnIgICAgPSAwOyAgICAgIC8vIGVycm9yIGNvZGUsIGlmIGhhcHBlbnMgKDAgPSBaX09LKVxuICB0aGlzLm1zZyAgICA9ICcnOyAgICAgLy8gZXJyb3IgbWVzc2FnZVxuICB0aGlzLmVuZGVkICA9IGZhbHNlOyAgLy8gdXNlZCB0byBhdm9pZCBtdWx0aXBsZSBvbkVuZCgpIGNhbGxzXG4gIHRoaXMuY2h1bmtzID0gW107ICAgICAvLyBjaHVua3Mgb2YgY29tcHJlc3NlZCBkYXRhXG5cbiAgdGhpcy5zdHJtICAgPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgdGhpcy5zdHJtLFxuICAgIG9wdC53aW5kb3dCaXRzXG4gICk7XG5cbiAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgfVxuXG4gIHRoaXMuaGVhZGVyID0gbmV3IEdaaGVhZGVyKCk7XG5cbiAgemxpYl9pbmZsYXRlLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLCB0aGlzLmhlYWRlcik7XG5cbiAgLy8gU2V0dXAgZGljdGlvbmFyeVxuICBpZiAob3B0LmRpY3Rpb25hcnkpIHtcbiAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBvcHQuZGljdGlvbmFyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gc3RyaW5ncy5zdHJpbmcyYnVmKG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwob3B0LmRpY3Rpb25hcnkpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9XG4gICAgaWYgKG9wdC5yYXcpIHsgLy9JbiByYXcgbW9kZSB3ZSBuZWVkIHRvIHNldCB0aGUgZGljdGlvbmFyeSBlYXJseVxuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgb3B0LmRpY3Rpb25hcnkpO1xuICAgICAgaWYgKHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5mbGF0ZSNwdXNoKGRhdGFbLCBtb2RlXSkgLT4gQm9vbGVhblxuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fEFycmF5QnVmZmVyfFN0cmluZyk6IGlucHV0IGRhdGFcbiAqIC0gbW9kZSAoTnVtYmVyfEJvb2xlYW4pOiAwLi42IGZvciBjb3JyZXNwb25kaW5nIFpfTk9fRkxVU0guLlpfVFJFRSBtb2Rlcy5cbiAqICAgU2VlIGNvbnN0YW50cy4gU2tpcHBlZCBvciBgZmFsc2VgIG1lYW5zIFpfTk9fRkxVU0gsIGB0cnVlYCBtZWFucyBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuXG4gIC8vIEZsYWcgdG8gcHJvcGVybHkgcHJvY2VzcyBaX0JVRl9FUlJPUiBvbiB0ZXN0aW5nIGluZmxhdGUgY2FsbFxuICAvLyB3aGVuIHdlIGNoZWNrIHRoYXQgYWxsIG91dHB1dCBkYXRhIHdhcyBmbHVzaGVkLlxuICB2YXIgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuICBfbW9kZSA9IChtb2RlID09PSB+fm1vZGUpID8gbW9kZSA6ICgobW9kZSA9PT0gdHJ1ZSkgPyBjLlpfRklOSVNIIDogYy5aX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBPbmx5IGJpbmFyeSBzdHJpbmdzIGNhbiBiZSBkZWNvbXByZXNzZWQgb24gcHJhY3RpY2VcbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5iaW5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZShzdHJtLCBjLlpfTk9fRkxVU0gpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfTkVFRF9ESUNUICYmIGRpY3Rpb25hcnkpIHtcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3Rpb25hcnkpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9CVUZfRVJST1IgJiYgYWxsb3dCdWZFcnJvciA9PT0gdHJ1ZSkge1xuICAgICAgc3RhdHVzID0gYy5aX09LO1xuICAgICAgYWxsb3dCdWZFcnJvciA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gYy5aX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RybS5uZXh0X291dCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBjLlpfRklOSVNIIHx8IF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkpKSB7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgIG5leHRfb3V0X3V0ZjggPSBzdHJpbmdzLnV0Zjhib3JkZXIoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpO1xuXG4gICAgICAgICAgdGFpbCA9IHN0cm0ubmV4dF9vdXQgLSBuZXh0X291dF91dGY4O1xuICAgICAgICAgIHV0ZjhzdHIgPSBzdHJpbmdzLmJ1ZjJzdHJpbmcoc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgpO1xuXG4gICAgICAgICAgLy8gbW92ZSB0YWlsXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHRhaWw7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemUgLSB0YWlsO1xuICAgICAgICAgIGlmICh0YWlsKSB7IHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCwgdGFpbCwgMCk7IH1cblxuICAgICAgICAgIHRoaXMub25EYXRhKHV0ZjhzdHIpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaGVuIG5vIG1vcmUgaW5wdXQgZGF0YSwgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaW50ZXJuYWwgaW5mbGF0ZSBidWZmZXJzXG4gICAgLy8gYXJlIGZsdXNoZWQuIFRoZSBvbmx5IHdheSB0byBkbyBpdCB3aGVuIGF2YWlsX291dCA9IDAgLSBydW4gb25lIG1vcmVcbiAgICAvLyBpbmZsYXRlIHBhc3MuIEJ1dCBpZiBvdXRwdXQgZGF0YSBub3QgZXhpc3RzLCBpbmZsYXRlIHJldHVybiBaX0JVRl9FUlJPUi5cbiAgICAvLyBIZXJlIHdlIHNldCBmbGFnIHRvIHByb2Nlc3MgdGhpcyBlcnJvciBwcm9wZXJseS5cbiAgICAvL1xuICAgIC8vIE5PVEUuIERlZmxhdGUgZG9lcyBub3QgcmV0dXJuIGVycm9yIGluIHRoaXMgY2FzZSBhbmQgZG9lcyBub3QgbmVlZHMgc3VjaFxuICAgIC8vIGxvZ2ljLlxuICAgIGlmIChzdHJtLmF2YWlsX2luID09PSAwICYmIHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSB3aGlsZSAoKHN0cm0uYXZhaWxfaW4gPiAwIHx8IHN0cm0uYXZhaWxfb3V0ID09PSAwKSAmJiBzdGF0dXMgIT09IGMuWl9TVFJFQU1fRU5EKTtcblxuICBpZiAoc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCkge1xuICAgIF9tb2RlID0gYy5aX0ZJTklTSDtcbiAgfVxuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IGMuWl9GSU5JU0gpIHtcbiAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gc3RhdHVzID09PSBjLlpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChjLlpfT0spO1xuICAgIHN0cm0uYXZhaWxfb3V0ID0gMDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25EYXRhKGNodW5rKSAtPiBWb2lkXG4gKiAtIGNodW5rIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IG91dHB1dCBkYXRhLiBUeXBlIG9mIGFycmF5IGRlcGVuZHNcbiAqICAgb24ganMgZW5naW5lIHN1cHBvcnQuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsIGVhY2ggY2h1bmtcbiAqICAgd2lsbCBiZSBzdHJpbmcuXG4gKlxuICogQnkgZGVmYXVsdCwgc3RvcmVzIGRhdGEgYmxvY2tzIGluIGBjaHVua3NbXWAgcHJvcGVydHkgYW5kIGdsdWVcbiAqIHRob3NlIGluIGBvbkVuZGAuIE92ZXJyaWRlIHRoaXMgaGFuZGxlciwgaWYgeW91IG5lZWQgYW5vdGhlciBiZWhhdmlvdXIuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgdGhpcy5jaHVua3MucHVzaChjaHVuayk7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkVuZChzdGF0dXMpIC0+IFZvaWRcbiAqIC0gc3RhdHVzIChOdW1iZXIpOiBpbmZsYXRlIHN0YXR1cy4gMCAoWl9PSykgb24gc3VjY2VzcyxcbiAqICAgb3RoZXIgaWYgbm90LlxuICpcbiAqIENhbGxlZCBlaXRoZXIgYWZ0ZXIgeW91IHRlbGwgaW5mbGF0ZSB0aGF0IHRoZSBpbnB1dCBzdHJlYW0gaXNcbiAqIGNvbXBsZXRlIChaX0ZJTklTSCkgb3Igc2hvdWxkIGJlIGZsdXNoZWQgKFpfU1lOQ19GTFVTSClcbiAqIG9yIGlmIGFuIGVycm9yIGhhcHBlbmVkLiBCeSBkZWZhdWx0IC0gam9pbiBjb2xsZWN0ZWQgY2h1bmtzLFxuICogZnJlZSBtZW1vcnkgYW5kIGZpbGwgYHJlc3VsdHNgIC8gYGVycmAgcHJvcGVydGllcy5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRW5kID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAvLyBPbiBzdWNjZXNzIC0gam9pblxuICBpZiAoc3RhdHVzID09PSBjLlpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gR2x1ZSAmIGNvbnZlcnQgaGVyZSwgdW50aWwgd2UgdGVhY2ggcGFrbyB0byBzZW5kXG4gICAgICAvLyB1dGY4IGFsaWduZWQgc3RyaW5ncyB0byBvbkRhdGFcbiAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5jaHVua3Muam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzdWx0ID0gdXRpbHMuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcyk7XG4gICAgfVxuICB9XG4gIHRoaXMuY2h1bmtzID0gW107XG4gIHRoaXMuZXJyID0gc3RhdHVzO1xuICB0aGlzLm1zZyA9IHRoaXMuc3RybS5tc2c7XG59O1xuXG5cbi8qKlxuICogaW5mbGF0ZShkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBEZWNvbXByZXNzIGBkYXRhYCB3aXRoIGluZmxhdGUvdW5nemlwIGFuZCBgb3B0aW9uc2AuIEF1dG9kZXRlY3RcbiAqIGZvcm1hdCB2aWEgd3JhcHBlciBoZWFkZXIgYnkgZGVmYXVsdC4gVGhhdCdzIHdoeSB3ZSBkb24ndCBwcm92aWRlXG4gKiBzZXBhcmF0ZSBgdW5nemlwYCBtZXRob2QuXG4gKlxuICogU3VwcG9ydGVkIG9wdGlvbnMgYXJlOlxuICpcbiAqIC0gd2luZG93Qml0c1xuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIGNvbnZlcnRlZFxuICogICBmcm9tIHV0ZjggdG8gdXRmMTYgKGphdmFzY3JpcHQpIHN0cmluZy4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCxcbiAqICAgY2h1bmsgbGVuZ3RoIGNhbiBkaWZmZXIgZnJvbSBgY2h1bmtTaXplYCwgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gKlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBpbnB1dCA9IHBha28uZGVmbGF0ZShbMSwyLDMsNCw1LDYsNyw4LDldKVxuICogICAsIG91dHB1dDtcbiAqXG4gKiB0cnkge1xuICogICBvdXRwdXQgPSBwYWtvLmluZmxhdGUoaW5wdXQpO1xuICogfSBjYXRjaCAoZXJyKVxuICogICBjb25zb2xlLmxvZyhlcnIpO1xuICogfVxuICogYGBgXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBpbmZsYXRvciA9IG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIGluZmxhdG9yLnB1c2goaW5wdXQsIHRydWUpO1xuXG4gIC8vIFRoYXQgd2lsbCBuZXZlciBoYXBwZW5zLCBpZiB5b3UgZG9uJ3QgY2hlYXQgd2l0aCBvcHRpb25zIDopXG4gIGlmIChpbmZsYXRvci5lcnIpIHsgdGhyb3cgaW5mbGF0b3IubXNnIHx8IG1zZ1tpbmZsYXRvci5lcnJdOyB9XG5cbiAgcmV0dXJuIGluZmxhdG9yLnJlc3VsdDtcbn1cblxuXG4vKipcbiAqIGluZmxhdGVSYXcoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tpbmZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogdW5nemlwKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIEp1c3Qgc2hvcnRjdXQgdG8gW1tpbmZsYXRlXV0sIGJlY2F1c2UgaXQgYXV0b2RldGVjdHMgZm9ybWF0XG4gKiBieSBoZWFkZXIuY29udGVudC4gRG9uZSBmb3IgY29udmVuaWVuY2UuXG4gKiovXG5cblxuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVSYXcgPSBpbmZsYXRlUmF3O1xuZXhwb3J0cy51bmd6aXAgID0gaW5mbGF0ZTtcbiJdLCJuYW1lcyI6WyJ6bGliX2luZmxhdGUiLCJyZXF1aXJlIiwidXRpbHMiLCJzdHJpbmdzIiwiYyIsIm1zZyIsIlpTdHJlYW0iLCJHWmhlYWRlciIsInRvU3RyaW5nIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiSW5mbGF0ZSIsIm9wdGlvbnMiLCJhc3NpZ24iLCJjaHVua1NpemUiLCJ3aW5kb3dCaXRzIiwidG8iLCJvcHQiLCJyYXciLCJlcnIiLCJlbmRlZCIsImNodW5rcyIsInN0cm0iLCJhdmFpbF9vdXQiLCJzdGF0dXMiLCJpbmZsYXRlSW5pdDIiLCJaX09LIiwiRXJyb3IiLCJoZWFkZXIiLCJpbmZsYXRlR2V0SGVhZGVyIiwiZGljdGlvbmFyeSIsInN0cmluZzJidWYiLCJjYWxsIiwiVWludDhBcnJheSIsImluZmxhdGVTZXREaWN0aW9uYXJ5IiwicHVzaCIsImRhdGEiLCJtb2RlIiwiX21vZGUiLCJuZXh0X291dF91dGY4IiwidGFpbCIsInV0ZjhzdHIiLCJhbGxvd0J1ZkVycm9yIiwiWl9GSU5JU0giLCJaX05PX0ZMVVNIIiwiaW5wdXQiLCJiaW5zdHJpbmcyYnVmIiwibmV4dF9pbiIsImF2YWlsX2luIiwibGVuZ3RoIiwib3V0cHV0IiwiQnVmOCIsIm5leHRfb3V0IiwiaW5mbGF0ZSIsIlpfTkVFRF9ESUNUIiwiWl9CVUZfRVJST1IiLCJaX1NUUkVBTV9FTkQiLCJvbkVuZCIsIlpfU1lOQ19GTFVTSCIsInV0Zjhib3JkZXIiLCJidWYyc3RyaW5nIiwiYXJyYXlTZXQiLCJvbkRhdGEiLCJzaHJpbmtCdWYiLCJpbmZsYXRlRW5kIiwiY2h1bmsiLCJyZXN1bHQiLCJqb2luIiwiZmxhdHRlbkNodW5rcyIsImluZmxhdG9yIiwiaW5mbGF0ZVJhdyIsImV4cG9ydHMiLCJ1bmd6aXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/inflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\nfunction _has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexports.assign = function(obj /*from1, from2, from3, ...*/ ) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    while(sources.length){\n        var source = sources.shift();\n        if (!source) {\n            continue;\n        }\n        if (typeof source !== \"object\") {\n            throw new TypeError(source + \"must be non-object\");\n        }\n        for(var p in source){\n            if (_has(source, p)) {\n                obj[p] = source[p];\n            }\n        }\n    }\n    return obj;\n};\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function(buf, size) {\n    if (buf.length === size) {\n        return buf;\n    }\n    if (buf.subarray) {\n        return buf.subarray(0, size);\n    }\n    buf.length = size;\n    return buf;\n};\nvar fnTyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n            return;\n        }\n        // Fallback to ordinary array\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        // calculate data length\n        len = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            len += chunks[i].length;\n        }\n        // join chunks\n        result = new Uint8Array(len);\n        pos = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            chunk = chunks[i];\n            result.set(chunk, pos);\n            pos += chunk.length;\n        }\n        return result;\n    }\n};\nvar fnUntyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n    }\n};\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function(on) {\n    if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n    } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n    }\n};\nexports.setTyped(TYPED_OK);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUdBLElBQUlBLFdBQVksT0FBUUMsZUFBZSxlQUN0QixPQUFPQyxnQkFBZ0IsZUFDdkIsT0FBT0MsZUFBZTtBQUV2QyxTQUFTQyxLQUFLQyxHQUFHLEVBQUVDLEdBQUc7SUFDcEIsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsS0FBS0M7QUFDbkQ7QUFFQUssY0FBYyxHQUFHLFNBQVVOLElBQUksMEJBQTBCLEdBQTNCO0lBQzVCLElBQUlRLFVBQVVDLE1BQU1OLFNBQVMsQ0FBQ08sS0FBSyxDQUFDTCxJQUFJLENBQUNNLFdBQVc7SUFDcEQsTUFBT0gsUUFBUUksTUFBTSxDQUFFO1FBQ3JCLElBQUlDLFNBQVNMLFFBQVFNLEtBQUs7UUFDMUIsSUFBSSxDQUFDRCxRQUFRO1lBQUU7UUFBVTtRQUV6QixJQUFJLE9BQU9BLFdBQVcsVUFBVTtZQUM5QixNQUFNLElBQUlFLFVBQVVGLFNBQVM7UUFDL0I7UUFFQSxJQUFLLElBQUlHLEtBQUtILE9BQVE7WUFDcEIsSUFBSWQsS0FBS2MsUUFBUUcsSUFBSTtnQkFDbkJoQixHQUFHLENBQUNnQixFQUFFLEdBQUdILE1BQU0sQ0FBQ0csRUFBRTtZQUNwQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPaEI7QUFDVDtBQUdBLHdDQUF3QztBQUN4Q00saUJBQWlCLEdBQUcsU0FBVVksR0FBRyxFQUFFQyxJQUFJO0lBQ3JDLElBQUlELElBQUlOLE1BQU0sS0FBS08sTUFBTTtRQUFFLE9BQU9EO0lBQUs7SUFDdkMsSUFBSUEsSUFBSUUsUUFBUSxFQUFFO1FBQUUsT0FBT0YsSUFBSUUsUUFBUSxDQUFDLEdBQUdEO0lBQU87SUFDbERELElBQUlOLE1BQU0sR0FBR087SUFDYixPQUFPRDtBQUNUO0FBR0EsSUFBSUcsVUFBVTtJQUNaQyxVQUFVLFNBQVVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEdBQUcsRUFBRUMsU0FBUztRQUNyRCxJQUFJSCxJQUFJSixRQUFRLElBQUlHLEtBQUtILFFBQVEsRUFBRTtZQUNqQ0csS0FBS0ssR0FBRyxDQUFDSixJQUFJSixRQUFRLENBQUNLLFVBQVVBLFdBQVdDLE1BQU1DO1lBQ2pEO1FBQ0Y7UUFDQSw2QkFBNkI7UUFDN0IsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlILEtBQUtHLElBQUs7WUFDNUJOLElBQUksQ0FBQ0ksWUFBWUUsRUFBRSxHQUFHTCxHQUFHLENBQUNDLFdBQVdJLEVBQUU7UUFDekM7SUFDRjtJQUNBLHdDQUF3QztJQUN4Q0MsZUFBZSxTQUFVQyxNQUFNO1FBQzdCLElBQUlGLEdBQUdHLEdBQUdOLEtBQUtPLEtBQUtDLE9BQU9DO1FBRTNCLHdCQUF3QjtRQUN4QlQsTUFBTTtRQUNOLElBQUtHLElBQUksR0FBR0csSUFBSUQsT0FBT25CLE1BQU0sRUFBRWlCLElBQUlHLEdBQUdILElBQUs7WUFDekNILE9BQU9LLE1BQU0sQ0FBQ0YsRUFBRSxDQUFDakIsTUFBTTtRQUN6QjtRQUVBLGNBQWM7UUFDZHVCLFNBQVMsSUFBSXZDLFdBQVc4QjtRQUN4Qk8sTUFBTTtRQUNOLElBQUtKLElBQUksR0FBR0csSUFBSUQsT0FBT25CLE1BQU0sRUFBRWlCLElBQUlHLEdBQUdILElBQUs7WUFDekNLLFFBQVFILE1BQU0sQ0FBQ0YsRUFBRTtZQUNqQk0sT0FBT1AsR0FBRyxDQUFDTSxPQUFPRDtZQUNsQkEsT0FBT0MsTUFBTXRCLE1BQU07UUFDckI7UUFFQSxPQUFPdUI7SUFDVDtBQUNGO0FBRUEsSUFBSUMsWUFBWTtJQUNkZCxVQUFVLFNBQVVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLEdBQUcsRUFBRUMsU0FBUztRQUNyRCxJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUgsS0FBS0csSUFBSztZQUM1Qk4sSUFBSSxDQUFDSSxZQUFZRSxFQUFFLEdBQUdMLEdBQUcsQ0FBQ0MsV0FBV0ksRUFBRTtRQUN6QztJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDQyxlQUFlLFNBQVVDLE1BQU07UUFDN0IsT0FBTyxFQUFFLENBQUNNLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLEVBQUUsRUFBRVA7SUFDN0I7QUFDRjtBQUdBLCtDQUErQztBQUMvQyxFQUFFO0FBQ0Z6QixnQkFBZ0IsR0FBRyxTQUFVa0MsRUFBRTtJQUM3QixJQUFJQSxJQUFJO1FBQ05sQyxZQUFZLEdBQUlWO1FBQ2hCVSxhQUFhLEdBQUdUO1FBQ2hCUyxhQUFhLEdBQUdSO1FBQ2hCUSxRQUFRQyxNQUFNLENBQUNELFNBQVNlO0lBQzFCLE9BQU87UUFDTGYsWUFBWSxHQUFJRztRQUNoQkgsYUFBYSxHQUFHRztRQUNoQkgsYUFBYSxHQUFHRztRQUNoQkgsUUFBUUMsTUFBTSxDQUFDRCxTQUFTOEI7SUFDMUI7QUFDRjtBQUVBOUIsUUFBUWlDLFFBQVEsQ0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcz80MjhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG52YXIgVFlQRURfT0sgPSAgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSAndW5kZWZpbmVkJykgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIEludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxuZnVuY3Rpb24gX2hhcyhvYmosIGtleSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoX2hhcyhzb3VyY2UsIHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuIl0sIm5hbWVzIjpbIlRZUEVEX09LIiwiVWludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIl9oYXMiLCJvYmoiLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwiYXNzaWduIiwic291cmNlcyIsIkFycmF5Iiwic2xpY2UiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJzaGlmdCIsIlR5cGVFcnJvciIsInAiLCJzaHJpbmtCdWYiLCJidWYiLCJzaXplIiwic3ViYXJyYXkiLCJmblR5cGVkIiwiYXJyYXlTZXQiLCJkZXN0Iiwic3JjIiwic3JjX29mZnMiLCJsZW4iLCJkZXN0X29mZnMiLCJzZXQiLCJpIiwiZmxhdHRlbkNodW5rcyIsImNodW5rcyIsImwiLCJwb3MiLCJjaHVuayIsInJlc3VsdCIsImZuVW50eXBlZCIsImNvbmNhdCIsImFwcGx5Iiwic2V0VHlwZWQiLCJvbiIsIkJ1ZjgiLCJCdWYxNiIsIkJ1ZjMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// String encode/decode helpers\n\nvar utils = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\ntry {\n    String.fromCharCode.apply(null, [\n        0\n    ]);\n} catch (__) {\n    STR_APPLY_OK = false;\n}\ntry {\n    String.fromCharCode.apply(null, new Uint8Array(1));\n} catch (__) {\n    STR_APPLY_UIA_OK = false;\n}\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor(var q = 0; q < 256; q++){\n    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nexports.string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    buf = new utils.Buf8(buf_len);\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n        }\n    }\n    var result = \"\";\n    for(var i = 0; i < len; i++){\n        result += String.fromCharCode(buf[i]);\n    }\n    return result;\n}\n// Convert byte array to binary string\nexports.buf2binstring = function(buf) {\n    return buf2binstring(buf, buf.length);\n};\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function(str) {\n    var buf = new utils.Buf8(str.length);\n    for(var i = 0, len = buf.length; i < len; i++){\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n};\n// convert array to string\nexports.buf2string = function(buf, max) {\n    var i, out, c, c_len;\n    var len = max || buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    return buf2binstring(utf16buf, out);\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsK0JBQStCO0FBQy9CO0FBR0EsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFHcEIsZ0VBQWdFO0FBQ2hFLEVBQUU7QUFDRix5Q0FBeUM7QUFDekMsaURBQWlEO0FBQ2pELEVBQUU7QUFDRixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLG1CQUFtQjtBQUV2QixJQUFJO0lBQUVDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU07UUFBRTtLQUFHO0FBQUcsRUFBRSxPQUFPQyxJQUFJO0lBQUVMLGVBQWU7QUFBTztBQUNuRixJQUFJO0lBQUVFLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sSUFBSUUsV0FBVztBQUFLLEVBQUUsT0FBT0QsSUFBSTtJQUFFSixtQkFBbUI7QUFBTztBQUduRyxpRUFBaUU7QUFDakUsb0ZBQW9GO0FBQ3BGLDZDQUE2QztBQUM3QyxJQUFJTSxXQUFXLElBQUlULE1BQU1VLElBQUksQ0FBQztBQUM5QixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxJQUFLO0lBQzVCRixRQUFRLENBQUNFLEVBQUUsR0FBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJO0FBQzVGO0FBQ0FGLFFBQVEsQ0FBQyxJQUFJLEdBQUdBLFFBQVEsQ0FBQyxJQUFJLEdBQUcsR0FBRyx5QkFBeUI7QUFHNUQsaURBQWlEO0FBQ2pERyxrQkFBa0IsR0FBRyxTQUFVRSxHQUFHO0lBQ2hDLElBQUlDLEtBQUtDLEdBQUdDLElBQUlDLE9BQU9DLEdBQUdDLFVBQVVOLElBQUlPLE1BQU0sRUFBRUMsVUFBVTtJQUUxRCxvQkFBb0I7SUFDcEIsSUFBS0osUUFBUSxHQUFHQSxR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QUN4Q0UsUUFBUSxDQUFDRixNQUFNLEdBQUcsU0FBVWhCLElBQUk7UUFDbEM7SUFDRjtJQUVBLE9BQU9RLGNBQWNVLFVBQVVGO0FBQ2pDO0FBR0Esa0RBQWtEO0FBQ2xELHVEQUF1RDtBQUN2RCwrQ0FBK0M7QUFDL0MsRUFBRTtBQUNGLDJCQUEyQjtBQUMzQixvQ0FBb0M7QUFDcENwQixrQkFBa0IsR0FBRyxTQUFVRyxHQUFHLEVBQUVnQixHQUFHO0lBQ3JDLElBQUlNO0lBRUpOLE1BQU1BLE9BQU9oQixJQUFJTSxNQUFNO0lBQ3ZCLElBQUlVLE1BQU1oQixJQUFJTSxNQUFNLEVBQUU7UUFBRVUsTUFBTWhCLElBQUlNLE1BQU07SUFBRTtJQUUxQyw0REFBNEQ7SUFDNURnQixNQUFNTixNQUFNO0lBQ1osTUFBT00sT0FBTyxLQUFLLENBQUN0QixHQUFHLENBQUNzQixJQUFJLEdBQUcsSUFBRyxNQUFPLEtBQU07UUFBRUE7SUFBTztJQUV4RCxrQ0FBa0M7SUFDbEMseURBQXlEO0lBQ3pELElBQUlBLE1BQU0sR0FBRztRQUFFLE9BQU9OO0lBQUs7SUFFM0Isa0VBQWtFO0lBQ2xFLGtCQUFrQjtJQUNsQixJQUFJTSxRQUFRLEdBQUc7UUFBRSxPQUFPTjtJQUFLO0lBRTdCLE9BQU8sTUFBT3RCLFFBQVEsQ0FBQ00sR0FBRyxDQUFDc0IsSUFBSSxDQUFDLEdBQUdOLE1BQU9NLE1BQU1OO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanM/YTEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJTVFJfQVBQTFlfT0siLCJTVFJfQVBQTFlfVUlBX09LIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJfXyIsIlVpbnQ4QXJyYXkiLCJfdXRmOGxlbiIsIkJ1ZjgiLCJxIiwiZXhwb3J0cyIsInN0cmluZzJidWYiLCJzdHIiLCJidWYiLCJjIiwiYzIiLCJtX3BvcyIsImkiLCJzdHJfbGVuIiwibGVuZ3RoIiwiYnVmX2xlbiIsImNoYXJDb2RlQXQiLCJidWYyYmluc3RyaW5nIiwibGVuIiwic3ViYXJyYXkiLCJzaHJpbmtCdWYiLCJyZXN1bHQiLCJiaW5zdHJpbmcyYnVmIiwiYnVmMnN0cmluZyIsIm1heCIsIm91dCIsImNfbGVuIiwidXRmMTZidWYiLCJBcnJheSIsInV0Zjhib3JkZXIiLCJwb3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction adler32(adler, buf, len, pos) {\n    var s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;\n    while(len !== 0){\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n        do {\n            s1 = s1 + buf[pos++] | 0;\n            s2 = s2 + s1 | 0;\n        }while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n    }\n    return s1 | s2 << 16 | 0;\n}\nmodule.exports = adler32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLDBEQUEwRDtBQUMxRCxxRUFBcUU7QUFDckUsNEJBQTRCO0FBRTVCLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLFNBQVNBLFFBQVFDLEtBQUssRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDbkMsSUFBSUMsS0FBSyxRQUFTLFNBQVMsR0FDdkJDLEtBQUssVUFBWSxLQUFNLFNBQVMsR0FDaENDLElBQUk7SUFFUixNQUFPSixRQUFRLEVBQUc7UUFDaEIsNENBQTRDO1FBQzVDLCtDQUErQztRQUMvQyw4QkFBOEI7UUFDOUJJLElBQUlKLE1BQU0sT0FBTyxPQUFPQTtRQUN4QkEsT0FBT0k7UUFFUCxHQUFHO1lBQ0RGLEtBQUssS0FBTUgsR0FBRyxDQUFDRSxNQUFNLEdBQUc7WUFDeEJFLEtBQUssS0FBTUQsS0FBSztRQUNsQixRQUFTLEVBQUVFLEdBQUc7UUFFZEYsTUFBTTtRQUNOQyxNQUFNO0lBQ1I7SUFFQSxPQUFPLEtBQU9BLE1BQU0sS0FBTTtBQUM1QjtBQUdBRSxPQUFPQyxPQUFPLEdBQUdUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcz82N2E0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiJdLCJuYW1lcyI6WyJhZGxlcjMyIiwiYWRsZXIiLCJidWYiLCJsZW4iLCJwb3MiLCJzMSIsInMyIiwibiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js ***!
  \**************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    /* Allowed flush values; see deflate() and inflate() below for details */ Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_TREES: 6,\n    /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */ Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    //Z_MEM_ERROR:     -4,\n    Z_BUF_ERROR: -5,\n    //Z_VERSION_ERROR: -6,\n    /* compression levels */ Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    /* Possible values of the data_type field (though see inflate()) */ Z_BINARY: 0,\n    Z_TEXT: 1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN: 2,\n    /* The deflate compression method */ Z_DEFLATED: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0VBLE9BQU9DLE9BQU8sR0FBRztJQUVmLHVFQUF1RSxHQUN2RUMsWUFBb0I7SUFDcEJDLGlCQUFvQjtJQUNwQkMsY0FBb0I7SUFDcEJDLGNBQW9CO0lBQ3BCQyxVQUFvQjtJQUNwQkMsU0FBb0I7SUFDcEJDLFNBQW9CO0lBRXBCOztFQUVBLEdBQ0FDLE1BQW9CO0lBQ3BCQyxjQUFvQjtJQUNwQkMsYUFBb0I7SUFDcEJDLFNBQW1CLENBQUM7SUFDcEJDLGdCQUFtQixDQUFDO0lBQ3BCQyxjQUFtQixDQUFDO0lBQ3BCLHNCQUFzQjtJQUN0QkMsYUFBbUIsQ0FBQztJQUNwQixzQkFBc0I7SUFFdEIsc0JBQXNCLEdBQ3RCQyxrQkFBMEI7SUFDMUJDLGNBQTBCO0lBQzFCQyxvQkFBMEI7SUFDMUJDLHVCQUF5QixDQUFDO0lBRzFCQyxZQUEwQjtJQUMxQkMsZ0JBQTBCO0lBQzFCQyxPQUEwQjtJQUMxQkMsU0FBMEI7SUFDMUJDLG9CQUEwQjtJQUUxQixpRUFBaUUsR0FDakVDLFVBQTBCO0lBQzFCQyxRQUEwQjtJQUMxQixxREFBcUQ7SUFDckRDLFdBQTBCO0lBRTFCLGtDQUFrQyxHQUNsQ0MsWUFBMEI7QUFFNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanM/YjYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJaX05PX0ZMVVNIIiwiWl9QQVJUSUFMX0ZMVVNIIiwiWl9TWU5DX0ZMVVNIIiwiWl9GVUxMX0ZMVVNIIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiWl9UUkVFUyIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX05FRURfRElDVCIsIlpfRVJSTk8iLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfQlVGX0VSUk9SIiwiWl9OT19DT01QUkVTU0lPTiIsIlpfQkVTVF9TUEVFRCIsIlpfQkVTVF9DT01QUkVTU0lPTiIsIlpfREVGQVVMVF9DT01QUkVTU0lPTiIsIlpfRklMVEVSRUQiLCJaX0hVRkZNQU5fT05MWSIsIlpfUkxFIiwiWl9GSVhFRCIsIlpfREVGQVVMVF9TVFJBVEVHWSIsIlpfQklOQVJZIiwiWl9URVhUIiwiWl9VTktOT1dOIiwiWl9ERUZMQVRFRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js ***!
  \**********************************************************************************/
/***/ ((module) => {

eval("\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc ^= -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = crc32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxtREFBbUQ7QUFDbkQsMERBQTBEO0FBQzFELGdDQUFnQztBQUVoQyxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSx3REFBd0Q7QUFDeEQsU0FBU0E7SUFDUCxJQUFJQyxHQUFHQyxRQUFRLEVBQUU7SUFFakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUksS0FBS0EsSUFBSztRQUM1QkYsSUFBSUU7UUFDSixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFLO1lBQzFCSCxJQUFLLElBQUssSUFBTSxhQUFjQSxNQUFNLElBQU9BLE1BQU07UUFDbkQ7UUFDQUMsS0FBSyxDQUFDQyxFQUFFLEdBQUdGO0lBQ2I7SUFFQSxPQUFPQztBQUNUO0FBRUEsOERBQThEO0FBQzlELElBQUlHLFdBQVdMO0FBR2YsU0FBU00sTUFBTUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUMvQixJQUFJQyxJQUFJTixVQUNKTyxNQUFNRixNQUFNRDtJQUVoQkYsT0FBTyxDQUFDO0lBRVIsSUFBSyxJQUFJTSxJQUFJSCxLQUFLRyxJQUFJRCxLQUFLQyxJQUFLO1FBQzlCTixNQUFNLFFBQVMsSUFBS0ksQ0FBQyxDQUFDLENBQUNKLE1BQU1DLEdBQUcsQ0FBQ0ssRUFBRSxJQUFJLEtBQUs7SUFDOUM7SUFFQSxPQUFRTixNQUFPLENBQUMsR0FBSyxTQUFTO0FBQ2hDO0FBR0FPLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcz9iMTNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBjID0gbjtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgYyA9ICgoYyAmIDEpID8gKDB4RURCODgzMjAgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKTtcbiAgICB9XG4gICAgdGFibGVbbl0gPSBjO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG4vLyBDcmVhdGUgdGFibGUgb24gbG9hZC4gSnVzdCAyNTUgc2lnbmVkIGxvbmdzLiBOb3QgYSBwcm9ibGVtLlxudmFyIGNyY1RhYmxlID0gbWFrZVRhYmxlKCk7XG5cblxuZnVuY3Rpb24gY3JjMzIoY3JjLCBidWYsIGxlbiwgcG9zKSB7XG4gIHZhciB0ID0gY3JjVGFibGUsXG4gICAgICBlbmQgPSBwb3MgKyBsZW47XG5cbiAgY3JjIF49IC0xO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiJdLCJuYW1lcyI6WyJtYWtlVGFibGUiLCJjIiwidGFibGUiLCJuIiwiayIsImNyY1RhYmxlIiwiY3JjMzIiLCJjcmMiLCJidWYiLCJsZW4iLCJwb3MiLCJ0IiwiZW5kIiwiaSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar trees = __webpack_require__(/*! ./trees */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js\");\nvar msg = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ var Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\n//var Z_TREES         = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* compression levels */ //var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_FILTERED = 1;\nvar Z_HUFFMAN_ONLY = 2;\nvar Z_RLE = 3;\nvar Z_FIXED = 4;\nvar Z_DEFAULT_STRATEGY = 0;\n/* Possible values of the data_type field (though see inflate()) */ //var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/*============================================================================*/ var MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */ var MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_MEM_LEVEL = 8;\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nvar PRESET_DICT = 0x20;\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\nvar BS_NEED_MORE = 1; /* block not completed, need more input or more output */ \nvar BS_BLOCK_DONE = 2; /* block flush performed */ \nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */ \nvar BS_FINISH_DONE = 4; /* finish done, accept no more input or output */ \nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\nfunction err(strm, errorCode) {\n    strm.msg = msg[errorCode];\n    return errorCode;\n}\nfunction rank(f) {\n    return (f << 1) - (f > 4 ? 9 : 0);\n}\nfunction zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */ function flush_pending(strm) {\n    var s = strm.state;\n    //_tr_flush_bits(s);\n    var len = s.pending;\n    if (len > strm.avail_out) {\n        len = strm.avail_out;\n    }\n    if (len === 0) {\n        return;\n    }\n    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n    strm.next_out += len;\n    s.pending_out += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending -= len;\n    if (s.pending === 0) {\n        s.pending_out = 0;\n    }\n}\nfunction flush_block_only(s, last) {\n    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n}\nfunction put_byte(s, b) {\n    s.pending_buf[s.pending++] = b;\n}\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */ function putShortMSB(s, b) {\n    //  put_byte(s, (Byte)(b >> 8));\n    //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n}\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */ function read_buf(strm, buf, start, size) {\n    var len = strm.avail_in;\n    if (len > size) {\n        len = size;\n    }\n    if (len === 0) {\n        return 0;\n    }\n    strm.avail_in -= len;\n    // zmemcpy(buf, strm->next_in, len);\n    utils.arraySet(buf, strm.input, strm.next_in, len, start);\n    if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n    } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n    }\n    strm.next_in += len;\n    strm.total_in += len;\n    return len;\n}\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */ function longest_match(s, cur_match) {\n    var chain_length = s.max_chain_length; /* max hash chain length */ \n    var scan = s.strstart; /* current string */ \n    var match; /* matched string */ \n    var len; /* length of current match */ \n    var best_len = s.prev_length; /* best match length so far */ \n    var nice_match = s.nice_match; /* stop if match long enough */ \n    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;\n    var _win = s.window; // shortcut\n    var wmask = s.w_mask;\n    var prev = s.prev;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */ var strend = s.strstart + MAX_MATCH;\n    var scan_end1 = _win[scan + best_len - 1];\n    var scan_end = _win[scan + best_len];\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */ // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n    /* Do not waste too much time if we already have a good match: */ if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */ if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n    }\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n    do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */ if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n            continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */ scan += 2;\n        match++;\n        // Assert(*scan == *match, \"match[2]?\");\n        /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */ do {\n        /*jshint noempty:false*/ }while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n            s.match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) {\n                break;\n            }\n            scan_end1 = _win[scan + best_len - 1];\n            scan_end = _win[scan + best_len];\n        }\n    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n    if (best_len <= s.lookahead) {\n        return best_len;\n    }\n    return s.lookahead;\n}\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */ function fill_window(s) {\n    var _w_size = s.w_size;\n    var p, n, m, more, str;\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n    do {\n        more = s.window_size - s.lookahead - s.strstart;\n        // JS ints have 32 bit, block below not needed\n        /* Deal with !@#$% 64K limit: */ //if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        //}\n        /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */ if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n            s.match_start -= _w_size;\n            s.strstart -= _w_size;\n            /* we now have strstart >= MAX_DIST */ s.block_start -= _w_size;\n            /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */ n = s.hash_size;\n            p = n;\n            do {\n                m = s.head[--p];\n                s.head[p] = m >= _w_size ? m - _w_size : 0;\n            }while (--n);\n            n = _w_size;\n            p = n;\n            do {\n                m = s.prev[--p];\n                s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */ }while (--n);\n            more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n            break;\n        }\n        /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */ //Assert(more >= 2, \"more < 2\");\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */ if (s.lookahead + s.insert >= MIN_MATCH) {\n            str = s.strstart - s.insert;\n            s.ins_h = s.window[str];\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //        Call update_hash() MIN_MATCH-3 more times\n            //#endif\n            while(s.insert){\n                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n                s.prev[str & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = str;\n                str++;\n                s.insert--;\n                if (s.lookahead + s.insert < MIN_MATCH) {\n                    break;\n                }\n            }\n        }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */ }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n/* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */ //  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */ function deflate_stored(s, flush) {\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */ var max_block_size = 0xffff;\n    if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n    }\n    /* Copy as much as possible from input to output: */ for(;;){\n        /* Fill the window as much as possible: */ if (s.lookahead <= 1) {\n            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n            //  s->block_start >= (long)s->w_size, \"slide too late\");\n            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n            //        s.block_start >= s.w_size)) {\n            //        throw  new Error(\"slide too late\");\n            //      }\n            fill_window(s);\n            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            }\n        /* flush the current block */ }\n        //Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */ var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n            /* strstart == 0 is possible when wraparound on 16-bit machine */ s.lookahead = s.strstart - max_start;\n            s.strstart = max_start;\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n        /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */ if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.strstart > s.block_start) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_NEED_MORE;\n}\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */ function deflate_fast(s, flush) {\n    var hash_head; /* head of the hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break; /* flush the current block */ \n            }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */ if (hash_head !== 0 /*NIL*/  && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */ }\n        if (s.match_length >= MIN_MATCH) {\n            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n            /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */ if (s.match_length <= s.max_lazy_match /*max_insert_length*/  && s.lookahead >= MIN_MATCH) {\n                s.match_length--; /* string at strstart already in table */ \n                do {\n                    s.strstart++;\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */ }while (--s.match_length !== 0);\n                s.strstart++;\n            } else {\n                s.strstart += s.match_length;\n                s.match_length = 0;\n                s.ins_h = s.window[s.strstart];\n                /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            //#endif\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */ }\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */ function deflate_slow(s, flush) {\n    var hash_head; /* head of hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    var max_insert;\n    /* Process the input block. */ for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     */ s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 /*NIL*/  && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */ if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ )) {\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */ s.match_length = MIN_MATCH - 1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */ if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n            max_insert = s.strstart + s.lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */ //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/ bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n            /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */ s.lookahead -= s.prev_length - 1;\n            s.prev_length -= 2;\n            do {\n                if (++s.strstart <= max_insert) {\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ }\n            }while (--s.prev_length !== 0);\n            s.match_available = 0;\n            s.match_length = MIN_MATCH - 1;\n            s.strstart++;\n            if (bflush) {\n                /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            /***/ }\n        } else if (s.match_available) {\n            /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */ //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n            if (bflush) {\n                /*** FLUSH_BLOCK_ONLY(s, 0) ***/ flush_block_only(s, false);\n            /***/ }\n            s.strstart++;\n            s.lookahead--;\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        } else {\n            /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */ s.match_available = 1;\n            s.strstart++;\n            s.lookahead--;\n        }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */ function deflate_rle(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    var prev; /* byte at distance one to match */ \n    var scan, strend; /* scan goes up to strend for length of run */ \n    var _win = s.window;\n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */ if (s.lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* See how many times the previous byte repeats */ s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n            scan = s.strstart - 1;\n            prev = _win[scan];\n            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n                strend = s.strstart + MAX_MATCH;\n                do {\n                /*jshint noempty:false*/ }while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n                s.match_length = MAX_MATCH - (strend - scan);\n                if (s.match_length > s.lookahead) {\n                    s.match_length = s.lookahead;\n                }\n            }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */ if (s.match_length >= MIN_MATCH) {\n            //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            s.strstart += s.match_length;\n            s.match_length = 0;\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */ function deflate_huff(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we have a literal to write. */ if (s.lookahead === 0) {\n            fill_window(s);\n            if (s.lookahead === 0) {\n                if (flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                break; /* flush the current block */ \n            }\n        }\n        /* Output a literal byte */ s.match_length = 0;\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */ function Config(good_length, max_lazy, nice_length, max_chain, func) {\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n}\nvar configuration_table;\nconfiguration_table = [\n    /*      good lazy nice chain */ new Config(0, 0, 0, 0, deflate_stored),\n    /* 0 store only */ new Config(4, 4, 8, 4, deflate_fast),\n    /* 1 max speed, no lazy matches */ new Config(4, 5, 16, 8, deflate_fast),\n    /* 2 */ new Config(4, 6, 32, 32, deflate_fast),\n    /* 3 */ new Config(4, 4, 16, 16, deflate_slow),\n    /* 4 lazy matches */ new Config(8, 16, 32, 32, deflate_slow),\n    /* 5 */ new Config(8, 16, 128, 128, deflate_slow),\n    /* 6 */ new Config(8, 32, 128, 256, deflate_slow),\n    /* 7 */ new Config(32, 128, 258, 1024, deflate_slow),\n    /* 8 */ new Config(32, 258, 258, 4096, deflate_slow)\n];\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */ function lm_init(s) {\n    s.window_size = 2 * s.w_size;\n    /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n    /* Set the default configuration parameters:\n   */ s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n}\nfunction DeflateState() {\n    this.strm = null; /* pointer back to this zlib stream */ \n    this.status = 0; /* as the name implies */ \n    this.pending_buf = null; /* output still pending */ \n    this.pending_buf_size = 0; /* size of pending_buf */ \n    this.pending_out = 0; /* next pending byte to output to the stream */ \n    this.pending = 0; /* nb of bytes in the pending buffer */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.gzhead = null; /* gzip header information to write */ \n    this.gzindex = 0; /* where in extra, name, or comment */ \n    this.method = Z_DEFLATED; /* can only be DEFLATED */ \n    this.last_flush = -1; /* value of flush param for previous deflate call */ \n    this.w_size = 0; /* LZ77 window size (32K by default) */ \n    this.w_bits = 0; /* log2(w_size)  (8..16) */ \n    this.w_mask = 0; /* w_size - 1 */ \n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */ this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */ this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */ this.head = null; /* Heads of the hash chains or NIL. */ \n    this.ins_h = 0; /* hash index of string to be inserted */ \n    this.hash_size = 0; /* number of elements in hash table */ \n    this.hash_bits = 0; /* log2(hash_size) */ \n    this.hash_mask = 0; /* hash_size-1 */ \n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */ this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */ this.match_length = 0; /* length of best match */ \n    this.prev_match = 0; /* previous match */ \n    this.match_available = 0; /* set if previous match exists */ \n    this.strstart = 0; /* start of string to insert */ \n    this.match_start = 0; /* start of matching string */ \n    this.lookahead = 0; /* number of valid bytes ahead in window */ \n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */ this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */ this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */ // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */ this.level = 0; /* compression level (1..9) */ \n    this.strategy = 0; /* favor or force Huffman coding*/ \n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */ this.nice_match = 0; /* Stop searching when current match exceeds this */ \n    /* used by trees.c: */ /* Didn't use ct_data typedef below to suppress compiler warning */ // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n    this.l_desc = null; /* desc. for literal tree */ \n    this.d_desc = null; /* desc. for distance tree */ \n    this.bl_desc = null; /* desc. for bit length tree */ \n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new utils.Buf16(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */ \n    zero(this.heap);\n    this.heap_len = 0; /* number of elements in the heap */ \n    this.heap_max = 0; /* element of largest frequency */ \n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */ this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */ this.l_buf = 0; /* buffer index for literals or lengths */ \n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */ this.last_lit = 0; /* running index in l_buf */ \n    this.d_buf = 0;\n    /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */ this.opt_len = 0; /* bit length of current block with optimal trees */ \n    this.static_len = 0; /* bit length of current block with static trees */ \n    this.matches = 0; /* number of string matches in current block */ \n    this.insert = 0; /* bytes at end of window left to insert */ \n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */ this.bi_valid = 0;\n/* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */ // Used for window memory init. We safely ignore it for JS. That makes\n// sense only for pointers and memory check tools.\n//this.high_water = 0;\n/* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */ }\nfunction deflateResetKeep(strm) {\n    var s;\n    if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n    s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n    if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */ }\n    s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n    strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n     : 1; // adler32(0, Z_NULL, 0)\n    s.last_flush = Z_NO_FLUSH;\n    trees._tr_init(s);\n    return Z_OK;\n}\nfunction deflateReset(strm) {\n    var ret = deflateResetKeep(strm);\n    if (ret === Z_OK) {\n        lm_init(strm.state);\n    }\n    return ret;\n}\nfunction deflateSetHeader(strm, head) {\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n    }\n    strm.state.gzhead = head;\n    return Z_OK;\n}\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    var wrap = 1;\n    if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n    }\n    if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else if (windowBits > 15) {\n        wrap = 2; /* write gzip wrapper instead */ \n        windowBits -= 16;\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    if (windowBits === 8) {\n        windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */ var s = new DeflateState();\n    strm.state = s;\n    s.strm = strm;\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n    s.window = new utils.Buf8(s.w_size * 2);\n    s.head = new utils.Buf16(s.hash_size);\n    s.prev = new utils.Buf16(s.w_size);\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n    s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */ \n    s.pending_buf_size = s.lit_bufsize * 4;\n    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    //s->pending_buf = (uchf *) overlay;\n    s.pending_buf = new utils.Buf8(s.pending_buf_size);\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s.d_buf = 1 * s.lit_bufsize;\n    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n    s.l_buf = (1 + 2) * s.lit_bufsize;\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n    return deflateReset(strm);\n}\nfunction deflateInit(strm, level) {\n    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\nfunction deflate(strm, flush) {\n    var old_flush, s;\n    var beg, val; // for gzip header write only\n    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n    s.strm = strm; /* just in case */ \n    old_flush = s.last_flush;\n    s.last_flush = flush;\n    /* Write the header */ if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n            put_byte(s, 31);\n            put_byte(s, 139);\n            put_byte(s, 8);\n            if (!s.gzhead) {\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, OS_CODE);\n                s.status = BUSY_STATE;\n            } else {\n                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n                put_byte(s, s.gzhead.time & 0xff);\n                put_byte(s, s.gzhead.time >> 8 & 0xff);\n                put_byte(s, s.gzhead.time >> 16 & 0xff);\n                put_byte(s, s.gzhead.time >> 24 & 0xff);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, s.gzhead.os & 0xff);\n                if (s.gzhead.extra && s.gzhead.extra.length) {\n                    put_byte(s, s.gzhead.extra.length & 0xff);\n                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n                }\n                if (s.gzhead.hcrc) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n                }\n                s.gzindex = 0;\n                s.status = EXTRA_STATE;\n            }\n        } else {\n            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n            var level_flags = -1;\n            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                level_flags = 0;\n            } else if (s.level < 6) {\n                level_flags = 1;\n            } else if (s.level === 6) {\n                level_flags = 2;\n            } else {\n                level_flags = 3;\n            }\n            header |= level_flags << 6;\n            if (s.strstart !== 0) {\n                header |= PRESET_DICT;\n            }\n            header += 31 - header % 31;\n            s.status = BUSY_STATE;\n            putShortMSB(s, header);\n            /* Save the adler32 of the preset dictionary: */ if (s.strstart !== 0) {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n            }\n            strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n    }\n    //#ifdef GZIP\n    if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            while(s.gzindex < (s.gzhead.extra.length & 0xffff)){\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        break;\n                    }\n                }\n                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n                s.gzindex++;\n            }\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (s.gzindex === s.gzhead.extra.length) {\n                s.gzindex = 0;\n                s.status = NAME_STATE;\n            }\n        } else {\n            s.status = NAME_STATE;\n        }\n    }\n    if (s.status === NAME_STATE) {\n        if (s.gzhead.name /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.name.length) {\n                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.gzindex = 0;\n                s.status = COMMENT_STATE;\n            }\n        } else {\n            s.status = COMMENT_STATE;\n        }\n    }\n    if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.comment.length) {\n                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.status = HCRC_STATE;\n            }\n        } else {\n            s.status = HCRC_STATE;\n        }\n    }\n    if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n            if (s.pending + 2 > s.pending_buf_size) {\n                flush_pending(strm);\n            }\n            if (s.pending + 2 <= s.pending_buf_size) {\n                put_byte(s, strm.adler & 0xff);\n                put_byte(s, strm.adler >> 8 & 0xff);\n                strm.adler = 0; //crc32(0L, Z_NULL, 0);\n                s.status = BUSY_STATE;\n            }\n        } else {\n            s.status = BUSY_STATE;\n        }\n    }\n    //#endif\n    /* Flush as much pending output as possible */ if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n            /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */ s.last_flush = -1;\n            return Z_OK;\n        }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */ } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* User must not provide more input after the first FINISH: */ if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* Start a new block or continue the current one.\n   */ if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n            s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n            if (strm.avail_out === 0) {\n                s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */ }\n            return Z_OK;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */ }\n        if (bstate === BS_BLOCK_DONE) {\n            if (flush === Z_PARTIAL_FLUSH) {\n                trees._tr_align(s);\n            } else if (flush !== Z_BLOCK) {\n                trees._tr_stored_block(s, 0, 0, false);\n                /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */ if (flush === Z_FULL_FLUSH) {\n                    /*** CLEAR_HASH(s); ***/ /* forget history */ zero(s.head); // Fill with NIL (= 0);\n                    if (s.lookahead === 0) {\n                        s.strstart = 0;\n                        s.block_start = 0;\n                        s.insert = 0;\n                    }\n                }\n            }\n            flush_pending(strm);\n            if (strm.avail_out === 0) {\n                s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */ \n                return Z_OK;\n            }\n        }\n    }\n    //Assert(strm->avail_out > 0, \"bug2\");\n    //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n    if (flush !== Z_FINISH) {\n        return Z_OK;\n    }\n    if (s.wrap <= 0) {\n        return Z_STREAM_END;\n    }\n    /* Write the trailer */ if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n    } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n    }\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */ if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n    }\n    /* write the trailer only once! */ return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\nfunction deflateEnd(strm) {\n    var status;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    status = strm.state.status;\n    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.state = null;\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */ function deflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var s;\n    var str, n;\n    var wrap;\n    var avail;\n    var next;\n    var input;\n    var tmpDict;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    wrap = s.wrap;\n    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n    }\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */ if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */ strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n    }\n    s.wrap = 0; /* avoid computing Adler-32 in read_buf */ \n    /* if dictionary would fill window, just replace the history */ if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n            /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n        }\n        /* use the tail */ // dictionary = dictionary.slice(dictLength - s.w_size);\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */ avail = strm.avail_in;\n    next = strm.next_in;\n    input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while(s.lookahead >= MIN_MATCH){\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n        }while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK;\n}\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = \"pako deflate (from Nodeca project)\"; /* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLElBQUlBLFFBQVVDLG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlDLFFBQVVELG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlHLFFBQVVILG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlJLE1BQVVKLG1CQUFPQSxDQUFDO0FBRXRCLDhFQUE4RSxHQUM5RSw4RUFBOEUsR0FHOUUsdUVBQXVFLEdBQ3ZFLElBQUlLLGFBQWtCO0FBQ3RCLElBQUlDLGtCQUFrQjtBQUN0QiwwQkFBMEI7QUFDMUIsSUFBSUMsZUFBa0I7QUFDdEIsSUFBSUMsV0FBa0I7QUFDdEIsSUFBSUMsVUFBa0I7QUFDdEIsMEJBQTBCO0FBRzFCOztDQUVDLEdBQ0QsSUFBSUMsT0FBa0I7QUFDdEIsSUFBSUMsZUFBa0I7QUFDdEIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixJQUFJQyxpQkFBa0IsQ0FBQztBQUN2QixJQUFJQyxlQUFrQixDQUFDO0FBQ3ZCLDJCQUEyQjtBQUMzQixJQUFJQyxjQUFrQixDQUFDO0FBQ3ZCLDJCQUEyQjtBQUczQixzQkFBc0IsR0FDdEIsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsSUFBSUMsd0JBQXdCLENBQUM7QUFH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akQ7SUFDZDtJQUNBQSxFQUFFYyxRQUFRLElBQUlkLEVBQUUrQyxTQUFTO0lBQ3pCL0MsRUFBRWEsV0FBVyxHQUFHYixFQUFFYyxRQUFRO0lBQzFCZCxFQUFFMkQsTUFBTSxHQUFHM0QsRUFBRStDLFNBQVM7SUFDdEIvQyxFQUFFK0MsU0FBUyxHQUFHO0lBQ2QvQyxFQUFFdUUsWUFBWSxHQUFHdkUsRUFBRWtDLFdBQVcsR0FBRzVELFlBQVk7SUFDN0MwQixFQUFFK0UsZUFBZSxHQUFHO0lBQ3BCeEYsS0FBS2dDLE9BQU8sR0FBR2lJO0lBQ2ZqSyxLQUFLK0IsS0FBSyxHQUFHQTtJQUNiL0IsS0FBSzhCLFFBQVEsR0FBR2tJO0lBQ2hCdkosRUFBRXdCLElBQUksR0FBR0E7SUFDVCxPQUFPekU7QUFDVDtBQUdBMk0sbUJBQW1CLEdBQUd6QjtBQUN0QnlCLG9CQUFvQixHQUFHN0I7QUFDdkI2QixvQkFBb0IsR0FBR2hDO0FBQ3ZCZ0Msd0JBQXdCLEdBQUduQztBQUMzQm1DLHdCQUF3QixHQUFHOUI7QUFDM0I4QixlQUFlLEdBQUd4QjtBQUNsQndCLGtCQUFrQixHQUFHUDtBQUNyQk8sNEJBQTRCLEdBQUdOO0FBQy9CTSxtQkFBbUIsR0FBRyxzQ0FFdEI7Ozs7Ozs7QUFPQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanM/ODU0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwidHJlZXMiLCJhZGxlcjMyIiwiY3JjMzIiLCJtc2ciLCJaX05PX0ZMVVNIIiwiWl9QQVJUSUFMX0ZMVVNIIiwiWl9GVUxMX0ZMVVNIIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiWl9PSyIsIlpfU1RSRUFNX0VORCIsIlpfU1RSRUFNX0VSUk9SIiwiWl9EQVRBX0VSUk9SIiwiWl9CVUZfRVJST1IiLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0ZJTFRFUkVEIiwiWl9IVUZGTUFOX09OTFkiLCJaX1JMRSIsIlpfRklYRUQiLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX1VOS05PV04iLCJaX0RFRkxBVEVEIiwiTUFYX01FTV9MRVZFTCIsIk1BWF9XQklUUyIsIkRFRl9NRU1fTEVWRUwiLCJMRU5HVEhfQ09ERVMiLCJMSVRFUkFMUyIsIkxfQ09ERVMiLCJEX0NPREVTIiwiQkxfQ09ERVMiLCJIRUFQX1NJWkUiLCJNQVhfQklUUyIsIk1JTl9NQVRDSCIsIk1BWF9NQVRDSCIsIk1JTl9MT09LQUhFQUQiLCJQUkVTRVRfRElDVCIsIklOSVRfU1RBVEUiLCJFWFRSQV9TVEFURSIsIk5BTUVfU1RBVEUiLCJDT01NRU5UX1NUQVRFIiwiSENSQ19TVEFURSIsIkJVU1lfU1RBVEUiLCJGSU5JU0hfU1RBVEUiLCJCU19ORUVEX01PUkUiLCJCU19CTE9DS19ET05FIiwiQlNfRklOSVNIX1NUQVJURUQiLCJCU19GSU5JU0hfRE9ORSIsIk9TX0NPREUiLCJlcnIiLCJzdHJtIiwiZXJyb3JDb2RlIiwicmFuayIsImYiLCJ6ZXJvIiwiYnVmIiwibGVuIiwibGVuZ3RoIiwiZmx1c2hfcGVuZGluZyIsInMiLCJzdGF0ZSIsInBlbmRpbmciLCJhdmFpbF9vdXQiLCJhcnJheVNldCIsIm91dHB1dCIsInBlbmRpbmdfYnVmIiwicGVuZGluZ19vdXQiLCJuZXh0X291dCIsInRvdGFsX291dCIsImZsdXNoX2Jsb2NrX29ubHkiLCJsYXN0IiwiX3RyX2ZsdXNoX2Jsb2NrIiwiYmxvY2tfc3RhcnQiLCJzdHJzdGFydCIsInB1dF9ieXRlIiwiYiIsInB1dFNob3J0TVNCIiwicmVhZF9idWYiLCJzdGFydCIsInNpemUiLCJhdmFpbF9pbiIsImlucHV0IiwibmV4dF9pbiIsIndyYXAiLCJhZGxlciIsInRvdGFsX2luIiwibG9uZ2VzdF9tYXRjaCIsImN1cl9tYXRjaCIsImNoYWluX2xlbmd0aCIsIm1heF9jaGFpbl9sZW5ndGgiLCJzY2FuIiwibWF0Y2giLCJiZXN0X2xlbiIsInByZXZfbGVuZ3RoIiwibmljZV9tYXRjaCIsImxpbWl0Iiwid19zaXplIiwiX3dpbiIsIndpbmRvdyIsIndtYXNrIiwid19tYXNrIiwicHJldiIsInN0cmVuZCIsInNjYW5fZW5kMSIsInNjYW5fZW5kIiwiZ29vZF9tYXRjaCIsImxvb2thaGVhZCIsIm1hdGNoX3N0YXJ0IiwiZmlsbF93aW5kb3ciLCJfd19zaXplIiwicCIsIm4iLCJtIiwibW9yZSIsInN0ciIsIndpbmRvd19zaXplIiwiaGFzaF9zaXplIiwiaGVhZCIsImluc2VydCIsImluc19oIiwiaGFzaF9zaGlmdCIsImhhc2hfbWFzayIsImRlZmxhdGVfc3RvcmVkIiwiZmx1c2giLCJtYXhfYmxvY2tfc2l6ZSIsInBlbmRpbmdfYnVmX3NpemUiLCJtYXhfc3RhcnQiLCJkZWZsYXRlX2Zhc3QiLCJoYXNoX2hlYWQiLCJiZmx1c2giLCJtYXRjaF9sZW5ndGgiLCJfdHJfdGFsbHkiLCJtYXhfbGF6eV9tYXRjaCIsImxhc3RfbGl0IiwiZGVmbGF0ZV9zbG93IiwibWF4X2luc2VydCIsInByZXZfbWF0Y2giLCJzdHJhdGVneSIsIm1hdGNoX2F2YWlsYWJsZSIsImRlZmxhdGVfcmxlIiwiZGVmbGF0ZV9odWZmIiwiQ29uZmlnIiwiZ29vZF9sZW5ndGgiLCJtYXhfbGF6eSIsIm5pY2VfbGVuZ3RoIiwibWF4X2NoYWluIiwiZnVuYyIsImNvbmZpZ3VyYXRpb25fdGFibGUiLCJsbV9pbml0IiwibGV2ZWwiLCJEZWZsYXRlU3RhdGUiLCJzdGF0dXMiLCJnemhlYWQiLCJnemluZGV4IiwibWV0aG9kIiwibGFzdF9mbHVzaCIsIndfYml0cyIsImhhc2hfYml0cyIsImR5bl9sdHJlZSIsIkJ1ZjE2IiwiZHluX2R0cmVlIiwiYmxfdHJlZSIsImxfZGVzYyIsImRfZGVzYyIsImJsX2Rlc2MiLCJibF9jb3VudCIsImhlYXAiLCJoZWFwX2xlbiIsImhlYXBfbWF4IiwiZGVwdGgiLCJsX2J1ZiIsImxpdF9idWZzaXplIiwiZF9idWYiLCJvcHRfbGVuIiwic3RhdGljX2xlbiIsIm1hdGNoZXMiLCJiaV9idWYiLCJiaV92YWxpZCIsImRlZmxhdGVSZXNldEtlZXAiLCJkYXRhX3R5cGUiLCJfdHJfaW5pdCIsImRlZmxhdGVSZXNldCIsInJldCIsImRlZmxhdGVTZXRIZWFkZXIiLCJkZWZsYXRlSW5pdDIiLCJ3aW5kb3dCaXRzIiwibWVtTGV2ZWwiLCJCdWY4IiwiZGVmbGF0ZUluaXQiLCJkZWZsYXRlIiwib2xkX2ZsdXNoIiwiYmVnIiwidmFsIiwidGV4dCIsImhjcmMiLCJleHRyYSIsIm5hbWUiLCJjb21tZW50IiwidGltZSIsIm9zIiwiaGVhZGVyIiwibGV2ZWxfZmxhZ3MiLCJjaGFyQ29kZUF0IiwiYnN0YXRlIiwiX3RyX2FsaWduIiwiX3RyX3N0b3JlZF9ibG9jayIsImRlZmxhdGVFbmQiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsImRpY3Rpb25hcnkiLCJkaWN0TGVuZ3RoIiwiYXZhaWwiLCJuZXh0IiwidG1wRGljdCIsImV4cG9ydHMiLCJkZWZsYXRlSW5mbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction GZheader() {\n    /* true if compressed data believed to be text */ this.text = 0;\n    /* modification time */ this.time = 0;\n    /* extra flags (not used when writing a gzip file) */ this.xflags = 0;\n    /* operating system */ this.os = 0;\n    /* pointer to extra field or Z_NULL if none */ this.extra = null;\n    /* extra field length (valid if extra != Z_NULL) */ this.extra_len = 0; // Actually, we don't need it in JS,\n    // but leave for few code modifications\n    //\n    // Setup limits is not necessary because in js we should not preallocate memory\n    // for inflate use constant limit in 65536 bytes\n    //\n    /* space at extra (only when reading header) */ // this.extra_max  = 0;\n    /* pointer to zero-terminated file name or Z_NULL */ this.name = \"\";\n    /* space at name (only when reading header) */ // this.name_max   = 0;\n    /* pointer to zero-terminated comment or Z_NULL */ this.comment = \"\";\n    /* space at comment (only when reading header) */ // this.comm_max   = 0;\n    /* true if there was or will be a header crc */ this.hcrc = 0;\n    /* true when done reading gzip header (not used when writing a gzip file) */ this.done = false;\n}\nmodule.exports = GZheader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSxTQUFTQTtJQUNQLCtDQUErQyxHQUMvQyxJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQixxQkFBcUIsR0FDckIsSUFBSSxDQUFDQyxJQUFJLEdBQVM7SUFDbEIsbURBQW1ELEdBQ25ELElBQUksQ0FBQ0MsTUFBTSxHQUFPO0lBQ2xCLG9CQUFvQixHQUNwQixJQUFJLENBQUNDLEVBQUUsR0FBVztJQUNsQiw0Q0FBNEMsR0FDNUMsSUFBSSxDQUFDQyxLQUFLLEdBQVE7SUFDbEIsaURBQWlELEdBQ2pELElBQUksQ0FBQ0MsU0FBUyxHQUFJLEdBQUcsb0NBQW9DO0lBQ3BDLHVDQUF1QztJQUU1RCxFQUFFO0lBQ0YsK0VBQStFO0lBQy9FLGdEQUFnRDtJQUNoRCxFQUFFO0lBRUYsNkNBQTZDLEdBQzdDLHVCQUF1QjtJQUN2QixrREFBa0QsR0FDbEQsSUFBSSxDQUFDQyxJQUFJLEdBQVM7SUFDbEIsNENBQTRDLEdBQzVDLHVCQUF1QjtJQUN2QixnREFBZ0QsR0FDaEQsSUFBSSxDQUFDQyxPQUFPLEdBQU07SUFDbEIsK0NBQStDLEdBQy9DLHVCQUF1QjtJQUN2Qiw2Q0FBNkMsR0FDN0MsSUFBSSxDQUFDQyxJQUFJLEdBQVM7SUFDbEIsMEVBQTBFLEdBQzFFLElBQUksQ0FBQ0MsSUFBSSxHQUFTO0FBQ3BCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcz82MzE5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcbiJdLCJuYW1lcyI6WyJHWmhlYWRlciIsInRleHQiLCJ0aW1lIiwieGZsYWdzIiwib3MiLCJleHRyYSIsImV4dHJhX2xlbiIsIm5hbWUiLCJjb21tZW50IiwiaGNyYyIsImRvbmUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/gzheader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// See state defs from inflate.js\nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */ module.exports = function inflate_fast(strm, start) {\n    var state;\n    var _in; /* local strm.input */ \n    var last; /* have enough input while in < last */ \n    var _out; /* local strm.output */ \n    var beg; /* inflate()'s initial strm.output */ \n    var end; /* while out < end, enough space available */ \n    //#ifdef INFLATE_STRICT\n    var dmax; /* maximum distance from zlib header */ \n    //#endif\n    var wsize; /* window size or zero if not using window */ \n    var whave; /* valid bytes in the window */ \n    var wnext; /* window write index */ \n    // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n    var s_window; /* allocated sliding window, if wsize != 0 */ \n    var hold; /* local strm.hold */ \n    var bits; /* local strm.bits */ \n    var lcode; /* local strm.lencode */ \n    var dcode; /* local strm.distcode */ \n    var lmask; /* mask for first level of length codes */ \n    var dmask; /* mask for first level of distance codes */ \n    var here; /* retrieved table entry */ \n    var op; /* code bits, operation, extra bits, or */ \n    /*  window position, window bytes to copy */ var len; /* match length, unused bytes */ \n    var dist; /* match distance */ \n    var from; /* where to copy match from */ \n    var from_source;\n    var input, output; // JS specific, because we have no pointers\n    /* copy state to local variables */ state = strm.state;\n    //here = state.here;\n    _in = strm.next_in;\n    input = strm.input;\n    last = _in + (strm.avail_in - 5);\n    _out = strm.next_out;\n    output = strm.output;\n    beg = _out - (start - strm.avail_out);\n    end = _out + (strm.avail_out - 257);\n    //#ifdef INFLATE_STRICT\n    dmax = state.dmax;\n    //#endif\n    wsize = state.wsize;\n    whave = state.whave;\n    wnext = state.wnext;\n    s_window = state.window;\n    hold = state.hold;\n    bits = state.bits;\n    lcode = state.lencode;\n    dcode = state.distcode;\n    lmask = (1 << state.lenbits) - 1;\n    dmask = (1 << state.distbits) - 1;\n    /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */ top: do {\n        if (bits < 15) {\n            hold += input[_in++] << bits;\n            bits += 8;\n            hold += input[_in++] << bits;\n            bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for(;;){\n            op = here >>> 24 /*here.bits*/ ;\n            hold >>>= op;\n            bits -= op;\n            op = here >>> 16 & 0xff /*here.op*/ ;\n            if (op === 0) {\n                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                //        \"inflate:         literal '%c'\\n\" :\n                //        \"inflate:         literal 0x%02x\\n\", here.val));\n                output[_out++] = here & 0xffff /*here.val*/ ;\n            } else if (op & 16) {\n                len = here & 0xffff /*here.val*/ ;\n                op &= 15; /* number of extra bits */ \n                if (op) {\n                    if (bits < op) {\n                        hold += input[_in++] << bits;\n                        bits += 8;\n                    }\n                    len += hold & (1 << op) - 1;\n                    hold >>>= op;\n                    bits -= op;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n                if (bits < 15) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                }\n                here = dcode[hold & dmask];\n                dodist: for(;;){\n                    op = here >>> 24 /*here.bits*/ ;\n                    hold >>>= op;\n                    bits -= op;\n                    op = here >>> 16 & 0xff /*here.op*/ ;\n                    if (op & 16) {\n                        dist = here & 0xffff /*here.val*/ ;\n                        op &= 15; /* number of extra bits */ \n                        if (bits < op) {\n                            hold += input[_in++] << bits;\n                            bits += 8;\n                            if (bits < op) {\n                                hold += input[_in++] << bits;\n                                bits += 8;\n                            }\n                        }\n                        dist += hold & (1 << op) - 1;\n                        //#ifdef INFLATE_STRICT\n                        if (dist > dmax) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break top;\n                        }\n                        //#endif\n                        hold >>>= op;\n                        bits -= op;\n                        //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                        op = _out - beg; /* max distance in output */ \n                        if (dist > op) {\n                            op = dist - op; /* distance back in window */ \n                            if (op > whave) {\n                                if (state.sane) {\n                                    strm.msg = \"invalid distance too far back\";\n                                    state.mode = BAD;\n                                    break top;\n                                }\n                            // (!) This block is disabled in zlib defaults,\n                            // don't enable it for binary compatibility\n                            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                            //                if (len <= op - whave) {\n                            //                  do {\n                            //                    output[_out++] = 0;\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //                len -= op - whave;\n                            //                do {\n                            //                  output[_out++] = 0;\n                            //                } while (--op > whave);\n                            //                if (op === 0) {\n                            //                  from = _out - dist;\n                            //                  do {\n                            //                    output[_out++] = output[from++];\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //#endif\n                            }\n                            from = 0; // window index\n                            from_source = s_window;\n                            if (wnext === 0) {\n                                from += wsize - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            } else if (wnext < op) {\n                                from += wsize + wnext - op;\n                                op -= wnext;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = 0;\n                                    if (wnext < len) {\n                                        op = wnext;\n                                        len -= op;\n                                        do {\n                                            output[_out++] = s_window[from++];\n                                        }while (--op);\n                                        from = _out - dist; /* rest from output */ \n                                        from_source = output;\n                                    }\n                                }\n                            } else {\n                                from += wnext - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            }\n                            while(len > 2){\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                len -= 3;\n                            }\n                            if (len) {\n                                output[_out++] = from_source[from++];\n                                if (len > 1) {\n                                    output[_out++] = from_source[from++];\n                                }\n                            }\n                        } else {\n                            from = _out - dist; /* copy direct from output */ \n                            do {\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                len -= 3;\n                            }while (len > 2);\n                            if (len) {\n                                output[_out++] = output[from++];\n                                if (len > 1) {\n                                    output[_out++] = output[from++];\n                                }\n                            }\n                        }\n                    } else if ((op & 64) === 0) {\n                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                        continue dodist;\n                    } else {\n                        strm.msg = \"invalid distance code\";\n                        state.mode = BAD;\n                        break top;\n                    }\n                    break; // need to emulate goto via \"continue\"\n                }\n            } else if ((op & 64) === 0) {\n                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                continue dolen;\n            } else if (op & 32) {\n                //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state.mode = TYPE;\n                break top;\n            } else {\n                strm.msg = \"invalid literal/length code\";\n                state.mode = BAD;\n                break top;\n            }\n            break; // need to emulate goto via \"continue\"\n        }\n    }while (_in < last && _out < end);\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */ len = bits >> 3;\n    _in -= len;\n    bits -= len << 3;\n    hold &= (1 << bits) - 1;\n    /* update state and return */ strm.next_in = _in;\n    strm.next_out = _out;\n    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n    state.hold = hold;\n    state.bits = bits;\n    return;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLGlDQUFpQztBQUNqQyxJQUFJQSxNQUFNLElBQVUsK0NBQStDO0FBQ25FLElBQUlDLE9BQU8sSUFBUyxxREFBcUQ7QUFFekU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQ0MsR0FDREMsT0FBT0MsT0FBTyxHQUFHLFNBQVNDLGFBQWFDLElBQUksRUFBRUMsS0FBSztJQUNoRCxJQUFJQztJQUNKLElBQUlDLEtBQXdCLG9CQUFvQjtJQUNoRCxJQUFJQyxNQUF3QixxQ0FBcUM7SUFDakUsSUFBSUMsTUFBd0IscUJBQXFCO0lBQ2pELElBQUlDLEtBQXdCLG1DQUFtQztJQUMvRCxJQUFJQyxLQUF3QiwyQ0FBMkM7SUFDekUsdUJBQXVCO0lBQ3JCLElBQUlDLE1BQXdCLHFDQUFxQztJQUNuRSxRQUFRO0lBQ04sSUFBSUMsT0FBd0IsMkNBQTJDO0lBQ3ZFLElBQUlDLE9BQXdCLDZCQUE2QjtJQUN6RCxJQUFJQyxPQUF3QixzQkFBc0I7SUFDbEQsNkVBQTZFO0lBQzdFLElBQUlDLFVBQXdCLDJDQUEyQztJQUN2RSxJQUFJQyxNQUF3QixtQkFBbUI7SUFDL0MsSUFBSUMsTUFBd0IsbUJBQW1CO0lBQy9DLElBQUlDLE9BQXdCLHNCQUFzQjtJQUNsRCxJQUFJQyxPQUF3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QUFNeUM7b0JBQ1I7b0JBRUEsT0FBTyxzQ0FBc0M7Z0JBQy9DO1lBQ0YsT0FDSyxJQUFJLENBQUNoQixLQUFLLEVBQUMsTUFBTyxHQUFHO2dCQUN4QkQsT0FBT0osS0FBSyxDQUFDLENBQUNJLE9BQU8sTUFBSyxJQUFrQk4sQ0FBQUEsT0FBUSxDQUFDLEtBQUtPLEVBQUMsSUFBSyxDQUFDLEVBQUc7Z0JBQ3BFLFNBQVNpQjtZQUNYLE9BQ0ssSUFBSWpCLEtBQUssSUFBSTtnQkFDaEIsdURBQXVEO2dCQUN2RGxCLE1BQU1zQyxJQUFJLEdBQUc1QztnQkFDYixNQUFNd0M7WUFDUixPQUNLO2dCQUNIcEMsS0FBS3VDLEdBQUcsR0FBRztnQkFDWHJDLE1BQU1zQyxJQUFJLEdBQUc3QztnQkFDYixNQUFNeUM7WUFDUjtZQUVBLE9BQU8sc0NBQXNDO1FBQy9DO0lBQ0YsUUFBU2pDLE1BQU1DLFFBQVFDLE9BQU9FLEtBQUs7SUFFbkMseUVBQXlFLEdBQ3pFYyxNQUFNUCxRQUFRO0lBQ2RYLE9BQU9rQjtJQUNQUCxRQUFRTyxPQUFPO0lBQ2ZSLFFBQVEsQ0FBQyxLQUFLQyxJQUFHLElBQUs7SUFFdEIsMkJBQTJCLEdBQzNCZCxLQUFLMkIsT0FBTyxHQUFHeEI7SUFDZkgsS0FBSzZCLFFBQVEsR0FBR3hCO0lBQ2hCTCxLQUFLNEIsUUFBUSxHQUFJekIsTUFBTUMsT0FBTyxJQUFLQSxDQUFBQSxPQUFPRCxHQUFFLElBQUssSUFBS0EsQ0FBQUEsTUFBTUMsSUFBRztJQUMvREosS0FBSzhCLFNBQVMsR0FBSXpCLE9BQU9FLE1BQU0sTUFBT0EsQ0FBQUEsTUFBTUYsSUFBRyxJQUFLLE1BQU9BLENBQUFBLE9BQU9FLEdBQUU7SUFDcEVMLE1BQU1XLElBQUksR0FBR0E7SUFDYlgsTUFBTVksSUFBSSxHQUFHQTtJQUNiO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzPzhhNjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIl0sIm5hbWVzIjpbIkJBRCIsIlRZUEUiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5mbGF0ZV9mYXN0Iiwic3RybSIsInN0YXJ0Iiwic3RhdGUiLCJfaW4iLCJsYXN0IiwiX291dCIsImJlZyIsImVuZCIsImRtYXgiLCJ3c2l6ZSIsIndoYXZlIiwid25leHQiLCJzX3dpbmRvdyIsImhvbGQiLCJiaXRzIiwibGNvZGUiLCJkY29kZSIsImxtYXNrIiwiZG1hc2siLCJoZXJlIiwib3AiLCJsZW4iLCJkaXN0IiwiZnJvbSIsImZyb21fc291cmNlIiwiaW5wdXQiLCJvdXRwdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJuZXh0X291dCIsImF2YWlsX291dCIsIndpbmRvdyIsImxlbmNvZGUiLCJkaXN0Y29kZSIsImxlbmJpdHMiLCJkaXN0Yml0cyIsInRvcCIsImRvbGVuIiwiZG9kaXN0IiwibXNnIiwibW9kZSIsInNhbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast = __webpack_require__(/*! ./inffast */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js\");\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ //var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\nvar Z_TREES = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/* STATES ====================================================================*/ /* ===========================================================================*/ var HEAD = 1; /* i: waiting for magic header */ \nvar FLAGS = 2; /* i: waiting for method and flags (gzip) */ \nvar TIME = 3; /* i: waiting for modification time (gzip) */ \nvar OS = 4; /* i: waiting for extra flags and operating system (gzip) */ \nvar EXLEN = 5; /* i: waiting for extra length (gzip) */ \nvar EXTRA = 6; /* i: waiting for extra bytes (gzip) */ \nvar NAME = 7; /* i: waiting for end of file name (gzip) */ \nvar COMMENT = 8; /* i: waiting for end of comment (gzip) */ \nvar HCRC = 9; /* i: waiting for header crc (gzip) */ \nvar DICTID = 10; /* i: waiting for dictionary check value */ \nvar DICT = 11; /* waiting for inflateSetDictionary() call */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \nvar TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */ \nvar STORED = 14; /* i: waiting for stored size (length and complement) */ \nvar COPY_ = 15; /* i/o: same as COPY below, but only first time in */ \nvar COPY = 16; /* i/o: waiting for input or output to copy stored block */ \nvar TABLE = 17; /* i: waiting for dynamic block table lengths */ \nvar LENLENS = 18; /* i: waiting for code length code lengths */ \nvar CODELENS = 19; /* i: waiting for length/lit and distance code lengths */ \nvar LEN_ = 20; /* i: same as LEN below, but only first time in */ \nvar LEN = 21; /* i: waiting for length/lit/eob code */ \nvar LENEXT = 22; /* i: waiting for length extra bits */ \nvar DIST = 23; /* i: waiting for distance code */ \nvar DISTEXT = 24; /* i: waiting for distance extra bits */ \nvar MATCH = 25; /* o: waiting for output space to copy string */ \nvar LIT = 26; /* o: waiting for output space to write literal */ \nvar CHECK = 27; /* i: waiting for 32-bit check value */ \nvar LENGTH = 28; /* i: waiting for 32-bit length (gzip) */ \nvar DONE = 29; /* finished check, done -- remain here until reset */ \nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar MEM = 31; /* got an inflate() memory error -- remain here until reset */ \nvar SYNC = 32; /* looking for synchronization bytes to restart inflate() */ \n/* ===========================================================================*/ var ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_WBITS = MAX_WBITS;\nfunction zswap32(q) {\n    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);\n}\nfunction InflateState() {\n    this.mode = 0; /* current inflate mode */ \n    this.last = false; /* true if processing last block */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.havedict = false; /* true if dictionary provided */ \n    this.flags = 0; /* gzip header method and flags (0 if zlib) */ \n    this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */ \n    this.check = 0; /* protected copy of check value */ \n    this.total = 0; /* protected copy of output count */ \n    // TODO: may be {}\n    this.head = null; /* where to save gzip header information */ \n    /* sliding window */ this.wbits = 0; /* log base 2 of requested window size */ \n    this.wsize = 0; /* window size or zero if not using window */ \n    this.whave = 0; /* valid bytes in the window */ \n    this.wnext = 0; /* window write index */ \n    this.window = null; /* allocated sliding window, if needed */ \n    /* bit accumulator */ this.hold = 0; /* input bit accumulator */ \n    this.bits = 0; /* number of bits in \"in\" */ \n    /* for string and stored block copying */ this.length = 0; /* literal or length of data to copy */ \n    this.offset = 0; /* distance back to copy string from */ \n    /* for table and code decoding */ this.extra = 0; /* extra bits needed */ \n    /* fixed and dynamic code tables */ this.lencode = null; /* starting table for length/literal codes */ \n    this.distcode = null; /* starting table for distance codes */ \n    this.lenbits = 0; /* index bits for lencode */ \n    this.distbits = 0; /* index bits for distcode */ \n    /* dynamic table building */ this.ncode = 0; /* number of code length code lengths */ \n    this.nlen = 0; /* number of length code lengths */ \n    this.ndist = 0; /* number of distance code lengths */ \n    this.have = 0; /* number of code lengths in lens[] */ \n    this.next = null; /* next available space in codes[] */ \n    this.lens = new utils.Buf16(320); /* temporary storage for code lengths */ \n    this.work = new utils.Buf16(288); /* work area for code table building */ \n    /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */ //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n    this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */ \n    this.distdyn = null; /* dynamic table for distance codes (JS specific) */ \n    this.sane = 0; /* if false, allow invalid distance too far */ \n    this.back = 0; /* bits back of last unprocessed length/lit */ \n    this.was = 0; /* initial length of match */ \n}\nfunction inflateResetKeep(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    strm.total_in = strm.total_out = state.total = 0;\n    strm.msg = \"\"; /*Z_NULL*/ \n    if (state.wrap) {\n        strm.adler = state.wrap & 1;\n    }\n    state.mode = HEAD;\n    state.last = 0;\n    state.havedict = 0;\n    state.dmax = 32768;\n    state.head = null /*Z_NULL*/ ;\n    state.hold = 0;\n    state.bits = 0;\n    //state.lencode = state.distcode = state.next = state.codes;\n    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n    state.sane = 1;\n    state.back = -1;\n    //Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\nfunction inflateReset(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    state.wsize = 0;\n    state.whave = 0;\n    state.wnext = 0;\n    return inflateResetKeep(strm);\n}\nfunction inflateReset2(strm, windowBits) {\n    var wrap;\n    var state;\n    /* get the state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    /* extract wrap request from windowBits parameter */ if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n            windowBits &= 15;\n        }\n    }\n    /* set number of window bits, free window if different */ if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n    }\n    if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n    }\n    /* update state and reset the rest of it */ state.wrap = wrap;\n    state.wbits = windowBits;\n    return inflateReset(strm);\n}\nfunction inflateInit2(strm, windowBits) {\n    var ret;\n    var state;\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    //strm.msg = Z_NULL;                 /* in case we return an error */\n    state = new InflateState();\n    //if (state === Z_NULL) return Z_MEM_ERROR;\n    //Tracev((stderr, \"inflate: allocated\\n\"));\n    strm.state = state;\n    state.window = null /*Z_NULL*/ ;\n    ret = inflateReset2(strm, windowBits);\n    if (ret !== Z_OK) {\n        strm.state = null /*Z_NULL*/ ;\n    }\n    return ret;\n}\nfunction inflateInit(strm) {\n    return inflateInit2(strm, DEF_WBITS);\n}\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */ var virgin = true;\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\nfunction fixedtables(state) {\n    /* build fixed huffman tables if first call (may not be thread safe) */ if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        /* literal/length table */ sym = 0;\n        while(sym < 144){\n            state.lens[sym++] = 8;\n        }\n        while(sym < 256){\n            state.lens[sym++] = 9;\n        }\n        while(sym < 280){\n            state.lens[sym++] = 7;\n        }\n        while(sym < 288){\n            state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n            bits: 9\n        });\n        /* distance table */ sym = 0;\n        while(sym < 32){\n            state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n            bits: 5\n        });\n        /* do this just once */ virgin = false;\n    }\n    state.lencode = lenfix;\n    state.lenbits = 9;\n    state.distcode = distfix;\n    state.distbits = 5;\n}\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */ function updatewindow(strm, src, end, copy) {\n    var dist;\n    var state = strm.state;\n    /* if it hasn't been done already, allocate space for the window */ if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n    }\n    /* copy state->wsize or less output bytes into the circular window */ if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n    } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n            dist = copy;\n        }\n        //zmemcpy(state->window + state->wnext, end - copy, dist);\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n            //zmemcpy(state->window, end - copy, copy);\n            utils.arraySet(state.window, src, end - copy, copy, 0);\n            state.wnext = copy;\n            state.whave = state.wsize;\n        } else {\n            state.wnext += dist;\n            if (state.wnext === state.wsize) {\n                state.wnext = 0;\n            }\n            if (state.whave < state.wsize) {\n                state.whave += dist;\n            }\n        }\n    }\n    return 0;\n}\nfunction inflate(strm, flush) {\n    var state;\n    var input, output; // input/output buffers\n    var next; /* next input INDEX */ \n    var put; /* next output INDEX */ \n    var have, left; /* available input and output */ \n    var hold; /* bit buffer */ \n    var bits; /* bits in bit buffer */ \n    var _in, _out; /* save starting available input and output */ \n    var copy; /* number of stored or match bytes to copy */ \n    var from; /* where to copy match bytes from */ \n    var from_source;\n    var here = 0; /* current decoding table entry */ \n    var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n    //var last;                   /* parent table entry */\n    var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n    var len; /* length to copy for repeats, bits to drop */ \n    var ret; /* return code */ \n    var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */ \n    var opts;\n    var n; // temporary var for NEED_BITS\n    var order = /* permutation of code lengths */ [\n        16,\n        17,\n        18,\n        0,\n        8,\n        7,\n        9,\n        6,\n        10,\n        5,\n        11,\n        4,\n        12,\n        3,\n        13,\n        2,\n        14,\n        1,\n        15\n    ];\n    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n    } /* skip check */ \n    //--- LOAD() ---\n    put = strm.next_out;\n    output = strm.output;\n    left = strm.avail_out;\n    next = strm.next_in;\n    input = strm.input;\n    have = strm.avail_in;\n    hold = state.hold;\n    bits = state.bits;\n    //---\n    _in = have;\n    _out = left;\n    ret = Z_OK;\n    inf_leave: for(;;){\n        switch(state.mode){\n            case HEAD:\n                if (state.wrap === 0) {\n                    state.mode = TYPEDO;\n                    break;\n                }\n                //=== NEEDBITS(16);\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.wrap & 2 && hold === 0x8b1f) {\n                    state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                    //===//\n                    state.mode = FLAGS;\n                    break;\n                }\n                state.flags = 0; /* expect zlib header */ \n                if (state.head) {\n                    state.head.done = false;\n                }\n                if (!(state.wrap & 1) || /* check if zlib header allowed */ (((hold & 0xff) << 8) + (hold >> 8)) % 31) {\n                    strm.msg = \"incorrect header check\";\n                    state.mode = BAD;\n                    break;\n                }\n                if ((hold & 0x0f) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                len = (hold & 0x0f) + 8;\n                if (state.wbits === 0) {\n                    state.wbits = len;\n                } else if (len > state.wbits) {\n                    strm.msg = \"invalid window size\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.dmax = 1 << len;\n                //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = hold & 0x200 ? DICTID : TYPE;\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                break;\n            case FLAGS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.flags = hold;\n                if ((state.flags & 0xff) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.flags & 0xe000) {\n                    strm.msg = \"unknown header flags set\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.head) {\n                    state.head.text = hold >> 8 & 1;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = TIME;\n            /* falls through */ case TIME:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.time = hold;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC4(state.check, hold)\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    hbuf[2] = hold >>> 16 & 0xff;\n                    hbuf[3] = hold >>> 24 & 0xff;\n                    state.check = crc32(state.check, hbuf, 4, 0);\n                //===\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = OS;\n            /* falls through */ case OS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.xflags = hold & 0xff;\n                    state.head.os = hold >> 8;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = EXLEN;\n            /* falls through */ case EXLEN:\n                if (state.flags & 0x0400) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length = hold;\n                    if (state.head) {\n                        state.head.extra_len = hold;\n                    }\n                    if (state.flags & 0x0200) {\n                        //=== CRC2(state.check, hold);\n                        hbuf[0] = hold & 0xff;\n                        hbuf[1] = hold >>> 8 & 0xff;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                } else if (state.head) {\n                    state.head.extra = null /*Z_NULL*/ ;\n                }\n                state.mode = EXTRA;\n            /* falls through */ case EXTRA:\n                if (state.flags & 0x0400) {\n                    copy = state.length;\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy) {\n                        if (state.head) {\n                            len = state.head.extra_len - state.length;\n                            if (!state.head.extra) {\n                                // Use untyped array for more convenient processing later\n                                state.head.extra = new Array(state.head.extra_len);\n                            }\n                            utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes\n                            // - no need for additional size check\n                            copy, /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/ len);\n                        //zmemcpy(state.head.extra + len, next,\n                        //        len + copy > state.head.extra_max ?\n                        //        state.head.extra_max - len : copy);\n                        }\n                        if (state.flags & 0x0200) {\n                            state.check = crc32(state.check, input, copy, next);\n                        }\n                        have -= copy;\n                        next += copy;\n                        state.length -= copy;\n                    }\n                    if (state.length) {\n                        break inf_leave;\n                    }\n                }\n                state.length = 0;\n                state.mode = NAME;\n            /* falls through */ case NAME:\n                if (state.flags & 0x0800) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        // TODO: 2 or 1 bytes?\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.name_max*/ ) {\n                            state.head.name += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.name = null;\n                }\n                state.length = 0;\n                state.mode = COMMENT;\n            /* falls through */ case COMMENT:\n                if (state.flags & 0x1000) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.comm_max*/ ) {\n                            state.head.comment += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.comment = null;\n                }\n                state.mode = HCRC;\n            /* falls through */ case HCRC:\n                if (state.flags & 0x0200) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.check & 0xffff)) {\n                        strm.msg = \"header crc mismatch\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                }\n                if (state.head) {\n                    state.head.hcrc = state.flags >> 9 & 1;\n                    state.head.done = true;\n                }\n                strm.adler = state.check = 0;\n                state.mode = TYPE;\n                break;\n            case DICTID:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                strm.adler = state.check = zswap32(hold);\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = DICT;\n            /* falls through */ case DICT:\n                if (state.havedict === 0) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    return Z_NEED_DICT;\n                }\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = TYPE;\n            /* falls through */ case TYPE:\n                if (flush === Z_BLOCK || flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case TYPEDO:\n                if (state.last) {\n                    //--- BYTEBITS() ---//\n                    hold >>>= bits & 7;\n                    bits -= bits & 7;\n                    //---//\n                    state.mode = CHECK;\n                    break;\n                }\n                //=== NEEDBITS(3); */\n                while(bits < 3){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.last = hold & 0x01 /*BITS(1)*/ ;\n                //--- DROPBITS(1) ---//\n                hold >>>= 1;\n                bits -= 1;\n                //---//\n                switch(hold & 0x03){\n                    case 0:\n                        /* stored block */ //Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = STORED;\n                        break;\n                    case 1:\n                        /* fixed block */ fixedtables(state);\n                        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = LEN_; /* decode codes */ \n                        if (flush === Z_TREES) {\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                            break inf_leave;\n                        }\n                        break;\n                    case 2:\n                        /* dynamic block */ //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = TABLE;\n                        break;\n                    case 3:\n                        strm.msg = \"invalid block type\";\n                        state.mode = BAD;\n                }\n                //--- DROPBITS(2) ---//\n                hold >>>= 2;\n                bits -= 2;\n                break;\n            case STORED:\n                //--- BYTEBITS() ---// /* go to byte boundary */\n                hold >>>= bits & 7;\n                bits -= bits & 7;\n                //---//\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {\n                    strm.msg = \"invalid stored block lengths\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.length = hold & 0xffff;\n                //Tracev((stderr, \"inflate:       stored length %u\\n\",\n                //        state.length));\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = COPY_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case COPY_:\n                state.mode = COPY;\n            /* falls through */ case COPY:\n                copy = state.length;\n                if (copy) {\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy > left) {\n                        copy = left;\n                    }\n                    if (copy === 0) {\n                        break inf_leave;\n                    }\n                    //--- zmemcpy(put, next, copy); ---\n                    utils.arraySet(output, input, next, copy, put);\n                    //---//\n                    have -= copy;\n                    next += copy;\n                    left -= copy;\n                    put += copy;\n                    state.length -= copy;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       stored end\\n\"));\n                state.mode = TYPE;\n                break;\n            case TABLE:\n                //=== NEEDBITS(14); */\n                while(bits < 14){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.nlen = (hold & 0x1f) + 257;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ndist = (hold & 0x1f) + 1;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ncode = (hold & 0x0f) + 4;\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                //#ifndef PKZIP_BUG_WORKAROUND\n                if (state.nlen > 286 || state.ndist > 30) {\n                    strm.msg = \"too many length or distance symbols\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n                state.have = 0;\n                state.mode = LENLENS;\n            /* falls through */ case LENLENS:\n                while(state.have < state.ncode){\n                    //=== NEEDBITS(3);\n                    while(bits < 3){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.lens[order[state.have++]] = hold & 0x07; //BITS(3);\n                    //--- DROPBITS(3) ---//\n                    hold >>>= 3;\n                    bits -= 3;\n                //---//\n                }\n                while(state.have < 19){\n                    state.lens[order[state.have++]] = 0;\n                }\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                //state.next = state.codes;\n                //state.lencode = state.next;\n                // Switch to use dynamic table\n                state.lencode = state.lendyn;\n                state.lenbits = 7;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n                state.lenbits = opts.bits;\n                if (ret) {\n                    strm.msg = \"invalid code lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n                state.have = 0;\n                state.mode = CODELENS;\n            /* falls through */ case CODELENS:\n                while(state.have < state.nlen + state.ndist){\n                    for(;;){\n                        here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    if (here_val < 16) {\n                        //--- DROPBITS(here.bits) ---//\n                        hold >>>= here_bits;\n                        bits -= here_bits;\n                        //---//\n                        state.lens[state.have++] = here_val;\n                    } else {\n                        if (here_val === 16) {\n                            //=== NEEDBITS(here.bits + 2);\n                            n = here_bits + 2;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            if (state.have === 0) {\n                                strm.msg = \"invalid bit length repeat\";\n                                state.mode = BAD;\n                                break;\n                            }\n                            len = state.lens[state.have - 1];\n                            copy = 3 + (hold & 0x03); //BITS(2);\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                        //---//\n                        } else if (here_val === 17) {\n                            //=== NEEDBITS(here.bits + 3);\n                            n = here_bits + 3;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 3 + (hold & 0x07); //BITS(3);\n                            //--- DROPBITS(3) ---//\n                            hold >>>= 3;\n                            bits -= 3;\n                        //---//\n                        } else {\n                            //=== NEEDBITS(here.bits + 7);\n                            n = here_bits + 7;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 11 + (hold & 0x7f); //BITS(7);\n                            //--- DROPBITS(7) ---//\n                            hold >>>= 7;\n                            bits -= 7;\n                        //---//\n                        }\n                        if (state.have + copy > state.nlen + state.ndist) {\n                            strm.msg = \"invalid bit length repeat\";\n                            state.mode = BAD;\n                            break;\n                        }\n                        while(copy--){\n                            state.lens[state.have++] = len;\n                        }\n                    }\n                }\n                /* handle error breaks in while */ if (state.mode === BAD) {\n                    break;\n                }\n                /* check for end-of-block code (better have one) */ if (state.lens[256] === 0) {\n                    strm.msg = \"invalid code -- missing end-of-block\";\n                    state.mode = BAD;\n                    break;\n                }\n                /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */ state.lenbits = 9;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.lenbits = opts.bits;\n                // state.lencode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid literal/lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.distbits = 6;\n                //state.distcode.copy(state.codes);\n                // Switch to use dynamic table\n                state.distcode = state.distdyn;\n                opts = {\n                    bits: state.distbits\n                };\n                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.distbits = opts.bits;\n                // state.distcode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid distances set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, 'inflate:       codes ok\\n'));\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case LEN_:\n                state.mode = LEN;\n            /* falls through */ case LEN:\n                if (have >= 6 && left >= 258) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    inflate_fast(strm, _out);\n                    //--- LOAD() ---\n                    put = strm.next_out;\n                    output = strm.output;\n                    left = strm.avail_out;\n                    next = strm.next_in;\n                    input = strm.input;\n                    have = strm.avail_in;\n                    hold = state.hold;\n                    bits = state.bits;\n                    //---\n                    if (state.mode === TYPE) {\n                        state.back = -1;\n                    }\n                    break;\n                }\n                state.back = 0;\n                for(;;){\n                    here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if (here_op && (here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                state.length = here_val;\n                if (here_op === 0) {\n                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                    //        \"inflate:         literal '%c'\\n\" :\n                    //        \"inflate:         literal 0x%02x\\n\", here.val));\n                    state.mode = LIT;\n                    break;\n                }\n                if (here_op & 32) {\n                    //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                    state.back = -1;\n                    state.mode = TYPE;\n                    break;\n                }\n                if (here_op & 64) {\n                    strm.msg = \"invalid literal/length code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.extra = here_op & 15;\n                state.mode = LENEXT;\n            /* falls through */ case LENEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n                state.was = state.length;\n                state.mode = DIST;\n            /* falls through */ case DIST:\n                for(;;){\n                    here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if ((here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                if (here_op & 64) {\n                    strm.msg = \"invalid distance code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.offset = here_val;\n                state.extra = here_op & 15;\n                state.mode = DISTEXT;\n            /* falls through */ case DISTEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //#ifdef INFLATE_STRICT\n                if (state.offset > state.dmax) {\n                    strm.msg = \"invalid distance too far back\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n                state.mode = MATCH;\n            /* falls through */ case MATCH:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                copy = _out - left;\n                if (state.offset > copy) {\n                    copy = state.offset - copy;\n                    if (copy > state.whave) {\n                        if (state.sane) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break;\n                        }\n                    // (!) This block is disabled in zlib defaults,\n                    // don't enable it for binary compatibility\n                    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    //          Trace((stderr, \"inflate.c too far\\n\"));\n                    //          copy -= state.whave;\n                    //          if (copy > state.length) { copy = state.length; }\n                    //          if (copy > left) { copy = left; }\n                    //          left -= copy;\n                    //          state.length -= copy;\n                    //          do {\n                    //            output[put++] = 0;\n                    //          } while (--copy);\n                    //          if (state.length === 0) { state.mode = LEN; }\n                    //          break;\n                    //#endif\n                    }\n                    if (copy > state.wnext) {\n                        copy -= state.wnext;\n                        from = state.wsize - copy;\n                    } else {\n                        from = state.wnext - copy;\n                    }\n                    if (copy > state.length) {\n                        copy = state.length;\n                    }\n                    from_source = state.window;\n                } else {\n                    from_source = output;\n                    from = put - state.offset;\n                    copy = state.length;\n                }\n                if (copy > left) {\n                    copy = left;\n                }\n                left -= copy;\n                state.length -= copy;\n                do {\n                    output[put++] = from_source[from++];\n                }while (--copy);\n                if (state.length === 0) {\n                    state.mode = LEN;\n                }\n                break;\n            case LIT:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                output[put++] = state.length;\n                left--;\n                state.mode = LEN;\n                break;\n            case CHECK:\n                if (state.wrap) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        // Use '|' instead of '+' to make sure that result is signed\n                        hold |= input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    _out -= left;\n                    strm.total_out += _out;\n                    state.total += _out;\n                    if (_out) {\n                        strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/ state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                    }\n                    _out = left;\n                    // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                        strm.msg = \"incorrect data check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n                }\n                state.mode = LENGTH;\n            /* falls through */ case LENGTH:\n                if (state.wrap && state.flags) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.total & 0xffffffff)) {\n                        strm.msg = \"incorrect length check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n                }\n                state.mode = DONE;\n            /* falls through */ case DONE:\n                ret = Z_STREAM_END;\n                break inf_leave;\n            case BAD:\n                ret = Z_DATA_ERROR;\n                break inf_leave;\n            case MEM:\n                return Z_MEM_ERROR;\n            case SYNC:\n            /* falls through */ default:\n                return Z_STREAM_ERROR;\n        }\n    }\n    // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n    /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */ //--- RESTORE() ---\n    strm.next_out = put;\n    strm.avail_out = left;\n    strm.next_in = next;\n    strm.avail_in = have;\n    state.hold = hold;\n    state.bits = bits;\n    //---\n    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n            state.mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    }\n    _in -= strm.avail_in;\n    _out -= strm.avail_out;\n    strm.total_in += _in;\n    strm.total_out += _out;\n    state.total += _out;\n    if (state.wrap && _out) {\n        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/ state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n    }\n    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n    }\n    return ret;\n}\nfunction inflateEnd(strm) {\n    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    var state = strm.state;\n    if (state.window) {\n        state.window = null;\n    }\n    strm.state = null;\n    return Z_OK;\n}\nfunction inflateGetHeader(strm, head) {\n    var state;\n    /* check state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n    }\n    /* save header structure */ state.head = head;\n    head.done = false;\n    return Z_OK;\n}\nfunction inflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var state;\n    var dictid;\n    var ret;\n    /* check state */ if (!strm /* == Z_NULL */  || !strm.state /* == Z_NULL */ ) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n    }\n    /* check for correct dictionary identifier */ if (state.mode === DICT) {\n        dictid = 1; /* adler32(0, null, 0)*/ \n        /* dictid = adler32(dictid, dictionary, dictLength); */ dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n            return Z_DATA_ERROR;\n        }\n    }\n    /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */ ret = updatewindow(strm, dictionary, dictLength, dictLength);\n    if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state.havedict = 1;\n    // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = \"pako inflate (from Nodeca project)\"; /* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLElBQUlBLFFBQWdCQyxtQkFBT0EsQ0FBQztBQUM1QixJQUFJQyxVQUFnQkQsbUJBQU9BLENBQUM7QUFDNUIsSUFBSUUsUUFBZ0JGLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlHLGVBQWdCSCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJSSxnQkFBZ0JKLG1CQUFPQSxDQUFDO0FBRTVCLElBQUlLLFFBQVE7QUFDWixJQUFJQyxPQUFPO0FBQ1gsSUFBSUMsUUFBUTtBQUVaLDhFQUE4RSxHQUM5RSw4RUFBOEUsR0FHOUUsdUVBQXVFLEdBQ3ZFLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixJQUFJQyxXQUFrQjtBQUN0QixJQUFJQyxVQUFrQjtBQUN0QixJQUFJQyxVQUFrQjtBQUd0Qjs7Q0FFQyxHQUNELElBQUlDLE9BQWtCO0FBQ3RCLElBQUlDLGVBQWtCO0FBQ3RCLElBQUlDLGNBQWtCO0FBQ3RCLDJCQUEyQjtBQUMzQixJQUFJQyxpQkFBa0IsQ0FBQztBQUN2QixJQUFJQyxlQUFrQixDQUFDO0FBQ3ZCLElBQUlDLGNBQWtCLENBQUM7QUFDdkIsSUFBSUMsY0FBa0IsQ0FBQztBQUN2QiwyQkFBMkI7QUFFM0Isa0NBQWtDLEdBQ2xDLElB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N0IsTUFBTTtRQUMzQyxPQUFPZjtJQUNUO0lBRUEsMkNBQTJDLEdBQzNDLElBQUlrRixNQUFNdEMsSUFBSSxLQUFLN0IsTUFBTTtRQUN2QndJLFNBQVMsR0FBRyxzQkFBc0I7UUFDbEMscURBQXFELEdBQ3JEQSxTQUFTcEssUUFBUW9LLFFBQVFGLFlBQVlDLFlBQVk7UUFDakQsSUFBSUMsV0FBV3JFLE1BQU1oQyxLQUFLLEVBQUU7WUFDMUIsT0FBT2pEO1FBQ1Q7SUFDRjtJQUNBO3NDQUNvQyxHQUNwQzJGLE1BQU1PLGFBQWFsQixNQUFNb0UsWUFBWUMsWUFBWUE7SUFDakQsSUFBSTFELEtBQUs7UUFDUFYsTUFBTXRDLElBQUksR0FBR1Q7UUFDYixPQUFPakM7SUFDVDtJQUNBZ0YsTUFBTW5DLFFBQVEsR0FBRztJQUNqQixtREFBbUQ7SUFDbkQsT0FBT2xEO0FBQ1Q7QUFFQTJKLG9CQUFvQixHQUFHaEU7QUFDdkJnRSxxQkFBcUIsR0FBRy9EO0FBQ3hCK0Qsd0JBQXdCLEdBQUd4RTtBQUMzQndFLG1CQUFtQixHQUFHM0Q7QUFDdEIyRCxvQkFBb0IsR0FBRzdEO0FBQ3ZCNkQsZUFBZSxHQUFHOUM7QUFDbEI4QyxrQkFBa0IsR0FBR047QUFDckJNLHdCQUF3QixHQUFHTDtBQUMzQkssNEJBQTRCLEdBQUdKO0FBQy9CSSxtQkFBbUIsR0FBRyxzQ0FFdEI7Ozs7Ozs7O0FBUUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi9zdGFuZGFyZC1mb250cy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzP2Q3MzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiYWRsZXIzMiIsImNyYzMyIiwiaW5mbGF0ZV9mYXN0IiwiaW5mbGF0ZV90YWJsZSIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiWl9UUkVFUyIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX05FRURfRElDVCIsIlpfU1RSRUFNX0VSUk9SIiwiWl9EQVRBX0VSUk9SIiwiWl9NRU1fRVJST1IiLCJaX0JVRl9FUlJPUiIsIlpfREVGTEFURUQiLCJIRUFEIiwiRkxBR1MiLCJUSU1FIiwiT1MiLCJFWExFTiIsIkVYVFJBIiwiTkFNRSIsIkNPTU1FTlQiLCJIQ1JDIiwiRElDVElEIiwiRElDVCIsIlRZUEUiLCJUWVBFRE8iLCJTVE9SRUQiLCJDT1BZXyIsIkNPUFkiLCJUQUJMRSIsIkxFTkxFTlMiLCJDT0RFTEVOUyIsIkxFTl8iLCJMRU4iLCJMRU5FWFQiLCJESVNUIiwiRElTVEVYVCIsIk1BVENIIiwiTElUIiwiQ0hFQ0siLCJMRU5HVEgiLCJET05FIiwiQkFEIiwiTUVNIiwiU1lOQyIsIkVOT1VHSF9MRU5TIiwiRU5PVUdIX0RJU1RTIiwiTUFYX1dCSVRTIiwiREVGX1dCSVRTIiwienN3YXAzMiIsInEiLCJJbmZsYXRlU3RhdGUiLCJtb2RlIiwibGFzdCIsIndyYXAiLCJoYXZlZGljdCIsImZsYWdzIiwiZG1heCIsImNoZWNrIiwidG90YWwiLCJoZWFkIiwid2JpdHMiLCJ3c2l6ZSIsIndoYXZlIiwid25leHQiLCJ3aW5kb3ciLCJob2xkIiwiYml0cyIsImxlbmd0aCIsIm9mZnNldCIsImV4dHJhIiwibGVuY29kZSIsImRpc3Rjb2RlIiwibGVuYml0cyIsImRpc3RiaXRzIiwibmNvZGUiLCJubGVuIiwibmRpc3QiLCJoYXZlIiwibmV4dCIsImxlbnMiLCJCdWYxNiIsIndvcmsiLCJsZW5keW4iLCJkaXN0ZHluIiwic2FuZSIsImJhY2siLCJ3YXMiLCJpbmZsYXRlUmVzZXRLZWVwIiwic3RybSIsInN0YXRlIiwidG90YWxfaW4iLCJ0b3RhbF9vdXQiLCJtc2ciLCJhZGxlciIsIkJ1ZjMyIiwiaW5mbGF0ZVJlc2V0IiwiaW5mbGF0ZVJlc2V0MiIsIndpbmRvd0JpdHMiLCJpbmZsYXRlSW5pdDIiLCJyZXQiLCJpbmZsYXRlSW5pdCIsInZpcmdpbiIsImxlbmZpeCIsImRpc3RmaXgiLCJmaXhlZHRhYmxlcyIsInN5bSIsInVwZGF0ZXdpbmRvdyIsInNyYyIsImVuZCIsImNvcHkiLCJkaXN0IiwiQnVmOCIsImFycmF5U2V0IiwiaW5mbGF0ZSIsImZsdXNoIiwiaW5wdXQiLCJvdXRwdXQiLCJwdXQiLCJsZWZ0IiwiX2luIiwiX291dCIsImZyb20iLCJmcm9tX3NvdXJjZSIsImhlcmUiLCJoZXJlX2JpdHMiLCJoZXJlX29wIiwiaGVyZV92YWwiLCJsYXN0X2JpdHMiLCJsYXN0X29wIiwibGFzdF92YWwiLCJsZW4iLCJoYnVmIiwib3B0cyIsIm4iLCJvcmRlciIsImF2YWlsX2luIiwibmV4dF9vdXQiLCJhdmFpbF9vdXQiLCJuZXh0X2luIiwiaW5mX2xlYXZlIiwiZG9uZSIsInRleHQiLCJ0aW1lIiwieGZsYWdzIiwib3MiLCJleHRyYV9sZW4iLCJBcnJheSIsIm5hbWUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjb21tZW50IiwiaGNyYyIsImRhdGFfdHlwZSIsImluZmxhdGVFbmQiLCJpbmZsYXRlR2V0SGVhZGVyIiwiaW5mbGF0ZVNldERpY3Rpb25hcnkiLCJkaWN0aW9uYXJ5IiwiZGljdExlbmd0aCIsImRpY3RpZCIsImV4cG9ydHMiLCJpbmZsYXRlSW5mbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar lbase = [\n    /* Length codes 257..285 base */ 3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    13,\n    15,\n    17,\n    19,\n    23,\n    27,\n    31,\n    35,\n    43,\n    51,\n    59,\n    67,\n    83,\n    99,\n    115,\n    131,\n    163,\n    195,\n    227,\n    258,\n    0,\n    0\n];\nvar lext = [\n    /* Length codes 257..285 extra */ 16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    17,\n    17,\n    18,\n    18,\n    18,\n    18,\n    19,\n    19,\n    19,\n    19,\n    20,\n    20,\n    20,\n    20,\n    21,\n    21,\n    21,\n    21,\n    16,\n    72,\n    78\n];\nvar dbase = [\n    /* Distance codes 0..29 base */ 1,\n    2,\n    3,\n    4,\n    5,\n    7,\n    9,\n    13,\n    17,\n    25,\n    33,\n    49,\n    65,\n    97,\n    129,\n    193,\n    257,\n    385,\n    513,\n    769,\n    1025,\n    1537,\n    2049,\n    3073,\n    4097,\n    6145,\n    8193,\n    12289,\n    16385,\n    24577,\n    0,\n    0\n];\nvar dext = [\n    /* Distance codes 0..29 extra */ 16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    18,\n    18,\n    19,\n    19,\n    20,\n    20,\n    21,\n    21,\n    22,\n    22,\n    23,\n    23,\n    24,\n    24,\n    25,\n    25,\n    26,\n    26,\n    27,\n    27,\n    28,\n    28,\n    29,\n    29,\n    64,\n    64\n];\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n    var bits = opts.bits;\n    //here = opts.here; /* table entry for duplication */\n    var len = 0; /* a code's length in bits */ \n    var sym = 0; /* index of code symbols */ \n    var min = 0, max = 0; /* minimum and maximum code lengths */ \n    var root = 0; /* number of index bits for root table */ \n    var curr = 0; /* number of index bits for current table */ \n    var drop = 0; /* code bits to drop for sub-table */ \n    var left = 0; /* number of prefix codes available */ \n    var used = 0; /* code entries in table used */ \n    var huff = 0; /* Huffman code */ \n    var incr; /* for incrementing code, index */ \n    var fill; /* index for replicating entries */ \n    var low; /* low bits for current root entry */ \n    var mask; /* mask for low root bits */ \n    var next; /* next available space in table */ \n    var base = null; /* base value table to use */ \n    var base_index = 0;\n    //  var shoextra;    /* extra bits table to use */\n    var end; /* use base and extra for symbol > end */ \n    var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n    var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n    var extra = null;\n    var extra_index = 0;\n    var here_bits, here_op, here_val;\n    /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */ /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */ for(len = 0; len <= MAXBITS; len++){\n        count[len] = 0;\n    }\n    for(sym = 0; sym < codes; sym++){\n        count[lens[lens_index + sym]]++;\n    }\n    /* bound code lengths, force root to be within code lengths */ root = bits;\n    for(max = MAXBITS; max >= 1; max--){\n        if (count[max] !== 0) {\n            break;\n        }\n    }\n    if (root > max) {\n        root = max;\n    }\n    if (max === 0) {\n        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        //table.op[opts.table_index] = 64;\n        //table.bits[opts.table_index] = 1;\n        //table.val[opts.table_index++] = 0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        opts.bits = 1;\n        return 0; /* no symbols, but wait for decoding to report error */ \n    }\n    for(min = 1; min < max; min++){\n        if (count[min] !== 0) {\n            break;\n        }\n    }\n    if (root < min) {\n        root = min;\n    }\n    /* check for an over-subscribed or incomplete set of lengths */ left = 1;\n    for(len = 1; len <= MAXBITS; len++){\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n            return -1;\n        } /* over-subscribed */ \n    }\n    if (left > 0 && (type === CODES || max !== 1)) {\n        return -1; /* incomplete set */ \n    }\n    /* generate offsets into symbol table for each length for sorting */ offs[1] = 0;\n    for(len = 1; len < MAXBITS; len++){\n        offs[len + 1] = offs[len] + count[len];\n    }\n    /* sort symbols by length, by symbol order within each length */ for(sym = 0; sym < codes; sym++){\n        if (lens[lens_index + sym] !== 0) {\n            work[offs[lens[lens_index + sym]]++] = sym;\n        }\n    }\n    /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */ /* set up for code type */ // poor man optimization - use if-else instead of switch,\n    // to avoid deopts in old v8\n    if (type === CODES) {\n        base = extra = work; /* dummy value--not used */ \n        end = 19;\n    } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n    } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n    /* initialize opts for loop */ huff = 0; /* starting code */ \n    sym = 0; /* starting code symbol */ \n    len = min; /* starting code length */ \n    next = table_index; /* current table to fill in */ \n    curr = root; /* current table index bits */ \n    drop = 0; /* current bits to drop from code for index */ \n    low = -1; /* trigger new sub-table when len > root */ \n    used = 1 << root; /* use root table entries */ \n    mask = used - 1; /* mask for comparing low */ \n    /* check available table space */ if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n        return 1;\n    }\n    /* process all codes and make table entries */ for(;;){\n        /* create table entry */ here_bits = len - drop;\n        if (work[sym] < end) {\n            here_op = 0;\n            here_val = work[sym];\n        } else if (work[sym] > end) {\n            here_op = extra[extra_index + work[sym]];\n            here_val = base[base_index + work[sym]];\n        } else {\n            here_op = 32 + 64; /* end of block */ \n            here_val = 0;\n        }\n        /* replicate for those indices with low len bits equal to huff */ incr = 1 << len - drop;\n        fill = 1 << curr;\n        min = fill; /* save offset to next table */ \n        do {\n            fill -= incr;\n            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        }while (fill !== 0);\n        /* backwards increment the len-bit code huff */ incr = 1 << len - 1;\n        while(huff & incr){\n            incr >>= 1;\n        }\n        if (incr !== 0) {\n            huff &= incr - 1;\n            huff += incr;\n        } else {\n            huff = 0;\n        }\n        /* go to next symbol, update count, len */ sym++;\n        if (--count[len] === 0) {\n            if (len === max) {\n                break;\n            }\n            len = lens[lens_index + work[sym]];\n        }\n        /* create new sub-table if needed */ if (len > root && (huff & mask) !== low) {\n            /* if first time, transition to sub-tables */ if (drop === 0) {\n                drop = root;\n            }\n            /* increment past last table */ next += min; /* here min is 1 << curr */ \n            /* determine length of next table */ curr = len - drop;\n            left = 1 << curr;\n            while(curr + drop < max){\n                left -= count[curr + drop];\n                if (left <= 0) {\n                    break;\n                }\n                curr++;\n                left <<= 1;\n            }\n            /* check for enough space */ used += 1 << curr;\n            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n                return 1;\n            }\n            /* point entry in root table to sub-table */ low = huff & mask;\n            /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/ table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n    }\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */ if (huff !== 0) {\n        //table.op[next + huff] = 64;            /* invalid code marker */\n        //table.bits[next + huff] = len - drop;\n        //table.val[next + huff] = 0;\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n    }\n    /* set return parameters */ //opts.table_index += used;\n    opts.bits = root;\n    return 0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQixJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxlQUFlO0FBQ25CLDBDQUEwQztBQUUxQyxJQUFJQyxRQUFRO0FBQ1osSUFBSUMsT0FBTztBQUNYLElBQUlDLFFBQVE7QUFFWixJQUFJQyxRQUFRO0lBQUUsOEJBQThCLEdBQzFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQ3JEO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBRztDQUM5RDtBQUVELElBQUlDLE9BQU87SUFBRSwrQkFBK0IsR0FDMUM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDNUQ7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0NBQ3pEO0FBRUQsSUFBSUMsUUFBUTtJQUFFLDZCQUE2QixH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QzFDZ0MsTUFBTUgsT0FBT0k7WUFDYjs7K0NBRXlDLEdBQ3pDbEIsS0FBSyxDQUFDaUIsSUFBSSxHQUFHLFFBQVMsS0FBT1AsUUFBUSxLQUFPUyxPQUFPbEIsY0FBYztRQUNuRTtJQUNGO0lBRUE7O29FQUVrRSxHQUNsRSxJQUFJYSxTQUFTLEdBQUc7UUFDZCxrRUFBa0U7UUFDbEUsdUNBQXVDO1FBQ3ZDLDZCQUE2QjtRQUM3QmQsS0FBSyxDQUFDbUIsT0FBT0wsS0FBSyxHQUFHLE1BQVFILFFBQVMsS0FBTyxNQUFNLEtBQUs7SUFDMUQ7SUFFQSx5QkFBeUIsR0FDekIsMkJBQTJCO0lBQzNCUixLQUFLQyxJQUFJLEdBQUdLO0lBQ1osT0FBTztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanM/ZTQxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiTUFYQklUUyIsIkVOT1VHSF9MRU5TIiwiRU5PVUdIX0RJU1RTIiwiQ09ERVMiLCJMRU5TIiwiRElTVFMiLCJsYmFzZSIsImxleHQiLCJkYmFzZSIsImRleHQiLCJtb2R1bGUiLCJleHBvcnRzIiwiaW5mbGF0ZV90YWJsZSIsInR5cGUiLCJsZW5zIiwibGVuc19pbmRleCIsImNvZGVzIiwidGFibGUiLCJ0YWJsZV9pbmRleCIsIndvcmsiLCJvcHRzIiwiYml0cyIsImxlbiIsInN5bSIsIm1pbiIsIm1heCIsInJvb3QiLCJjdXJyIiwiZHJvcCIsImxlZnQiLCJ1c2VkIiwiaHVmZiIsImluY3IiLCJmaWxsIiwibG93IiwibWFzayIsIm5leHQiLCJiYXNlIiwiYmFzZV9pbmRleCIsImVuZCIsImNvdW50IiwiQnVmMTYiLCJvZmZzIiwiZXh0cmEiLCJleHRyYV9pbmRleCIsImhlcmVfYml0cyIsImhlcmVfb3AiLCJoZXJlX3ZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/inftrees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js ***!
  \*************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    2: \"need dictionary\",\n    /* Z_NEED_DICT       2  */ 1: \"stream end\",\n    /* Z_STREAM_END      1  */ 0: \"\",\n    /* Z_OK              0  */ \"-1\": \"file error\",\n    /* Z_ERRNO         (-1) */ \"-2\": \"stream error\",\n    /* Z_STREAM_ERROR  (-2) */ \"-3\": \"data error\",\n    /* Z_DATA_ERROR    (-3) */ \"-4\": \"insufficient memory\",\n    /* Z_MEM_ERROR     (-4) */ \"-5\": \"buffer error\",\n    /* Z_BUF_ERROR     (-5) */ \"-6\": \"incompatible version\" /* Z_VERSION_ERROR (-6) */ \n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RUEsT0FBT0MsT0FBTyxHQUFHO0lBQ2YsR0FBUTtJQUF1Qix3QkFBd0IsR0FDdkQsR0FBUTtJQUF1Qix3QkFBd0IsR0FDdkQsR0FBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUTtJQUF1Qix3QkFBd0IsR0FDdkQsTUFBUSx1QkFBdUIsd0JBQXdCO0FBQ3pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanM/YWFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n/* eslint-disable space-unary-ops */ var utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/utils/common.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ //var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n/* Possible values of the data_type field (though see inflate()) */ var Z_BINARY = 0;\nvar Z_TEXT = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/*============================================================================*/ function zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n// From zutil.h\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\n/* The three kinds of block type */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\n/* The minimum and maximum match lengths */ // From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */ var LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var Buf_size = 16;\n/* size of bit buffer in bi_buf */ /* ===========================================================================\n * Constants\n */ var MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */ var END_BLOCK = 256;\n/* end of block literal code */ var REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */ var REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */ var REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */ /* eslint-disable comma-spacing,array-bracket-spacing */ var extra_lbits = /* extra bits for each length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0\n];\nvar extra_dbits = /* extra bits for each distance code */ [\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13\n];\nvar extra_blbits = /* extra bits for each bit length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    3,\n    7\n];\nvar bl_order = [\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n];\n/* eslint-enable comma-spacing,array-bracket-spacing */ /* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */ /* ===========================================================================\n * Local data. These are initialized only once.\n */ // We pre-fill arrays with 0 to avoid uninitialized gaps\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */ \n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */ var static_dtree = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */ var _dist_code = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */ var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */ var base_length = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */ var base_dist = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */ function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n    this.static_tree = static_tree; /* static tree or NULL */ \n    this.extra_bits = extra_bits; /* extra bits for each code or NULL */ \n    this.extra_base = extra_base; /* base index for extra_bits */ \n    this.elems = elems; /* max number of elements in the tree */ \n    this.max_length = max_length; /* max bit length for the codes */ \n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree = static_tree && static_tree.length;\n}\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\nfunction TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree; /* the dynamic tree */ \n    this.max_code = 0; /* largest code with non zero frequency */ \n    this.stat_desc = stat_desc; /* the corresponding static tree */ \n}\nfunction d_code(dist) {\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */ function put_short(s, w) {\n    //    put_byte(s, (uch)((w) & 0xff));\n    //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = w & 0xff;\n    s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */ function send_bits(s, value, length) {\n    if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n    } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n    }\n}\nfunction send_code(s, c, tree) {\n    send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n}\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */ function bi_reverse(code, len) {\n    var res = 0;\n    do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n    }while (--len > 0);\n    return res >>> 1;\n}\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */ function bi_flush(s) {\n    if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n    } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n    }\n}\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */ function gen_bitlen(s, desc) //    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var max_code = desc.max_code;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var extra = desc.stat_desc.extra_bits;\n    var base = desc.stat_desc.extra_base;\n    var max_length = desc.stat_desc.max_length;\n    var h; /* heap index */ \n    var n, m; /* iterate over the tree elements */ \n    var bits; /* bit length */ \n    var xbits; /* extra bits */ \n    var f; /* frequency */ \n    var overflow = 0; /* number of elements with bit length too large */ \n    for(bits = 0; bits <= MAX_BITS; bits++){\n        s.bl_count[bits] = 0;\n    }\n    /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */ tree[s.heap[s.heap_max] * 2 + 1] = 0; /* root of the heap */ \n    for(h = s.heap_max + 1; h < HEAP_SIZE; h++){\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n            bits = max_length;\n            overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        /* We overwrite tree[n].Dad which is no longer needed */ if (n > max_code) {\n            continue;\n        } /* not a leaf node */ \n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n            xbits = extra[n - base];\n        }\n        f = tree[n * 2] /*.Freq*/ ;\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n            s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n    }\n    if (overflow === 0) {\n        return;\n    }\n    // Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */ /* Find the first bit length which could increase: */ do {\n        bits = max_length - 1;\n        while(s.bl_count[bits] === 0){\n            bits--;\n        }\n        s.bl_count[bits]--; /* move one leaf down the tree */ \n        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */ \n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */ overflow -= 2;\n    }while (overflow > 0);\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */ for(bits = max_length; bits !== 0; bits--){\n        n = s.bl_count[bits];\n        while(n !== 0){\n            m = s.heap[--h];\n            if (m > max_code) {\n                continue;\n            }\n            if (tree[m * 2 + 1] !== bits) {\n                // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2] /*.Freq*/ ;\n                tree[m * 2 + 1] = bits;\n            }\n            n--;\n        }\n    }\n}\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */ function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n    var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */ \n    var code = 0; /* running code value */ \n    var bits; /* bit index */ \n    var n; /* code index */ \n    /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */ for(bits = 1; bits <= MAX_BITS; bits++){\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */ //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n    for(n = 0; n <= max_code; n++){\n        var len = tree[n * 2 + 1] /*.Len*/ ;\n        if (len === 0) {\n            continue;\n        }\n        /* Now reverse the bits */ tree[n * 2] = bi_reverse(next_code[len]++, len);\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n}\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */ function tr_static_init() {\n    var n; /* iterates over tree elements */ \n    var bits; /* bit counter */ \n    var length; /* length value */ \n    var code; /* code value */ \n    var dist; /* distance index */ \n    var bl_count = new Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ // do check in _tr_init()\n    //if (static_init_done) return;\n    /* For some embedded targets, global variables are not initialized: */ /*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/ /* Initialize the mapping length (0..255) -> length code (0..28) */ length = 0;\n    for(code = 0; code < LENGTH_CODES - 1; code++){\n        base_length[code] = length;\n        for(n = 0; n < 1 << extra_lbits[code]; n++){\n            _length_code[length++] = code;\n        }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */ _length_code[length - 1] = code;\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */ dist = 0;\n    for(code = 0; code < 16; code++){\n        base_dist[code] = dist;\n        for(n = 0; n < 1 << extra_dbits[code]; n++){\n            _dist_code[dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */ \n    for(; code < D_CODES; code++){\n        base_dist[code] = dist << 7;\n        for(n = 0; n < 1 << extra_dbits[code] - 7; n++){\n            _dist_code[256 + dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n    /* Construct the codes of the static literal tree */ for(bits = 0; bits <= MAX_BITS; bits++){\n        bl_count[bits] = 0;\n    }\n    n = 0;\n    while(n <= 143){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    while(n <= 255){\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n    }\n    while(n <= 279){\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n    }\n    while(n <= 287){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */ gen_codes(static_ltree, L_CODES + 1, bl_count);\n    /* The static distance tree is trivial: */ for(n = 0; n < D_CODES; n++){\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n    }\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n//static_init_done = true;\n}\n/* ===========================================================================\n * Initialize a new block.\n */ function init_block(s) {\n    var n; /* iterates over tree elements */ \n    /* Initialize the trees. */ for(n = 0; n < L_CODES; n++){\n        s.dyn_ltree[n * 2] = 0;\n    }\n    for(n = 0; n < D_CODES; n++){\n        s.dyn_dtree[n * 2] = 0;\n    }\n    for(n = 0; n < BL_CODES; n++){\n        s.bl_tree[n * 2] = 0;\n    }\n    s.dyn_ltree[END_BLOCK * 2] = 1;\n    s.opt_len = s.static_len = 0;\n    s.last_lit = s.matches = 0;\n}\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */ function bi_windup(s) {\n    if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n        //put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n}\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */ function copy_block(s, buf, len, header) //DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n    bi_windup(s); /* align on byte boundary */ \n    if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n    }\n    //  while (len--) {\n    //    put_byte(s, *buf++);\n    //  }\n    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n    s.pending += len;\n}\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */ function smaller(tree, n, m, depth) {\n    var _n2 = n * 2;\n    var _m2 = m * 2;\n    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n}\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */ function pqdownheap(s, tree, k) //    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n    var v = s.heap[k];\n    var j = k << 1; /* left son of k */ \n    while(j <= s.heap_len){\n        /* Set j to the smallest of the two sons: */ if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */ if (smaller(tree, v, s.heap[j], s.depth)) {\n            break;\n        }\n        /* Exchange v with the smallest son */ s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */ j <<= 1;\n    }\n    s.heap[k] = v;\n}\n// inlined manually\n// var SMALLEST = 1;\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */ function compress_block(s, ltree, dtree) //    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n    var dist; /* distance of matched string */ \n    var lc; /* match length or unmatched char (if dist == 0) */ \n    var lx = 0; /* running index in l_buf */ \n    var code; /* the code to send */ \n    var extra; /* number of extra bits to send */ \n    if (s.last_lit !== 0) {\n        do {\n            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n            lc = s.pending_buf[s.l_buf + lx];\n            lx++;\n            if (dist === 0) {\n                send_code(s, lc, ltree); /* send a literal byte */ \n            //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n            } else {\n                /* Here, lc is the match length - MIN_MATCH */ code = _length_code[lc];\n                send_code(s, code + LITERALS + 1, ltree); /* send the length code */ \n                extra = extra_lbits[code];\n                if (extra !== 0) {\n                    lc -= base_length[code];\n                    send_bits(s, lc, extra); /* send the extra length bits */ \n                }\n                dist--; /* dist is now the match distance - 1 */ \n                code = d_code(dist);\n                //Assert (code < D_CODES, \"bad d_code\");\n                send_code(s, code, dtree); /* send the distance code */ \n                extra = extra_dbits[code];\n                if (extra !== 0) {\n                    dist -= base_dist[code];\n                    send_bits(s, dist, extra); /* send the extra distance bits */ \n                }\n            } /* literal or match pair ? */ \n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */ //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n        //       \"pendingBuf overflow\");\n        }while (lx < s.last_lit);\n    }\n    send_code(s, END_BLOCK, ltree);\n}\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */ function build_tree(s, desc) //    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var elems = desc.stat_desc.elems;\n    var n, m; /* iterate over heap elements */ \n    var max_code = -1; /* largest code with non zero frequency */ \n    var node; /* new node being created */ \n    /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */ s.heap_len = 0;\n    s.heap_max = HEAP_SIZE;\n    for(n = 0; n < elems; n++){\n        if (tree[n * 2] !== 0) {\n            s.heap[++s.heap_len] = max_code = n;\n            s.depth[n] = 0;\n        } else {\n            tree[n * 2 + 1] = 0;\n        }\n    }\n    /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */ while(s.heap_len < 2){\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n            s.static_len -= stree[node * 2 + 1] /*.Len*/ ;\n        }\n    /* node is 0 or 1 so it does not have extra bits */ }\n    desc.max_code = max_code;\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */ for(n = s.heap_len >> 1 /*int /2*/ ; n >= 1; n--){\n        pqdownheap(s, tree, n);\n    }\n    /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */ node = elems; /* next internal node of the tree */ \n    do {\n        //pqremove(s, tree, n);  /* n = node of least frequency */\n        /*** pqremove ***/ n = s.heap[1 /*SMALLEST*/ ];\n        s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n        /***/ m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */ \n        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */ \n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */ tree[node * 2] = tree[n * 2] + tree[m * 2] /*.Freq*/ ;\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        /* and insert the new node in the heap */ s.heap[1 /*SMALLEST*/ ] = node++;\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n    }while (s.heap_len >= 2);\n    s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];\n    /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */ gen_bitlen(s, desc);\n    /* The field len is now set, we can generate the bit codes */ gen_codes(tree, max_code, s.bl_count);\n}\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */ function scan_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1] = 0xffff; /* guard */ \n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                s.bl_tree[curlen * 2]++;\n            }\n            s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n            s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n            s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */ function send_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    /* tree[max_code+1].Len = -1; */ /* guard already set */ if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do {\n                send_code(s, curlen, s.bl_tree);\n            }while (--count !== 0);\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                send_code(s, curlen, s.bl_tree);\n                count--;\n            }\n            //Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s.bl_tree);\n            send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s.bl_tree);\n            send_bits(s, count - 3, 3);\n        } else {\n            send_code(s, REPZ_11_138, s.bl_tree);\n            send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */ function build_bl_tree(s) {\n    var max_blindex; /* index of last bit length code of non zero freq */ \n    /* Determine the bit length frequencies for literal and distance trees */ scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n    /* Build the bit length tree: */ build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */ /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */ for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n            break;\n        }\n    }\n    /* Update opt_len to include the bit length tree and counts */ s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n    return max_blindex;\n}\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */ function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    var rank; /* index in bl_order */ \n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */ \n    send_bits(s, dcodes - 1, 5);\n    send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */ \n    for(rank = 0; rank < blcodes; rank++){\n        //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */ \n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */ \n//Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */ function detect_data_type(s) {\n    /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */ var black_mask = 0xf3ffc07f;\n    var n;\n    /* Check for non-textual (\"black-listed\") bytes. */ for(n = 0; n <= 31; n++, black_mask >>>= 1){\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n            return Z_BINARY;\n        }\n    }\n    /* Check for textual (\"white-listed\") bytes. */ if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n    }\n    for(n = 32; n < LITERALS; n++){\n        if (s.dyn_ltree[n * 2] !== 0) {\n            return Z_TEXT;\n        }\n    }\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */ return Z_BINARY;\n}\nvar static_init_done = false;\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */ function _tr_init(s) {\n    if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n    }\n    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n    /* Initialize the first block of the first file: */ init_block(s);\n}\n/* ===========================================================================\n * Send a stored block\n */ function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */ \n    copy_block(s, buf, stored_len, true); /* with header */ \n}\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */ function _tr_align(s) {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n}\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */ function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    var opt_lenb, static_lenb; /* opt_len and static_len in bytes */ \n    var max_blindex = 0; /* index of last bit length code of non zero freq */ \n    /* Build the Huffman trees unless a stored block is forced */ if (s.level > 0) {\n        /* Check if the file is binary or text */ if (s.strm.data_type === Z_UNKNOWN) {\n            s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */ build_tree(s, s.l_desc);\n        // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        build_tree(s, s.d_desc);\n        // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */ /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */ max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */ opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3;\n        // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n        if (static_lenb <= opt_lenb) {\n            opt_lenb = static_lenb;\n        }\n    } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */ \n    }\n    if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */ /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */ _tr_stored_block(s, buf, stored_len, last);\n    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n    } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */ init_block(s);\n    if (last) {\n        bi_windup(s);\n    }\n// Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n//       s->compressed_len-7*last));\n}\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */ function _tr_tally(s, dist, lc) //    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    //var out_length, in_length, dcode;\n    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n    s.last_lit++;\n    if (dist === 0) {\n        /* lc is the unmatched char */ s.dyn_ltree[lc * 2]++;\n    } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */ dist--; /* dist = match distance - 1 */ \n        //Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n    }\n    // (!) This block is disabled in zlib defaults,\n    // don't enable it for binary compatibility\n    //#ifdef TRUNCATE_BLOCK\n    //  /* Try to guess if it is profitable to stop the current block here */\n    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n    //    /* Compute an upper bound for the compressed length */\n    //    out_length = s.last_lit*8;\n    //    in_length = s.strstart - s.block_start;\n    //\n    //    for (dcode = 0; dcode < D_CODES; dcode++) {\n    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n    //    }\n    //    out_length >>>= 3;\n    //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n    //    //       s->last_lit, in_length, out_length,\n    //    //       100L - out_length*100L/in_length));\n    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n    //      return true;\n    //    }\n    //  }\n    //#endif\n    return s.last_lit === s.lit_bufsize - 1;\n/* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */ }\nexports._tr_init = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RSxrQ0FBa0MsR0FFbEMsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFFcEIsOEVBQThFLEdBQzlFLDhFQUE4RSxHQUc5RSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QixJQUFJQyxVQUF3QjtBQUM1Qiw4QkFBOEI7QUFFOUIsaUVBQWlFLEdBQ2pFLElBQUlDLFdBQXdCO0FBQzVCLElBQUlDLFNBQXdCO0FBQzVCLDBDQUEwQztBQUMxQyxJQUFJQyxZQUF3QjtBQUU1Qiw4RUFBOEUsR0FHOUUsU0FBU0MsS0FBS0MsR0FBRztJQUFJLElBQUlDLE1BQU1ELElBQUlFLE1BQU07SUFBRSxNQUFPLEVBQUVELE9BQU8sRUFBRztRQUFFRCxHQUFHLENBQUNDLElBQUksR0FBRztJQUFHO0FBQUU7QUFFaEYsZUFBZTtBQUVmLElBQUlFLGVBQWU7QUFDbkIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQyxZQUFlO0FBQ25CLGlDQUFpQyxHQUVqQyxJQUFJQyxZQUFlO0FBQ25CLElBQUlDLFlBQWU7QUFDbkIseUNBQXlDLEdBRXpDLGlCQUFpQjtBQUNqQjs7Q0FFQyxHQUVELElBQUlDLGVBQWdCO0FBQ3BCLG1FQUFtRSxHQUVuRSxJQUFJQyxXQUFnQjtBQUNwQixrQ0FBa0MsR0FF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T0FBTztJQUNQLHdCQUF3QjtJQUN4QixpRUFBaUU7SUFDakUsa0RBQWtEO0lBQ2xELGtEQUFrRDtJQUNsRCwyRkFBMkY7SUFDM0Ysb0JBQW9CO0lBQ3BCLE9BQU87SUFDUCxLQUFLO0lBQ0wsUUFBUTtJQUVOLE9BQVFFLEVBQUV1QyxRQUFRLEtBQUt2QyxFQUFFa0csV0FBVyxHQUFHO0FBQ3ZDOzs7R0FHQyxHQUNIO0FBRUFDLGdCQUFnQixHQUFJZDtBQUNwQmMsd0JBQXdCLEdBQUdiO0FBQzNCYSx1QkFBdUIsR0FBSVQ7QUFDM0JTLGlCQUFpQixHQUFHRjtBQUNwQkUsaUJBQWlCLEdBQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanM/Zjg2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiJdLCJuYW1lcyI6WyJ1dGlscyIsInJlcXVpcmUiLCJaX0ZJWEVEIiwiWl9CSU5BUlkiLCJaX1RFWFQiLCJaX1VOS05PV04iLCJ6ZXJvIiwiYnVmIiwibGVuIiwibGVuZ3RoIiwiU1RPUkVEX0JMT0NLIiwiU1RBVElDX1RSRUVTIiwiRFlOX1RSRUVTIiwiTUlOX01BVENIIiwiTUFYX01BVENIIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJCdWZfc2l6ZSIsIk1BWF9CTF9CSVRTIiwiRU5EX0JMT0NLIiwiUkVQXzNfNiIsIlJFUFpfM18xMCIsIlJFUFpfMTFfMTM4IiwiZXh0cmFfbGJpdHMiLCJleHRyYV9kYml0cyIsImV4dHJhX2JsYml0cyIsImJsX29yZGVyIiwiRElTVF9DT0RFX0xFTiIsInN0YXRpY19sdHJlZSIsIkFycmF5Iiwic3RhdGljX2R0cmVlIiwiX2Rpc3RfY29kZSIsIl9sZW5ndGhfY29kZSIsImJhc2VfbGVuZ3RoIiwiYmFzZV9kaXN0IiwiU3RhdGljVHJlZURlc2MiLCJzdGF0aWNfdHJlZSIsImV4dHJhX2JpdHMiLCJleHRyYV9iYXNlIiwiZWxlbXMiLCJtYXhfbGVuZ3RoIiwiaGFzX3N0cmVlIiwic3RhdGljX2xfZGVzYyIsInN0YXRpY19kX2Rlc2MiLCJzdGF0aWNfYmxfZGVzYyIsIlRyZWVEZXNjIiwiZHluX3RyZWUiLCJzdGF0X2Rlc2MiLCJtYXhfY29kZSIsImRfY29kZSIsImRpc3QiLCJwdXRfc2hvcnQiLCJzIiwidyIsInBlbmRpbmdfYnVmIiwicGVuZGluZyIsInNlbmRfYml0cyIsInZhbHVlIiwiYmlfdmFsaWQiLCJiaV9idWYiLCJzZW5kX2NvZGUiLCJjIiwidHJlZSIsImJpX3JldmVyc2UiLCJjb2RlIiwicmVzIiwiYmlfZmx1c2giLCJnZW5fYml0bGVuIiwiZGVzYyIsInN0cmVlIiwiZXh0cmEiLCJiYXNlIiwiaCIsIm4iLCJtIiwiYml0cyIsInhiaXRzIiwiZiIsIm92ZXJmbG93IiwiYmxfY291bnQiLCJoZWFwIiwiaGVhcF9tYXgiLCJvcHRfbGVuIiwic3RhdGljX2xlbiIsImdlbl9jb2RlcyIsIm5leHRfY29kZSIsInRyX3N0YXRpY19pbml0IiwiaW5pdF9ibG9jayIsImR5bl9sdHJlZSIsImR5bl9kdHJlZSIsImJsX3RyZWUiLCJsYXN0X2xpdCIsIm1hdGNoZXMiLCJiaV93aW5kdXAiLCJjb3B5X2Jsb2NrIiwiaGVhZGVyIiwiYXJyYXlTZXQiLCJ3aW5kb3ciLCJzbWFsbGVyIiwiZGVwdGgiLCJfbjIiLCJfbTIiLCJwcWRvd25oZWFwIiwiayIsInYiLCJqIiwiaGVhcF9sZW4iLCJjb21wcmVzc19ibG9jayIsImx0cmVlIiwiZHRyZWUiLCJsYyIsImx4IiwiZF9idWYiLCJsX2J1ZiIsImJ1aWxkX3RyZWUiLCJub2RlIiwic2Nhbl90cmVlIiwicHJldmxlbiIsImN1cmxlbiIsIm5leHRsZW4iLCJjb3VudCIsIm1heF9jb3VudCIsIm1pbl9jb3VudCIsInNlbmRfdHJlZSIsImJ1aWxkX2JsX3RyZWUiLCJtYXhfYmxpbmRleCIsImxfZGVzYyIsImRfZGVzYyIsImJsX2Rlc2MiLCJzZW5kX2FsbF90cmVlcyIsImxjb2RlcyIsImRjb2RlcyIsImJsY29kZXMiLCJyYW5rIiwiZGV0ZWN0X2RhdGFfdHlwZSIsImJsYWNrX21hc2siLCJzdGF0aWNfaW5pdF9kb25lIiwiX3RyX2luaXQiLCJfdHJfc3RvcmVkX2Jsb2NrIiwic3RvcmVkX2xlbiIsImxhc3QiLCJfdHJfYWxpZ24iLCJfdHJfZmx1c2hfYmxvY2siLCJvcHRfbGVuYiIsInN0YXRpY19sZW5iIiwibGV2ZWwiLCJzdHJtIiwiZGF0YV90eXBlIiwic3RyYXRlZ3kiLCJfdHJfdGFsbHkiLCJsaXRfYnVmc2l6ZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction ZStream() {\n    /* next input byte */ this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */ this.avail_in = 0;\n    /* total number of input bytes read so far */ this.total_in = 0;\n    /* next output byte should be put there */ this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */ this.avail_out = 0;\n    /* total number of bytes output so far */ this.total_out = 0;\n    /* last error message, NULL if no error */ this.msg = \"\" /*Z_NULL*/ ;\n    /* not visible by applications */ this.state = null;\n    /* best guess about the data type: binary or text */ this.data_type = 2 /*Z_UNKNOWN*/ ;\n    /* adler32 value of the uncompressed data */ this.adler = 0;\n}\nmodule.exports = ZStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvc3RhbmRhcmQtZm9udHMvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLFNBQVNBO0lBQ1AsbUJBQW1CLEdBQ25CLElBQUksQ0FBQ0MsS0FBSyxHQUFHLE1BQU0sMkNBQTJDO0lBQzlELElBQUksQ0FBQ0MsT0FBTyxHQUFHO0lBQ2Ysc0NBQXNDLEdBQ3RDLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLDJDQUEyQyxHQUMzQyxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQix3Q0FBd0MsR0FDeEMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsTUFBTSwyQ0FBMkM7SUFDL0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsa0NBQWtDLEdBQ2xDLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLHVDQUF1QyxHQUN2QyxJQUFJLENBQUNDLFNBQVMsR0FBRztJQUNqQix3Q0FBd0MsR0FDeEMsSUFBSSxDQUFDQyxHQUFHLEdBQUcsR0FBRSxRQUFRO0lBQ3JCLCtCQUErQixHQUMvQixJQUFJLENBQUNDLEtBQUssR0FBRztJQUNiLGtEQUFrRCxHQUNsRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxFQUFDLFdBQVc7SUFDN0IsMENBQTBDLEdBQzFDLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0FBQ2Y7QUFFQUMsT0FBT0MsT0FBTyxHQUFHZCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3N0YW5kYXJkLWZvbnRzL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanM/YzU4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIl0sIm5hbWVzIjpbIlpTdHJlYW0iLCJpbnB1dCIsIm5leHRfaW4iLCJhdmFpbF9pbiIsInRvdGFsX2luIiwib3V0cHV0IiwibmV4dF9vdXQiLCJhdmFpbF9vdXQiLCJ0b3RhbF9vdXQiLCJtc2ciLCJzdGF0ZSIsImRhdGFfdHlwZSIsImFkbGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/standard-fonts/node_modules/pako/lib/zlib/zstream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/UPNG.js":
/*!********************************************!*\
  !*** ./node_modules/@pdf-lib/upng/UPNG.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n\nvar UPNG = {};\nUPNG.toRGBA8 = function(out) {\n    var w = out.width, h = out.height;\n    if (out.tabs.acTL == null) return [\n        UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer\n    ];\n    var frms = [];\n    if (out.frames[0].data == null) out.frames[0].data = out.data;\n    var len = w * h * 4, img = new Uint8Array(len), empty = new Uint8Array(len), prev = new Uint8Array(len);\n    for(var i = 0; i < out.frames.length; i++){\n        var frm = out.frames[i];\n        var fx = frm.rect.x, fy = frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\n        var fdata = UPNG.toRGBA8.decodeImage(frm.data, fw, fh, out);\n        if (i != 0) for(var j = 0; j < len; j++)prev[j] = img[j];\n        if (frm.blend == 0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n        else if (frm.blend == 1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n        frms.push(img.buffer.slice(0));\n        if (frm.dispose == 0) {} else if (frm.dispose == 1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n        else if (frm.dispose == 2) for(var j = 0; j < len; j++)img[j] = prev[j];\n    }\n    return frms;\n};\nUPNG.toRGBA8.decodeImage = function(data, w, h, out) {\n    var area = w * h, bpp = UPNG.decode._getBPP(out);\n    var bpl = Math.ceil(w * bpp / 8); // bytes per line\n    var bf = new Uint8Array(area * 4), bf32 = new Uint32Array(bf.buffer);\n    var ctype = out.ctype, depth = out.depth;\n    var rs = UPNG._bin.readUshort;\n    //console.log(ctype, depth);\n    var time = Date.now();\n    if (ctype == 6) {\n        var qarea = area << 2;\n        if (depth == 8) for(var i = 0; i < qarea; i += 4){\n            bf[i] = data[i];\n            bf[i + 1] = data[i + 1];\n            bf[i + 2] = data[i + 2];\n            bf[i + 3] = data[i + 3];\n        }\n        if (depth == 16) for(var i = 0; i < qarea; i++){\n            bf[i] = data[i << 1];\n        }\n    } else if (ctype == 2) {\n        var ts = out.tabs[\"tRNS\"];\n        if (ts == null) {\n            if (depth == 8) for(var i = 0; i < area; i++){\n                var ti = i * 3;\n                bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n            }\n            if (depth == 16) for(var i = 0; i < area; i++){\n                var ti = i * 6;\n                bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n            }\n        } else {\n            var tr = ts[0], tg = ts[1], tb = ts[2];\n            if (depth == 8) for(var i = 0; i < area; i++){\n                var qi = i << 2, ti = i * 3;\n                bf32[i] = 255 << 24 | data[ti + 2] << 16 | data[ti + 1] << 8 | data[ti];\n                if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n            }\n            if (depth == 16) for(var i = 0; i < area; i++){\n                var qi = i << 2, ti = i * 6;\n                bf32[i] = 255 << 24 | data[ti + 4] << 16 | data[ti + 2] << 8 | data[ti];\n                if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n            }\n        }\n    } else if (ctype == 3) {\n        var p = out.tabs[\"PLTE\"], ap = out.tabs[\"tRNS\"], tl = ap ? ap.length : 0;\n        //console.log(p, ap);\n        if (depth == 1) for(var y = 0; y < h; y++){\n            var s0 = y * bpl, t0 = y * w;\n            for(var i = 0; i < w; i++){\n                var qi = t0 + i << 2, j = data[s0 + (i >> 3)] >> 7 - ((i & 7) << 0) & 1, cj = 3 * j;\n                bf[qi] = p[cj];\n                bf[qi + 1] = p[cj + 1];\n                bf[qi + 2] = p[cj + 2];\n                bf[qi + 3] = j < tl ? ap[j] : 255;\n            }\n        }\n        if (depth == 2) for(var y = 0; y < h; y++){\n            var s0 = y * bpl, t0 = y * w;\n            for(var i = 0; i < w; i++){\n                var qi = t0 + i << 2, j = data[s0 + (i >> 2)] >> 6 - ((i & 3) << 1) & 3, cj = 3 * j;\n                bf[qi] = p[cj];\n                bf[qi + 1] = p[cj + 1];\n                bf[qi + 2] = p[cj + 2];\n                bf[qi + 3] = j < tl ? ap[j] : 255;\n            }\n        }\n        if (depth == 4) for(var y = 0; y < h; y++){\n            var s0 = y * bpl, t0 = y * w;\n            for(var i = 0; i < w; i++){\n                var qi = t0 + i << 2, j = data[s0 + (i >> 1)] >> 4 - ((i & 1) << 2) & 15, cj = 3 * j;\n                bf[qi] = p[cj];\n                bf[qi + 1] = p[cj + 1];\n                bf[qi + 2] = p[cj + 2];\n                bf[qi + 3] = j < tl ? ap[j] : 255;\n            }\n        }\n        if (depth == 8) for(var i = 0; i < area; i++){\n            var qi = i << 2, j = data[i], cj = 3 * j;\n            bf[qi] = p[cj];\n            bf[qi + 1] = p[cj + 1];\n            bf[qi + 2] = p[cj + 2];\n            bf[qi + 3] = j < tl ? ap[j] : 255;\n        }\n    } else if (ctype == 4) {\n        if (depth == 8) for(var i = 0; i < area; i++){\n            var qi = i << 2, di = i << 1, gr = data[di];\n            bf[qi] = gr;\n            bf[qi + 1] = gr;\n            bf[qi + 2] = gr;\n            bf[qi + 3] = data[di + 1];\n        }\n        if (depth == 16) for(var i = 0; i < area; i++){\n            var qi = i << 2, di = i << 2, gr = data[di];\n            bf[qi] = gr;\n            bf[qi + 1] = gr;\n            bf[qi + 2] = gr;\n            bf[qi + 3] = data[di + 2];\n        }\n    } else if (ctype == 0) {\n        var tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n        for(var y = 0; y < h; y++){\n            var off = y * bpl, to = y * w;\n            if (depth == 1) for(var x = 0; x < w; x++){\n                var gr = 255 * (data[off + (x >>> 3)] >>> 7 - (x & 7) & 1), al = gr == tr * 255 ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 2) for(var x = 0; x < w; x++){\n                var gr = 85 * (data[off + (x >>> 2)] >>> 6 - ((x & 3) << 1) & 3), al = gr == tr * 85 ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 4) for(var x = 0; x < w; x++){\n                var gr = 17 * (data[off + (x >>> 1)] >>> 4 - ((x & 1) << 2) & 15), al = gr == tr * 17 ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 8) for(var x = 0; x < w; x++){\n                var gr = data[off + x], al = gr == tr ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n            else if (depth == 16) for(var x = 0; x < w; x++){\n                var gr = data[off + (x << 1)], al = rs(data, off + (x << i)) == tr ? 0 : 255;\n                bf32[to + x] = al << 24 | gr << 16 | gr << 8 | gr;\n            }\n        }\n    }\n    //console.log(Date.now()-time);\n    return bf;\n};\nUPNG.decode = function(buff) {\n    var data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\n    var out = {\n        tabs: {},\n        frames: []\n    };\n    var dd = new Uint8Array(data.length), doff = 0; // put all IDAT data into it\n    var fd, foff = 0; // frames\n    var mgck = [\n        0x89,\n        0x50,\n        0x4e,\n        0x47,\n        0x0d,\n        0x0a,\n        0x1a,\n        0x0a\n    ];\n    for(var i = 0; i < 8; i++)if (data[i] != mgck[i]) throw \"The input is not a PNG file!\";\n    while(offset < data.length){\n        var len = bin.readUint(data, offset);\n        offset += 4;\n        var type = bin.readASCII(data, offset, 4);\n        offset += 4;\n        //console.log(type,len);\n        if (type == \"IHDR\") {\n            UPNG.decode._IHDR(data, offset, out);\n        } else if (type == \"IDAT\") {\n            for(var i = 0; i < len; i++)dd[doff + i] = data[offset + i];\n            doff += len;\n        } else if (type == \"acTL\") {\n            out.tabs[type] = {\n                num_frames: rUi(data, offset),\n                num_plays: rUi(data, offset + 4)\n            };\n            fd = new Uint8Array(data.length);\n        } else if (type == \"fcTL\") {\n            if (foff != 0) {\n                var fr = out.frames[out.frames.length - 1];\n                fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n                foff = 0;\n            }\n            var rct = {\n                x: rUi(data, offset + 12),\n                y: rUi(data, offset + 16),\n                width: rUi(data, offset + 4),\n                height: rUi(data, offset + 8)\n            };\n            var del = rUs(data, offset + 22);\n            del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n            var frm = {\n                rect: rct,\n                delay: Math.round(del * 1000),\n                dispose: data[offset + 24],\n                blend: data[offset + 25]\n            };\n            //console.log(frm);\n            out.frames.push(frm);\n        } else if (type == \"fdAT\") {\n            for(var i = 0; i < len - 4; i++)fd[foff + i] = data[offset + i + 4];\n            foff += len - 4;\n        } else if (type == \"pHYs\") {\n            out.tabs[type] = [\n                bin.readUint(data, offset),\n                bin.readUint(data, offset + 4),\n                data[offset + 8]\n            ];\n        } else if (type == \"cHRM\") {\n            out.tabs[type] = [];\n            for(var i = 0; i < 8; i++)out.tabs[type].push(bin.readUint(data, offset + i * 4));\n        } else if (type == \"tEXt\") {\n            if (out.tabs[type] == null) out.tabs[type] = {};\n            var nz = bin.nextZero(data, offset);\n            var keyw = bin.readASCII(data, offset, nz - offset);\n            var text = bin.readASCII(data, nz + 1, offset + len - nz - 1);\n            out.tabs[type][keyw] = text;\n        } else if (type == \"iTXt\") {\n            if (out.tabs[type] == null) out.tabs[type] = {};\n            var nz = 0, off = offset;\n            nz = bin.nextZero(data, off);\n            var keyw = bin.readASCII(data, off, nz - off);\n            off = nz + 1;\n            var cflag = data[off], cmeth = data[off + 1];\n            off += 2;\n            nz = bin.nextZero(data, off);\n            var ltag = bin.readASCII(data, off, nz - off);\n            off = nz + 1;\n            nz = bin.nextZero(data, off);\n            var tkeyw = bin.readUTF8(data, off, nz - off);\n            off = nz + 1;\n            var text = bin.readUTF8(data, off, len - (off - offset));\n            out.tabs[type][keyw] = text;\n        } else if (type == \"PLTE\") {\n            out.tabs[type] = bin.readBytes(data, offset, len);\n        } else if (type == \"hIST\") {\n            var pl = out.tabs[\"PLTE\"].length / 3;\n            out.tabs[type] = [];\n            for(var i = 0; i < pl; i++)out.tabs[type].push(rUs(data, offset + i * 2));\n        } else if (type == \"tRNS\") {\n            if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);\n            else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);\n            else if (out.ctype == 2) out.tabs[type] = [\n                rUs(data, offset),\n                rUs(data, offset + 2),\n                rUs(data, offset + 4)\n            ];\n        //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n        } else if (type == \"gAMA\") out.tabs[type] = bin.readUint(data, offset) / 100000;\n        else if (type == \"sRGB\") out.tabs[type] = data[offset];\n        else if (type == \"bKGD\") {\n            if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [\n                rUs(data, offset)\n            ];\n            else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [\n                rUs(data, offset),\n                rUs(data, offset + 2),\n                rUs(data, offset + 4)\n            ];\n            else if (out.ctype == 3) out.tabs[type] = data[offset];\n        } else if (type == \"IEND\") {\n            break;\n        }\n        //else {  log(\"unknown chunk type\", type, len);  }\n        offset += len;\n        var crc = bin.readUint(data, offset);\n        offset += 4;\n    }\n    if (foff != 0) {\n        var fr = out.frames[out.frames.length - 1];\n        fr.data = UPNG.decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n        foff = 0;\n    }\n    out.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n    delete out.compress;\n    delete out.interlace;\n    delete out.filter;\n    return out;\n};\nUPNG.decode._decompress = function(out, dd, w, h) {\n    var time = Date.now();\n    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n    dd = UPNG.decode._inflate(dd, buff);\n    //console.log(dd.length, buff.length);\n    //console.log(Date.now()-time);\n    var time = Date.now();\n    if (out.interlace == 0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n    else if (out.interlace == 1) dd = UPNG.decode._readInterlace(dd, out);\n    //console.log(Date.now()-time);\n    return dd;\n};\nUPNG.decode._inflate = function(data, buff) {\n    var out = UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2, data.length - 6), buff);\n    return out;\n};\nUPNG.inflateRaw = function() {\n    var H = {};\n    H.H = {};\n    H.H.N = function(N, W) {\n        var R = Uint8Array, i = 0, m = 0, J = 0, h = 0, Q = 0, X = 0, u = 0, w = 0, d = 0, v, C;\n        if (N[0] == 3 && N[1] == 0) return W ? W : new R(0);\n        var V = H.H, n = V.b, A = V.e, l = V.R, M = V.n, I = V.A, e = V.Z, b = V.m, Z = W == null;\n        if (Z) W = new R(N.length >>> 2 << 3);\n        while(i == 0){\n            i = n(N, d, 1);\n            m = n(N, d + 1, 2);\n            d += 3;\n            if (m == 0) {\n                if ((d & 7) != 0) d += 8 - (d & 7);\n                var D = (d >>> 3) + 4, q = N[D - 4] | N[D - 3] << 8;\n                if (Z) W = H.H.W(W, w + q);\n                W.set(new R(N.buffer, N.byteOffset + D, q), w);\n                d = D + q << 3;\n                w += q;\n                continue;\n            }\n            if (Z) W = H.H.W(W, w + (1 << 17));\n            if (m == 1) {\n                v = b.J;\n                C = b.h;\n                X = (1 << 9) - 1;\n                u = (1 << 5) - 1;\n            }\n            if (m == 2) {\n                J = A(N, d, 5) + 257;\n                h = A(N, d + 5, 5) + 1;\n                Q = A(N, d + 10, 4) + 4;\n                d += 14;\n                var E = d, j = 1;\n                for(var c = 0; c < 38; c += 2){\n                    b.Q[c] = 0;\n                    b.Q[c + 1] = 0;\n                }\n                for(var c = 0; c < Q; c++){\n                    var K = A(N, d + c * 3, 3);\n                    b.Q[(b.X[c] << 1) + 1] = K;\n                    if (K > j) j = K;\n                }\n                d += 3 * Q;\n                M(b.Q, j);\n                I(b.Q, j, b.u);\n                v = b.w;\n                C = b.d;\n                d = l(b.u, (1 << j) - 1, J + h, N, d, b.v);\n                var r = V.V(b.v, 0, J, b.C);\n                X = (1 << r) - 1;\n                var S = V.V(b.v, J, h, b.D);\n                u = (1 << S) - 1;\n                M(b.C, r);\n                I(b.C, r, v);\n                M(b.D, S);\n                I(b.D, S, C);\n            }\n            while(!0){\n                var T = v[e(N, d) & X];\n                d += T & 15;\n                var p = T >>> 4;\n                if (p >>> 8 == 0) {\n                    W[w++] = p;\n                } else if (p == 256) {\n                    break;\n                } else {\n                    var z = w + p - 254;\n                    if (p > 264) {\n                        var _ = b.q[p - 257];\n                        z = w + (_ >>> 3) + A(N, d, _ & 7);\n                        d += _ & 7;\n                    }\n                    var $ = C[e(N, d) & u];\n                    d += $ & 15;\n                    var s = $ >>> 4, Y = b.c[s], a = (Y >>> 4) + n(N, d, Y & 15);\n                    d += Y & 15;\n                    while(w < z){\n                        W[w] = W[w++ - a];\n                        W[w] = W[w++ - a];\n                        W[w] = W[w++ - a];\n                        W[w] = W[w++ - a];\n                    }\n                    w = z;\n                }\n            }\n        }\n        return W.length == w ? W : W.slice(0, w);\n    };\n    H.H.W = function(N, W) {\n        var R = N.length;\n        if (W <= R) return N;\n        var V = new Uint8Array(R << 1);\n        V.set(N, 0);\n        return V;\n    };\n    H.H.R = function(N, W, R, V, n, A) {\n        var l = H.H.e, M = H.H.Z, I = 0;\n        while(I < R){\n            var e = N[M(V, n) & W];\n            n += e & 15;\n            var b = e >>> 4;\n            if (b <= 15) {\n                A[I] = b;\n                I++;\n            } else {\n                var Z = 0, m = 0;\n                if (b == 16) {\n                    m = 3 + l(V, n, 2);\n                    n += 2;\n                    Z = A[I - 1];\n                } else if (b == 17) {\n                    m = 3 + l(V, n, 3);\n                    n += 3;\n                } else if (b == 18) {\n                    m = 11 + l(V, n, 7);\n                    n += 7;\n                }\n                var J = I + m;\n                while(I < J){\n                    A[I] = Z;\n                    I++;\n                }\n            }\n        }\n        return n;\n    };\n    H.H.V = function(N, W, R, V) {\n        var n = 0, A = 0, l = V.length >>> 1;\n        while(A < R){\n            var M = N[A + W];\n            V[A << 1] = 0;\n            V[(A << 1) + 1] = M;\n            if (M > n) n = M;\n            A++;\n        }\n        while(A < l){\n            V[A << 1] = 0;\n            V[(A << 1) + 1] = 0;\n            A++;\n        }\n        return n;\n    };\n    H.H.n = function(N, W) {\n        var R = H.H.m, V = N.length, n, A, l, M, I, e = R.j;\n        for(var M = 0; M <= W; M++)e[M] = 0;\n        for(M = 1; M < V; M += 2)e[N[M]]++;\n        var b = R.K;\n        n = 0;\n        e[0] = 0;\n        for(A = 1; A <= W; A++){\n            n = n + e[A - 1] << 1;\n            b[A] = n;\n        }\n        for(l = 0; l < V; l += 2){\n            I = N[l + 1];\n            if (I != 0) {\n                N[l] = b[I];\n                b[I]++;\n            }\n        }\n    };\n    H.H.A = function(N, W, R) {\n        var V = N.length, n = H.H.m, A = n.r;\n        for(var l = 0; l < V; l += 2)if (N[l + 1] != 0) {\n            var M = l >> 1, I = N[l + 1], e = M << 4 | I, b = W - I, Z = N[l] << b, m = Z + (1 << b);\n            while(Z != m){\n                var J = A[Z] >>> 15 - W;\n                R[J] = e;\n                Z++;\n            }\n        }\n    };\n    H.H.l = function(N, W) {\n        var R = H.H.m.r, V = 15 - W;\n        for(var n = 0; n < N.length; n += 2){\n            var A = N[n] << W - N[n + 1];\n            N[n] = R[A] >>> V;\n        }\n    };\n    H.H.M = function(N, W, R) {\n        R = R << (W & 7);\n        var V = W >>> 3;\n        N[V] |= R;\n        N[V + 1] |= R >>> 8;\n    };\n    H.H.I = function(N, W, R) {\n        R = R << (W & 7);\n        var V = W >>> 3;\n        N[V] |= R;\n        N[V + 1] |= R >>> 8;\n        N[V + 2] |= R >>> 16;\n    };\n    H.H.e = function(N, W, R) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1;\n    };\n    H.H.b = function(N, W, R) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1;\n    };\n    H.H.Z = function(N, W) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7);\n    };\n    H.H.i = function(N, W) {\n        return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7);\n    };\n    H.H.m = function() {\n        var N = Uint16Array, W = Uint32Array;\n        return {\n            K: new N(16),\n            j: new N(16),\n            X: [\n                16,\n                17,\n                18,\n                0,\n                8,\n                7,\n                9,\n                6,\n                10,\n                5,\n                11,\n                4,\n                12,\n                3,\n                13,\n                2,\n                14,\n                1,\n                15\n            ],\n            S: [\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                13,\n                15,\n                17,\n                19,\n                23,\n                27,\n                31,\n                35,\n                43,\n                51,\n                59,\n                67,\n                83,\n                99,\n                115,\n                131,\n                163,\n                195,\n                227,\n                258,\n                999,\n                999,\n                999\n            ],\n            T: [\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                1,\n                1,\n                2,\n                2,\n                2,\n                2,\n                3,\n                3,\n                3,\n                3,\n                4,\n                4,\n                4,\n                4,\n                5,\n                5,\n                5,\n                5,\n                0,\n                0,\n                0,\n                0\n            ],\n            q: new N(32),\n            p: [\n                1,\n                2,\n                3,\n                4,\n                5,\n                7,\n                9,\n                13,\n                17,\n                25,\n                33,\n                49,\n                65,\n                97,\n                129,\n                193,\n                257,\n                385,\n                513,\n                769,\n                1025,\n                1537,\n                2049,\n                3073,\n                4097,\n                6145,\n                8193,\n                12289,\n                16385,\n                24577,\n                65535,\n                65535\n            ],\n            z: [\n                0,\n                0,\n                0,\n                0,\n                1,\n                1,\n                2,\n                2,\n                3,\n                3,\n                4,\n                4,\n                5,\n                5,\n                6,\n                6,\n                7,\n                7,\n                8,\n                8,\n                9,\n                9,\n                10,\n                10,\n                11,\n                11,\n                12,\n                12,\n                13,\n                13,\n                0,\n                0\n            ],\n            c: new W(32),\n            J: new N(512),\n            _: [],\n            h: new N(32),\n            $: [],\n            w: new N(32768),\n            C: [],\n            v: [],\n            d: new N(32768),\n            D: [],\n            u: new N(512),\n            Q: [],\n            r: new N(1 << 15),\n            s: new W(286),\n            Y: new W(30),\n            a: new W(19),\n            t: new W(15e3),\n            k: new N(1 << 16),\n            g: new N(1 << 15)\n        };\n    }();\n    (function() {\n        var N = H.H.m, W = 1 << 15;\n        for(var R = 0; R < W; R++){\n            var V = R;\n            V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n            V = (V & 3435973836) >>> 2 | (V & 858993459) << 2;\n            V = (V & 4042322160) >>> 4 | (V & 252645135) << 4;\n            V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n            N.r[R] = (V >>> 16 | V << 16) >>> 17;\n        }\n        function n(A, l, M) {\n            while(l-- != 0)A.push(0, M);\n        }\n        for(var R = 0; R < 32; R++){\n            N.q[R] = N.S[R] << 3 | N.T[R];\n            N.c[R] = N.p[R] << 4 | N.z[R];\n        }\n        n(N._, 144, 8);\n        n(N._, 255 - 143, 9);\n        n(N._, 279 - 255, 7);\n        n(N._, 287 - 279, 8);\n        H.H.n(N._, 9);\n        H.H.A(N._, 9, N.J);\n        H.H.l(N._, 9);\n        n(N.$, 32, 5);\n        H.H.n(N.$, 5);\n        H.H.A(N.$, 5, N.h);\n        H.H.l(N.$, 5);\n        n(N.Q, 19, 0);\n        n(N.C, 286, 0);\n        n(N.D, 30, 0);\n        n(N.v, 320, 0);\n    })();\n    return H.H.N;\n}();\nUPNG.decode._readInterlace = function(data, out) {\n    var w = out.width, h = out.height;\n    var bpp = UPNG.decode._getBPP(out), cbpp = bpp >> 3, bpl = Math.ceil(w * bpp / 8);\n    var img = new Uint8Array(h * bpl);\n    var di = 0;\n    var starting_row = [\n        0,\n        0,\n        4,\n        0,\n        2,\n        0,\n        1\n    ];\n    var starting_col = [\n        0,\n        4,\n        0,\n        2,\n        0,\n        1,\n        0\n    ];\n    var row_increment = [\n        8,\n        8,\n        8,\n        4,\n        4,\n        2,\n        2\n    ];\n    var col_increment = [\n        8,\n        8,\n        4,\n        4,\n        2,\n        2,\n        1\n    ];\n    var pass = 0;\n    while(pass < 7){\n        var ri = row_increment[pass], ci = col_increment[pass];\n        var sw = 0, sh = 0;\n        var cr = starting_row[pass];\n        while(cr < h){\n            cr += ri;\n            sh++;\n        }\n        var cc = starting_col[pass];\n        while(cc < w){\n            cc += ci;\n            sw++;\n        }\n        var bpll = Math.ceil(sw * bpp / 8);\n        UPNG.decode._filterZero(data, out, di, sw, sh);\n        var y = 0, row = starting_row[pass];\n        while(row < h){\n            var col = starting_col[pass];\n            var cdi = di + y * bpll << 3;\n            while(col < w){\n                if (bpp == 1) {\n                    var val = data[cdi >> 3];\n                    val = val >> 7 - (cdi & 7) & 1;\n                    img[row * bpl + (col >> 3)] |= val << 7 - ((col & 7) << 0);\n                }\n                if (bpp == 2) {\n                    var val = data[cdi >> 3];\n                    val = val >> 6 - (cdi & 7) & 3;\n                    img[row * bpl + (col >> 2)] |= val << 6 - ((col & 3) << 1);\n                }\n                if (bpp == 4) {\n                    var val = data[cdi >> 3];\n                    val = val >> 4 - (cdi & 7) & 15;\n                    img[row * bpl + (col >> 1)] |= val << 4 - ((col & 1) << 2);\n                }\n                if (bpp >= 8) {\n                    var ii = row * bpl + col * cbpp;\n                    for(var j = 0; j < cbpp; j++)img[ii + j] = data[(cdi >> 3) + j];\n                }\n                cdi += bpp;\n                col += ci;\n            }\n            y++;\n            row += ri;\n        }\n        if (sw * sh != 0) di += sh * (1 + bpll);\n        pass = pass + 1;\n    }\n    return img;\n};\nUPNG.decode._getBPP = function(out) {\n    var noc = [\n        1,\n        null,\n        3,\n        1,\n        2,\n        null,\n        4\n    ][out.ctype];\n    return noc * out.depth;\n};\nUPNG.decode._filterZero = function(data, out, off, w, h) {\n    var bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w * bpp / 8), paeth = UPNG.decode._paeth;\n    bpp = Math.ceil(bpp / 8);\n    var i = 0, di = 1, type = data[off], x = 0;\n    if (type > 1) data[off] = [\n        0,\n        0,\n        1\n    ][type - 2];\n    if (type == 3) for(x = bpp; x < bpl; x++)data[x + 1] = data[x + 1] + (data[x + 1 - bpp] >>> 1) & 255;\n    for(var y = 0; y < h; y++){\n        i = off + y * bpl;\n        di = i + y + 1;\n        type = data[di - 1];\n        x = 0;\n        if (type == 0) for(; x < bpl; x++)data[i + x] = data[di + x];\n        else if (type == 1) {\n            for(; x < bpp; x++)data[i + x] = data[di + x];\n            for(; x < bpl; x++)data[i + x] = data[di + x] + data[i + x - bpp];\n        } else if (type == 2) {\n            for(; x < bpl; x++)data[i + x] = data[di + x] + data[i + x - bpl];\n        } else if (type == 3) {\n            for(; x < bpp; x++)data[i + x] = data[di + x] + (data[i + x - bpl] >>> 1);\n            for(; x < bpl; x++)data[i + x] = data[di + x] + (data[i + x - bpl] + data[i + x - bpp] >>> 1);\n        } else {\n            for(; x < bpp; x++)data[i + x] = data[di + x] + paeth(0, data[i + x - bpl], 0);\n            for(; x < bpl; x++)data[i + x] = data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]);\n        }\n    }\n    return data;\n};\nUPNG.decode._paeth = function(a, b, c) {\n    var p = a + b - c, pa = p - a, pb = p - b, pc = p - c;\n    if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;\n    else if (pb * pb <= pc * pc) return b;\n    return c;\n};\nUPNG.decode._IHDR = function(data, offset, out) {\n    var bin = UPNG._bin;\n    out.width = bin.readUint(data, offset);\n    offset += 4;\n    out.height = bin.readUint(data, offset);\n    offset += 4;\n    out.depth = data[offset];\n    offset++;\n    out.ctype = data[offset];\n    offset++;\n    out.compress = data[offset];\n    offset++;\n    out.filter = data[offset];\n    offset++;\n    out.interlace = data[offset];\n    offset++;\n};\nUPNG._bin = {\n    nextZero: function(data, p) {\n        while(data[p] != 0)p++;\n        return p;\n    },\n    readUshort: function(buff, p) {\n        return buff[p] << 8 | buff[p + 1];\n    },\n    writeUshort: function(buff, p, n) {\n        buff[p] = n >> 8 & 255;\n        buff[p + 1] = n & 255;\n    },\n    readUint: function(buff, p) {\n        return buff[p] * (256 * 256 * 256) + (buff[p + 1] << 16 | buff[p + 2] << 8 | buff[p + 3]);\n    },\n    writeUint: function(buff, p, n) {\n        buff[p] = n >> 24 & 255;\n        buff[p + 1] = n >> 16 & 255;\n        buff[p + 2] = n >> 8 & 255;\n        buff[p + 3] = n & 255;\n    },\n    readASCII: function(buff, p, l) {\n        var s = \"\";\n        for(var i = 0; i < l; i++)s += String.fromCharCode(buff[p + i]);\n        return s;\n    },\n    writeASCII: function(data, p, s) {\n        for(var i = 0; i < s.length; i++)data[p + i] = s.charCodeAt(i);\n    },\n    readBytes: function(buff, p, l) {\n        var arr = [];\n        for(var i = 0; i < l; i++)arr.push(buff[p + i]);\n        return arr;\n    },\n    pad: function(n) {\n        return n.length < 2 ? \"0\" + n : n;\n    },\n    readUTF8: function(buff, p, l) {\n        var s = \"\", ns;\n        for(var i = 0; i < l; i++)s += \"%\" + UPNG._bin.pad(buff[p + i].toString(16));\n        try {\n            ns = decodeURIComponent(s);\n        } catch (e) {\n            return UPNG._bin.readASCII(buff, p, l);\n        }\n        return ns;\n    }\n};\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n    var w = Math.min(sw, tw), h = Math.min(sh, th);\n    var si = 0, ti = 0;\n    for(var y = 0; y < h; y++)for(var x = 0; x < w; x++){\n        if (xoff >= 0 && yoff >= 0) {\n            si = y * sw + x << 2;\n            ti = (yoff + y) * tw + xoff + x << 2;\n        } else {\n            si = (-yoff + y) * sw - xoff + x << 2;\n            ti = y * tw + x << 2;\n        }\n        if (mode == 0) {\n            tb[ti] = sb[si];\n            tb[ti + 1] = sb[si + 1];\n            tb[ti + 2] = sb[si + 2];\n            tb[ti + 3] = sb[si + 3];\n        } else if (mode == 1) {\n            var fa = sb[si + 3] * (1 / 255), fr = sb[si] * fa, fg = sb[si + 1] * fa, fb = sb[si + 2] * fa;\n            var ba = tb[ti + 3] * (1 / 255), br = tb[ti] * ba, bg = tb[ti + 1] * ba, bb = tb[ti + 2] * ba;\n            var ifa = 1 - fa, oa = fa + ba * ifa, ioa = oa == 0 ? 0 : 1 / oa;\n            tb[ti + 3] = 255 * oa;\n            tb[ti + 0] = (fr + br * ifa) * ioa;\n            tb[ti + 1] = (fg + bg * ifa) * ioa;\n            tb[ti + 2] = (fb + bb * ifa) * ioa;\n        } else if (mode == 2) {\n            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];\n            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];\n            if (fa == ba && fr == br && fg == bg && fb == bb) {\n                tb[ti] = 0;\n                tb[ti + 1] = 0;\n                tb[ti + 2] = 0;\n                tb[ti + 3] = 0;\n            } else {\n                tb[ti] = fr;\n                tb[ti + 1] = fg;\n                tb[ti + 2] = fb;\n                tb[ti + 3] = fa;\n            }\n        } else if (mode == 3) {\n            var fa = sb[si + 3], fr = sb[si], fg = sb[si + 1], fb = sb[si + 2];\n            var ba = tb[ti + 3], br = tb[ti], bg = tb[ti + 1], bb = tb[ti + 2];\n            if (fa == ba && fr == br && fg == bg && fb == bb) continue;\n            //if(fa!=255 && ba!=0) return false;\n            if (fa < 220 && ba > 20) return false;\n        }\n    }\n    return true;\n};\nUPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte) {\n    if (ps == null) ps = 0;\n    if (forbidPlte == null) forbidPlte = false;\n    var nimg = UPNG.encode.compress(bufs, w, h, ps, [\n        false,\n        false,\n        false,\n        0,\n        forbidPlte\n    ]);\n    UPNG.encode.compressPNG(nimg, -1);\n    return UPNG.encode._main(nimg, w, h, dels, tabs);\n};\nUPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {\n    var nimg = {\n        ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4),\n        depth: depth,\n        frames: []\n    };\n    var time = Date.now();\n    var bipp = (cc + ac) * depth, bipl = bipp * w;\n    for(var i = 0; i < bufs.length; i++)nimg.frames.push({\n        rect: {\n            x: 0,\n            y: 0,\n            width: w,\n            height: h\n        },\n        img: new Uint8Array(bufs[i]),\n        blend: 0,\n        dispose: 1,\n        bpp: Math.ceil(bipp / 8),\n        bpl: Math.ceil(bipl / 8)\n    });\n    UPNG.encode.compressPNG(nimg, 0, true);\n    var out = UPNG.encode._main(nimg, w, h, dels, tabs);\n    return out;\n};\nUPNG.encode._main = function(nimg, w, h, dels, tabs) {\n    if (tabs == null) tabs = {};\n    var crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;\n    var offset = 8, anim = nimg.frames.length > 1, pltAlpha = false;\n    var leng = 8 + (16 + 5 + 4) + (anim ? 20 : 0);\n    if (tabs[\"sRGB\"] != null) leng += 8 + 1 + 4;\n    if (tabs[\"pHYs\"] != null) leng += 8 + 9 + 4;\n    if (nimg.ctype == 3) {\n        var dl = nimg.plte.length;\n        for(var i = 0; i < dl; i++)if (nimg.plte[i] >>> 24 != 255) pltAlpha = true;\n        leng += 8 + dl * 3 + 4 + (pltAlpha ? 8 + dl * 1 + 4 : 0);\n    }\n    for(var j = 0; j < nimg.frames.length; j++){\n        var fr = nimg.frames[j];\n        if (anim) leng += 38;\n        leng += fr.cimg.length + 12;\n        if (j != 0) leng += 4;\n    }\n    leng += 12;\n    var data = new Uint8Array(leng);\n    var wr = [\n        0x89,\n        0x50,\n        0x4e,\n        0x47,\n        0x0d,\n        0x0a,\n        0x1a,\n        0x0a\n    ];\n    for(var i = 0; i < 8; i++)data[i] = wr[i];\n    wUi(data, offset, 13);\n    offset += 4;\n    wAs(data, offset, \"IHDR\");\n    offset += 4;\n    wUi(data, offset, w);\n    offset += 4;\n    wUi(data, offset, h);\n    offset += 4;\n    data[offset] = nimg.depth;\n    offset++; // depth\n    data[offset] = nimg.ctype;\n    offset++; // ctype\n    data[offset] = 0;\n    offset++; // compress\n    data[offset] = 0;\n    offset++; // filter\n    data[offset] = 0;\n    offset++; // interlace\n    wUi(data, offset, crc(data, offset - 17, 17));\n    offset += 4; // crc\n    // 13 bytes to say, that it is sRGB\n    if (tabs[\"sRGB\"] != null) {\n        wUi(data, offset, 1);\n        offset += 4;\n        wAs(data, offset, \"sRGB\");\n        offset += 4;\n        data[offset] = tabs[\"sRGB\"];\n        offset++;\n        wUi(data, offset, crc(data, offset - 5, 5));\n        offset += 4; // crc\n    }\n    if (tabs[\"pHYs\"] != null) {\n        wUi(data, offset, 9);\n        offset += 4;\n        wAs(data, offset, \"pHYs\");\n        offset += 4;\n        wUi(data, offset, tabs[\"pHYs\"][0]);\n        offset += 4;\n        wUi(data, offset, tabs[\"pHYs\"][1]);\n        offset += 4;\n        data[offset] = tabs[\"pHYs\"][2];\n        offset++;\n        wUi(data, offset, crc(data, offset - 13, 13));\n        offset += 4; // crc\n    }\n    if (anim) {\n        wUi(data, offset, 8);\n        offset += 4;\n        wAs(data, offset, \"acTL\");\n        offset += 4;\n        wUi(data, offset, nimg.frames.length);\n        offset += 4;\n        wUi(data, offset, tabs[\"loop\"] != null ? tabs[\"loop\"] : 0);\n        offset += 4;\n        wUi(data, offset, crc(data, offset - 12, 12));\n        offset += 4; // crc\n    }\n    if (nimg.ctype == 3) {\n        var dl = nimg.plte.length;\n        wUi(data, offset, dl * 3);\n        offset += 4;\n        wAs(data, offset, \"PLTE\");\n        offset += 4;\n        for(var i = 0; i < dl; i++){\n            var ti = i * 3, c = nimg.plte[i], r = c & 255, g = c >>> 8 & 255, b = c >>> 16 & 255;\n            data[offset + ti + 0] = r;\n            data[offset + ti + 1] = g;\n            data[offset + ti + 2] = b;\n        }\n        offset += dl * 3;\n        wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4));\n        offset += 4; // crc\n        if (pltAlpha) {\n            wUi(data, offset, dl);\n            offset += 4;\n            wAs(data, offset, \"tRNS\");\n            offset += 4;\n            for(var i = 0; i < dl; i++)data[offset + i] = nimg.plte[i] >>> 24 & 255;\n            offset += dl;\n            wUi(data, offset, crc(data, offset - dl - 4, dl + 4));\n            offset += 4; // crc\n        }\n    }\n    var fi = 0;\n    for(var j = 0; j < nimg.frames.length; j++){\n        var fr = nimg.frames[j];\n        if (anim) {\n            wUi(data, offset, 26);\n            offset += 4;\n            wAs(data, offset, \"fcTL\");\n            offset += 4;\n            wUi(data, offset, fi++);\n            offset += 4;\n            wUi(data, offset, fr.rect.width);\n            offset += 4;\n            wUi(data, offset, fr.rect.height);\n            offset += 4;\n            wUi(data, offset, fr.rect.x);\n            offset += 4;\n            wUi(data, offset, fr.rect.y);\n            offset += 4;\n            wUs(data, offset, dels[j]);\n            offset += 2;\n            wUs(data, offset, 1000);\n            offset += 2;\n            data[offset] = fr.dispose;\n            offset++; // dispose\n            data[offset] = fr.blend;\n            offset++; // blend\n            wUi(data, offset, crc(data, offset - 30, 30));\n            offset += 4; // crc\n        }\n        var imgd = fr.cimg, dl = imgd.length;\n        wUi(data, offset, dl + (j == 0 ? 0 : 4));\n        offset += 4;\n        var ioff = offset;\n        wAs(data, offset, j == 0 ? \"IDAT\" : \"fdAT\");\n        offset += 4;\n        if (j != 0) {\n            wUi(data, offset, fi++);\n            offset += 4;\n        }\n        data.set(imgd, offset);\n        offset += dl;\n        wUi(data, offset, crc(data, ioff, offset - ioff));\n        offset += 4; // crc\n    }\n    wUi(data, offset, 0);\n    offset += 4;\n    wAs(data, offset, \"IEND\");\n    offset += 4;\n    wUi(data, offset, crc(data, offset - 4, 4));\n    offset += 4; // crc\n    return data.buffer;\n};\nUPNG.encode.compressPNG = function(out, filter, levelZero) {\n    for(var i = 0; i < out.frames.length; i++){\n        var frm = out.frames[i], nw = frm.rect.width, nh = frm.rect.height;\n        var fdata = new Uint8Array(nh * frm.bpl + nh);\n        frm.cimg = UPNG.encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);\n    }\n};\nUPNG.encode.compress = function(bufs, w, h, ps, prms) {\n    //var time = Date.now();\n    var onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];\n    var ctype = 6, depth = 8, alphaAnd = 255;\n    for(var j = 0; j < bufs.length; j++){\n        var img = new Uint8Array(bufs[j]), ilen = img.length;\n        for(var i = 0; i < ilen; i += 4)alphaAnd &= img[i + 3];\n    }\n    var gotAlpha = alphaAnd != 255;\n    //console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n    //var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n    var frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\n    //console.log(\"framize\", Date.now()-time);  time = Date.now();\n    var cmap = {}, plte = [], inds = [];\n    if (ps != 0) {\n        var nbufs = [];\n        for(var i = 0; i < frms.length; i++)nbufs.push(frms[i].img.buffer);\n        var abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);\n        var cof = 0, bb = new Uint8Array(qres.abuf);\n        for(var i = 0; i < frms.length; i++){\n            var ti = frms[i].img, bln = ti.length;\n            inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));\n            for(var j = 0; j < bln; j += 4){\n                ti[j] = bb[cof + j];\n                ti[j + 1] = bb[cof + j + 1];\n                ti[j + 2] = bb[cof + j + 2];\n                ti[j + 3] = bb[cof + j + 3];\n            }\n            cof += bln;\n        }\n        for(var i = 0; i < qres.plte.length; i++)plte.push(qres.plte[i].est.rgba);\n    //console.log(\"quantize\", Date.now()-time);  time = Date.now();\n    } else {\n        // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n        for(var j = 0; j < frms.length; j++){\n            var frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw = frm.rect.width, ilen = img32.length;\n            var ind = new Uint8Array(ilen);\n            inds.push(ind);\n            for(var i = 0; i < ilen; i++){\n                var c = img32[i];\n                if (i != 0 && c == img32[i - 1]) ind[i] = ind[i - 1];\n                else if (i > nw && c == img32[i - nw]) ind[i] = ind[i - nw];\n                else {\n                    var cmc = cmap[c];\n                    if (cmc == null) {\n                        cmap[c] = cmc = plte.length;\n                        plte.push(c);\n                        if (plte.length >= 300) break;\n                    }\n                    ind[i] = cmc;\n                }\n            }\n        }\n    //console.log(\"make palette\", Date.now()-time);  time = Date.now();\n    }\n    var cc = plte.length; //console.log(\"colors:\",cc);\n    if (cc <= 256 && forbidPlte == false) {\n        if (cc <= 2) depth = 1;\n        else if (cc <= 4) depth = 2;\n        else if (cc <= 16) depth = 4;\n        else depth = 8;\n        depth = Math.max(depth, minBits);\n    }\n    for(var j = 0; j < frms.length; j++){\n        var frm = frms[j], nx = frm.rect.x, ny = frm.rect.y, nw = frm.rect.width, nh = frm.rect.height;\n        var cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);\n        var bpl = 4 * nw, bpp = 4;\n        if (cc <= 256 && forbidPlte == false) {\n            bpl = Math.ceil(depth * nw / 8);\n            var nimg = new Uint8Array(bpl * nh);\n            var inj = inds[j];\n            for(var y = 0; y < nh; y++){\n                var i = y * bpl, ii = y * nw;\n                if (depth == 8) for(var x = 0; x < nw; x++)nimg[i + x] = inj[ii + x];\n                else if (depth == 4) for(var x = 0; x < nw; x++)nimg[i + (x >> 1)] |= inj[ii + x] << 4 - (x & 1) * 4;\n                else if (depth == 2) for(var x = 0; x < nw; x++)nimg[i + (x >> 2)] |= inj[ii + x] << 6 - (x & 3) * 2;\n                else if (depth == 1) for(var x = 0; x < nw; x++)nimg[i + (x >> 3)] |= inj[ii + x] << 7 - (x & 7) * 1;\n            }\n            cimg = nimg;\n            ctype = 3;\n            bpp = 1;\n        } else if (gotAlpha == false && frms.length == 1) {\n            var nimg = new Uint8Array(nw * nh * 3), area = nw * nh;\n            for(var i = 0; i < area; i++){\n                var ti = i * 3, qi = i * 4;\n                nimg[ti] = cimg[qi];\n                nimg[ti + 1] = cimg[qi + 1];\n                nimg[ti + 2] = cimg[qi + 2];\n            }\n            cimg = nimg;\n            ctype = 2;\n            bpp = 3;\n            bpl = 3 * nw;\n        }\n        frm.img = cimg;\n        frm.bpl = bpl;\n        frm.bpp = bpp;\n    }\n    //console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n    return {\n        ctype: ctype,\n        depth: depth,\n        plte: plte,\n        frames: frms\n    };\n};\nUPNG.encode.framize = function(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {\n    /*  DISPOSE\n\t    - 0 : no change\n\t\t- 1 : clear to transparent\n\t\t- 2 : retstore to content before rendering (previous frame disposed)\n\t\tBLEND\n\t\t- 0 : replace\n\t\t- 1 : blend\n\t*/ var frms = [];\n    for(var j = 0; j < bufs.length; j++){\n        var cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\n        var nimg;\n        var nx = 0, ny = 0, nw = w, nh = h, blend = alwaysBlend ? 1 : 0;\n        if (j != 0) {\n            var tlim = forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0 ? 1 : 2, tstp = 0, tarea = 1e9;\n            for(var it = 0; it < tlim; it++){\n                var pimg = new Uint8Array(bufs[j - 1 - it]), p32 = new Uint32Array(bufs[j - 1 - it]);\n                var mix = w, miy = h, max = -1, may = -1;\n                for(var y = 0; y < h; y++)for(var x = 0; x < w; x++){\n                    var i = y * w + x;\n                    if (cimg32[i] != p32[i]) {\n                        if (x < mix) mix = x;\n                        if (x > max) max = x;\n                        if (y < miy) miy = y;\n                        if (y > may) may = y;\n                    }\n                }\n                if (max == -1) mix = miy = max = may = 0;\n                if (evenCrd) {\n                    if ((mix & 1) == 1) mix--;\n                    if ((miy & 1) == 1) miy--;\n                }\n                var sarea = (max - mix + 1) * (may - miy + 1);\n                if (sarea < tarea) {\n                    tarea = sarea;\n                    tstp = it;\n                    nx = mix;\n                    ny = miy;\n                    nw = max - mix + 1;\n                    nh = may - miy + 1;\n                }\n            }\n            // alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\n            var pimg = new Uint8Array(bufs[j - 1 - tstp]);\n            if (tstp == 1) frms[j - 1].dispose = 2;\n            nimg = new Uint8Array(nw * nh * 4);\n            UPNG._copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n            blend = UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;\n            if (blend == 1) UPNG.encode._prepareDiff(cimg, w, h, nimg, {\n                x: nx,\n                y: ny,\n                width: nw,\n                height: nh\n            });\n            else UPNG._copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n        //UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\n        } else nimg = cimg.slice(0); // img may be rewritten further ... don't rewrite input\n        frms.push({\n            rect: {\n                x: nx,\n                y: ny,\n                width: nw,\n                height: nh\n            },\n            img: nimg,\n            blend: blend,\n            dispose: 0\n        });\n    }\n    if (alwaysBlend) for(var j = 0; j < frms.length; j++){\n        var frm = frms[j];\n        if (frm.blend == 1) continue;\n        var r0 = frm.rect, r1 = frms[j - 1].rect;\n        var miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);\n        var maX = Math.max(r0.x + r0.width, r1.x + r1.width), maY = Math.max(r0.y + r0.height, r1.y + r1.height);\n        var r = {\n            x: miX,\n            y: miY,\n            width: maX - miX,\n            height: maY - miY\n        };\n        frms[j - 1].dispose = 1;\n        if (j - 1 != 0) UPNG.encode._updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);\n        UPNG.encode._updateFrame(bufs, w, h, frms, j, r, evenCrd);\n    }\n    var area = 0;\n    if (bufs.length != 1) for(var i = 0; i < frms.length; i++){\n        var frm = frms[i];\n        area += frm.rect.width * frm.rect.height;\n    //if(i==0 || frm.blend!=1) continue;\n    //var ob = new Uint8Array(\n    //console.log(frm.blend, frm.dispose, frm.rect);\n    }\n    //if(area!=0) console.log(area);\n    return frms;\n};\nUPNG.encode._updateFrame = function(bufs, w, h, frms, i, r, evenCrd) {\n    var U8 = Uint8Array, U32 = Uint32Array;\n    var pimg = new U8(bufs[i - 1]), pimg32 = new U32(bufs[i - 1]), nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;\n    var cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);\n    var mix = w, miy = h, max = -1, may = -1;\n    for(var y = 0; y < r.height; y++)for(var x = 0; x < r.width; x++){\n        var cx = r.x + x, cy = r.y + y;\n        var j = cy * w + cx, cc = cimg32[j];\n        // no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n        if (cc == 0 || frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0)) {} else {\n            if (cx < mix) mix = cx;\n            if (cx > max) max = cx;\n            if (cy < miy) miy = cy;\n            if (cy > may) may = cy;\n        }\n    }\n    if (max == -1) mix = miy = max = may = 0;\n    if (evenCrd) {\n        if ((mix & 1) == 1) mix--;\n        if ((miy & 1) == 1) miy--;\n    }\n    r = {\n        x: mix,\n        y: miy,\n        width: max - mix + 1,\n        height: may - miy + 1\n    };\n    var fr = frms[i];\n    fr.rect = r;\n    fr.blend = 1;\n    fr.img = new Uint8Array(r.width * r.height * 4);\n    if (frms[i - 1].dispose == 0) {\n        UPNG._copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n        UPNG.encode._prepareDiff(cimg, w, h, fr.img, r);\n    //UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\n    } else UPNG._copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n};\nUPNG.encode._prepareDiff = function(cimg, w, h, nimg, rec) {\n    UPNG._copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);\n/*\n\tvar n32 = new Uint32Array(nimg.buffer);\n\tvar og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\n\tUPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\n\tfor(var i=4; i<nimg.length; i+=4) {\n\t\tif(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}\n\tfor(var i=nimg.length-8; i>0; i-=4) {\n\t\tif(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}*/ };\nUPNG.encode._filterZero = function(img, h, bpp, bpl, data, filter, levelZero) {\n    var fls = [], ftry = [\n        0,\n        1,\n        2,\n        3,\n        4\n    ];\n    if (filter != -1) ftry = [\n        filter\n    ];\n    else if (h * bpl > 500000 || bpp == 1) ftry = [\n        0\n    ];\n    var opts;\n    if (levelZero) opts = {\n        level: 0\n    };\n    var CMPR = levelZero && UZIP != null ? UZIP : (pako__WEBPACK_IMPORTED_MODULE_0___default());\n    for(var i = 0; i < ftry.length; i++){\n        for(var y = 0; y < h; y++)UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);\n        //var nimg = new Uint8Array(data.length);\n        //var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n        //var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n        //var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n        //console.log(crc, UZIP.adler(data,2,data.length-6));\n        fls.push(CMPR[\"deflate\"](data, opts));\n    }\n    var ti, tsize = 1e9;\n    for(var i = 0; i < fls.length; i++)if (fls[i].length < tsize) {\n        ti = i;\n        tsize = fls[i].length;\n    }\n    return fls[ti];\n};\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type) {\n    var i = y * bpl, di = i + y, paeth = UPNG.decode._paeth;\n    data[di] = type;\n    di++;\n    if (type == 0) {\n        if (bpl < 500) for(var x = 0; x < bpl; x++)data[di + x] = img[i + x];\n        else data.set(new Uint8Array(img.buffer, i, bpl), di);\n    } else if (type == 1) {\n        for(var x = 0; x < bpp; x++)data[di + x] = img[i + x];\n        for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] - img[i + x - bpp] + 256 & 255;\n    } else if (y == 0) {\n        for(var x = 0; x < bpp; x++)data[di + x] = img[i + x];\n        if (type == 2) for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x];\n        if (type == 3) for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] - (img[i + x - bpp] >> 1) + 256 & 255;\n        if (type == 4) for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256 & 255;\n    } else {\n        if (type == 2) {\n            for(var x = 0; x < bpl; x++)data[di + x] = img[i + x] + 256 - img[i + x - bpl] & 255;\n        }\n        if (type == 3) {\n            for(var x = 0; x < bpp; x++)data[di + x] = img[i + x] + 256 - (img[i + x - bpl] >> 1) & 255;\n            for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] + 256 - (img[i + x - bpl] + img[i + x - bpp] >> 1) & 255;\n        }\n        if (type == 4) {\n            for(var x = 0; x < bpp; x++)data[di + x] = img[i + x] + 256 - paeth(0, img[i + x - bpl], 0) & 255;\n            for(var x = bpp; x < bpl; x++)data[di + x] = img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl]) & 255;\n        }\n    }\n};\nUPNG.crc = {\n    table: function() {\n        var tab = new Uint32Array(256);\n        for(var n = 0; n < 256; n++){\n            var c = n;\n            for(var k = 0; k < 8; k++){\n                if (c & 1) c = 0xedb88320 ^ c >>> 1;\n                else c = c >>> 1;\n            }\n            tab[n] = c;\n        }\n        return tab;\n    }(),\n    update: function(c, buf, off, len) {\n        for(var i = 0; i < len; i++)c = UPNG.crc.table[(c ^ buf[off + i]) & 0xff] ^ c >>> 8;\n        return c;\n    },\n    crc: function(b, o, l) {\n        return UPNG.crc.update(0xffffffff, b, o, l) ^ 0xffffffff;\n    }\n};\nUPNG.quantize = function(abuf, ps) {\n    var oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);\n    var KD = UPNG.quantize.getKDtree(nimg, ps);\n    var root = KD[0], leafs = KD[1];\n    var planeDst = UPNG.quantize.planeDst;\n    var sb = oimg, tb = nimg32, len = sb.length;\n    var inds = new Uint8Array(oimg.length >> 2);\n    for(var i = 0; i < len; i += 4){\n        var r = sb[i] * (1 / 255), g = sb[i + 1] * (1 / 255), b = sb[i + 2] * (1 / 255), a = sb[i + 3] * (1 / 255);\n        //  exact, but too slow :(\n        var nd = UPNG.quantize.getNearest(root, r, g, b, a);\n        //var nd = root;\n        //while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n        inds[i >> 2] = nd.ind;\n        tb[i >> 2] = nd.est.rgba;\n    }\n    return {\n        abuf: nimg.buffer,\n        inds: inds,\n        plte: leafs\n    };\n};\nUPNG.quantize.getKDtree = function(nimg, ps, err) {\n    if (err == null) err = 0.0001;\n    var nimg32 = new Uint32Array(nimg.buffer);\n    var root = {\n        i0: 0,\n        i1: nimg.length,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n    }; // basic statistic, extra statistic\n    root.bst = UPNG.quantize.stats(nimg, root.i0, root.i1);\n    root.est = UPNG.quantize.estats(root.bst);\n    var leafs = [\n        root\n    ];\n    while(leafs.length < ps){\n        var maxL = 0, mi = 0;\n        for(var i = 0; i < leafs.length; i++)if (leafs[i].est.L > maxL) {\n            maxL = leafs[i].est.L;\n            mi = i;\n        }\n        if (maxL < err) break;\n        var node = leafs[mi];\n        var s0 = UPNG.quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n        var s0wrong = node.i0 >= s0 || node.i1 <= s0;\n        //console.log(maxL, leafs.length, mi);\n        if (s0wrong) {\n            node.est.L = 0;\n            continue;\n        }\n        var ln = {\n            i0: node.i0,\n            i1: s0,\n            bst: null,\n            est: null,\n            tdst: 0,\n            left: null,\n            right: null\n        };\n        ln.bst = UPNG.quantize.stats(nimg, ln.i0, ln.i1);\n        ln.est = UPNG.quantize.estats(ln.bst);\n        var rn = {\n            i0: s0,\n            i1: node.i1,\n            bst: null,\n            est: null,\n            tdst: 0,\n            left: null,\n            right: null\n        };\n        rn.bst = {\n            R: [],\n            m: [],\n            N: node.bst.N - ln.bst.N\n        };\n        for(var i = 0; i < 16; i++)rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];\n        for(var i = 0; i < 4; i++)rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];\n        rn.est = UPNG.quantize.estats(rn.bst);\n        node.left = ln;\n        node.right = rn;\n        leafs[mi] = ln;\n        leafs.push(rn);\n    }\n    leafs.sort(function(a, b) {\n        return b.bst.N - a.bst.N;\n    });\n    for(var i = 0; i < leafs.length; i++)leafs[i].ind = i;\n    return [\n        root,\n        leafs\n    ];\n};\nUPNG.quantize.getNearest = function(nd, r, g, b, a) {\n    if (nd.left == null) {\n        nd.tdst = UPNG.quantize.dist(nd.est.q, r, g, b, a);\n        return nd;\n    }\n    var planeDst = UPNG.quantize.planeDst(nd.est, r, g, b, a);\n    var node0 = nd.left, node1 = nd.right;\n    if (planeDst > 0) {\n        node0 = nd.right;\n        node1 = nd.left;\n    }\n    var ln = UPNG.quantize.getNearest(node0, r, g, b, a);\n    if (ln.tdst <= planeDst * planeDst) return ln;\n    var rn = UPNG.quantize.getNearest(node1, r, g, b, a);\n    return rn.tdst < ln.tdst ? rn : ln;\n};\nUPNG.quantize.planeDst = function(est, r, g, b, a) {\n    var e = est.e;\n    return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;\n};\nUPNG.quantize.dist = function(q, r, g, b, a) {\n    var d0 = r - q[0], d1 = g - q[1], d2 = b - q[2], d3 = a - q[3];\n    return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;\n};\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq) {\n    var vecDot = UPNG.quantize.vecDot;\n    i1 -= 4;\n    var shfs = 0;\n    while(i0 < i1){\n        while(vecDot(nimg, i0, e) <= eMq)i0 += 4;\n        while(vecDot(nimg, i1, e) > eMq)i1 -= 4;\n        if (i0 >= i1) break;\n        var t = nimg32[i0 >> 2];\n        nimg32[i0 >> 2] = nimg32[i1 >> 2];\n        nimg32[i1 >> 2] = t;\n        i0 += 4;\n        i1 -= 4;\n    }\n    while(vecDot(nimg, i0, e) > eMq)i0 -= 4;\n    return i0 + 4;\n};\nUPNG.quantize.vecDot = function(nimg, i, e) {\n    return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];\n};\nUPNG.quantize.stats = function(nimg, i0, i1) {\n    var R = [\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n    var m = [\n        0,\n        0,\n        0,\n        0\n    ];\n    var N = i1 - i0 >> 2;\n    for(var i = i0; i < i1; i += 4){\n        var r = nimg[i] * (1 / 255), g = nimg[i + 1] * (1 / 255), b = nimg[i + 2] * (1 / 255), a = nimg[i + 3] * (1 / 255);\n        //var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n        m[0] += r;\n        m[1] += g;\n        m[2] += b;\n        m[3] += a;\n        R[0] += r * r;\n        R[1] += r * g;\n        R[2] += r * b;\n        R[3] += r * a;\n        R[5] += g * g;\n        R[6] += g * b;\n        R[7] += g * a;\n        R[10] += b * b;\n        R[11] += b * a;\n        R[15] += a * a;\n    }\n    R[4] = R[1];\n    R[8] = R[2];\n    R[9] = R[6];\n    R[12] = R[3];\n    R[13] = R[7];\n    R[14] = R[11];\n    return {\n        R: R,\n        m: m,\n        N: N\n    };\n};\nUPNG.quantize.estats = function(stats) {\n    var R = stats.R, m = stats.m, N = stats.N;\n    // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n    var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = N == 0 ? 0 : 1 / N;\n    var Rj = [\n        R[0] - m0 * m0 * iN,\n        R[1] - m0 * m1 * iN,\n        R[2] - m0 * m2 * iN,\n        R[3] - m0 * m3 * iN,\n        R[4] - m1 * m0 * iN,\n        R[5] - m1 * m1 * iN,\n        R[6] - m1 * m2 * iN,\n        R[7] - m1 * m3 * iN,\n        R[8] - m2 * m0 * iN,\n        R[9] - m2 * m1 * iN,\n        R[10] - m2 * m2 * iN,\n        R[11] - m2 * m3 * iN,\n        R[12] - m3 * m0 * iN,\n        R[13] - m3 * m1 * iN,\n        R[14] - m3 * m2 * iN,\n        R[15] - m3 * m3 * iN\n    ];\n    var A = Rj, M = UPNG.M4;\n    var b = [\n        0.5,\n        0.5,\n        0.5,\n        0.5\n    ], mi = 0, tmi = 0;\n    if (N != 0) for(var i = 0; i < 10; i++){\n        b = M.multVec(A, b);\n        tmi = Math.sqrt(M.dot(b, b));\n        b = M.sml(1 / tmi, b);\n        if (Math.abs(tmi - mi) < 1e-9) break;\n        mi = tmi;\n    }\n    //b = [0,0,1,0];  mi=N;\n    var q = [\n        m0 * iN,\n        m1 * iN,\n        m2 * iN,\n        m3 * iN\n    ];\n    var eMq255 = M.dot(M.sml(255, q), b);\n    return {\n        Cov: Rj,\n        q: q,\n        e: b,\n        L: mi,\n        eMq255: eMq255,\n        eMq: M.dot(b, q),\n        rgba: (Math.round(255 * q[3]) << 24 | Math.round(255 * q[2]) << 16 | Math.round(255 * q[1]) << 8 | Math.round(255 * q[0]) << 0) >>> 0\n    };\n};\nUPNG.M4 = {\n    multVec: function(m, v) {\n        return [\n            m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],\n            m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],\n            m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],\n            m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]\n        ];\n    },\n    dot: function(x, y) {\n        return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];\n    },\n    sml: function(a, y) {\n        return [\n            a * y[0],\n            a * y[1],\n            a * y[2],\n            a * y[3]\n        ];\n    }\n};\nUPNG.encode.concatRGBA = function(bufs) {\n    var tlen = 0;\n    for(var i = 0; i < bufs.length; i++)tlen += bufs[i].byteLength;\n    var nimg = new Uint8Array(tlen), noff = 0;\n    for(var i = 0; i < bufs.length; i++){\n        var img = new Uint8Array(bufs[i]), il = img.length;\n        for(var j = 0; j < il; j += 4){\n            var r = img[j], g = img[j + 1], b = img[j + 2], a = img[j + 3];\n            if (a == 0) r = g = b = 0;\n            nimg[noff + j] = r;\n            nimg[noff + j + 1] = g;\n            nimg[noff + j + 2] = b;\n            nimg[noff + j + 3] = a;\n        }\n        noff += il;\n    }\n    return nimg.buffer;\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UPNG);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9VUE5HLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3QjtBQUV4QixJQUFJQyxPQUFPLENBQUM7QUFJWkEsS0FBS0MsT0FBTyxHQUFHLFNBQVNDLEdBQUc7SUFFMUIsSUFBSUMsSUFBSUQsSUFBSUUsS0FBSyxFQUFFQyxJQUFJSCxJQUFJSSxNQUFNO0lBQ2pDLElBQUdKLElBQUlLLElBQUksQ0FBQ0MsSUFBSSxJQUFFLE1BQU0sT0FBTztRQUFDUixLQUFLQyxPQUFPLENBQUNRLFdBQVcsQ0FBQ1AsSUFBSVEsSUFBSSxFQUFFUCxHQUFHRSxHQUFHSCxLQUFLUyxNQUFNO0tBQUM7SUFFckYsSUFBSUMsT0FBTyxFQUFFO0lBQ2IsSUFBR1YsSUFBSVcsTUFBTSxDQUFDLEVBQUUsQ0FBQ0gsSUFBSSxJQUFFLE1BQU1SLElBQUlXLE1BQU0sQ0FBQyxFQUFFLENBQUNILElBQUksR0FBR1IsSUFBSVEsSUFBSTtJQUUxRCxJQUFJSSxNQUFNWCxJQUFFRSxJQUFFLEdBQUdVLE1BQU0sSUFBSUMsV0FBV0YsTUFBTUcsUUFBUSxJQUFJRCxXQUFXRixNQUFNSSxPQUFLLElBQUlGLFdBQVdGO0lBQzdGLElBQUksSUFBSUssSUFBRSxHQUFHQSxJQUFFakIsSUFBSVcsTUFBTSxDQUFDTyxNQUFNLEVBQUVELElBQ2xDO1FBQ0MsSUFBSUUsTUFBTW5CLElBQUlXLE1BQU0sQ0FBQ00sRUFBRTtRQUN2QixJQUFJRyxLQUFHRCxJQUFJRSxJQUFJLENBQUNDLENBQUMsRUFBRUMsS0FBR0osSUFBSUUsSUFBSSxDQUFDRyxDQUFDLEVBQUVDLEtBQUtOLElBQUlFLElBQUksQ0FBQ25CLEtBQUssRUFBRXdCLEtBQUtQLElBQUlFLElBQUksQ0FBQ2pCLE1BQU07UUFDM0UsSUFBSXVCLFFBQVE3QixLQUFLQyxPQUFPLENBQUNRLFdBQVcsQ0FBQ1ksSUFBSVgsSUFBSSxFQUFFaUIsSUFBR0MsSUFBSTFCO1FBRXRELElBQUdpQixLQUFHLEdB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QUMsU0FBU2YsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFNLENBQUNGLENBQUMsQ0FBQ0MsTUFBSSxFQUFFLEdBQUNELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLE9BQU1BLENBQUFBLElBQUUsS0FBRyxDQUFDLEtBQUdDLENBQUFBLElBQUc7SUFBQztJQUMxSkgsRUFBRUEsQ0FBQyxDQUFDYyxDQUFDLEdBQUMsU0FBU2IsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFNLENBQUNGLENBQUMsQ0FBQ0MsTUFBSSxFQUFFLEdBQUNELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLElBQUVELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLEVBQUMsTUFBTUEsQ0FBQUEsSUFBRSxLQUFHLENBQUMsS0FBR0MsQ0FBQUEsSUFBRztJQUFDO0lBQUVILEVBQUVBLENBQUMsQ0FBQ29CLENBQUMsR0FBQyxTQUFTbkIsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsT0FBTSxDQUFDRCxDQUFDLENBQUNDLE1BQUksRUFBRSxHQUFDRCxDQUFDLENBQUMsQ0FBQ0MsTUFBSSxLQUFHLEVBQUUsSUFBRSxJQUFFRCxDQUFDLENBQUMsQ0FBQ0MsTUFBSSxLQUFHLEVBQUUsSUFBRSxFQUFDLE1BQU1BLENBQUFBLElBQUU7SUFBRTtJQUN2S0YsRUFBRUEsQ0FBQyxDQUFDOUYsQ0FBQyxHQUFDLFNBQVMrRixDQUFDLEVBQUNDLENBQUM7UUFBRSxPQUFNLENBQUNELENBQUMsQ0FBQ0MsTUFBSSxFQUFFLEdBQUNELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLElBQUVELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLEtBQUdELENBQUMsQ0FBQyxDQUFDQyxNQUFJLEtBQUcsRUFBRSxJQUFFLEVBQUMsTUFBTUEsQ0FBQUEsSUFBRTtJQUFFO0lBQUVGLEVBQUVBLENBQUMsQ0FBQ0ksQ0FBQyxHQUFDO1FBQVcsSUFB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ZHVsZXMvQHBkZi1saWIvdXBuZy9VUE5HLmpzP2I4YWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBha28gZnJvbSAncGFrbyc7XG5cbnZhciBVUE5HID0ge307XG5cblx0XG5cblVQTkcudG9SR0JBOCA9IGZ1bmN0aW9uKG91dClcbntcblx0dmFyIHcgPSBvdXQud2lkdGgsIGggPSBvdXQuaGVpZ2h0O1xuXHRpZihvdXQudGFicy5hY1RMPT1udWxsKSByZXR1cm4gW1VQTkcudG9SR0JBOC5kZWNvZGVJbWFnZShvdXQuZGF0YSwgdywgaCwgb3V0KS5idWZmZXJdO1xuXHRcblx0dmFyIGZybXMgPSBbXTtcblx0aWYob3V0LmZyYW1lc1swXS5kYXRhPT1udWxsKSBvdXQuZnJhbWVzWzBdLmRhdGEgPSBvdXQuZGF0YTtcblx0XG5cdHZhciBsZW4gPSB3KmgqNCwgaW1nID0gbmV3IFVpbnQ4QXJyYXkobGVuKSwgZW1wdHkgPSBuZXcgVWludDhBcnJheShsZW4pLCBwcmV2PW5ldyBVaW50OEFycmF5KGxlbik7XG5cdGZvcih2YXIgaT0wOyBpPG91dC5mcmFtZXMubGVuZ3RoOyBpKyspXG5cdHtcblx0XHR2YXIgZnJtID0gb3V0LmZyYW1lc1tpXTtcblx0XHR2YXIgZng9ZnJtLnJlY3QueCwgZnk9ZnJtLnJlY3QueSwgZncgPSBmcm0ucmVjdC53aWR0aCwgZmggPSBmcm0ucmVjdC5oZWlnaHQ7XG5cdFx0dmFyIGZkYXRhID0gVVBORy50b1JHQkE4LmRlY29kZUltYWdlKGZybS5kYXRhLCBmdyxmaCwgb3V0KTtcblx0XHRcblx0XHRpZihpIT0wKSBmb3IodmFyIGo9MDsgajxsZW47IGorKykgcHJldltqXT1pbWdbal07XG5cdFx0XG5cdFx0aWYgICAgIChmcm0uYmxlbmQ9PTApIFVQTkcuX2NvcHlUaWxlKGZkYXRhLCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAwKTtcblx0XHRlbHNlIGlmKGZybS5ibGVuZD09MSkgVVBORy5fY29weVRpbGUoZmRhdGEsIGZ3LCBmaCwgaW1nLCB3LCBoLCBmeCwgZnksIDEpO1xuXHRcdFxuXHRcdGZybXMucHVzaChpbWcuYnVmZmVyLnNsaWNlKDApKTtcblx0XHRcblx0XHRpZiAgICAgKGZybS5kaXNwb3NlPT0wKSB7fVxuXHRcdGVsc2UgaWYoZnJtLmRpc3Bvc2U9PTEpIFVQTkcuX2NvcHlUaWxlKGVtcHR5LCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAwKTtcblx0XHRlbHNlIGlmKGZybS5kaXNwb3NlPT0yKSBmb3IodmFyIGo9MDsgajxsZW47IGorKykgaW1nW2pdPXByZXZbal07XG5cdH1cblx0cmV0dXJuIGZybXM7XG59XG5VUE5HLnRvUkdCQTguZGVjb2RlSW1hZ2UgPSBmdW5jdGlvbihkYXRhLCB3LCBoLCBvdXQpXG57XG5cdHZhciBhcmVhID0gdypoLCBicHAgPSBVUE5HLmRlY29kZS5fZ2V0QlBQKG91dCk7XG5cdHZhciBicGwgPSBNYXRoLmNlaWwodypicHAvOCk7XHQvLyBieXRlcyBwZXIgbGluZVxuXG5cdHZhciBiZiA9IG5ldyBVaW50OEFycmF5KGFyZWEqNCksIGJmMzIgPSBuZXcgVWludDMyQXJyYXkoYmYuYnVmZmVyKTtcblx0dmFyIGN0eXBlID0gb3V0LmN0eXBlLCBkZXB0aCA9IG91dC5kZXB0aDtcblx0dmFyIHJzID0gVVBORy5fYmluLnJlYWRVc2hvcnQ7XG5cdFxuXHQvL2NvbnNvbGUubG9nKGN0eXBlLCBkZXB0aCk7XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblxuXHRpZiAgICAgKGN0eXBlPT02KSB7IC8vIFJHQiArIGFscGhhXG5cdFx0dmFyIHFhcmVhID0gYXJlYTw8Mjtcblx0XHRpZihkZXB0aD09IDgpIGZvcih2YXIgaT0wOyBpPHFhcmVhO2krPTQpIHsgIGJmW2ldID0gZGF0YVtpXTsgIGJmW2krMV0gPSBkYXRhW2krMV07ICBiZltpKzJdID0gZGF0YVtpKzJdOyAgYmZbaSszXSA9IGRhdGFbaSszXTsgfVxuXHRcdGlmKGRlcHRoPT0xNikgZm9yKHZhciBpPTA7IGk8cWFyZWE7aSsrICkgeyAgYmZbaV0gPSBkYXRhW2k8PDFdOyAgfVxuXHR9XG5cdGVsc2UgaWYoY3R5cGU9PTIpIHtcdC8vIFJHQlxuXHRcdHZhciB0cz1vdXQudGFic1tcInRSTlNcIl07XG5cdFx0aWYodHM9PW51bGwpIHtcblx0XHRcdGlmKGRlcHRoPT0gOCkgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgdGk9aSozOyAgYmYzMltpXSA9ICgyNTU8PDI0KXwoZGF0YVt0aSsyXTw8MTYpfChkYXRhW3RpKzFdPDw4KXxkYXRhW3RpXTsgIH1cblx0XHRcdGlmKGRlcHRoPT0xNikgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgdGk9aSo2OyAgYmYzMltpXSA9ICgyNTU8PDI0KXwoZGF0YVt0aSs0XTw8MTYpfChkYXRhW3RpKzJdPDw4KXxkYXRhW3RpXTsgIH1cblx0XHR9XG5cdFx0ZWxzZSB7ICB2YXIgdHI9dHNbMF0sIHRnPXRzWzFdLCB0Yj10c1syXTtcblx0XHRcdGlmKGRlcHRoPT0gOCkgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgcWk9aTw8MiwgdGk9aSozOyAgYmYzMltpXSA9ICgyNTU8PDI0KXwoZGF0YVt0aSsyXTw8MTYpfChkYXRhW3RpKzFdPDw4KXxkYXRhW3RpXTtcblx0XHRcdFx0aWYoZGF0YVt0aV0gICA9PXRyICYmIGRhdGFbdGkrMV0gICA9PXRnICYmIGRhdGFbdGkrMl0gICA9PXRiKSBiZltxaSszXSA9IDA7ICB9XG5cdFx0XHRpZihkZXB0aD09MTYpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIHRpPWkqNjsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrNF08PDE2KXwoZGF0YVt0aSsyXTw8OCl8ZGF0YVt0aV07XG5cdFx0XHRcdGlmKHJzKGRhdGEsdGkpPT10ciAmJiBycyhkYXRhLHRpKzIpPT10ZyAmJiBycyhkYXRhLHRpKzQpPT10YikgYmZbcWkrM10gPSAwOyAgfVxuXHRcdH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT0zKSB7XHQvLyBwYWxldHRlXG5cdFx0dmFyIHA9b3V0LnRhYnNbXCJQTFRFXCJdLCBhcD1vdXQudGFic1tcInRSTlNcIl0sIHRsPWFwP2FwLmxlbmd0aDowO1xuXHRcdC8vY29uc29sZS5sb2cocCwgYXApO1xuXHRcdGlmKGRlcHRoPT0xKSBmb3IodmFyIHk9MDsgeTxoOyB5KyspIHsgIHZhciBzMCA9IHkqYnBsLCB0MCA9IHkqdztcblx0XHRcdGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyB2YXIgcWk9KHQwK2kpPDwyLCBqPSgoZGF0YVtzMCsoaT4+MyldPj4oNy0oKGkmNyk8PDApKSkmIDEpLCBjaj0zKmo7ICBiZltxaV09cFtjal07ICBiZltxaSsxXT1wW2NqKzFdOyAgYmZbcWkrMl09cFtjaisyXTsgIGJmW3FpKzNdPShqPHRsKT9hcFtqXToyNTU7ICB9XG5cdFx0fVxuXHRcdGlmKGRlcHRoPT0yKSBmb3IodmFyIHk9MDsgeTxoOyB5KyspIHsgIHZhciBzMCA9IHkqYnBsLCB0MCA9IHkqdztcblx0XHRcdGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyB2YXIgcWk9KHQwK2kpPDwyLCBqPSgoZGF0YVtzMCsoaT4+MildPj4oNi0oKGkmMyk8PDEpKSkmIDMpLCBjaj0zKmo7ICBiZltxaV09cFtjal07ICBiZltxaSsxXT1wW2NqKzFdOyAgYmZbcWkrMl09cFtjaisyXTsgIGJmW3FpKzNdPShqPHRsKT9hcFtqXToyNTU7ICB9XG5cdFx0fVxuXHRcdGlmKGRlcHRoPT00KSBmb3IodmFyIHk9MDsgeTxoOyB5KyspIHsgIHZhciBzMCA9IHkqYnBsLCB0MCA9IHkqdztcblx0XHRcdGZvcih2YXIgaT0wOyBpPHc7IGkrKykgeyB2YXIgcWk9KHQwK2kpPDwyLCBqPSgoZGF0YVtzMCsoaT4+MSldPj4oNC0oKGkmMSk8PDIpKSkmMTUpLCBjaj0zKmo7ICBiZltxaV09cFtjal07ICBiZltxaSsxXT1wW2NqKzFdOyAgYmZbcWkrMl09cFtjaisyXTsgIGJmW3FpKzNdPShqPHRsKT9hcFtqXToyNTU7ICB9XG5cdFx0fVxuXHRcdGlmKGRlcHRoPT04KSBmb3IodmFyIGk9MDsgaTxhcmVhOyBpKysgKSB7ICB2YXIgcWk9aTw8Miwgaj1kYXRhW2ldICAgICAgICAgICAgICAgICAgICAgICwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHR9XG5cdGVsc2UgaWYoY3R5cGU9PTQpIHtcdC8vIGdyYXkgKyBhbHBoYVxuXHRcdGlmKGRlcHRoPT0gOCkgIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIGRpPWk8PDEsIGdyPWRhdGFbZGldOyAgYmZbcWldPWdyOyAgYmZbcWkrMV09Z3I7ICBiZltxaSsyXT1ncjsgIGJmW3FpKzNdPWRhdGFbZGkrMV07ICB9XG5cdFx0aWYoZGVwdGg9PTE2KSAgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7ICB2YXIgcWk9aTw8MiwgZGk9aTw8MiwgZ3I9ZGF0YVtkaV07ICBiZltxaV09Z3I7ICBiZltxaSsxXT1ncjsgIGJmW3FpKzJdPWdyOyAgYmZbcWkrM109ZGF0YVtkaSsyXTsgIH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT0wKSB7XHQvLyBncmF5XG5cdFx0dmFyIHRyID0gb3V0LnRhYnNbXCJ0Uk5TXCJdID8gb3V0LnRhYnNbXCJ0Uk5TXCJdIDogLTE7XG5cdFx0Zm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7XG5cdFx0XHR2YXIgb2ZmID0geSpicGwsIHRvID0geSp3O1xuXHRcdFx0aWYgICAgIChkZXB0aD09IDEpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPTI1NSooKGRhdGFbb2ZmKyh4Pj4+MyldPj4+KDcgLSgoeCY3KSAgICkpKSYgMSksIGFsPShncj09dHIqMjU1KT8wOjI1NTsgIGJmMzJbdG8reF09KGFsPDwyNCl8KGdyPDwxNil8KGdyPDw4KXxncjsgIH1cblx0XHRcdGVsc2UgaWYoZGVwdGg9PSAyKSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHsgIHZhciBncj0gODUqKChkYXRhW29mZisoeD4+PjIpXT4+Pig2IC0oKHgmMyk8PDEpKSkmIDMpLCBhbD0oZ3I9PXRyKiA4NSk/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0XHRlbHNlIGlmKGRlcHRoPT0gNCkgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7ICB2YXIgZ3I9IDE3KigoZGF0YVtvZmYrKHg+Pj4xKV0+Pj4oNCAtKCh4JjEpPDwyKSkpJjE1KSwgYWw9KGdyPT10ciogMTcpPzA6MjU1OyAgYmYzMlt0byt4XT0oYWw8PDI0KXwoZ3I8PDE2KXwoZ3I8PDgpfGdyOyAgfVxuXHRcdFx0ZWxzZSBpZihkZXB0aD09IDgpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPWRhdGFbb2ZmKyAgICAgeF0sIGFsPShnciAgICAgICAgICAgICAgICAgPT10cik/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0XHRlbHNlIGlmKGRlcHRoPT0xNikgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7ICB2YXIgZ3I9ZGF0YVtvZmYrKHg8PDEpXSwgYWw9KHJzKGRhdGEsb2ZmKyh4PDxpKSk9PXRyKT8wOjI1NTsgIGJmMzJbdG8reF09KGFsPDwyNCl8KGdyPDwxNil8KGdyPDw4KXxncjsgIH1cblx0XHR9XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhEYXRlLm5vdygpLXRpbWUpO1xuXHRyZXR1cm4gYmY7XG59XG5cblxuXG5VUE5HLmRlY29kZSA9IGZ1bmN0aW9uKGJ1ZmYpXG57XG5cdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZiksIG9mZnNldCA9IDgsIGJpbiA9IFVQTkcuX2JpbiwgclVzID0gYmluLnJlYWRVc2hvcnQsIHJVaSA9IGJpbi5yZWFkVWludDtcblx0dmFyIG91dCA9IHt0YWJzOnt9LCBmcmFtZXM6W119O1xuXHR2YXIgZGQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCksIGRvZmYgPSAwO1x0IC8vIHB1dCBhbGwgSURBVCBkYXRhIGludG8gaXRcblx0dmFyIGZkLCBmb2ZmID0gMDtcdC8vIGZyYW1lc1xuXHRcblx0dmFyIG1nY2sgPSBbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV07XG5cdGZvcih2YXIgaT0wOyBpPDg7IGkrKykgaWYoZGF0YVtpXSE9bWdja1tpXSkgdGhyb3cgXCJUaGUgaW5wdXQgaXMgbm90IGEgUE5HIGZpbGUhXCI7XG5cblx0d2hpbGUob2Zmc2V0PGRhdGEubGVuZ3RoKVxuXHR7XG5cdFx0dmFyIGxlbiAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXHRcdHZhciB0eXBlID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIDQpOyAgb2Zmc2V0ICs9IDQ7XG5cdFx0Ly9jb25zb2xlLmxvZyh0eXBlLGxlbik7XG5cdFx0XG5cdFx0aWYgICAgICh0eXBlPT1cIklIRFJcIikgIHsgIFVQTkcuZGVjb2RlLl9JSERSKGRhdGEsIG9mZnNldCwgb3V0KTsgIH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiSURBVFwiKSB7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW47IGkrKykgZGRbZG9mZitpXSA9IGRhdGFbb2Zmc2V0K2ldO1xuXHRcdFx0ZG9mZiArPSBsZW47XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJhY1RMXCIpICB7XG5cdFx0XHRvdXQudGFic1t0eXBlXSA9IHsgIG51bV9mcmFtZXM6clVpKGRhdGEsIG9mZnNldCksIG51bV9wbGF5czpyVWkoZGF0YSwgb2Zmc2V0KzQpICB9O1xuXHRcdFx0ZmQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJmY1RMXCIpICB7XG5cdFx0XHRpZihmb2ZmIT0wKSB7ICB2YXIgZnIgPSBvdXQuZnJhbWVzW291dC5mcmFtZXMubGVuZ3RoLTFdO1xuXHRcdFx0XHRmci5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBmZC5zbGljZSgwLGZvZmYpLCBmci5yZWN0LndpZHRoLCBmci5yZWN0LmhlaWdodCk7ICBmb2ZmPTA7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcmN0ID0ge3g6clVpKGRhdGEsIG9mZnNldCsxMikseTpyVWkoZGF0YSwgb2Zmc2V0KzE2KSx3aWR0aDpyVWkoZGF0YSwgb2Zmc2V0KzQpLGhlaWdodDpyVWkoZGF0YSwgb2Zmc2V0KzgpfTtcblx0XHRcdHZhciBkZWwgPSByVXMoZGF0YSwgb2Zmc2V0KzIyKTsgIGRlbCA9IHJVcyhkYXRhLCBvZmZzZXQrMjApIC8gKGRlbD09MD8xMDA6ZGVsKTtcblx0XHRcdHZhciBmcm0gPSB7cmVjdDpyY3QsIGRlbGF5Ok1hdGgucm91bmQoZGVsKjEwMDApLCBkaXNwb3NlOmRhdGFbb2Zmc2V0KzI0XSwgYmxlbmQ6ZGF0YVtvZmZzZXQrMjVdfTtcblx0XHRcdC8vY29uc29sZS5sb2coZnJtKTtcblx0XHRcdG91dC5mcmFtZXMucHVzaChmcm0pO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiZmRBVFwiKSB7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxsZW4tNDsgaSsrKSBmZFtmb2ZmK2ldID0gZGF0YVtvZmZzZXQraSs0XTtcblx0XHRcdGZvZmYgKz0gbGVuLTQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJwSFlzXCIpIHtcblx0XHRcdG91dC50YWJzW3R5cGVdID0gW2Jpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpLCBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KzQpLCBkYXRhW29mZnNldCs4XV07XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJjSFJNXCIpIHtcblx0XHRcdG91dC50YWJzW3R5cGVdID0gW107XG5cdFx0XHRmb3IodmFyIGk9MDsgaTw4OyBpKyspIG91dC50YWJzW3R5cGVdLnB1c2goYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCtpKjQpKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cInRFWHRcIikge1xuXHRcdFx0aWYob3V0LnRhYnNbdHlwZV09PW51bGwpIG91dC50YWJzW3R5cGVdID0ge307XG5cdFx0XHR2YXIgbnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2Zmc2V0KTtcblx0XHRcdHZhciBrZXl3ID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmZzZXQsIG56LW9mZnNldCk7XG5cdFx0XHR2YXIgdGV4dCA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgbnorMSwgb2Zmc2V0K2xlbi1uei0xKTtcblx0XHRcdG91dC50YWJzW3R5cGVdW2tleXddID0gdGV4dDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImlUWHRcIikge1xuXHRcdFx0aWYob3V0LnRhYnNbdHlwZV09PW51bGwpIG91dC50YWJzW3R5cGVdID0ge307XG5cdFx0XHR2YXIgbnogPSAwLCBvZmYgPSBvZmZzZXQ7XG5cdFx0XHRueiA9IGJpbi5uZXh0WmVybyhkYXRhLCBvZmYpO1xuXHRcdFx0dmFyIGtleXcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZiwgbnotb2ZmKTsgIG9mZiA9IG56ICsgMTtcblx0XHRcdHZhciBjZmxhZyA9IGRhdGFbb2ZmXSwgY21ldGggPSBkYXRhW29mZisxXTsgIG9mZis9Mjtcblx0XHRcdG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZik7XG5cdFx0XHR2YXIgbHRhZyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2ZmLCBuei1vZmYpOyAgb2ZmID0gbnogKyAxO1xuXHRcdFx0bnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2ZmKTtcblx0XHRcdHZhciB0a2V5dyA9IGJpbi5yZWFkVVRGOChkYXRhLCBvZmYsIG56LW9mZik7ICBvZmYgPSBueiArIDE7XG5cdFx0XHR2YXIgdGV4dCAgPSBiaW4ucmVhZFVURjgoZGF0YSwgb2ZmLCBsZW4tKG9mZi1vZmZzZXQpKTtcblx0XHRcdG91dC50YWJzW3R5cGVdW2tleXddID0gdGV4dDtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cIlBMVEVcIikge1xuXHRcdFx0b3V0LnRhYnNbdHlwZV0gPSBiaW4ucmVhZEJ5dGVzKGRhdGEsIG9mZnNldCwgbGVuKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImhJU1RcIikge1xuXHRcdFx0dmFyIHBsID0gb3V0LnRhYnNbXCJQTFRFXCJdLmxlbmd0aC8zO1xuXHRcdFx0b3V0LnRhYnNbdHlwZV0gPSBbXTsgIGZvcih2YXIgaT0wOyBpPHBsOyBpKyspIG91dC50YWJzW3R5cGVdLnB1c2goclVzKGRhdGEsIG9mZnNldCtpKjIpKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cInRSTlNcIikge1xuXHRcdFx0aWYgICAgIChvdXQuY3R5cGU9PTMpIG91dC50YWJzW3R5cGVdID0gYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQsIGxlbik7XG5cdFx0XHRlbHNlIGlmKG91dC5jdHlwZT09MCkgb3V0LnRhYnNbdHlwZV0gPSByVXMoZGF0YSwgb2Zmc2V0KTtcblx0XHRcdGVsc2UgaWYob3V0LmN0eXBlPT0yKSBvdXQudGFic1t0eXBlXSA9IFsgclVzKGRhdGEsb2Zmc2V0KSxyVXMoZGF0YSxvZmZzZXQrMiksclVzKGRhdGEsb2Zmc2V0KzQpIF07XG5cdFx0XHQvL2Vsc2UgY29uc29sZS5sb2coXCJ0Uk5TIGZvciB1bnN1cHBvcnRlZCBjb2xvciB0eXBlXCIsb3V0LmN0eXBlLCBsZW4pO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiZ0FNQVwiKSBvdXQudGFic1t0eXBlXSA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpLzEwMDAwMDtcblx0XHRlbHNlIGlmKHR5cGU9PVwic1JHQlwiKSBvdXQudGFic1t0eXBlXSA9IGRhdGFbb2Zmc2V0XTtcblx0XHRlbHNlIGlmKHR5cGU9PVwiYktHRFwiKVxuXHRcdHtcblx0XHRcdGlmICAgICAob3V0LmN0eXBlPT0wIHx8IG91dC5jdHlwZT09NCkgb3V0LnRhYnNbdHlwZV0gPSBbclVzKGRhdGEsIG9mZnNldCldO1xuXHRcdFx0ZWxzZSBpZihvdXQuY3R5cGU9PTIgfHwgb3V0LmN0eXBlPT02KSBvdXQudGFic1t0eXBlXSA9IFtyVXMoZGF0YSwgb2Zmc2V0KSwgclVzKGRhdGEsIG9mZnNldCsyKSwgclVzKGRhdGEsIG9mZnNldCs0KV07XG5cdFx0XHRlbHNlIGlmKG91dC5jdHlwZT09Mykgb3V0LnRhYnNbdHlwZV0gPSBkYXRhW29mZnNldF07XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJJRU5EXCIpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHQvL2Vsc2UgeyAgbG9nKFwidW5rbm93biBjaHVuayB0eXBlXCIsIHR5cGUsIGxlbik7ICB9XG5cdFx0b2Zmc2V0ICs9IGxlbjtcblx0XHR2YXIgY3JjID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0fVxuXHRpZihmb2ZmIT0wKSB7ICB2YXIgZnIgPSBvdXQuZnJhbWVzW291dC5mcmFtZXMubGVuZ3RoLTFdO1xuXHRcdGZyLmRhdGEgPSBVUE5HLmRlY29kZS5fZGVjb21wcmVzcyhvdXQsIGZkLnNsaWNlKDAsZm9mZiksIGZyLnJlY3Qud2lkdGgsIGZyLnJlY3QuaGVpZ2h0KTsgIGZvZmY9MDtcblx0fVx0XG5cdG91dC5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBkZCwgb3V0LndpZHRoLCBvdXQuaGVpZ2h0KTtcblx0XG5cdGRlbGV0ZSBvdXQuY29tcHJlc3M7ICBkZWxldGUgb3V0LmludGVybGFjZTsgIGRlbGV0ZSBvdXQuZmlsdGVyO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5VUE5HLmRlY29kZS5fZGVjb21wcmVzcyA9IGZ1bmN0aW9uKG91dCwgZGQsIHcsIGgpIHtcblx0dmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR2YXIgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpLCBicGwgPSBNYXRoLmNlaWwodypicHAvOCksIGJ1ZmYgPSBuZXcgVWludDhBcnJheSgoYnBsKzErb3V0LmludGVybGFjZSkqaCk7XG5cdGRkID0gVVBORy5kZWNvZGUuX2luZmxhdGUoZGQsYnVmZik7XG5cdC8vY29uc29sZS5sb2coZGQubGVuZ3RoLCBidWZmLmxlbmd0aCk7XG5cdC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblxuXHR2YXIgdGltZT1EYXRlLm5vdygpO1xuXHRpZiAgICAgKG91dC5pbnRlcmxhY2U9PTApIGRkID0gVVBORy5kZWNvZGUuX2ZpbHRlclplcm8oZGQsIG91dCwgMCwgdywgaCk7XG5cdGVsc2UgaWYob3V0LmludGVybGFjZT09MSkgZGQgPSBVUE5HLmRlY29kZS5fcmVhZEludGVybGFjZShkZCwgb3V0KTtcblx0Ly9jb25zb2xlLmxvZyhEYXRlLm5vdygpLXRpbWUpO1xuXHRyZXR1cm4gZGQ7XG59XG5cblVQTkcuZGVjb2RlLl9pbmZsYXRlID0gZnVuY3Rpb24oZGF0YSwgYnVmZikgeyAgdmFyIG91dD1VUE5HW1wiaW5mbGF0ZVJhd1wiXShuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlciwgMixkYXRhLmxlbmd0aC02KSxidWZmKTsgIHJldHVybiBvdXQ7ICB9XG5VUE5HLmluZmxhdGVSYXc9ZnVuY3Rpb24oKXt2YXIgSD17fTtILkg9e307SC5ILk49ZnVuY3Rpb24oTixXKXt2YXIgUj1VaW50OEFycmF5LGk9MCxtPTAsSj0wLGg9MCxRPTAsWD0wLHU9MCx3PTAsZD0wLHYsQztcbmlmKE5bMF09PTMmJk5bMV09PTApcmV0dXJuIFc/VzpuZXcgUigwKTt2YXIgVj1ILkgsbj1WLmIsQT1WLmUsbD1WLlIsTT1WLm4sST1WLkEsZT1WLlosYj1WLm0sWj1XPT1udWxsO1xuaWYoWilXPW5ldyBSKE4ubGVuZ3RoPj4+Mjw8Myk7d2hpbGUoaT09MCl7aT1uKE4sZCwxKTttPW4oTixkKzEsMik7ZCs9MztpZihtPT0wKXtpZigoZCY3KSE9MClkKz04LShkJjcpO1xudmFyIEQ9KGQ+Pj4zKSs0LHE9TltELTRdfE5bRC0zXTw8ODtpZihaKVc9SC5ILlcoVyx3K3EpO1cuc2V0KG5ldyBSKE4uYnVmZmVyLE4uYnl0ZU9mZnNldCtELHEpLHcpO2Q9RCtxPDwzO1xudys9cTtjb250aW51ZX1pZihaKVc9SC5ILlcoVyx3KygxPDwxNykpO2lmKG09PTEpe3Y9Yi5KO0M9Yi5oO1g9KDE8PDkpLTE7dT0oMTw8NSktMX1pZihtPT0yKXtKPUEoTixkLDUpKzI1Nztcbmg9QShOLGQrNSw1KSsxO1E9QShOLGQrMTAsNCkrNDtkKz0xNDt2YXIgRT1kLGo9MTtmb3IodmFyIGM9MDtjPDM4O2MrPTIpe2IuUVtjXT0wO2IuUVtjKzFdPTB9Zm9yKHZhciBjPTA7XG5jPFE7YysrKXt2YXIgSz1BKE4sZCtjKjMsMyk7Yi5RWyhiLlhbY108PDEpKzFdPUs7aWYoSz5qKWo9S31kKz0zKlE7TShiLlEsaik7SShiLlEsaixiLnUpO3Y9Yi53O0M9Yi5kO1xuZD1sKGIudSwoMTw8aiktMSxKK2gsTixkLGIudik7dmFyIHI9Vi5WKGIudiwwLEosYi5DKTtYPSgxPDxyKS0xO3ZhciBTPVYuVihiLnYsSixoLGIuRCk7dT0oMTw8UyktMTtNKGIuQyxyKTtcbkkoYi5DLHIsdik7TShiLkQsUyk7SShiLkQsUyxDKX13aGlsZSghMCl7dmFyIFQ9dltlKE4sZCkmWF07ZCs9VCYxNTt2YXIgcD1UPj4+NDtpZihwPj4+OD09MCl7V1t3KytdPXB9ZWxzZSBpZihwPT0yNTYpe2JyZWFrfWVsc2V7dmFyIHo9dytwLTI1NDtcbmlmKHA+MjY0KXt2YXIgXz1iLnFbcC0yNTddO3o9dysoXz4+PjMpK0EoTixkLF8mNyk7ZCs9XyY3fXZhciAkPUNbZShOLGQpJnVdO2QrPSQmMTU7dmFyIHM9JD4+PjQsWT1iLmNbc10sYT0oWT4+PjQpK24oTixkLFkmMTUpO1xuZCs9WSYxNTt3aGlsZSh3PHope1dbd109V1t3KystYV07V1t3XT1XW3crKy1hXTtXW3ddPVdbdysrLWFdO1dbd109V1t3KystYV19dz16fX19cmV0dXJuIFcubGVuZ3RoPT13P1c6Vy5zbGljZSgwLHcpfTtcbkguSC5XPWZ1bmN0aW9uKE4sVyl7dmFyIFI9Ti5sZW5ndGg7aWYoVzw9UilyZXR1cm4gTjt2YXIgVj1uZXcgVWludDhBcnJheShSPDwxKTtWLnNldChOLDApO3JldHVybiBWfTtcbkguSC5SPWZ1bmN0aW9uKE4sVyxSLFYsbixBKXt2YXIgbD1ILkguZSxNPUguSC5aLEk9MDt3aGlsZShJPFIpe3ZhciBlPU5bTShWLG4pJlddO24rPWUmMTU7dmFyIGI9ZT4+PjQ7XG5pZihiPD0xNSl7QVtJXT1iO0krK31lbHNle3ZhciBaPTAsbT0wO2lmKGI9PTE2KXttPTMrbChWLG4sMik7bis9MjtaPUFbSS0xXX1lbHNlIGlmKGI9PTE3KXttPTMrbChWLG4sMyk7XG5uKz0zfWVsc2UgaWYoYj09MTgpe209MTErbChWLG4sNyk7bis9N312YXIgSj1JK207d2hpbGUoSTxKKXtBW0ldPVo7SSsrfX19cmV0dXJuIG59O0guSC5WPWZ1bmN0aW9uKE4sVyxSLFYpe3ZhciBuPTAsQT0wLGw9Vi5sZW5ndGg+Pj4xO1xud2hpbGUoQTxSKXt2YXIgTT1OW0ErV107VltBPDwxXT0wO1ZbKEE8PDEpKzFdPU07aWYoTT5uKW49TTtBKyt9d2hpbGUoQTxsKXtWW0E8PDFdPTA7VlsoQTw8MSkrMV09MDtBKyt9cmV0dXJuIG59O1xuSC5ILm49ZnVuY3Rpb24oTixXKXt2YXIgUj1ILkgubSxWPU4ubGVuZ3RoLG4sQSxsLE0sSSxlPVIuajtmb3IodmFyIE09MDtNPD1XO00rKyllW01dPTA7Zm9yKE09MTtNPFY7TSs9MillW05bTV1dKys7XG52YXIgYj1SLks7bj0wO2VbMF09MDtmb3IoQT0xO0E8PVc7QSsrKXtuPW4rZVtBLTFdPDwxO2JbQV09bn1mb3IobD0wO2w8VjtsKz0yKXtJPU5bbCsxXTtpZihJIT0wKXtOW2xdPWJbSV07XG5iW0ldKyt9fX07SC5ILkE9ZnVuY3Rpb24oTixXLFIpe3ZhciBWPU4ubGVuZ3RoLG49SC5ILm0sQT1uLnI7Zm9yKHZhciBsPTA7bDxWO2wrPTIpaWYoTltsKzFdIT0wKXt2YXIgTT1sPj4xLEk9TltsKzFdLGU9TTw8NHxJLGI9Vy1JLFo9TltsXTw8YixtPVorKDE8PGIpO1xud2hpbGUoWiE9bSl7dmFyIEo9QVtaXT4+PjE1LVc7UltKXT1lO1orK319fTtILkgubD1mdW5jdGlvbihOLFcpe3ZhciBSPUguSC5tLnIsVj0xNS1XO2Zvcih2YXIgbj0wO248Ti5sZW5ndGg7XG5uKz0yKXt2YXIgQT1OW25dPDxXLU5bbisxXTtOW25dPVJbQV0+Pj5WfX07SC5ILk09ZnVuY3Rpb24oTixXLFIpe1I9Ujw8KFcmNyk7dmFyIFY9Vz4+PjM7TltWXXw9UjtOW1YrMV18PVI+Pj44fTtcbkguSC5JPWZ1bmN0aW9uKE4sVyxSKXtSPVI8PChXJjcpO3ZhciBWPVc+Pj4zO05bVl18PVI7TltWKzFdfD1SPj4+ODtOW1YrMl18PVI+Pj4xNn07SC5ILmU9ZnVuY3Rpb24oTixXLFIpe3JldHVybihOW1c+Pj4zXXxOWyhXPj4+MykrMV08PDgpPj4+KFcmNykmKDE8PFIpLTF9O1xuSC5ILmI9ZnVuY3Rpb24oTixXLFIpe3JldHVybihOW1c+Pj4zXXxOWyhXPj4+MykrMV08PDh8TlsoVz4+PjMpKzJdPDwxNik+Pj4oVyY3KSYoMTw8UiktMX07SC5ILlo9ZnVuY3Rpb24oTixXKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4fE5bKFc+Pj4zKSsyXTw8MTYpPj4+KFcmNyl9O1xuSC5ILmk9ZnVuY3Rpb24oTixXKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4fE5bKFc+Pj4zKSsyXTw8MTZ8TlsoVz4+PjMpKzNdPDwyNCk+Pj4oVyY3KX07SC5ILm09ZnVuY3Rpb24oKXt2YXIgTj1VaW50MTZBcnJheSxXPVVpbnQzMkFycmF5O1xucmV0dXJue0s6bmV3IE4oMTYpLGo6bmV3IE4oMTYpLFg6WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdLFM6WzMsNCw1LDYsNyw4LDksMTAsMTEsMTMsMTUsMTcsMTksMjMsMjcsMzEsMzUsNDMsNTEsNTksNjcsODMsOTksMTE1LDEzMSwxNjMsMTk1LDIyNywyNTgsOTk5LDk5OSw5OTldLFQ6WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0scTpuZXcgTigzMikscDpbMSwyLDMsNCw1LDcsOSwxMywxNywyNSwzMyw0OSw2NSw5NywxMjksMTkzLDI1NywzODUsNTEzLDc2OSwxMDI1LDE1MzcsMjA0OSwzMDczLDQwOTcsNjE0NSw4MTkzLDEyMjg5LDE2Mzg1LDI0NTc3LDY1NTM1LDY1NTM1XSx6OlswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0sYzpuZXcgVygzMiksSjpuZXcgTig1MTIpLF86W10saDpuZXcgTigzMiksJDpbXSx3Om5ldyBOKDMyNzY4KSxDOltdLHY6W10sZDpuZXcgTigzMjc2OCksRDpbXSx1Om5ldyBOKDUxMiksUTpbXSxyOm5ldyBOKDE8PDE1KSxzOm5ldyBXKDI4NiksWTpuZXcgVygzMCksYTpuZXcgVygxOSksdDpuZXcgVygxNWUzKSxrOm5ldyBOKDE8PDE2KSxnOm5ldyBOKDE8PDE1KX19KCk7XG4oZnVuY3Rpb24oKXt2YXIgTj1ILkgubSxXPTE8PDE1O2Zvcih2YXIgUj0wO1I8VztSKyspe3ZhciBWPVI7Vj0oViYyODYzMzExNTMwKT4+PjF8KFYmMTQzMTY1NTc2NSk8PDE7XG5WPShWJjM0MzU5NzM4MzYpPj4+MnwoViY4NTg5OTM0NTkpPDwyO1Y9KFYmNDA0MjMyMjE2MCk+Pj40fChWJjI1MjY0NTEzNSk8PDQ7Vj0oViY0Mjc4MjU1MzYwKT4+Pjh8KFYmMTY3MTE5MzUpPDw4O1xuTi5yW1JdPShWPj4+MTZ8Vjw8MTYpPj4+MTd9ZnVuY3Rpb24gbihBLGwsTSl7d2hpbGUobC0tIT0wKUEucHVzaCgwLE0pfWZvcih2YXIgUj0wO1I8MzI7UisrKXtOLnFbUl09Ti5TW1JdPDwzfE4uVFtSXTtcbk4uY1tSXT1OLnBbUl08PDR8Ti56W1JdfW4oTi5fLDE0NCw4KTtuKE4uXywyNTUtMTQzLDkpO24oTi5fLDI3OS0yNTUsNyk7bihOLl8sMjg3LTI3OSw4KTtILkgubihOLl8sOSk7XG5ILkguQShOLl8sOSxOLkopO0guSC5sKE4uXyw5KTtuKE4uJCwzMiw1KTtILkgubihOLiQsNSk7SC5ILkEoTi4kLDUsTi5oKTtILkgubChOLiQsNSk7bihOLlEsMTksMCk7bihOLkMsMjg2LDApO1xubihOLkQsMzAsMCk7bihOLnYsMzIwLDApfSgpKTtyZXR1cm4gSC5ILk59KClcblxuXG5VUE5HLmRlY29kZS5fcmVhZEludGVybGFjZSA9IGZ1bmN0aW9uKGRhdGEsIG91dClcbntcblx0dmFyIHcgPSBvdXQud2lkdGgsIGggPSBvdXQuaGVpZ2h0O1xuXHR2YXIgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpLCBjYnBwID0gYnBwPj4zLCBicGwgPSBNYXRoLmNlaWwodypicHAvOCk7XG5cdHZhciBpbWcgPSBuZXcgVWludDhBcnJheSggaCAqIGJwbCApO1xuXHR2YXIgZGkgPSAwO1xuXG5cdHZhciBzdGFydGluZ19yb3cgID0gWyAwLCAwLCA0LCAwLCAyLCAwLCAxIF07XG5cdHZhciBzdGFydGluZ19jb2wgID0gWyAwLCA0LCAwLCAyLCAwLCAxLCAwIF07XG5cdHZhciByb3dfaW5jcmVtZW50ID0gWyA4LCA4LCA4LCA0LCA0LCAyLCAyIF07XG5cdHZhciBjb2xfaW5jcmVtZW50ID0gWyA4LCA4LCA0LCA0LCAyLCAyLCAxIF07XG5cblx0dmFyIHBhc3M9MDtcblx0d2hpbGUocGFzczw3KVxuXHR7XG5cdFx0dmFyIHJpID0gcm93X2luY3JlbWVudFtwYXNzXSwgY2kgPSBjb2xfaW5jcmVtZW50W3Bhc3NdO1xuXHRcdHZhciBzdyA9IDAsIHNoID0gMDtcblx0XHR2YXIgY3IgPSBzdGFydGluZ19yb3dbcGFzc107ICB3aGlsZShjcjxoKSB7ICBjcis9cmk7ICBzaCsrOyAgfVxuXHRcdHZhciBjYyA9IHN0YXJ0aW5nX2NvbFtwYXNzXTsgIHdoaWxlKGNjPHcpIHsgIGNjKz1jaTsgIHN3Kys7ICB9XG5cdFx0dmFyIGJwbGwgPSBNYXRoLmNlaWwoc3cqYnBwLzgpO1xuXHRcdFVQTkcuZGVjb2RlLl9maWx0ZXJaZXJvKGRhdGEsIG91dCwgZGksIHN3LCBzaCk7XG5cblx0XHR2YXIgeT0wLCByb3cgPSBzdGFydGluZ19yb3dbcGFzc107XG5cdFx0d2hpbGUocm93PGgpXG5cdFx0e1xuXHRcdFx0dmFyIGNvbCA9IHN0YXJ0aW5nX2NvbFtwYXNzXTtcblx0XHRcdHZhciBjZGkgPSAoZGkreSpicGxsKTw8MztcblxuXHRcdFx0d2hpbGUoY29sPHcpXG5cdFx0XHR7XG5cdFx0XHRcdGlmKGJwcD09MSkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBkYXRhW2NkaT4+M107ICB2YWwgPSAodmFsPj4oNy0oY2RpJjcpKSkmMTtcblx0XHRcdFx0XHRpbWdbcm93KmJwbCArIChjb2w+PjMpXSB8PSAodmFsIDw8ICg3LSgoY29sJjcpPDwwKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJwcD09Mikge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBkYXRhW2NkaT4+M107ICB2YWwgPSAodmFsPj4oNi0oY2RpJjcpKSkmMztcblx0XHRcdFx0XHRpbWdbcm93KmJwbCArIChjb2w+PjIpXSB8PSAodmFsIDw8ICg2LSgoY29sJjMpPDwxKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJwcD09NCkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBkYXRhW2NkaT4+M107ICB2YWwgPSAodmFsPj4oNC0oY2RpJjcpKSkmMTU7XG5cdFx0XHRcdFx0aW1nW3JvdypicGwgKyAoY29sPj4xKV0gfD0gKHZhbCA8PCAoNC0oKGNvbCYxKTw8MikpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicHA+PTgpIHtcblx0XHRcdFx0XHR2YXIgaWkgPSByb3cqYnBsK2NvbCpjYnBwO1xuXHRcdFx0XHRcdGZvcih2YXIgaj0wOyBqPGNicHA7IGorKykgaW1nW2lpK2pdID0gZGF0YVsoY2RpPj4zKStqXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjZGkrPWJwcDsgIGNvbCs9Y2k7XG5cdFx0XHR9XG5cdFx0XHR5Kys7ICByb3cgKz0gcmk7XG5cdFx0fVxuXHRcdGlmKHN3KnNoIT0wKSBkaSArPSBzaCAqICgxICsgYnBsbCk7XG5cdFx0cGFzcyA9IHBhc3MgKyAxO1xuXHR9XG5cdHJldHVybiBpbWc7XG59XG5cblVQTkcuZGVjb2RlLl9nZXRCUFAgPSBmdW5jdGlvbihvdXQpIHtcblx0dmFyIG5vYyA9IFsxLG51bGwsMywxLDIsbnVsbCw0XVtvdXQuY3R5cGVdO1xuXHRyZXR1cm4gbm9jICogb3V0LmRlcHRoO1xufVxuXG5VUE5HLmRlY29kZS5fZmlsdGVyWmVybyA9IGZ1bmN0aW9uKGRhdGEsIG91dCwgb2ZmLCB3LCBoKVxue1xuXHR2YXIgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpLCBicGwgPSBNYXRoLmNlaWwodypicHAvOCksIHBhZXRoID0gVVBORy5kZWNvZGUuX3BhZXRoO1xuXHRicHAgPSBNYXRoLmNlaWwoYnBwLzgpO1xuXHRcblx0dmFyIGk9MCwgZGk9MSwgdHlwZT1kYXRhW29mZl0sIHg9MDtcblx0XG5cdGlmKHR5cGU+MSkgZGF0YVtvZmZdPVswLDAsMV1bdHlwZS0yXTsgIFxuXHRpZih0eXBlPT0zKSBmb3IoeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbeCsxXSA9IChkYXRhW3grMV0gKyAoZGF0YVt4KzEtYnBwXT4+PjEpICkmMjU1O1xuXG5cdGZvcih2YXIgeT0wOyB5PGg7IHkrKykgIHtcblx0XHRpID0gb2ZmK3kqYnBsOyBkaSA9IGkreSsxO1xuXHRcdHR5cGUgPSBkYXRhW2RpLTFdOyB4PTA7XG5cblx0XHRpZiAgICAgKHR5cGU9PTApICAgZm9yKDsgeDxicGw7IHgrKykgZGF0YVtpK3hdID0gZGF0YVtkaSt4XTtcblx0XHRlbHNlIGlmKHR5cGU9PTEpIHsgZm9yKDsgeDxicHA7IHgrKykgZGF0YVtpK3hdID0gZGF0YVtkaSt4XTtcblx0XHRcdFx0XHRcdCAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgZGF0YVtpK3gtYnBwXSk7ICB9XG5cdFx0ZWxzZSBpZih0eXBlPT0yKSB7IGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgZGF0YVtpK3gtYnBsXSk7ICB9XG5cdFx0ZWxzZSBpZih0eXBlPT0zKSB7IGZvcig7IHg8YnBwOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgKCBkYXRhW2kreC1icGxdPj4+MSkpO1xuXHRcdFx0ICAgICAgICAgICAgICAgZm9yKDsgeDxicGw7IHgrKykgZGF0YVtpK3hdID0gKGRhdGFbZGkreF0gKyAoKGRhdGFbaSt4LWJwbF0rZGF0YVtpK3gtYnBwXSk+Pj4xKSApOyAgfVxuXHRcdGVsc2UgICAgICAgICAgICAgeyBmb3IoOyB4PGJwcDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIHBhZXRoKDAsIGRhdGFbaSt4LWJwbF0sIDApKTtcblx0XHRcdFx0XHRcdCAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgcGFldGgoZGF0YVtpK3gtYnBwXSwgZGF0YVtpK3gtYnBsXSwgZGF0YVtpK3gtYnBwLWJwbF0pICk7ICB9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cblVQTkcuZGVjb2RlLl9wYWV0aCA9IGZ1bmN0aW9uKGEsYixjKVxue1xuXHR2YXIgcCA9IGErYi1jLCBwYSA9IChwLWEpLCBwYiA9IChwLWIpLCBwYyA9IChwLWMpO1xuXHRpZiAocGEqcGEgPD0gcGIqcGIgJiYgcGEqcGEgPD0gcGMqcGMpICByZXR1cm4gYTtcblx0ZWxzZSBpZiAocGIqcGIgPD0gcGMqcGMpICByZXR1cm4gYjtcblx0cmV0dXJuIGM7XG59XG5cblVQTkcuZGVjb2RlLl9JSERSID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBvdXQpXG57XG5cdHZhciBiaW4gPSBVUE5HLl9iaW47XG5cdG91dC53aWR0aCAgPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KTsgIG9mZnNldCArPSA0O1xuXHRvdXQuaGVpZ2h0ID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b3V0LmRlcHRoICAgICA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRvdXQuY3R5cGUgICAgID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdG91dC5jb21wcmVzcyAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0b3V0LmZpbHRlciAgICA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRvdXQuaW50ZXJsYWNlID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG59XG5cblVQTkcuX2JpbiA9IHtcblx0bmV4dFplcm8gICA6IGZ1bmN0aW9uKGRhdGEscCkgIHsgIHdoaWxlKGRhdGFbcF0hPTApIHArKzsgIHJldHVybiBwOyAgfSxcblx0cmVhZFVzaG9ydCA6IGZ1bmN0aW9uKGJ1ZmYscCkgIHsgIHJldHVybiAoYnVmZltwXTw8IDgpIHwgYnVmZltwKzFdOyAgfSxcblx0d3JpdGVVc2hvcnQ6IGZ1bmN0aW9uKGJ1ZmYscCxuKXsgIGJ1ZmZbcF0gPSAobj4+OCkmMjU1OyAgYnVmZltwKzFdID0gbiYyNTU7ICB9LFxuXHRyZWFkVWludCAgIDogZnVuY3Rpb24oYnVmZixwKSAgeyAgcmV0dXJuIChidWZmW3BdKigyNTYqMjU2KjI1NikpICsgKChidWZmW3ArMV08PDE2KSB8IChidWZmW3ArMl08PCA4KSB8IGJ1ZmZbcCszXSk7ICB9LFxuXHR3cml0ZVVpbnQgIDogZnVuY3Rpb24oYnVmZixwLG4peyAgYnVmZltwXT0obj4+MjQpJjI1NTsgIGJ1ZmZbcCsxXT0obj4+MTYpJjI1NTsgIGJ1ZmZbcCsyXT0obj4+OCkmMjU1OyAgYnVmZltwKzNdPW4mMjU1OyAgfSxcblx0cmVhZEFTQ0lJICA6IGZ1bmN0aW9uKGJ1ZmYscCxsKXsgIHZhciBzID0gXCJcIjsgIGZvcih2YXIgaT0wOyBpPGw7IGkrKykgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCtpXSk7ICByZXR1cm4gczsgICAgfSxcblx0d3JpdGVBU0NJSSA6IGZ1bmN0aW9uKGRhdGEscCxzKXsgIGZvcih2YXIgaT0wOyBpPHMubGVuZ3RoOyBpKyspIGRhdGFbcCtpXSA9IHMuY2hhckNvZGVBdChpKTsgIH0sXG5cdHJlYWRCeXRlcyAgOiBmdW5jdGlvbihidWZmLHAsbCl7ICB2YXIgYXJyID0gW107ICAgZm9yKHZhciBpPTA7IGk8bDsgaSsrKSBhcnIucHVzaChidWZmW3AraV0pOyAgIHJldHVybiBhcnI7ICB9LFxuXHRwYWQgOiBmdW5jdGlvbihuKSB7IHJldHVybiBuLmxlbmd0aCA8IDIgPyBcIjBcIiArIG4gOiBuOyB9LFxuXHRyZWFkVVRGOCA6IGZ1bmN0aW9uKGJ1ZmYsIHAsIGwpIHtcblx0XHR2YXIgcyA9IFwiXCIsIG5zO1xuXHRcdGZvcih2YXIgaT0wOyBpPGw7IGkrKykgcyArPSBcIiVcIiArIFVQTkcuX2Jpbi5wYWQoYnVmZltwK2ldLnRvU3RyaW5nKDE2KSk7XG5cdFx0dHJ5IHsgIG5zID0gZGVjb2RlVVJJQ29tcG9uZW50KHMpOyB9XG5cdFx0Y2F0Y2goZSkgeyAgcmV0dXJuIFVQTkcuX2Jpbi5yZWFkQVNDSUkoYnVmZiwgcCwgbCk7ICB9XG5cdFx0cmV0dXJuICBucztcblx0fVxufVxuVVBORy5fY29weVRpbGUgPSBmdW5jdGlvbihzYiwgc3csIHNoLCB0YiwgdHcsIHRoLCB4b2ZmLCB5b2ZmLCBtb2RlKVxue1xuXHR2YXIgdyA9IE1hdGgubWluKHN3LHR3KSwgaCA9IE1hdGgubWluKHNoLHRoKTtcblx0dmFyIHNpPTAsIHRpPTA7XG5cdGZvcih2YXIgeT0wOyB5PGg7IHkrKylcblx0XHRmb3IodmFyIHg9MDsgeDx3OyB4KyspXG5cdFx0e1xuXHRcdFx0aWYoeG9mZj49MCAmJiB5b2ZmPj0wKSB7ICBzaSA9ICh5KnN3K3gpPDwyOyAgdGkgPSAoKCB5b2ZmK3kpKnR3K3hvZmYreCk8PDI7ICB9XG5cdFx0XHRlbHNlICAgICAgICAgICAgICAgICAgIHsgIHNpID0gKCgteW9mZit5KSpzdy14b2ZmK3gpPDwyOyAgdGkgPSAoeSp0dyt4KTw8MjsgIH1cblx0XHRcdFxuXHRcdFx0aWYgICAgIChtb2RlPT0wKSB7ICB0Ylt0aV0gPSBzYltzaV07ICB0Ylt0aSsxXSA9IHNiW3NpKzFdOyAgdGJbdGkrMl0gPSBzYltzaSsyXTsgIHRiW3RpKzNdID0gc2Jbc2krM107ICB9XG5cdFx0XHRlbHNlIGlmKG1vZGU9PTEpIHtcblx0XHRcdFx0dmFyIGZhID0gc2Jbc2krM10qKDEvMjU1KSwgZnI9c2Jbc2ldKmZhLCBmZz1zYltzaSsxXSpmYSwgZmI9c2Jbc2krMl0qZmE7IFxuXHRcdFx0XHR2YXIgYmEgPSB0Ylt0aSszXSooMS8yNTUpLCBicj10Ylt0aV0qYmEsIGJnPXRiW3RpKzFdKmJhLCBiYj10Ylt0aSsyXSpiYTsgXG5cdFx0XHRcdFxuXHRcdFx0XHR2YXIgaWZhPTEtZmEsIG9hID0gZmErYmEqaWZhLCBpb2EgPSAob2E9PTA/MDoxL29hKTtcblx0XHRcdFx0dGJbdGkrM10gPSAyNTUqb2E7ICBcblx0XHRcdFx0dGJbdGkrMF0gPSAoZnIrYnIqaWZhKSppb2E7ICBcblx0XHRcdFx0dGJbdGkrMV0gPSAoZmcrYmcqaWZhKSppb2E7ICAgXG5cdFx0XHRcdHRiW3RpKzJdID0gKGZiK2JiKmlmYSkqaW9hOyAgXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKG1vZGU9PTIpe1x0Ly8gY29weSBvbmx5IGRpZmZlcmVuY2VzLCBvdGhlcndpc2UgemVyb1xuXHRcdFx0XHR2YXIgZmEgPSBzYltzaSszXSwgZnI9c2Jbc2ldLCBmZz1zYltzaSsxXSwgZmI9c2Jbc2krMl07IFxuXHRcdFx0XHR2YXIgYmEgPSB0Ylt0aSszXSwgYnI9dGJbdGldLCBiZz10Ylt0aSsxXSwgYmI9dGJbdGkrMl07IFxuXHRcdFx0XHRpZihmYT09YmEgJiYgZnI9PWJyICYmIGZnPT1iZyAmJiBmYj09YmIpIHsgIHRiW3RpXT0wOyAgdGJbdGkrMV09MDsgIHRiW3RpKzJdPTA7ICB0Ylt0aSszXT0wOyAgfVxuXHRcdFx0XHRlbHNlIHsgIHRiW3RpXT1mcjsgIHRiW3RpKzFdPWZnOyAgdGJbdGkrMl09ZmI7ICB0Ylt0aSszXT1mYTsgIH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYobW9kZT09Myl7XHQvLyBjaGVjayBpZiBjYW4gYmUgYmxlbmRlZFxuXHRcdFx0XHR2YXIgZmEgPSBzYltzaSszXSwgZnI9c2Jbc2ldLCBmZz1zYltzaSsxXSwgZmI9c2Jbc2krMl07IFxuXHRcdFx0XHR2YXIgYmEgPSB0Ylt0aSszXSwgYnI9dGJbdGldLCBiZz10Ylt0aSsxXSwgYmI9dGJbdGkrMl07IFxuXHRcdFx0XHRpZihmYT09YmEgJiYgZnI9PWJyICYmIGZnPT1iZyAmJiBmYj09YmIpIGNvbnRpbnVlO1xuXHRcdFx0XHQvL2lmKGZhIT0yNTUgJiYgYmEhPTApIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWYoZmE8MjIwICYmIGJhPjIwKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuXG5cblxuVVBORy5lbmNvZGUgPSBmdW5jdGlvbihidWZzLCB3LCBoLCBwcywgZGVscywgdGFicywgZm9yYmlkUGx0ZSlcbntcblx0aWYocHM9PW51bGwpIHBzPTA7XG5cdGlmKGZvcmJpZFBsdGU9PW51bGwpIGZvcmJpZFBsdGUgPSBmYWxzZTtcblxuXHR2YXIgbmltZyA9IFVQTkcuZW5jb2RlLmNvbXByZXNzKGJ1ZnMsIHcsIGgsIHBzLCBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgZm9yYmlkUGx0ZV0pO1xuXHRVUE5HLmVuY29kZS5jb21wcmVzc1BORyhuaW1nLCAtMSk7XG5cdFxuXHRyZXR1cm4gVVBORy5lbmNvZGUuX21haW4obmltZywgdywgaCwgZGVscywgdGFicyk7XG59XG5cblVQTkcuZW5jb2RlTEwgPSBmdW5jdGlvbihidWZzLCB3LCBoLCBjYywgYWMsIGRlcHRoLCBkZWxzLCB0YWJzKSB7XG5cdHZhciBuaW1nID0geyAgY3R5cGU6IDAgKyAoY2M9PTEgPyAwIDogMikgKyAoYWM9PTAgPyAwIDogNCksICAgICAgZGVwdGg6IGRlcHRoLCAgZnJhbWVzOiBbXSAgfTtcblx0XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0dmFyIGJpcHAgPSAoY2MrYWMpKmRlcHRoLCBiaXBsID0gYmlwcCAqIHc7XG5cdGZvcih2YXIgaT0wOyBpPGJ1ZnMubGVuZ3RoOyBpKyspXG5cdFx0bmltZy5mcmFtZXMucHVzaCh7ICByZWN0Ont4OjAseTowLHdpZHRoOncsaGVpZ2h0Omh9LCAgaW1nOm5ldyBVaW50OEFycmF5KGJ1ZnNbaV0pLCBibGVuZDowLCBkaXNwb3NlOjEsIGJwcDpNYXRoLmNlaWwoYmlwcC84KSwgYnBsOk1hdGguY2VpbChiaXBsLzgpICB9KTtcblx0XG5cdFVQTkcuZW5jb2RlLmNvbXByZXNzUE5HKG5pbWcsIDAsIHRydWUpO1xuXHRcblx0dmFyIG91dCA9IFVQTkcuZW5jb2RlLl9tYWluKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpO1xuXHRyZXR1cm4gb3V0O1xufVxuXG5VUE5HLmVuY29kZS5fbWFpbiA9IGZ1bmN0aW9uKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpIHtcblx0aWYodGFicz09bnVsbCkgdGFicz17fTtcblx0dmFyIGNyYyA9IFVQTkcuY3JjLmNyYywgd1VpID0gVVBORy5fYmluLndyaXRlVWludCwgd1VzID0gVVBORy5fYmluLndyaXRlVXNob3J0LCB3QXMgPSBVUE5HLl9iaW4ud3JpdGVBU0NJSTtcblx0dmFyIG9mZnNldCA9IDgsIGFuaW0gPSBuaW1nLmZyYW1lcy5sZW5ndGg+MSwgcGx0QWxwaGEgPSBmYWxzZTtcblx0XG5cdHZhciBsZW5nID0gOCArICgxNis1KzQpIC8qKyAoOSs0KSovICsgKGFuaW0gPyAyMCA6IDApO1xuXHRpZih0YWJzW1wic1JHQlwiXSE9bnVsbCkgbGVuZyArPSA4KzErNDtcblx0aWYodGFic1tcInBIWXNcIl0hPW51bGwpIGxlbmcgKz0gOCs5KzQ7XG5cdGlmKG5pbWcuY3R5cGU9PTMpIHtcblx0XHR2YXIgZGwgPSBuaW1nLnBsdGUubGVuZ3RoO1xuXHRcdGZvcih2YXIgaT0wOyBpPGRsOyBpKyspIGlmKChuaW1nLnBsdGVbaV0+Pj4yNCkhPTI1NSkgcGx0QWxwaGEgPSB0cnVlO1xuXHRcdGxlbmcgKz0gKDggKyBkbCozICsgNCkgKyAocGx0QWxwaGEgPyAoOCArIGRsKjEgKyA0KSA6IDApO1xuXHR9XG5cdGZvcih2YXIgaj0wOyBqPG5pbWcuZnJhbWVzLmxlbmd0aDsgaisrKVxuXHR7XG5cdFx0dmFyIGZyID0gbmltZy5mcmFtZXNbal07XG5cdFx0aWYoYW5pbSkgbGVuZyArPSAzODtcblx0XHRsZW5nICs9IGZyLmNpbWcubGVuZ3RoICsgMTI7XG5cdFx0aWYoaiE9MCkgbGVuZys9NDtcblx0fVxuXHRsZW5nICs9IDEyOyBcblx0XG5cdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGVuZyk7XG5cdHZhciB3cj1bMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV07XG5cdGZvcih2YXIgaT0wOyBpPDg7IGkrKykgZGF0YVtpXT13cltpXTtcblx0XG5cdHdVaShkYXRhLG9mZnNldCwgMTMpOyAgICAgb2Zmc2V0Kz00O1xuXHR3QXMoZGF0YSxvZmZzZXQsXCJJSERSXCIpOyAgb2Zmc2V0Kz00O1xuXHR3VWkoZGF0YSxvZmZzZXQsdyk7ICBvZmZzZXQrPTQ7XG5cdHdVaShkYXRhLG9mZnNldCxoKTsgIG9mZnNldCs9NDtcblx0ZGF0YVtvZmZzZXRdID0gbmltZy5kZXB0aDsgIG9mZnNldCsrOyAgLy8gZGVwdGhcblx0ZGF0YVtvZmZzZXRdID0gbmltZy5jdHlwZTsgIG9mZnNldCsrOyAgLy8gY3R5cGVcblx0ZGF0YVtvZmZzZXRdID0gMDsgIG9mZnNldCsrOyAgLy8gY29tcHJlc3Ncblx0ZGF0YVtvZmZzZXRdID0gMDsgIG9mZnNldCsrOyAgLy8gZmlsdGVyXG5cdGRhdGFbb2Zmc2V0XSA9IDA7ICBvZmZzZXQrKzsgIC8vIGludGVybGFjZVxuXHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTE3LDE3KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXG5cdC8vIDEzIGJ5dGVzIHRvIHNheSwgdGhhdCBpdCBpcyBzUkdCXG5cdGlmKHRhYnNbXCJzUkdCXCJdIT1udWxsKSB7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCAxKTsgICAgICBvZmZzZXQrPTQ7XG5cdFx0d0FzKGRhdGEsb2Zmc2V0LFwic1JHQlwiKTsgIG9mZnNldCs9NDtcblx0XHRkYXRhW29mZnNldF0gPSB0YWJzW1wic1JHQlwiXTsgIG9mZnNldCsrO1xuXHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtNSw1KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHR9XG5cdGlmKHRhYnNbXCJwSFlzXCJdIT1udWxsKSB7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCA5KTsgICAgICBvZmZzZXQrPTQ7XG5cdFx0d0FzKGRhdGEsb2Zmc2V0LFwicEhZc1wiKTsgIG9mZnNldCs9NDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIHRhYnNbXCJwSFlzXCJdWzBdKTsgICAgICBvZmZzZXQrPTQ7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCB0YWJzW1wicEhZc1wiXVsxXSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdGRhdGFbb2Zmc2V0XT10YWJzW1wicEhZc1wiXVsyXTtcdFx0XHRvZmZzZXQrKztcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTEzLDEzKSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHR9XG5cblx0aWYoYW5pbSkge1xuXHRcdHdVaShkYXRhLG9mZnNldCwgOCk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcImFjVExcIik7ICBvZmZzZXQrPTQ7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCBuaW1nLmZyYW1lcy5sZW5ndGgpOyAgICAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCwgdGFic1tcImxvb3BcIl0hPW51bGw/dGFic1tcImxvb3BcIl06MCk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtMTIsMTIpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cdH1cblxuXHRpZihuaW1nLmN0eXBlPT0zKSB7XG5cdFx0dmFyIGRsID0gbmltZy5wbHRlLmxlbmd0aDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIGRsKjMpOyAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcIlBMVEVcIik7ICBvZmZzZXQrPTQ7XG5cdFx0Zm9yKHZhciBpPTA7IGk8ZGw7IGkrKyl7XG5cdFx0XHR2YXIgdGk9aSozLCBjPW5pbWcucGx0ZVtpXSwgcj0oYykmMjU1LCBnPShjPj4+OCkmMjU1LCBiPShjPj4+MTYpJjI1NTtcblx0XHRcdGRhdGFbb2Zmc2V0K3RpKzBdPXI7ICBkYXRhW29mZnNldCt0aSsxXT1nOyAgZGF0YVtvZmZzZXQrdGkrMl09Yjtcblx0XHR9XG5cdFx0b2Zmc2V0Kz1kbCozO1xuXHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtZGwqMy00LGRsKjMrNCkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblxuXHRcdGlmKHBsdEFscGhhKSB7XG5cdFx0XHR3VWkoZGF0YSxvZmZzZXQsIGRsKTsgIG9mZnNldCs9NDtcblx0XHRcdHdBcyhkYXRhLG9mZnNldCxcInRSTlNcIik7ICBvZmZzZXQrPTQ7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxkbDsgaSsrKSAgZGF0YVtvZmZzZXQraV09KG5pbWcucGx0ZVtpXT4+PjI0KSYyNTU7XG5cdFx0XHRvZmZzZXQrPWRsO1xuXHRcdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC1kbC00LGRsKzQpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cdFx0fVxuXHR9XG5cdFxuXHR2YXIgZmkgPSAwO1xuXHRmb3IodmFyIGo9MDsgajxuaW1nLmZyYW1lcy5sZW5ndGg7IGorKylcblx0e1xuXHRcdHZhciBmciA9IG5pbWcuZnJhbWVzW2pdO1xuXHRcdGlmKGFuaW0pIHtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIDI2KTsgICAgIG9mZnNldCs9NDtcblx0XHRcdHdBcyhkYXRhLCBvZmZzZXQsXCJmY1RMXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VpKGRhdGEsIG9mZnNldCwgZmkrKyk7ICAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC53aWR0aCApOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3QuaGVpZ2h0KTsgICBvZmZzZXQrPTQ7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCBmci5yZWN0LngpOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3QueSk7ICAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VzKGRhdGEsIG9mZnNldCwgZGVsc1tqXSk7ICAgb2Zmc2V0Kz0yO1xuXHRcdFx0d1VzKGRhdGEsIG9mZnNldCwgIDEwMDApOyAgIG9mZnNldCs9Mjtcblx0XHRcdGRhdGFbb2Zmc2V0XSA9IGZyLmRpc3Bvc2U7ICBvZmZzZXQrKztcdC8vIGRpc3Bvc2Vcblx0XHRcdGRhdGFbb2Zmc2V0XSA9IGZyLmJsZW5kICA7ICBvZmZzZXQrKztcdC8vIGJsZW5kXG5cdFx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTMwLDMwKSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHRcdH1cblx0XHRcdFx0XG5cdFx0dmFyIGltZ2QgPSBmci5jaW1nLCBkbCA9IGltZ2QubGVuZ3RoO1xuXHRcdHdVaShkYXRhLG9mZnNldCwgZGwrKGo9PTA/MDo0KSk7ICAgICBvZmZzZXQrPTQ7XG5cdFx0dmFyIGlvZmYgPSBvZmZzZXQ7XG5cdFx0d0FzKGRhdGEsb2Zmc2V0LChqPT0wKT9cIklEQVRcIjpcImZkQVRcIik7ICBvZmZzZXQrPTQ7XG5cdFx0aWYoaiE9MCkgeyAgd1VpKGRhdGEsIG9mZnNldCwgZmkrKyk7ICBvZmZzZXQrPTQ7ICB9XG5cdFx0ZGF0YS5zZXQoaW1nZCxvZmZzZXQpO1xuXHRcdG9mZnNldCArPSBkbDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsaW9mZixvZmZzZXQtaW9mZikpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0fVxuXG5cdHdVaShkYXRhLG9mZnNldCwgMCk7ICAgICBvZmZzZXQrPTQ7XG5cdHdBcyhkYXRhLG9mZnNldCxcIklFTkRcIik7ICBvZmZzZXQrPTQ7XG5cdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtNCw0KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXG5cdHJldHVybiBkYXRhLmJ1ZmZlcjtcbn1cblxuVVBORy5lbmNvZGUuY29tcHJlc3NQTkcgPSBmdW5jdGlvbihvdXQsIGZpbHRlciwgbGV2ZWxaZXJvKSB7XG5cdGZvcih2YXIgaT0wOyBpPG91dC5mcmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZnJtID0gb3V0LmZyYW1lc1tpXSwgbnc9ZnJtLnJlY3Qud2lkdGgsIG5oPWZybS5yZWN0LmhlaWdodDtcblx0XHR2YXIgZmRhdGEgPSBuZXcgVWludDhBcnJheShuaCpmcm0uYnBsK25oKTtcblx0XHRmcm0uY2ltZyA9IFVQTkcuZW5jb2RlLl9maWx0ZXJaZXJvKGZybS5pbWcsbmgsZnJtLmJwcCxmcm0uYnBsLGZkYXRhLCBmaWx0ZXIsIGxldmVsWmVybyk7XG5cdH1cbn1cblxuXG5cblVQTkcuZW5jb2RlLmNvbXByZXNzID0gZnVuY3Rpb24oYnVmcywgdywgaCwgcHMsIHBybXMpIC8vIHBybXM6ICBvbmx5QmxlbmQsIG1pbkJpdHMsIGZvcmJpZFBsdGVcbntcblx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XG5cdHZhciBvbmx5QmxlbmQgPSBwcm1zWzBdLCBldmVuQ3JkID0gcHJtc1sxXSwgZm9yYmlkUHJldiA9IHBybXNbMl0sIG1pbkJpdHMgPSBwcm1zWzNdLCBmb3JiaWRQbHRlID0gcHJtc1s0XTtcblx0XG5cdHZhciBjdHlwZSA9IDYsIGRlcHRoID0gOCwgYWxwaGFBbmQ9MjU1XG5cdFxuXHRmb3IodmFyIGo9MDsgajxidWZzLmxlbmd0aDsgaisrKSAgeyAgLy8gd2hlbiBub3QgcXVhbnRpemVkLCBvdGhlciBmcmFtZXMgY2FuIGNvbnRhaW4gY29sb3JzLCB0aGF0IGFyZSBub3QgaW4gYW4gaW5pdGlhbCBmcmFtZVxuXHRcdHZhciBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2pdKSwgaWxlbiA9IGltZy5sZW5ndGg7XG5cdFx0Zm9yKHZhciBpPTA7IGk8aWxlbjsgaSs9NCkgYWxwaGFBbmQgJj0gaW1nW2krM107XG5cdH1cblx0dmFyIGdvdEFscGhhID0gKGFscGhhQW5kIT0yNTUpO1xuXHRcblx0Ly9jb25zb2xlLmxvZyhcImFscGhhIGNoZWNrXCIsIERhdGUubm93KCktdGltZSk7ICB0aW1lID0gRGF0ZS5ub3coKTtcblx0XG5cdC8vdmFyIGJydXRlID0gZ290QWxwaGEgJiYgZm9yR0lGO1x0XHQvLyBicnV0ZSA6IGZyYW1lcyBjYW4gb25seSBiZSBjb3BpZWQsIG5vdCBcImJsZW5kZWRcIlxuXHR2YXIgZnJtcyA9IFVQTkcuZW5jb2RlLmZyYW1pemUoYnVmcywgdywgaCwgb25seUJsZW5kLCBldmVuQ3JkLCBmb3JiaWRQcmV2KTtcblx0Ly9jb25zb2xlLmxvZyhcImZyYW1pemVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHRcblx0dmFyIGNtYXA9e30sIHBsdGU9W10sIGluZHM9W107ICBcblx0XG5cdGlmKHBzIT0wKSB7XG5cdFx0dmFyIG5idWZzID0gW107ICBmb3IodmFyIGk9MDsgaTxmcm1zLmxlbmd0aDsgaSsrKSBuYnVmcy5wdXNoKGZybXNbaV0uaW1nLmJ1ZmZlcik7XG5cdFx0XG5cdFx0dmFyIGFidWYgPSBVUE5HLmVuY29kZS5jb25jYXRSR0JBKG5idWZzKSwgcXJlcyA9IFVQTkcucXVhbnRpemUoYWJ1ZiwgcHMpOyAgXG5cdFx0dmFyIGNvZiA9IDAsIGJiID0gbmV3IFVpbnQ4QXJyYXkocXJlcy5hYnVmKTtcblx0XHRmb3IodmFyIGk9MDsgaTxmcm1zLmxlbmd0aDsgaSsrKSB7ICB2YXIgdGk9ZnJtc1tpXS5pbWcsIGJsbj10aS5sZW5ndGg7ICBpbmRzLnB1c2gobmV3IFVpbnQ4QXJyYXkocXJlcy5pbmRzLmJ1ZmZlciwgY29mPj4yLCBibG4+PjIpKTtcblx0XHRcdGZvcih2YXIgaj0wOyBqPGJsbjsgais9NCkgeyAgdGlbal09YmJbY29mK2pdOyAgdGlbaisxXT1iYltjb2YraisxXTsgIHRpW2orMl09YmJbY29mK2orMl07ICB0aVtqKzNdPWJiW2NvZitqKzNdOyAgfSAgICBjb2YrPWJsbjsgIH1cblx0XHRcblx0XHRmb3IodmFyIGk9MDsgaTxxcmVzLnBsdGUubGVuZ3RoOyBpKyspIHBsdGUucHVzaChxcmVzLnBsdGVbaV0uZXN0LnJnYmEpO1xuXHRcdC8vY29uc29sZS5sb2coXCJxdWFudGl6ZVwiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gd2hhdCBpZiBwcz09MCwgYnV0IHRoZXJlIGFyZSA8PTI1NiBjb2xvcnM/ICB3ZSBzdGlsbCBuZWVkIHRvIGRldGVjdCwgaWYgdGhlIHBhbGV0dGUgY291bGQgYmUgdXNlZFxuXHRcdGZvcih2YXIgaj0wOyBqPGZybXMubGVuZ3RoOyBqKyspICB7ICAvLyB3aGVuIG5vdCBxdWFudGl6ZWQsIG90aGVyIGZyYW1lcyBjYW4gY29udGFpbiBjb2xvcnMsIHRoYXQgYXJlIG5vdCBpbiBhbiBpbml0aWFsIGZyYW1lXG5cdFx0XHR2YXIgZnJtID0gZnJtc1tqXSwgaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoZnJtLmltZy5idWZmZXIpLCBudz1mcm0ucmVjdC53aWR0aCwgaWxlbiA9IGltZzMyLmxlbmd0aDtcblx0XHRcdHZhciBpbmQgPSBuZXcgVWludDhBcnJheShpbGVuKTsgIGluZHMucHVzaChpbmQpO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8aWxlbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gaW1nMzJbaV07XG5cdFx0XHRcdGlmICAgICAoaSE9MCAmJiBjPT1pbWczMltpLSAxXSkgaW5kW2ldPWluZFtpLTFdO1xuXHRcdFx0XHRlbHNlIGlmKGk+bncgJiYgYz09aW1nMzJbaS1ud10pIGluZFtpXT1pbmRbaS1ud107XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBjbWMgPSBjbWFwW2NdO1xuXHRcdFx0XHRcdGlmKGNtYz09bnVsbCkgeyAgY21hcFtjXT1jbWM9cGx0ZS5sZW5ndGg7ICBwbHRlLnB1c2goYyk7ICBpZihwbHRlLmxlbmd0aD49MzAwKSBicmVhazsgIH1cblx0XHRcdFx0XHRpbmRbaV09Y21jO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vY29uc29sZS5sb2coXCJtYWtlIHBhbGV0dGVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR9XG5cdFxuXHR2YXIgY2M9cGx0ZS5sZW5ndGg7IC8vY29uc29sZS5sb2coXCJjb2xvcnM6XCIsY2MpO1xuXHRpZihjYzw9MjU2ICYmIGZvcmJpZFBsdGU9PWZhbHNlKSB7XG5cdFx0aWYoY2M8PSAyKSBkZXB0aD0xOyAgZWxzZSBpZihjYzw9IDQpIGRlcHRoPTI7ICBlbHNlIGlmKGNjPD0xNikgZGVwdGg9NDsgIGVsc2UgZGVwdGg9ODtcblx0XHRkZXB0aCA9ICBNYXRoLm1heChkZXB0aCwgbWluQml0cyk7XG5cdH1cblx0XG5cdGZvcih2YXIgaj0wOyBqPGZybXMubGVuZ3RoOyBqKyspXG5cdHtcblx0XHR2YXIgZnJtID0gZnJtc1tqXSwgbng9ZnJtLnJlY3QueCwgbnk9ZnJtLnJlY3QueSwgbnc9ZnJtLnJlY3Qud2lkdGgsIG5oPWZybS5yZWN0LmhlaWdodDtcblx0XHR2YXIgY2ltZyA9IGZybS5pbWcsIGNpbWczMiA9IG5ldyBVaW50MzJBcnJheShjaW1nLmJ1ZmZlcik7XG5cdFx0dmFyIGJwbCA9IDQqbncsIGJwcD00O1xuXHRcdGlmKGNjPD0yNTYgJiYgZm9yYmlkUGx0ZT09ZmFsc2UpIHtcblx0XHRcdGJwbCA9IE1hdGguY2VpbChkZXB0aCpudy84KTtcblx0XHRcdHZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnBsKm5oKTtcblx0XHRcdHZhciBpbmogPSBpbmRzW2pdO1xuXHRcdFx0Zm9yKHZhciB5PTA7IHk8bmg7IHkrKykgeyAgdmFyIGk9eSpicGwsIGlpPXkqbnc7XG5cdFx0XHRcdGlmICAgICAoZGVwdGg9PTgpIGZvcih2YXIgeD0wOyB4PG53OyB4KyspIG5pbWdbaSsoeCkgICBdICAgPSAgKGlualtpaSt4XSAgICAgICAgICAgICApO1xuXHRcdFx0XHRlbHNlIGlmKGRlcHRoPT00KSBmb3IodmFyIHg9MDsgeDxudzsgeCsrKSBuaW1nW2krKHg+PjEpXSAgfD0gIChpbmpbaWkreF08PCg0LSh4JjEpKjQpKTtcblx0XHRcdFx0ZWxzZSBpZihkZXB0aD09MikgZm9yKHZhciB4PTA7IHg8bnc7IHgrKykgbmltZ1tpKyh4Pj4yKV0gIHw9ICAoaW5qW2lpK3hdPDwoNi0oeCYzKSoyKSk7XG5cdFx0XHRcdGVsc2UgaWYoZGVwdGg9PTEpIGZvcih2YXIgeD0wOyB4PG53OyB4KyspIG5pbWdbaSsoeD4+MyldICB8PSAgKGlualtpaSt4XTw8KDctKHgmNykqMSkpO1xuXHRcdFx0fVxuXHRcdFx0Y2ltZz1uaW1nOyAgY3R5cGU9MzsgIGJwcD0xO1xuXHRcdH1cblx0XHRlbHNlIGlmKGdvdEFscGhhPT1mYWxzZSAmJiBmcm1zLmxlbmd0aD09MSkge1x0Ly8gc29tZSBuZXh0IFwicmVkdWNlZFwiIGZyYW1lcyBtYXkgY29udGFpbiBhbHBoYSBmb3IgYmxlbmRpbmdcblx0XHRcdHZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkobncqbmgqMyksIGFyZWE9bncqbmg7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTxhcmVhOyBpKyspIHsgdmFyIHRpPWkqMywgcWk9aSo0OyAgbmltZ1t0aV09Y2ltZ1txaV07ICBuaW1nW3RpKzFdPWNpbWdbcWkrMV07ICBuaW1nW3RpKzJdPWNpbWdbcWkrMl07ICB9XG5cdFx0XHRjaW1nPW5pbWc7ICBjdHlwZT0yOyAgYnBwPTM7ICBicGw9Mypudztcblx0XHR9XG5cdFx0ZnJtLmltZz1jaW1nOyAgZnJtLmJwbD1icGw7ICBmcm0uYnBwPWJwcDtcblx0fVxuXHQvL2NvbnNvbGUubG9nKFwiY29sb3JzID0+IHBhbGV0dGUgaW5kaWNlc1wiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cdFxuXHRyZXR1cm4ge2N0eXBlOmN0eXBlLCBkZXB0aDpkZXB0aCwgcGx0ZTpwbHRlLCBmcmFtZXM6ZnJtcyAgfTtcbn1cblVQTkcuZW5jb2RlLmZyYW1pemUgPSBmdW5jdGlvbihidWZzLHcsaCxhbHdheXNCbGVuZCxldmVuQ3JkLGZvcmJpZFByZXYpIHtcblx0LyogIERJU1BPU0Vcblx0ICAgIC0gMCA6IG5vIGNoYW5nZVxuXHRcdC0gMSA6IGNsZWFyIHRvIHRyYW5zcGFyZW50XG5cdFx0LSAyIDogcmV0c3RvcmUgdG8gY29udGVudCBiZWZvcmUgcmVuZGVyaW5nIChwcmV2aW91cyBmcmFtZSBkaXNwb3NlZClcblx0XHRCTEVORFxuXHRcdC0gMCA6IHJlcGxhY2Vcblx0XHQtIDEgOiBibGVuZFxuXHQqL1xuXHR2YXIgZnJtcyA9IFtdO1xuXHRmb3IodmFyIGo9MDsgajxidWZzLmxlbmd0aDsgaisrKSB7XG5cdFx0dmFyIGNpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2pdKSwgY2ltZzMyID0gbmV3IFVpbnQzMkFycmF5KGNpbWcuYnVmZmVyKTtcblx0XHR2YXIgbmltZztcblx0XHRcblx0XHR2YXIgbng9MCwgbnk9MCwgbnc9dywgbmg9aCwgYmxlbmQ9YWx3YXlzQmxlbmQ/MTowO1xuXHRcdGlmKGohPTApIHtcblx0XHRcdHZhciB0bGltID0gKGZvcmJpZFByZXYgfHwgYWx3YXlzQmxlbmQgfHwgaj09MSB8fCBmcm1zW2otMl0uZGlzcG9zZSE9MCk/MToyLCB0c3RwID0gMCwgdGFyZWEgPSAxZTk7XG5cdFx0XHRmb3IodmFyIGl0PTA7IGl0PHRsaW07IGl0KyspXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBwaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqLTEtaXRdKSwgcDMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZnNbai0xLWl0XSk7XG5cdFx0XHRcdHZhciBtaXg9dyxtaXk9aCxtYXg9LTEsbWF5PS0xO1xuXHRcdFx0XHRmb3IodmFyIHk9MDsgeTxoOyB5KyspIGZvcih2YXIgeD0wOyB4PHc7IHgrKykge1xuXHRcdFx0XHRcdHZhciBpID0geSp3K3g7XG5cdFx0XHRcdFx0aWYoY2ltZzMyW2ldIT1wMzJbaV0pIHtcblx0XHRcdFx0XHRcdGlmKHg8bWl4KSBtaXg9eDsgIGlmKHg+bWF4KSBtYXg9eDtcblx0XHRcdFx0XHRcdGlmKHk8bWl5KSBtaXk9eTsgIGlmKHk+bWF5KSBtYXk9eTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYobWF4PT0tMSkgbWl4PW1peT1tYXg9bWF5PTA7XG5cdFx0XHRcdGlmKGV2ZW5DcmQpIHsgIGlmKChtaXgmMSk9PTEpbWl4LS07ICBpZigobWl5JjEpPT0xKW1peS0tOyAgfVxuXHRcdFx0XHR2YXIgc2FyZWEgPSAobWF4LW1peCsxKSoobWF5LW1peSsxKTtcblx0XHRcdFx0aWYoc2FyZWE8dGFyZWEpIHtcblx0XHRcdFx0XHR0YXJlYSA9IHNhcmVhOyAgdHN0cCA9IGl0O1xuXHRcdFx0XHRcdG54ID0gbWl4OyBueSA9IG1peTsgbncgPSBtYXgtbWl4KzE7IG5oID0gbWF5LW1peSsxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIGFsd2F5c0JsZW5kOiBwb2t1ZCB6amlzdMOtbSwgxb5lIGJsZW5kaXQgbmVsemUsIG5hc3RhdsOtbSBwxZllZGNob3rDrW11IHNuw61ta3UgZGlzcG9zZT0xLiBaYWppc3TDrW0sIGFieSBvYnNhaG92YWwgbcWvaiBvYmTDqWxuw61rLlxuXHRcdFx0dmFyIHBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2otMS10c3RwXSk7XG5cdFx0XHRpZih0c3RwPT0xKSBmcm1zW2otMV0uZGlzcG9zZSA9IDI7XG5cdFx0XHRcblx0XHRcdG5pbWcgPSBuZXcgVWludDhBcnJheShudypuaCo0KTtcblx0XHRcdFVQTkcuX2NvcHlUaWxlKHBpbWcsdyxoLCBuaW1nLG53LG5oLCAtbngsLW55LCAwKTtcblx0XHRcdFxuXHRcdFx0YmxlbmQgPSAgVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcsbncsbmgsIC1ueCwtbnksIDMpID8gMSA6IDA7XG5cdFx0XHRpZihibGVuZD09MSkgVVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmKGNpbWcsdyxoLG5pbWcse3g6bngseTpueSx3aWR0aDpudyxoZWlnaHQ6bmh9KTtcblx0XHRcdGVsc2UgICAgICAgICBVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgbmltZyxudyxuaCwgLW54LC1ueSwgMCk7XG5cdFx0XHQvL1VQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBuaW1nLG53LG5oLCAtbngsLW55LCBibGVuZD09MT8yOjApO1xuXHRcdH1cblx0XHRlbHNlIG5pbWcgPSBjaW1nLnNsaWNlKDApO1x0Ly8gaW1nIG1heSBiZSByZXdyaXR0ZW4gZnVydGhlciAuLi4gZG9uJ3QgcmV3cml0ZSBpbnB1dFxuXHRcdFxuXHRcdGZybXMucHVzaCh7cmVjdDp7eDpueCx5Om55LHdpZHRoOm53LGhlaWdodDpuaH0sIGltZzpuaW1nLCBibGVuZDpibGVuZCwgZGlzcG9zZTowfSk7XG5cdH1cblx0XG5cdFxuXHRpZihhbHdheXNCbGVuZCkgZm9yKHZhciBqPTA7IGo8ZnJtcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBmcm0gPSBmcm1zW2pdOyAgaWYoZnJtLmJsZW5kPT0xKSBjb250aW51ZTtcblx0XHR2YXIgcjAgPSBmcm0ucmVjdCwgcjEgPSBmcm1zW2otMV0ucmVjdFxuXHRcdHZhciBtaVggPSBNYXRoLm1pbihyMC54LCByMS54KSwgbWlZID0gTWF0aC5taW4ocjAueSwgcjEueSk7XG5cdFx0dmFyIG1hWCA9IE1hdGgubWF4KHIwLngrcjAud2lkdGgsIHIxLngrcjEud2lkdGgpLCBtYVkgPSBNYXRoLm1heChyMC55K3IwLmhlaWdodCwgcjEueStyMS5oZWlnaHQpO1xuXHRcdHZhciByID0ge3g6bWlYLCB5Om1pWSwgd2lkdGg6bWFYLW1pWCwgaGVpZ2h0Om1hWS1taVl9O1xuXHRcdFxuXHRcdGZybXNbai0xXS5kaXNwb3NlID0gMTtcblx0XHRpZihqLTEhPTApIFxuXHRcdFVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZShidWZzLCB3LGgsZnJtcywgai0xLHIsIGV2ZW5DcmQpO1xuXHRcdFVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZShidWZzLCB3LGgsZnJtcywgaiAgLHIsIGV2ZW5DcmQpO1xuXHR9XG5cdHZhciBhcmVhID0gMDtcblx0aWYoYnVmcy5sZW5ndGghPTEpIGZvcih2YXIgaT0wOyBpPGZybXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZnJtID0gZnJtc1tpXTtcblx0XHRhcmVhICs9IGZybS5yZWN0LndpZHRoKmZybS5yZWN0LmhlaWdodDtcblx0XHQvL2lmKGk9PTAgfHwgZnJtLmJsZW5kIT0xKSBjb250aW51ZTtcblx0XHQvL3ZhciBvYiA9IG5ldyBVaW50OEFycmF5KFxuXHRcdC8vY29uc29sZS5sb2coZnJtLmJsZW5kLCBmcm0uZGlzcG9zZSwgZnJtLnJlY3QpO1xuXHR9XG5cdC8vaWYoYXJlYSE9MCkgY29uc29sZS5sb2coYXJlYSk7XG5cdHJldHVybiBmcm1zO1xufVxuVVBORy5lbmNvZGUuX3VwZGF0ZUZyYW1lID0gZnVuY3Rpb24oYnVmcywgdyxoLCBmcm1zLCBpLCByLCBldmVuQ3JkKSB7XG5cdHZhciBVOCA9IFVpbnQ4QXJyYXksIFUzMiA9IFVpbnQzMkFycmF5O1xuXHR2YXIgcGltZyA9IG5ldyBVOChidWZzW2ktMV0pLCBwaW1nMzIgPSBuZXcgVTMyKGJ1ZnNbaS0xXSksIG5pbWcgPSBpKzE8YnVmcy5sZW5ndGggPyBuZXcgVTgoYnVmc1tpKzFdKTpudWxsO1xuXHR2YXIgY2ltZyA9IG5ldyBVOChidWZzW2ldKSwgY2ltZzMyID0gbmV3IFUzMihjaW1nLmJ1ZmZlcik7XG5cdFxuXHR2YXIgbWl4PXcsbWl5PWgsbWF4PS0xLG1heT0tMTtcblx0Zm9yKHZhciB5PTA7IHk8ci5oZWlnaHQ7IHkrKykgZm9yKHZhciB4PTA7IHg8ci53aWR0aDsgeCsrKSB7XG5cdFx0dmFyIGN4ID0gci54K3gsIGN5ID0gci55K3k7XG5cdFx0dmFyIGogPSBjeSp3K2N4LCBjYyA9IGNpbWczMltqXTtcblx0XHQvLyBubyBuZWVkIHRvIGRyYXcgdHJhbnNwYXJlbmN5LCBvciB0byBkaXNwb3NlIGl0LiBPciwgaWYgd3JpdGluZyB0aGUgc2FtZSBjb2xvciBhbmQgdGhlIG5leHQgb25lIGRvZXMgbm90IG5lZWQgdHJhbnNwYXJlbmN5LlxuXHRcdGlmKGNjPT0wIHx8IChmcm1zW2ktMV0uZGlzcG9zZT09MCAmJiBwaW1nMzJbal09PWNjICYmIChuaW1nPT1udWxsIHx8IG5pbWdbaio0KzNdIT0wKSkvKiovKSB7fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYoY3g8bWl4KSBtaXg9Y3g7ICBpZihjeD5tYXgpIG1heD1jeDtcblx0XHRcdGlmKGN5PG1peSkgbWl5PWN5OyAgaWYoY3k+bWF5KSBtYXk9Y3k7XG5cdFx0fVxuXHR9XG5cdGlmKG1heD09LTEpIG1peD1taXk9bWF4PW1heT0wO1xuXHRpZihldmVuQ3JkKSB7ICBpZigobWl4JjEpPT0xKW1peC0tOyAgaWYoKG1peSYxKT09MSltaXktLTsgIH1cblx0ciA9IHt4Om1peCwgeTptaXksIHdpZHRoOm1heC1taXgrMSwgaGVpZ2h0Om1heS1taXkrMX07XG5cdFxuXHR2YXIgZnIgPSBmcm1zW2ldOyAgZnIucmVjdCA9IHI7ICBmci5ibGVuZCA9IDE7ICBmci5pbWcgPSBuZXcgVWludDhBcnJheShyLndpZHRoKnIuaGVpZ2h0KjQpO1xuXHRpZihmcm1zW2ktMV0uZGlzcG9zZT09MCkge1xuXHRcdFVQTkcuX2NvcHlUaWxlKHBpbWcsdyxoLCBmci5pbWcsci53aWR0aCxyLmhlaWdodCwgLXIueCwtci55LCAwKTtcblx0XHRVUE5HLmVuY29kZS5fcHJlcGFyZURpZmYoY2ltZyx3LGgsZnIuaW1nLHIpO1xuXHRcdC8vVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIGZyLmltZyxyLndpZHRoLHIuaGVpZ2h0LCAtci54LC1yLnksIDIpO1xuXHR9XG5cdGVsc2Vcblx0XHRVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgZnIuaW1nLHIud2lkdGgsci5oZWlnaHQsIC1yLngsLXIueSwgMCk7XG59XG5VUE5HLmVuY29kZS5fcHJlcGFyZURpZmYgPSBmdW5jdGlvbihjaW1nLCB3LGgsIG5pbWcsIHJlYykge1xuXHRVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgbmltZyxyZWMud2lkdGgscmVjLmhlaWdodCwgLXJlYy54LC1yZWMueSwgMik7XG5cdC8qXG5cdHZhciBuMzIgPSBuZXcgVWludDMyQXJyYXkobmltZy5idWZmZXIpO1xuXHR2YXIgb2cgPSBuZXcgVWludDhBcnJheShyZWMud2lkdGgqcmVjLmhlaWdodCo0KSwgbzMyID0gbmV3IFVpbnQzMkFycmF5KG9nLmJ1ZmZlcik7XG5cdFVQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBvZyxyZWMud2lkdGgscmVjLmhlaWdodCwgLXJlYy54LC1yZWMueSwgMCk7XG5cdGZvcih2YXIgaT00OyBpPG5pbWcubGVuZ3RoOyBpKz00KSB7XG5cdFx0aWYobmltZ1tpLTFdIT0wICYmIG5pbWdbaSszXT09MCAmJiBvMzJbaT4+PjJdPT1vMzJbKGk+Pj4yKS0xXSkge1xuXHRcdFx0bjMyW2k+Pj4yXT1vMzJbaT4+PjJdO1xuXHRcdFx0Ly92YXIgaiA9IGksIGM9cDMyWyhpPj4+MiktMV07XG5cdFx0XHQvL3doaWxlKHAzMltqPj4+Ml09PWMpIHsgIG4zMltqPj4+Ml09YzsgIGorPTQ7ICB9XG5cdFx0fVxuXHR9XG5cdGZvcih2YXIgaT1uaW1nLmxlbmd0aC04OyBpPjA7IGktPTQpIHtcblx0XHRpZihuaW1nW2krN10hPTAgJiYgbmltZ1tpKzNdPT0wICYmIG8zMltpPj4+Ml09PW8zMlsoaT4+PjIpKzFdKSB7XG5cdFx0XHRuMzJbaT4+PjJdPW8zMltpPj4+Ml07XG5cdFx0XHQvL3ZhciBqID0gaSwgYz1wMzJbKGk+Pj4yKS0xXTtcblx0XHRcdC8vd2hpbGUocDMyW2o+Pj4yXT09YykgeyAgbjMyW2o+Pj4yXT1jOyAgais9NDsgIH1cblx0XHR9XG5cdH0qL1xufVxuXG5VUE5HLmVuY29kZS5fZmlsdGVyWmVybyA9IGZ1bmN0aW9uKGltZyxoLGJwcCxicGwsZGF0YSwgZmlsdGVyLCBsZXZlbFplcm8pXG57XG5cdHZhciBmbHMgPSBbXSwgZnRyeT1bMCwxLDIsMyw0XTtcblx0aWYgICAgIChmaWx0ZXIhPS0xKSAgICAgICAgICAgICBmdHJ5PVtmaWx0ZXJdO1xuXHRlbHNlIGlmKGgqYnBsPjUwMDAwMCB8fCBicHA9PTEpIGZ0cnk9WzBdO1xuXHR2YXIgb3B0czsgIGlmKGxldmVsWmVybykgb3B0cz17bGV2ZWw6MH07XG5cdFxuXHR2YXIgQ01QUiA9IChsZXZlbFplcm8gJiYgVVpJUCE9bnVsbCkgPyBVWklQIDogcGFrbztcblx0XG5cdGZvcih2YXIgaT0wOyBpPGZ0cnkubGVuZ3RoOyBpKyspIHtcblx0XHRmb3IodmFyIHk9MDsgeTxoOyB5KyspIFVQTkcuZW5jb2RlLl9maWx0ZXJMaW5lKGRhdGEsIGltZywgeSwgYnBsLCBicHAsIGZ0cnlbaV0pO1xuXHRcdC8vdmFyIG5pbWcgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG5cdFx0Ly92YXIgc3ogPSBVWklQLkYuZGVmbGF0ZShkYXRhLCBuaW1nKTsgIGZscy5wdXNoKG5pbWcuc2xpY2UoMCxzeikpO1xuXHRcdC8vdmFyIGRmbCA9IHBha29bXCJkZWZsYXRlXCJdKGRhdGEpLCBkbD1kZmwubGVuZ3RoLTQ7XG5cdFx0Ly92YXIgY3JjID0gKGRmbFtkbCszXTw8MjQpfChkZmxbZGwrMl08PDE2KXwoZGZsW2RsKzFdPDw4KXwoZGZsW2RsKzBdPDwwKTtcblx0XHQvL2NvbnNvbGUubG9nKGNyYywgVVpJUC5hZGxlcihkYXRhLDIsZGF0YS5sZW5ndGgtNikpO1xuXHRcdGZscy5wdXNoKENNUFJbXCJkZWZsYXRlXCJdKGRhdGEsb3B0cykpO1xuXHR9XG5cdHZhciB0aSwgdHNpemU9MWU5O1xuXHRmb3IodmFyIGk9MDsgaTxmbHMubGVuZ3RoOyBpKyspIGlmKGZsc1tpXS5sZW5ndGg8dHNpemUpIHsgIHRpPWk7ICB0c2l6ZT1mbHNbaV0ubGVuZ3RoOyAgfVxuXHRyZXR1cm4gZmxzW3RpXTtcbn1cblVQTkcuZW5jb2RlLl9maWx0ZXJMaW5lID0gZnVuY3Rpb24oZGF0YSwgaW1nLCB5LCBicGwsIGJwcCwgdHlwZSlcbntcblx0dmFyIGkgPSB5KmJwbCwgZGkgPSBpK3ksIHBhZXRoID0gVVBORy5kZWNvZGUuX3BhZXRoXG5cdGRhdGFbZGldPXR5cGU7ICBkaSsrO1xuXG5cdGlmKHR5cGU9PTApIHtcblx0XHRpZihicGw8NTAwKSBmb3IodmFyIHg9MDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IGltZ1tpK3hdO1xuXHRcdGVsc2UgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoaW1nLmJ1ZmZlcixpLGJwbCksZGkpO1xuXHR9XG5cdGVsc2UgaWYodHlwZT09MSkge1xuXHRcdGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSAgaW1nW2kreF07XG5cdFx0Zm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XS1pbWdbaSt4LWJwcF0rMjU2KSYyNTU7XG5cdH1cblx0ZWxzZSBpZih5PT0wKSB7XG5cdFx0Zm9yKHZhciB4PSAgMDsgeDxicHA7IHgrKykgZGF0YVtkaSt4XSA9IGltZ1tpK3hdO1xuXG5cdFx0aWYodHlwZT09MikgZm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IGltZ1tpK3hdO1xuXHRcdGlmKHR5cGU9PTMpIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0gLSAoaW1nW2kreC1icHBdPj4xKSArMjU2KSYyNTU7XG5cdFx0aWYodHlwZT09NCkgZm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XSAtIHBhZXRoKGltZ1tpK3gtYnBwXSwgMCwgMCkgKzI1NikmMjU1O1xuXHR9XG5cdGVsc2Uge1xuXHRcdGlmKHR5cGU9PTIpIHsgZm9yKHZhciB4PSAgMDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XSsyNTYgLSBpbWdbaSt4LWJwbF0pJjI1NTsgIH1cblx0XHRpZih0eXBlPT0zKSB7IGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gKGltZ1tpK3gtYnBsXT4+MSkpJjI1NTtcblx0XHRcdFx0XHQgIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gKChpbWdbaSt4LWJwbF0raW1nW2kreC1icHBdKT4+MSkpJjI1NTsgIH1cblx0XHRpZih0eXBlPT00KSB7IGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gcGFldGgoMCwgaW1nW2kreC1icGxdLCAwKSkmMjU1O1xuXHRcdFx0XHRcdCAgZm9yKHZhciB4PWJwcDsgeDxicGw7IHgrKykgZGF0YVtkaSt4XSA9IChpbWdbaSt4XSsyNTYgLSBwYWV0aChpbWdbaSt4LWJwcF0sIGltZ1tpK3gtYnBsXSwgaW1nW2kreC1icHAtYnBsXSkpJjI1NTsgIH1cblx0fVxufVxuXG5VUE5HLmNyYyA9IHtcblx0dGFibGUgOiAoIGZ1bmN0aW9uKCkge1xuXHQgICB2YXIgdGFiID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG5cdCAgIGZvciAodmFyIG49MDsgbjwyNTY7IG4rKykge1xuXHRcdFx0dmFyIGMgPSBuO1xuXHRcdFx0Zm9yICh2YXIgaz0wOyBrPDg7IGsrKykge1xuXHRcdFx0XHRpZiAoYyAmIDEpICBjID0gMHhlZGI4ODMyMCBeIChjID4+PiAxKTtcblx0XHRcdFx0ZWxzZSAgICAgICAgYyA9IGMgPj4+IDE7XG5cdFx0XHR9XG5cdFx0XHR0YWJbbl0gPSBjOyAgfVxuXHRcdHJldHVybiB0YWI7ICB9KSgpLFxuXHR1cGRhdGUgOiBmdW5jdGlvbihjLCBidWYsIG9mZiwgbGVuKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSAgYyA9IFVQTkcuY3JjLnRhYmxlWyhjIF4gYnVmW29mZitpXSkgJiAweGZmXSBeIChjID4+PiA4KTtcblx0XHRyZXR1cm4gYztcblx0fSxcblx0Y3JjIDogZnVuY3Rpb24oYixvLGwpICB7ICByZXR1cm4gVVBORy5jcmMudXBkYXRlKDB4ZmZmZmZmZmYsYixvLGwpIF4gMHhmZmZmZmZmZjsgIH1cbn1cblxuXG5VUE5HLnF1YW50aXplID0gZnVuY3Rpb24oYWJ1ZiwgcHMpXG57XHRcblx0dmFyIG9pbWcgPSBuZXcgVWludDhBcnJheShhYnVmKSwgbmltZyA9IG9pbWcuc2xpY2UoMCksIG5pbWczMiA9IG5ldyBVaW50MzJBcnJheShuaW1nLmJ1ZmZlcik7XG5cdFxuXHR2YXIgS0QgPSBVUE5HLnF1YW50aXplLmdldEtEdHJlZShuaW1nLCBwcyk7XG5cdHZhciByb290ID0gS0RbMF0sIGxlYWZzID0gS0RbMV07XG5cdFxuXHR2YXIgcGxhbmVEc3QgPSBVUE5HLnF1YW50aXplLnBsYW5lRHN0O1xuXHR2YXIgc2IgPSBvaW1nLCB0YiA9IG5pbWczMiwgbGVuPXNiLmxlbmd0aDtcblx0XHRcblx0dmFyIGluZHMgPSBuZXcgVWludDhBcnJheShvaW1nLmxlbmd0aD4+Mik7XG5cdGZvcih2YXIgaT0wOyBpPGxlbjsgaSs9NCkge1xuXHRcdHZhciByPXNiW2ldKigxLzI1NSksIGc9c2JbaSsxXSooMS8yNTUpLCBiPXNiW2krMl0qKDEvMjU1KSwgYT1zYltpKzNdKigxLzI1NSk7XG5cdFx0XG5cdFx0Ly8gIGV4YWN0LCBidXQgdG9vIHNsb3cgOihcblx0XHR2YXIgbmQgPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qocm9vdCwgciwgZywgYiwgYSk7XG5cdFx0Ly92YXIgbmQgPSByb290O1xuXHRcdC8vd2hpbGUobmQubGVmdCkgbmQgPSAocGxhbmVEc3QobmQuZXN0LHIsZyxiLGEpPD0wKSA/IG5kLmxlZnQgOiBuZC5yaWdodDtcblx0XHRcblx0XHRpbmRzW2k+PjJdID0gbmQuaW5kO1xuXHRcdHRiW2k+PjJdID0gbmQuZXN0LnJnYmE7XG5cdH1cblx0cmV0dXJuIHsgIGFidWY6bmltZy5idWZmZXIsIGluZHM6aW5kcywgcGx0ZTpsZWFmcyAgfTtcbn1cblxuVVBORy5xdWFudGl6ZS5nZXRLRHRyZWUgPSBmdW5jdGlvbihuaW1nLCBwcywgZXJyKSB7XG5cdGlmKGVycj09bnVsbCkgZXJyID0gMC4wMDAxO1xuXHR2YXIgbmltZzMyID0gbmV3IFVpbnQzMkFycmF5KG5pbWcuYnVmZmVyKTtcblx0XG5cdHZhciByb290ID0ge2kwOjAsIGkxOm5pbWcubGVuZ3RoLCBic3Q6bnVsbCwgZXN0Om51bGwsIHRkc3Q6MCwgbGVmdDpudWxsLCByaWdodDpudWxsIH07ICAvLyBiYXNpYyBzdGF0aXN0aWMsIGV4dHJhIHN0YXRpc3RpY1xuXHRyb290LmJzdCA9IFVQTkcucXVhbnRpemUuc3RhdHMoICBuaW1nLHJvb3QuaTAsIHJvb3QuaTEgICk7ICByb290LmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKCByb290LmJzdCApO1xuXHR2YXIgbGVhZnMgPSBbcm9vdF07XG5cdFxuXHR3aGlsZShsZWFmcy5sZW5ndGg8cHMpXG5cdHtcblx0XHR2YXIgbWF4TCA9IDAsIG1pPTA7XG5cdFx0Zm9yKHZhciBpPTA7IGk8bGVhZnMubGVuZ3RoOyBpKyspIGlmKGxlYWZzW2ldLmVzdC5MID4gbWF4TCkgeyAgbWF4TD1sZWFmc1tpXS5lc3QuTDsgIG1pPWk7ICB9XG5cdFx0aWYobWF4TDxlcnIpIGJyZWFrO1xuXHRcdHZhciBub2RlID0gbGVhZnNbbWldO1xuXHRcdFxuXHRcdHZhciBzMCA9IFVQTkcucXVhbnRpemUuc3BsaXRQaXhlbHMobmltZyxuaW1nMzIsIG5vZGUuaTAsIG5vZGUuaTEsIG5vZGUuZXN0LmUsIG5vZGUuZXN0LmVNcTI1NSk7XG5cdFx0dmFyIHMwd3JvbmcgPSAobm9kZS5pMD49czAgfHwgbm9kZS5pMTw9czApO1xuXHRcdC8vY29uc29sZS5sb2cobWF4TCwgbGVhZnMubGVuZ3RoLCBtaSk7XG5cdFx0aWYoczB3cm9uZykgeyAgbm9kZS5lc3QuTD0wOyAgY29udGludWU7ICB9XG5cdFx0XG5cdFx0XG5cdFx0dmFyIGxuID0ge2kwOm5vZGUuaTAsIGkxOnMwLCBic3Q6bnVsbCwgZXN0Om51bGwsIHRkc3Q6MCwgbGVmdDpudWxsLCByaWdodDpudWxsIH07ICBsbi5ic3QgPSBVUE5HLnF1YW50aXplLnN0YXRzKCBuaW1nLCBsbi5pMCwgbG4uaTEgKTsgIFxuXHRcdGxuLmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKCBsbi5ic3QgKTtcblx0XHR2YXIgcm4gPSB7aTA6czAsIGkxOm5vZGUuaTEsIGJzdDpudWxsLCBlc3Q6bnVsbCwgdGRzdDowLCBsZWZ0Om51bGwsIHJpZ2h0Om51bGwgfTsgIHJuLmJzdCA9IHtSOltdLCBtOltdLCBOOm5vZGUuYnN0Lk4tbG4uYnN0Lk59O1xuXHRcdGZvcih2YXIgaT0wOyBpPDE2OyBpKyspIHJuLmJzdC5SW2ldID0gbm9kZS5ic3QuUltpXS1sbi5ic3QuUltpXTtcblx0XHRmb3IodmFyIGk9MDsgaTwgNDsgaSsrKSBybi5ic3QubVtpXSA9IG5vZGUuYnN0Lm1baV0tbG4uYnN0Lm1baV07XG5cdFx0cm4uZXN0ID0gVVBORy5xdWFudGl6ZS5lc3RhdHMoIHJuLmJzdCApO1xuXHRcdFxuXHRcdG5vZGUubGVmdCA9IGxuOyAgbm9kZS5yaWdodCA9IHJuO1xuXHRcdGxlYWZzW21pXT1sbjsgIGxlYWZzLnB1c2gocm4pO1xuXHR9XG5cdGxlYWZzLnNvcnQoZnVuY3Rpb24oYSxiKSB7ICByZXR1cm4gYi5ic3QuTi1hLmJzdC5OOyAgfSk7XG5cdGZvcih2YXIgaT0wOyBpPGxlYWZzLmxlbmd0aDsgaSsrKSBsZWFmc1tpXS5pbmQ9aTtcblx0cmV0dXJuIFtyb290LCBsZWFmc107XG59XG5cblVQTkcucXVhbnRpemUuZ2V0TmVhcmVzdCA9IGZ1bmN0aW9uKG5kLCByLGcsYixhKVxue1xuXHRpZihuZC5sZWZ0PT1udWxsKSB7ICBuZC50ZHN0ID0gVVBORy5xdWFudGl6ZS5kaXN0KG5kLmVzdC5xLHIsZyxiLGEpOyAgcmV0dXJuIG5kOyAgfVxuXHR2YXIgcGxhbmVEc3QgPSBVUE5HLnF1YW50aXplLnBsYW5lRHN0KG5kLmVzdCxyLGcsYixhKTtcblx0XG5cdHZhciBub2RlMCA9IG5kLmxlZnQsIG5vZGUxID0gbmQucmlnaHQ7XG5cdGlmKHBsYW5lRHN0PjApIHsgIG5vZGUwPW5kLnJpZ2h0OyAgbm9kZTE9bmQubGVmdDsgIH1cblx0XG5cdHZhciBsbiA9IFVQTkcucXVhbnRpemUuZ2V0TmVhcmVzdChub2RlMCwgcixnLGIsYSk7XG5cdGlmKGxuLnRkc3Q8PXBsYW5lRHN0KnBsYW5lRHN0KSByZXR1cm4gbG47XG5cdHZhciBybiA9IFVQTkcucXVhbnRpemUuZ2V0TmVhcmVzdChub2RlMSwgcixnLGIsYSk7XG5cdHJldHVybiBybi50ZHN0PGxuLnRkc3QgPyBybiA6IGxuO1xufVxuVVBORy5xdWFudGl6ZS5wbGFuZURzdCA9IGZ1bmN0aW9uKGVzdCwgcixnLGIsYSkgeyAgdmFyIGUgPSBlc3QuZTsgIHJldHVybiBlWzBdKnIgKyBlWzFdKmcgKyBlWzJdKmIgKyBlWzNdKmEgLSBlc3QuZU1xOyAgfVxuVVBORy5xdWFudGl6ZS5kaXN0ICAgICA9IGZ1bmN0aW9uKHEsICAgcixnLGIsYSkgeyAgdmFyIGQwPXItcVswXSwgZDE9Zy1xWzFdLCBkMj1iLXFbMl0sIGQzPWEtcVszXTsgIHJldHVybiBkMCpkMCtkMSpkMStkMipkMitkMypkMzsgIH1cblxuVVBORy5xdWFudGl6ZS5zcGxpdFBpeGVscyA9IGZ1bmN0aW9uKG5pbWcsIG5pbWczMiwgaTAsIGkxLCBlLCBlTXEpXG57XG5cdHZhciB2ZWNEb3QgPSBVUE5HLnF1YW50aXplLnZlY0RvdDtcblx0aTEtPTQ7XG5cdHZhciBzaGZzID0gMDtcblx0d2hpbGUoaTA8aTEpXG5cdHtcblx0XHR3aGlsZSh2ZWNEb3QobmltZywgaTAsIGUpPD1lTXEpIGkwKz00O1xuXHRcdHdoaWxlKHZlY0RvdChuaW1nLCBpMSwgZSk+IGVNcSkgaTEtPTQ7XG5cdFx0aWYoaTA+PWkxKSBicmVhaztcblx0XHRcblx0XHR2YXIgdCA9IG5pbWczMltpMD4+Ml07ICBuaW1nMzJbaTA+PjJdID0gbmltZzMyW2kxPj4yXTsgIG5pbWczMltpMT4+Ml09dDtcblx0XHRcblx0XHRpMCs9NDsgIGkxLT00O1xuXHR9XG5cdHdoaWxlKHZlY0RvdChuaW1nLCBpMCwgZSk+ZU1xKSBpMC09NDtcblx0cmV0dXJuIGkwKzQ7XG59XG5VUE5HLnF1YW50aXplLnZlY0RvdCA9IGZ1bmN0aW9uKG5pbWcsIGksIGUpXG57XG5cdHJldHVybiBuaW1nW2ldKmVbMF0gKyBuaW1nW2krMV0qZVsxXSArIG5pbWdbaSsyXSplWzJdICsgbmltZ1tpKzNdKmVbM107XG59XG5VUE5HLnF1YW50aXplLnN0YXRzID0gZnVuY3Rpb24obmltZywgaTAsIGkxKXtcblx0dmFyIFIgPSBbMCwwLDAsMCwgIDAsMCwwLDAsICAwLDAsMCwwLCAgMCwwLDAsMF07XG5cdHZhciBtID0gWzAsMCwwLDBdO1xuXHR2YXIgTiA9IChpMS1pMCk+PjI7XG5cdGZvcih2YXIgaT1pMDsgaTxpMTsgaSs9NClcblx0e1xuXHRcdHZhciByID0gbmltZ1tpXSooMS8yNTUpLCBnID0gbmltZ1tpKzFdKigxLzI1NSksIGIgPSBuaW1nW2krMl0qKDEvMjU1KSwgYSA9IG5pbWdbaSszXSooMS8yNTUpO1xuXHRcdC8vdmFyIHIgPSBuaW1nW2ldLCBnID0gbmltZ1tpKzFdLCBiID0gbmltZ1tpKzJdLCBhID0gbmltZ1tpKzNdO1xuXHRcdG1bMF0rPXI7ICBtWzFdKz1nOyAgbVsyXSs9YjsgIG1bM10rPWE7XG5cdFx0XG5cdFx0UlsgMF0gKz0gcipyOyAgUlsgMV0gKz0gcipnOyAgUlsgMl0gKz0gcipiOyAgUlsgM10gKz0gciphOyAgXG5cdFx0ICAgICAgICAgICAgICAgUlsgNV0gKz0gZypnOyAgUlsgNl0gKz0gZypiOyAgUlsgN10gKz0gZyphOyBcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSWzEwXSArPSBiKmI7ICBSWzExXSArPSBiKmE7ICBcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSWzE1XSArPSBhKmE7ICBcblx0fVxuXHRSWzRdPVJbMV07ICBSWzhdPVJbMl07ICBSWzldPVJbNl07ICBSWzEyXT1SWzNdOyAgUlsxM109Uls3XTsgIFJbMTRdPVJbMTFdO1xuXHRcblx0cmV0dXJuIHtSOlIsIG06bSwgTjpOfTtcbn1cblVQTkcucXVhbnRpemUuZXN0YXRzID0gZnVuY3Rpb24oc3RhdHMpe1xuXHR2YXIgUiA9IHN0YXRzLlIsIG0gPSBzdGF0cy5tLCBOID0gc3RhdHMuTjtcblx0XG5cdC8vIHdoZW4gYWxsIHNhbXBsZXMgYXJlIGVxdWFsLCBidXQgTiBpcyBsYXJnZSAobWlsbGlvbnMpLCB0aGUgUmogY2FuIGJlIG5vbi16ZXJvICggMC4wMDAzLi4uLiAtIHByZWNpc3Npb24gZXJyb3IpXG5cdHZhciBtMCA9IG1bMF0sIG0xID0gbVsxXSwgbTIgPSBtWzJdLCBtMyA9IG1bM10sIGlOID0gKE49PTAgPyAwIDogMS9OKTtcblx0dmFyIFJqID0gW1xuXHRcdFJbIDBdIC0gbTAqbTAqaU4sICBSWyAxXSAtIG0wKm0xKmlOLCAgUlsgMl0gLSBtMCptMippTiwgIFJbIDNdIC0gbTAqbTMqaU4sICBcblx0XHRSWyA0XSAtIG0xKm0wKmlOLCAgUlsgNV0gLSBtMSptMSppTiwgIFJbIDZdIC0gbTEqbTIqaU4sICBSWyA3XSAtIG0xKm0zKmlOLFxuXHRcdFJbIDhdIC0gbTIqbTAqaU4sICBSWyA5XSAtIG0yKm0xKmlOLCAgUlsxMF0gLSBtMiptMippTiwgIFJbMTFdIC0gbTIqbTMqaU4sICBcblx0XHRSWzEyXSAtIG0zKm0wKmlOLCAgUlsxM10gLSBtMyptMSppTiwgIFJbMTRdIC0gbTMqbTIqaU4sICBSWzE1XSAtIG0zKm0zKmlOIFxuXHRdO1xuXHRcblx0dmFyIEEgPSBSaiwgTSA9IFVQTkcuTTQ7XG5cdHZhciBiID0gWzAuNSwwLjUsMC41LDAuNV0sIG1pID0gMCwgdG1pID0gMDtcblx0XG5cdGlmKE4hPTApXG5cdGZvcih2YXIgaT0wOyBpPDEwOyBpKyspIHtcblx0XHRiID0gTS5tdWx0VmVjKEEsIGIpOyAgdG1pID0gTWF0aC5zcXJ0KE0uZG90KGIsYikpOyAgYiA9IE0uc21sKDEvdG1pLCAgYik7XG5cdFx0aWYoTWF0aC5hYnModG1pLW1pKTwxZS05KSBicmVhazsgIG1pID0gdG1pO1xuXHR9XHRcblx0Ly9iID0gWzAsMCwxLDBdOyAgbWk9Tjtcblx0dmFyIHEgPSBbbTAqaU4sIG0xKmlOLCBtMippTiwgbTMqaU5dO1xuXHR2YXIgZU1xMjU1ID0gTS5kb3QoTS5zbWwoMjU1LHEpLGIpO1xuXHRcblx0cmV0dXJuIHsgIENvdjpSaiwgcTpxLCBlOmIsIEw6bWksICBlTXEyNTU6ZU1xMjU1LCBlTXEgOiBNLmRvdChiLHEpLFxuXHRcdFx0XHRyZ2JhOiAoKChNYXRoLnJvdW5kKDI1NSpxWzNdKTw8MjQpIHwgKE1hdGgucm91bmQoMjU1KnFbMl0pPDwxNikgfCAgKE1hdGgucm91bmQoMjU1KnFbMV0pPDw4KSB8IChNYXRoLnJvdW5kKDI1NSpxWzBdKTw8MCkpPj4+MCkgIH07XG59XG5VUE5HLk00ID0ge1xuXHRtdWx0VmVjIDogZnVuY3Rpb24obSx2KSB7XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRtWyAwXSp2WzBdICsgbVsgMV0qdlsxXSArIG1bIDJdKnZbMl0gKyBtWyAzXSp2WzNdLFxuXHRcdFx0XHRtWyA0XSp2WzBdICsgbVsgNV0qdlsxXSArIG1bIDZdKnZbMl0gKyBtWyA3XSp2WzNdLFxuXHRcdFx0XHRtWyA4XSp2WzBdICsgbVsgOV0qdlsxXSArIG1bMTBdKnZbMl0gKyBtWzExXSp2WzNdLFxuXHRcdFx0XHRtWzEyXSp2WzBdICsgbVsxM10qdlsxXSArIG1bMTRdKnZbMl0gKyBtWzE1XSp2WzNdXG5cdFx0XHRdO1xuXHR9LFxuXHRkb3QgOiBmdW5jdGlvbih4LHkpIHsgIHJldHVybiAgeFswXSp5WzBdK3hbMV0qeVsxXSt4WzJdKnlbMl0reFszXSp5WzNdOyAgfSxcblx0c21sIDogZnVuY3Rpb24oYSx5KSB7ICByZXR1cm4gW2EqeVswXSxhKnlbMV0sYSp5WzJdLGEqeVszXV07ICB9XG59XG5cblVQTkcuZW5jb2RlLmNvbmNhdFJHQkEgPSBmdW5jdGlvbihidWZzKSB7XG5cdHZhciB0bGVuID0gMDtcblx0Zm9yKHZhciBpPTA7IGk8YnVmcy5sZW5ndGg7IGkrKykgdGxlbiArPSBidWZzW2ldLmJ5dGVMZW5ndGg7XG5cdHZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkodGxlbiksIG5vZmY9MDtcblx0Zm9yKHZhciBpPTA7IGk8YnVmcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpbWcgPSBuZXcgVWludDhBcnJheShidWZzW2ldKSwgaWwgPSBpbWcubGVuZ3RoO1xuXHRcdGZvcih2YXIgaj0wOyBqPGlsOyBqKz00KSB7ICBcblx0XHRcdHZhciByPWltZ1tqXSwgZz1pbWdbaisxXSwgYj1pbWdbaisyXSwgYSA9IGltZ1tqKzNdO1xuXHRcdFx0aWYoYT09MCkgcj1nPWI9MDtcblx0XHRcdG5pbWdbbm9mZitqXT1yOyAgbmltZ1tub2ZmK2orMV09ZzsgIG5pbWdbbm9mZitqKzJdPWI7ICBuaW1nW25vZmYraiszXT1hOyAgfVxuXHRcdG5vZmYgKz0gaWw7XG5cdH1cblx0cmV0dXJuIG5pbWcuYnVmZmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUE5HO1xuXG4iXSwibmFtZXMiOlsicGFrbyIsIlVQTkciLCJ0b1JHQkE4Iiwib3V0IiwidyIsIndpZHRoIiwiaCIsImhlaWdodCIsInRhYnMiLCJhY1RMIiwiZGVjb2RlSW1hZ2UiLCJkYXRhIiwiYnVmZmVyIiwiZnJtcyIsImZyYW1lcyIsImxlbiIsImltZyIsIlVpbnQ4QXJyYXkiLCJlbXB0eSIsInByZXYiLCJpIiwibGVuZ3RoIiwiZnJtIiwiZngiLCJyZWN0IiwieCIsImZ5IiwieSIsImZ3IiwiZmgiLCJmZGF0YSIsImoiLCJibGVuZCIsIl9jb3B5VGlsZSIsInB1c2giLCJzbGljZSIsImRpc3Bvc2UiLCJhcmVhIiwiYnBwIiwiZGVjb2RlIiwiX2dldEJQUCIsImJwbCIsIk1hdGgiLCJjZWlsIiwiYmYiLCJiZjMyIiwiVWludDMyQXJyYXkiLCJjdHlwZSIsImRlcHRoIiwicnMiLCJfYmluIiwicmVhZFVzaG9ydCIsInRpbWUiLCJEYXRlIiwibm93IiwicWFyZWEiLCJ0cyIsInRpIiwidHIiLCJ0ZyIsInRiIiwicWkiLCJwIiwiYXAiLCJ0bCIsInMwIiwidDAiLCJjaiIsImRpIiwiZ3IiLCJvZmYiLCJ0byIsImFsIiwiYnVmZiIsIm9mZnNldCIsImJpbiIsInJVcyIsInJVaSIsInJlYWRVaW50IiwiZGQiLCJkb2ZmIiwiZmQiLCJmb2ZmIiwibWdjayIsInR5cGUiLCJyZWFkQVNDSUkiLCJfSUhEUiIsIm51bV9mcmFtZXMiLCJudW1fcGxheXMiLCJmciIsIl9kZWNvbXByZXNzIiwicmN0IiwiZGVsIiwiZGVsYXkiLCJyb3VuZCIsIm56IiwibmV4dFplcm8iLCJrZXl3IiwidGV4dCIsImNmbGFnIiwiY21ldGgiLCJsdGFnIiwidGtleXciLCJyZWFkVVRGOCIsInJlYWRCeXRlcyIsInBsIiwiY3JjIiwiY29tcHJlc3MiLCJpbnRlcmxhY2UiLCJmaWx0ZXIiLCJfaW5mbGF0ZSIsIl9maWx0ZXJaZXJvIiwiX3JlYWRJbnRlcmxhY2UiLCJpbmZsYXRlUmF3IiwiSCIsIk4iLCJXIiwiUiIsIm0iLCJKIiwiUSIsIlgiLCJ1IiwiZCIsInYiLCJDIiwiViIsIm4iLCJiIiwiQSIsImUiLCJsIiwiTSIsIkkiLCJaIiwiRCIsInEiLCJzZXQiLCJieXRlT2Zmc2V0IiwiRSIsImMiLCJLIiwiciIsIlMiLCJUIiwieiIsIl8iLCIkIiwicyIsIlkiLCJhIiwiVWludDE2QXJyYXkiLCJ0IiwiayIsImciLCJjYnBwIiwic3RhcnRpbmdfcm93Iiwic3RhcnRpbmdfY29sIiwicm93X2luY3JlbWVudCIsImNvbF9pbmNyZW1lbnQiLCJwYXNzIiwicmkiLCJjaSIsInN3Iiwic2giLCJjciIsImNjIiwiYnBsbCIsInJvdyIsImNvbCIsImNkaSIsInZhbCIsImlpIiwibm9jIiwicGFldGgiLCJfcGFldGgiLCJwYSIsInBiIiwicGMiLCJ3cml0ZVVzaG9ydCIsIndyaXRlVWludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIndyaXRlQVNDSUkiLCJjaGFyQ29kZUF0IiwiYXJyIiwicGFkIiwibnMiLCJ0b1N0cmluZyIsImRlY29kZVVSSUNvbXBvbmVudCIsInNiIiwidHciLCJ0aCIsInhvZmYiLCJ5b2ZmIiwibW9kZSIsIm1pbiIsInNpIiwiZmEiLCJmZyIsImZiIiwiYmEiLCJiciIsImJnIiwiYmIiLCJpZmEiLCJvYSIsImlvYSIsImVuY29kZSIsImJ1ZnMiLCJwcyIsImRlbHMiLCJmb3JiaWRQbHRlIiwibmltZyIsImNvbXByZXNzUE5HIiwiX21haW4iLCJlbmNvZGVMTCIsImFjIiwiYmlwcCIsImJpcGwiLCJ3VWkiLCJ3VXMiLCJ3QXMiLCJhbmltIiwicGx0QWxwaGEiLCJsZW5nIiwiZGwiLCJwbHRlIiwiY2ltZyIsIndyIiwiZmkiLCJpbWdkIiwiaW9mZiIsImxldmVsWmVybyIsIm53IiwibmgiLCJwcm1zIiwib25seUJsZW5kIiwiZXZlbkNyZCIsImZvcmJpZFByZXYiLCJtaW5CaXRzIiwiYWxwaGFBbmQiLCJpbGVuIiwiZ290QWxwaGEiLCJmcmFtaXplIiwiY21hcCIsImluZHMiLCJuYnVmcyIsImFidWYiLCJjb25jYXRSR0JBIiwicXJlcyIsInF1YW50aXplIiwiY29mIiwiYmxuIiwiZXN0IiwicmdiYSIsImltZzMyIiwiaW5kIiwiY21jIiwibWF4IiwibngiLCJueSIsImNpbWczMiIsImluaiIsImFsd2F5c0JsZW5kIiwidGxpbSIsInRzdHAiLCJ0YXJlYSIsIml0IiwicGltZyIsInAzMiIsIm1peCIsIm1peSIsIm1heSIsInNhcmVhIiwiX3ByZXBhcmVEaWZmIiwicjAiLCJyMSIsIm1pWCIsIm1pWSIsIm1hWCIsIm1hWSIsIl91cGRhdGVGcmFtZSIsIlU4IiwiVTMyIiwicGltZzMyIiwiY3giLCJjeSIsInJlYyIsImZscyIsImZ0cnkiLCJvcHRzIiwibGV2ZWwiLCJDTVBSIiwiVVpJUCIsIl9maWx0ZXJMaW5lIiwidHNpemUiLCJ0YWJsZSIsInRhYiIsInVwZGF0ZSIsImJ1ZiIsIm8iLCJvaW1nIiwibmltZzMyIiwiS0QiLCJnZXRLRHRyZWUiLCJyb290IiwibGVhZnMiLCJwbGFuZURzdCIsIm5kIiwiZ2V0TmVhcmVzdCIsImVyciIsImkwIiwiaTEiLCJic3QiLCJ0ZHN0IiwibGVmdCIsInJpZ2h0Iiwic3RhdHMiLCJlc3RhdHMiLCJtYXhMIiwibWkiLCJMIiwibm9kZSIsInNwbGl0UGl4ZWxzIiwiZU1xMjU1IiwiczB3cm9uZyIsImxuIiwicm4iLCJzb3J0IiwiZGlzdCIsIm5vZGUwIiwibm9kZTEiLCJlTXEiLCJkMCIsImQxIiwiZDIiLCJkMyIsInZlY0RvdCIsInNoZnMiLCJtMCIsIm0xIiwibTIiLCJtMyIsImlOIiwiUmoiLCJNNCIsInRtaSIsIm11bHRWZWMiLCJzcXJ0IiwiZG90Iiwic21sIiwiYWJzIiwiQ292IiwidGxlbiIsImJ5dGVMZW5ndGgiLCJub2ZmIiwiaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/UPNG.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Top level file is just a mixin of submodules & constants\n\nvar assign = (__webpack_require__(/*! ./lib/utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\").assign);\nvar deflate = __webpack_require__(/*! ./lib/deflate */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js\");\nvar inflate = __webpack_require__(/*! ./lib/inflate */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js\");\nvar pako = {};\nassign(pako, deflate, inflate, constants);\nmodule.exports = pako;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyREFBMkQ7QUFDM0Q7QUFFQSxJQUFJQSxTQUFZQyxrSUFBb0M7QUFFcEQsSUFBSUMsVUFBWUQsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUUsVUFBWUYsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUcsWUFBWUgsbUJBQU9BLENBQUM7QUFFeEIsSUFBSUksT0FBTyxDQUFDO0FBRVpMLE9BQU9LLE1BQU1ILFNBQVNDLFNBQVNDO0FBRS9CRSxPQUFPQyxPQUFPLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9pbmRleC5qcz85MDA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iXSwibmFtZXMiOlsiYXNzaWduIiwicmVxdWlyZSIsImRlZmxhdGUiLCJpbmZsYXRlIiwiY29uc3RhbnRzIiwicGFrbyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js\");\nvar toString = Object.prototype.toString;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ var Z_NO_FLUSH = 0;\nvar Z_FINISH = 4;\nvar Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_SYNC_FLUSH = 2;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_DEFAULT_STRATEGY = 0;\nvar Z_DEFLATED = 8;\n/* ===========================================================================*/ /**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/ /* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/ /**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/ /**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/ /**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/ function Deflate(options) {\n    if (!(this instanceof Deflate)) return new Deflate(options);\n    this.options = utils.assign({\n        level: Z_DEFAULT_COMPRESSION,\n        method: Z_DEFLATED,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    if (opt.raw && opt.windowBits > 0) {\n        opt.windowBits = -opt.windowBits;\n    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n        opt.windowBits += 16;\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n    if (status !== Z_OK) {\n        throw new Error(msg[status]);\n    }\n    if (opt.header) {\n        zlib_deflate.deflateSetHeader(this.strm, opt.header);\n    }\n    if (opt.dictionary) {\n        var dict;\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            // If we need to compress text, change encoding to utf8.\n            dict = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            dict = new Uint8Array(opt.dictionary);\n        } else {\n            dict = opt.dictionary;\n        }\n        status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n        if (status !== Z_OK) {\n            throw new Error(msg[status]);\n        }\n        this._dict_set = true;\n    }\n}\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Deflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var status, _mode;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // If we need to compress text, change encoding to utf8.\n        strm.input = strings.string2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_deflate.deflate(strm, _mode); /* no bad return value */ \n        if (status !== Z_STREAM_END && status !== Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {\n            if (this.options.to === \"string\") {\n                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n            } else {\n                this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n            }\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n    // Finalize on the last chunk.\n    if (_mode === Z_FINISH) {\n        status = zlib_deflate.deflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === Z_SYNC_FLUSH) {\n        this.onEnd(Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Deflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Deflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === Z_OK) {\n        if (this.options.to === \"string\") {\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/ function deflate(input, options) {\n    var deflator = new Deflate(options);\n    deflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (deflator.err) {\n        throw deflator.msg || msg[deflator.err];\n    }\n    return deflator.result;\n}\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function deflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return deflate(input, options);\n}\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/ function gzip(input, options) {\n    options = options || {};\n    options.gzip = true;\n    return deflate(input, options);\n}\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUdBLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlDLFFBQWVELG1CQUFPQSxDQUFDO0FBQzNCLElBQUlFLFVBQWVGLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlHLE1BQWVILG1CQUFPQSxDQUFDO0FBQzNCLElBQUlJLFVBQWVKLG1CQUFPQSxDQUFDO0FBRTNCLElBQUlLLFdBQVdDLE9BQU9DLFNBQVMsQ0FBQ0YsUUFBUTtBQUV4Qyw4RUFBOEUsR0FDOUUsOEVBQThFLEdBRTlFLElBQUlHLGFBQWtCO0FBQ3RCLElBQUlDLFdBQWtCO0FBRXRCLElBQUlDLE9BQWtCO0FBQ3RCLElBQUlDLGVBQWtCO0FBQ3RCLElBQUlDLGVBQWtCO0FBRXRCLElBQUlDLHdCQUF3QixDQUFDO0FBRTdCLElBQUlDLHFCQUF3QjtBQUU1QixJQUFJQyxhQUFjO0FBRWxCLDhFQUE4RSxHQUc5RTs7Ozs7O0VBTUUsR0FFRjs7OztFQUlFLEdBRUY7Ozs7Ozs7O0VBUUUsR0FFRjs7Ozs7OztFQU9FLEdBRUY7Ozs7RUFJRSxHQUdGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFnREUsR0FDRixTQUFTQyxRQUFRQyxPQUFPO0lBQ3RCLElBQUksQ0FBRSxLQUFJLFlBQVlELE9BQU0sR0FBSSxPQUFPLElBQUlBLFFBQVFDO0lBRW5ELElBQUksQ0FBQ0EsT0FBTyxHQUFHaEIsTUFBTWlCLE1BQU0sQ0FBQztRQUMxQkMsT0FBT047UUFDUE8sUUFBUUw7UUFDUk0sV0FBVztRQUNYQyxZQUFZO1FBQ1pDLFVBQVU7UUFDVkMsVUFBVVY7UUFDVlcsSUFBSTtJQUNOLEdBQUdSLFdBQVcsQ0FBQztJQUVmLElBQUlTLE1BQU0sSUFBSSxDQUFDVCxPQUFPO0lBRXRCLElBQUlTLElBQUlDLEdBQUcsSUFB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QUFFakMsT0FBTztJQUNoQ0EsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCQSxRQUFRVSxHQUFHLEdBQUc7SUFDZCxPQUFPOEIsUUFBUVAsT0FBT2pDO0FBQ3hCO0FBR0E7Ozs7Ozs7RUFPRSxHQUNGLFNBQVNXLEtBQUtzQixLQUFLLEVBQUVqQyxPQUFPO0lBQzFCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEJBLFFBQVFXLElBQUksR0FBRztJQUNmLE9BQU82QixRQUFRUCxPQUFPakM7QUFDeEI7QUFHQW9ELGVBQWUsR0FBR3JEO0FBQ2xCcUQsZUFBZSxHQUFHWjtBQUNsQlksa0JBQWtCLEdBQUdEO0FBQ3JCQyxZQUFZLEdBQUd6QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL2RlZmxhdGUuanM/NWJiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iXSwibmFtZXMiOlsiemxpYl9kZWZsYXRlIiwicmVxdWlyZSIsInV0aWxzIiwic3RyaW5ncyIsIm1zZyIsIlpTdHJlYW0iLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsIlpfTk9fRkxVU0giLCJaX0ZJTklTSCIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX1NZTkNfRkxVU0giLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0RFRkxBVEVEIiwiRGVmbGF0ZSIsIm9wdGlvbnMiLCJhc3NpZ24iLCJsZXZlbCIsIm1ldGhvZCIsImNodW5rU2l6ZSIsIndpbmRvd0JpdHMiLCJtZW1MZXZlbCIsInN0cmF0ZWd5IiwidG8iLCJvcHQiLCJyYXciLCJnemlwIiwiZXJyIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0Iiwic3RhdHVzIiwiZGVmbGF0ZUluaXQyIiwiRXJyb3IiLCJoZWFkZXIiLCJkZWZsYXRlU2V0SGVhZGVyIiwiZGljdGlvbmFyeSIsImRpY3QiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsIl9kaWN0X3NldCIsInB1c2giLCJkYXRhIiwibW9kZSIsIl9tb2RlIiwiaW5wdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJsZW5ndGgiLCJvdXRwdXQiLCJCdWY4IiwibmV4dF9vdXQiLCJkZWZsYXRlIiwib25FbmQiLCJvbkRhdGEiLCJidWYyYmluc3RyaW5nIiwic2hyaW5rQnVmIiwiZGVmbGF0ZUVuZCIsImNodW5rIiwicmVzdWx0Iiwiam9pbiIsImZsYXR0ZW5DaHVua3MiLCJkZWZsYXRvciIsImRlZmxhdGVSYXciLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js\");\nvar utils = __webpack_require__(/*! ./utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar strings = __webpack_require__(/*! ./utils/strings */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js\");\nvar c = __webpack_require__(/*! ./zlib/constants */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js\");\nvar msg = __webpack_require__(/*! ./zlib/messages */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\");\nvar ZStream = __webpack_require__(/*! ./zlib/zstream */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader = __webpack_require__(/*! ./zlib/gzheader */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js\");\nvar toString = Object.prototype.toString;\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/ /* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/ /**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/ /**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/ /**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/ /**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/ function Inflate(options) {\n    if (!(this instanceof Inflate)) return new Inflate(options);\n    this.options = utils.assign({\n        chunkSize: 16384,\n        windowBits: 0,\n        to: \"\"\n    }, options || {});\n    var opt = this.options;\n    // Force window size for `raw` data, if not set directly,\n    // because we have no header for autodetect.\n    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n        opt.windowBits = -opt.windowBits;\n        if (opt.windowBits === 0) {\n            opt.windowBits = -15;\n        }\n    }\n    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n        opt.windowBits += 32;\n    }\n    // Gzip header has no info about windows size, we can do autodetect only\n    // for deflate. So, if window size not set, force it to max when gzip possible\n    if (opt.windowBits > 15 && opt.windowBits < 48) {\n        // bit 3 (16) -> gzipped data\n        // bit 4 (32) -> autodetect gzip/deflate\n        if ((opt.windowBits & 15) === 0) {\n            opt.windowBits |= 15;\n        }\n    }\n    this.err = 0; // error code, if happens (0 = Z_OK)\n    this.msg = \"\"; // error message\n    this.ended = false; // used to avoid multiple onEnd() calls\n    this.chunks = []; // chunks of compressed data\n    this.strm = new ZStream();\n    this.strm.avail_out = 0;\n    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n    if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n    }\n    this.header = new GZheader();\n    zlib_inflate.inflateGetHeader(this.strm, this.header);\n    // Setup dictionary\n    if (opt.dictionary) {\n        // Convert data if needed\n        if (typeof opt.dictionary === \"string\") {\n            opt.dictionary = strings.string2buf(opt.dictionary);\n        } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n            opt.dictionary = new Uint8Array(opt.dictionary);\n        }\n        if (opt.raw) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n            if (status !== c.Z_OK) {\n                throw new Error(msg[status]);\n            }\n        }\n    }\n}\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/ Inflate.prototype.push = function(data, mode) {\n    var strm = this.strm;\n    var chunkSize = this.options.chunkSize;\n    var dictionary = this.options.dictionary;\n    var status, _mode;\n    var next_out_utf8, tail, utf8str;\n    // Flag to properly process Z_BUF_ERROR on testing inflate call\n    // when we check that all output data was flushed.\n    var allowBufError = false;\n    if (this.ended) {\n        return false;\n    }\n    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;\n    // Convert data if needed\n    if (typeof data === \"string\") {\n        // Only binary strings can be decompressed on practice\n        strm.input = strings.binstring2buf(data);\n    } else if (toString.call(data) === \"[object ArrayBuffer]\") {\n        strm.input = new Uint8Array(data);\n    } else {\n        strm.input = data;\n    }\n    strm.next_in = 0;\n    strm.avail_in = strm.input.length;\n    do {\n        if (strm.avail_out === 0) {\n            strm.output = new utils.Buf8(chunkSize);\n            strm.next_out = 0;\n            strm.avail_out = chunkSize;\n        }\n        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH); /* no bad return value */ \n        if (status === c.Z_NEED_DICT && dictionary) {\n            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n        }\n        if (status === c.Z_BUF_ERROR && allowBufError === true) {\n            status = c.Z_OK;\n            allowBufError = false;\n        }\n        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n            this.onEnd(status);\n            this.ended = true;\n            return false;\n        }\n        if (strm.next_out) {\n            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {\n                if (this.options.to === \"string\") {\n                    next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n                    tail = strm.next_out - next_out_utf8;\n                    utf8str = strings.buf2string(strm.output, next_out_utf8);\n                    // move tail\n                    strm.next_out = tail;\n                    strm.avail_out = chunkSize - tail;\n                    if (tail) {\n                        utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n                    }\n                    this.onData(utf8str);\n                } else {\n                    this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n                }\n            }\n        }\n        // When no more input data, we should check that internal inflate buffers\n        // are flushed. The only way to do it when avail_out = 0 - run one more\n        // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n        // Here we set flag to process this error properly.\n        //\n        // NOTE. Deflate does not return error in this case and does not needs such\n        // logic.\n        if (strm.avail_in === 0 && strm.avail_out === 0) {\n            allowBufError = true;\n        }\n    }while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n    if (status === c.Z_STREAM_END) {\n        _mode = c.Z_FINISH;\n    }\n    // Finalize on the last chunk.\n    if (_mode === c.Z_FINISH) {\n        status = zlib_inflate.inflateEnd(this.strm);\n        this.onEnd(status);\n        this.ended = true;\n        return status === c.Z_OK;\n    }\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === c.Z_SYNC_FLUSH) {\n        this.onEnd(c.Z_OK);\n        strm.avail_out = 0;\n        return true;\n    }\n    return true;\n};\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/ Inflate.prototype.onData = function(chunk) {\n    this.chunks.push(chunk);\n};\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/ Inflate.prototype.onEnd = function(status) {\n    // On success - join\n    if (status === c.Z_OK) {\n        if (this.options.to === \"string\") {\n            // Glue & convert here, until we teach pako to send\n            // utf8 aligned strings to onData\n            this.result = this.chunks.join(\"\");\n        } else {\n            this.result = utils.flattenChunks(this.chunks);\n        }\n    }\n    this.chunks = [];\n    this.err = status;\n    this.msg = this.strm.msg;\n};\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/ function inflate(input, options) {\n    var inflator = new Inflate(options);\n    inflator.push(input, true);\n    // That will never happens, if you don't cheat with options :)\n    if (inflator.err) {\n        throw inflator.msg || msg[inflator.err];\n    }\n    return inflator.result;\n}\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/ function inflateRaw(input, options) {\n    options = options || {};\n    options.raw = true;\n    return inflate(input, options);\n}\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/ exports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip = inflate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUdBLElBQUlBLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlDLFFBQWVELG1CQUFPQSxDQUFDO0FBQzNCLElBQUlFLFVBQWVGLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlHLElBQWVILG1CQUFPQSxDQUFDO0FBQzNCLElBQUlJLE1BQWVKLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlLLFVBQWVMLG1CQUFPQSxDQUFDO0FBQzNCLElBQUlNLFdBQWVOLG1CQUFPQSxDQUFDO0FBRTNCLElBQUlPLFdBQVdDLE9BQU9DLFNBQVMsQ0FBQ0YsUUFBUTtBQUV4Qzs7Ozs7O0VBTUUsR0FFRjs7OztFQUlFLEdBRUY7Ozs7Ozs7O0VBUUUsR0FFRjs7Ozs7RUFLRSxHQUVGOzs7O0VBSUUsR0FHRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXdDRSxHQUNGLFNBQVNHLFFBQVFDLE9BQU87SUFDdEIsSUFBSSxDQUFFLEtBQUksWUFBWUQsT0FBTSxHQUFJLE9BQU8sSUFBSUEsUUFBUUM7SUFFbkQsSUFBSSxDQUFDQSxPQUFPLEdBQUdWLE1BQU1XLE1BQU0sQ0FBQztRQUMxQkMsV0FBVztRQUNYQyxZQUFZO1FBQ1pDLElBQUk7SUFDTixHQUFHSixXQUFXLENBQUM7SUFFZixJQUFJSyxNQUFNLElBQUksQ0FBQ0wsT0FBTztJQUV0Qix5REFBeUQ7SUFDekQsNENBQTRDO0lBQzVDLElBQUlLLElBQUlDLEdBQUcsSUFBS0QsSUFBSUYsVUFBVSxJQUFJLEtBQU9FLElBQUlGLFVBQVUsR0FBRyxJQUFLO1FBQzdERSxJQUFJRixVQUFVLEdBQUcsQ0FBQ0UsSUFBSUYsVUFBVTtRQUNoQyxJQUFJRSxJQUFJRixVQUFVLEtBQUssR0FBRztZQUFFRSxJQUFJRixVQUFVLEdBQUcsQ0FBQztRQUFJO0lBQ3BEO0lBRUEs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QUFJeUQsV0FBVyxJQUFJMUQsUUFBUUM7SUFFM0J5RCxTQUFTbEMsSUFBSSxDQUFDVSxPQUFPO0lBRXJCLDhEQUE4RDtJQUM5RCxJQUFJd0IsU0FBU2xELEdBQUcsRUFBRTtRQUFFLE1BQU1rRCxTQUFTaEUsR0FBRyxJQUFJQSxHQUFHLENBQUNnRSxTQUFTbEQsR0FBRyxDQUFDO0lBQUU7SUFFN0QsT0FBT2tELFNBQVNILE1BQU07QUFDeEI7QUFHQTs7Ozs7OztFQU9FLEdBQ0YsU0FBU0ksV0FBV3pCLEtBQUssRUFBRWpDLE9BQU87SUFDaENBLFVBQVVBLFdBQVcsQ0FBQztJQUN0QkEsUUFBUU0sR0FBRyxHQUFHO0lBQ2QsT0FBT21DLFFBQVFSLE9BQU9qQztBQUN4QjtBQUdBOzs7Ozs7O0VBT0UsR0FHRjJELGVBQWUsR0FBRzVEO0FBQ2xCNEQsZUFBZSxHQUFHbEI7QUFDbEJrQixrQkFBa0IsR0FBR0Q7QUFDckJDLGNBQWMsR0FBSWxCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvaW5mbGF0ZS5qcz8xNTMzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgnLi96bGliL2luZmxhdGUnKTtcbnZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL2NvbW1vbicpO1xudmFyIHN0cmluZ3MgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvc3RyaW5ncycpO1xudmFyIGMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9jb25zdGFudHMnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xudmFyIEdaaGVhZGVyICAgICA9IHJlcXVpcmUoJy4vemxpYi9nemhlYWRlcicpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIGNsYXNzIEluZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tpbmZsYXRlXV1cbiAqIGFuZCBbW2luZmxhdGVSYXddXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIGluZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0luZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogSW5mbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqXG4gKiBVbmNvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0luZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0luZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSBvciBpZiB5b3VcbiAqIHB1c2ggYSBjaHVuayB3aXRoIGV4cGxpY2l0IGZsdXNoIChjYWxsIFtbSW5mbGF0ZSNwdXNoXV0gd2l0aFxuICogYFpfU1lOQ19GTFVTSGAgcGFyYW0pLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUuZXJyIC0+IE51bWJlclxuICpcbiAqIEVycm9yIGNvZGUgYWZ0ZXIgaW5mbGF0ZSBmaW5pc2hlZC4gMCAoWl9PSykgb24gc3VjY2Vzcy5cbiAqIFNob3VsZCBiZSBjaGVja2VkIGlmIGJyb2tlbiBkYXRhIHBvc3NpYmxlLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbSW5mbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgSW5mbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBpbmZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYHdpbmRvd0JpdHNgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBpbmZsYXRlXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gbm8gb3B0aW9ucyBzZXQsIGF1dG9kZXRlY3QgZGVmbGF0ZS9nemlwIGRhdGEgZm9ybWF0IHZpYVxuICogd3JhcHBlciBoZWFkZXIuXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGNodW5rMSA9IFVpbnQ4QXJyYXkoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBjaHVuazIgPSBVaW50OEFycmF5KFsxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOV0pO1xuICpcbiAqIHZhciBpbmZsYXRlID0gbmV3IHBha28uSW5mbGF0ZSh7IGxldmVsOiAzfSk7XG4gKlxuICogaW5mbGF0ZS5wdXNoKGNodW5rMSwgZmFsc2UpO1xuICogaW5mbGF0ZS5wdXNoKGNodW5rMiwgdHJ1ZSk7ICAvLyB0cnVlIC0+IGxhc3QgY2h1bmtcbiAqXG4gKiBpZiAoaW5mbGF0ZS5lcnIpIHsgdGhyb3cgbmV3IEVycm9yKGluZmxhdGUuZXJyKTsgfVxuICpcbiAqIGNvbnNvbGUubG9nKGluZmxhdGUucmVzdWx0KTtcbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gSW5mbGF0ZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlKSkgcmV0dXJuIG5ldyBJbmZsYXRlKG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucyA9IHV0aWxzLmFzc2lnbih7XG4gICAgY2h1bmtTaXplOiAxNjM4NCxcbiAgICB3aW5kb3dCaXRzOiAwLFxuICAgIHRvOiAnJ1xuICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICB2YXIgb3B0ID0gdGhpcy5vcHRpb25zO1xuXG4gIC8vIEZvcmNlIHdpbmRvdyBzaXplIGZvciBgcmF3YCBkYXRhLCBpZiBub3Qgc2V0IGRpcmVjdGx5LFxuICAvLyBiZWNhdXNlIHdlIGhhdmUgbm8gaGVhZGVyIGZvciBhdXRvZGV0ZWN0LlxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgPSAtb3B0LndpbmRvd0JpdHM7XG4gICAgaWYgKG9wdC53aW5kb3dCaXRzID09PSAwKSB7IG9wdC53aW5kb3dCaXRzID0gLTE1OyB9XG4gIH1cblxuICAvLyBJZiBgd2luZG93Qml0c2Agbm90IGRlZmluZWQgKGFuZCBtb2RlIG5vdCByYXcpIC0gc2V0IGF1dG9kZXRlY3QgZmxhZyBmb3IgZ3ppcC9kZWZsYXRlXG4gIGlmICgob3B0LndpbmRvd0JpdHMgPj0gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpICYmXG4gICAgICAhKG9wdGlvbnMgJiYgb3B0aW9ucy53aW5kb3dCaXRzKSkge1xuICAgIG9wdC53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgLy8gR3ppcCBoZWFkZXIgaGFzIG5vIGluZm8gYWJvdXQgd2luZG93cyBzaXplLCB3ZSBjYW4gZG8gYXV0b2RldGVjdCBvbmx5XG4gIC8vIGZvciBkZWZsYXRlLiBTbywgaWYgd2luZG93IHNpemUgbm90IHNldCwgZm9yY2UgaXQgdG8gbWF4IHdoZW4gZ3ppcCBwb3NzaWJsZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID4gMTUpICYmIChvcHQud2luZG93Qml0cyA8IDQ4KSkge1xuICAgIC8vIGJpdCAzICgxNikgLT4gZ3ppcHBlZCBkYXRhXG4gICAgLy8gYml0IDQgKDMyKSAtPiBhdXRvZGV0ZWN0IGd6aXAvZGVmbGF0ZVxuICAgIGlmICgob3B0LndpbmRvd0JpdHMgJiAxNSkgPT09IDApIHtcbiAgICAgIG9wdC53aW5kb3dCaXRzIHw9IDE1O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZXJyICAgID0gMDsgICAgICAvLyBlcnJvciBjb2RlLCBpZiBoYXBwZW5zICgwID0gWl9PSylcbiAgdGhpcy5tc2cgICAgPSAnJzsgICAgIC8vIGVycm9yIG1lc3NhZ2VcbiAgdGhpcy5lbmRlZCAgPSBmYWxzZTsgIC8vIHVzZWQgdG8gYXZvaWQgbXVsdGlwbGUgb25FbmQoKSBjYWxsc1xuICB0aGlzLmNodW5rcyA9IFtdOyAgICAgLy8gY2h1bmtzIG9mIGNvbXByZXNzZWQgZGF0YVxuXG4gIHRoaXMuc3RybSAgID0gbmV3IFpTdHJlYW0oKTtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IDA7XG5cbiAgdmFyIHN0YXR1cyAgPSB6bGliX2luZmxhdGUuaW5mbGF0ZUluaXQyKFxuICAgIHRoaXMuc3RybSxcbiAgICBvcHQud2luZG93Qml0c1xuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2dbc3RhdHVzXSk7XG4gIH1cblxuICB0aGlzLmhlYWRlciA9IG5ldyBHWmhlYWRlcigpO1xuXG4gIHpsaWJfaW5mbGF0ZS5pbmZsYXRlR2V0SGVhZGVyKHRoaXMuc3RybSwgdGhpcy5oZWFkZXIpO1xuXG4gIC8vIFNldHVwIGRpY3Rpb25hcnlcbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuZGljdGlvbmFyeSA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBuZXcgVWludDhBcnJheShvcHQuZGljdGlvbmFyeSk7XG4gICAgfVxuICAgIGlmIChvcHQucmF3KSB7IC8vSW4gcmF3IG1vZGUgd2UgbmVlZCB0byBzZXQgdGhlIGRpY3Rpb25hcnkgZWFybHlcbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIG9wdC5kaWN0aW9uYXJ5KTtcbiAgICAgIGlmIChzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZmxhdGUjcHVzaChkYXRhWywgbW9kZV0pIC0+IEJvb2xlYW5cbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxBcnJheUJ1ZmZlcnxTdHJpbmcpOiBpbnB1dCBkYXRhXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBpbmZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tJbmZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBvdXRwdXQgY2h1bmtzLiBSZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzLiBUaGUgbGFzdCBkYXRhIGJsb2NrIG11c3QgaGF2ZVxuICogbW9kZSBaX0ZJTklTSCAob3IgYHRydWVgKS4gVGhhdCB3aWxsIGZsdXNoIGludGVybmFsIHBlbmRpbmcgYnVmZmVycyBhbmQgY2FsbFxuICogW1tJbmZsYXRlI29uRW5kXV0uIEZvciBpbnRlcmltIGV4cGxpY2l0IGZsdXNoZXMgKHdpdGhvdXQgZW5kaW5nIHRoZSBzdHJlYW0pIHlvdVxuICogY2FuIHVzZSBtb2RlIFpfU1lOQ19GTFVTSCwga2VlcGluZyB0aGUgZGVjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0luZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBkaWN0aW9uYXJ5ID0gdGhpcy5vcHRpb25zLmRpY3Rpb25hcnk7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuICB2YXIgbmV4dF9vdXRfdXRmOCwgdGFpbCwgdXRmOHN0cjtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBkaWN0aW9uYXJ5KTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSBjLlpfQlVGX0VSUk9SICYmIGFsbG93QnVmRXJyb3IgPT09IHRydWUpIHtcbiAgICAgIHN0YXR1cyA9IGMuWl9PSztcbiAgICAgIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IGMuWl9PSykge1xuICAgICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0cm0ubmV4dF9vdXQpIHtcbiAgICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCB8fCBzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCB8fCBfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpKSkge1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICBuZXh0X291dF91dGY4ID0gc3RyaW5ncy51dGY4Ym9yZGVyKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KTtcblxuICAgICAgICAgIHRhaWwgPSBzdHJtLm5leHRfb3V0IC0gbmV4dF9vdXRfdXRmODtcbiAgICAgICAgICB1dGY4c3RyID0gc3RyaW5ncy5idWYyc3RyaW5nKHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4KTtcblxuICAgICAgICAgIC8vIG1vdmUgdGFpbFxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSB0YWlsO1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplIC0gdGFpbDtcbiAgICAgICAgICBpZiAodGFpbCkgeyB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgc3RybS5vdXRwdXQsIG5leHRfb3V0X3V0ZjgsIHRhaWwsIDApOyB9XG5cbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGY4c3RyKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25EYXRhKHV0aWxzLnNocmlua0J1ZihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBubyBtb3JlIGlucHV0IGRhdGEsIHdlIHNob3VsZCBjaGVjayB0aGF0IGludGVybmFsIGluZmxhdGUgYnVmZmVyc1xuICAgIC8vIGFyZSBmbHVzaGVkLiBUaGUgb25seSB3YXkgdG8gZG8gaXQgd2hlbiBhdmFpbF9vdXQgPSAwIC0gcnVuIG9uZSBtb3JlXG4gICAgLy8gaW5mbGF0ZSBwYXNzLiBCdXQgaWYgb3V0cHV0IGRhdGEgbm90IGV4aXN0cywgaW5mbGF0ZSByZXR1cm4gWl9CVUZfRVJST1IuXG4gICAgLy8gSGVyZSB3ZSBzZXQgZmxhZyB0byBwcm9jZXNzIHRoaXMgZXJyb3IgcHJvcGVybHkuXG4gICAgLy9cbiAgICAvLyBOT1RFLiBEZWZsYXRlIGRvZXMgbm90IHJldHVybiBlcnJvciBpbiB0aGlzIGNhc2UgYW5kIGRvZXMgbm90IG5lZWRzIHN1Y2hcbiAgICAvLyBsb2dpYy5cbiAgICBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiBzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgYWxsb3dCdWZFcnJvciA9IHRydWU7XG4gICAgfVxuXG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBjLlpfU1RSRUFNX0VORCk7XG5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX1NUUkVBTV9FTkQpIHtcbiAgICBfbW9kZSA9IGMuWl9GSU5JU0g7XG4gIH1cblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBjLlpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gYy5aX09LO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaW50ZXJpbSByZXN1bHRzIGlmIFpfU1lOQ19GTFVTSC5cbiAgaWYgKF9tb2RlID09PSBjLlpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoYy5aX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGlnbmVkIHN0cmluZ3MgdG8gb25EYXRhXG4gICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuY2h1bmtzLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlc3VsdCA9IHV0aWxzLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpO1xuICAgIH1cbiAgfVxuICB0aGlzLmNodW5rcyA9IFtdO1xuICB0aGlzLmVyciA9IHN0YXR1cztcbiAgdGhpcy5tc2cgPSB0aGlzLnN0cm0ubXNnO1xufTtcblxuXG4vKipcbiAqIGluZmxhdGUoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogRGVjb21wcmVzcyBgZGF0YWAgd2l0aCBpbmZsYXRlL3VuZ3ppcCBhbmQgYG9wdGlvbnNgLiBBdXRvZGV0ZWN0XG4gKiBmb3JtYXQgdmlhIHdyYXBwZXIgaGVhZGVyIGJ5IGRlZmF1bHQuIFRoYXQncyB3aHkgd2UgZG9uJ3QgcHJvdmlkZVxuICogc2VwYXJhdGUgYHVuZ3ppcGAgbWV0aG9kLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIHdpbmRvd0JpdHNcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBTdWdhciAob3B0aW9ucyk6XG4gKlxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBzYXkgdGhhdCB3ZSB3b3JrIHdpdGggcmF3IHN0cmVhbSwgaWYgeW91IGRvbid0IHdpc2ggdG8gc3BlY2lmeVxuICogICBuZWdhdGl2ZSB3aW5kb3dCaXRzIGltcGxpY2l0bHkuXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBjb252ZXJ0ZWRcbiAqICAgZnJvbSB1dGY4IHRvIHV0ZjE2IChqYXZhc2NyaXB0KSBzdHJpbmcuIFdoZW4gc3RyaW5nIG91dHB1dCByZXF1ZXN0ZWQsXG4gKiAgIGNodW5rIGxlbmd0aCBjYW4gZGlmZmVyIGZyb20gYGNodW5rU2l6ZWAsIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICpcbiAqXG4gKiAjIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBwYWtvID0gcmVxdWlyZSgncGFrbycpXG4gKiAgICwgaW5wdXQgPSBwYWtvLmRlZmxhdGUoWzEsMiwzLDQsNSw2LDcsOCw5XSlcbiAqICAgLCBvdXRwdXQ7XG4gKlxuICogdHJ5IHtcbiAqICAgb3V0cHV0ID0gcGFrby5pbmZsYXRlKGlucHV0KTtcbiAqIH0gY2F0Y2ggKGVycilcbiAqICAgY29uc29sZS5sb2coZXJyKTtcbiAqIH1cbiAqIGBgYFxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgaW5mbGF0b3IgPSBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICBpbmZsYXRvci5wdXNoKGlucHV0LCB0cnVlKTtcblxuICAvLyBUaGF0IHdpbGwgbmV2ZXIgaGFwcGVucywgaWYgeW91IGRvbid0IGNoZWF0IHdpdGggb3B0aW9ucyA6KVxuICBpZiAoaW5mbGF0b3IuZXJyKSB7IHRocm93IGluZmxhdG9yLm1zZyB8fCBtc2dbaW5mbGF0b3IuZXJyXTsgfVxuXG4gIHJldHVybiBpbmZsYXRvci5yZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBpbmZsYXRlUmF3KGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIFRoZSBzYW1lIGFzIFtbaW5mbGF0ZV1dLCBidXQgY3JlYXRlcyByYXcgZGF0YSwgd2l0aG91dCB3cmFwcGVyXG4gKiAoaGVhZGVyIGFuZCBhZGxlcjMyIGNyYykuXG4gKiovXG5mdW5jdGlvbiBpbmZsYXRlUmF3KGlucHV0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnJhdyA9IHRydWU7XG4gIHJldHVybiBpbmZsYXRlKGlucHV0LCBvcHRpb25zKTtcbn1cblxuXG4vKipcbiAqIHVuZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBKdXN0IHNob3J0Y3V0IHRvIFtbaW5mbGF0ZV1dLCBiZWNhdXNlIGl0IGF1dG9kZXRlY3RzIGZvcm1hdFxuICogYnkgaGVhZGVyLmNvbnRlbnQuIERvbmUgZm9yIGNvbnZlbmllbmNlLlxuICoqL1xuXG5cbmV4cG9ydHMuSW5mbGF0ZSA9IEluZmxhdGU7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlUmF3ID0gaW5mbGF0ZVJhdztcbmV4cG9ydHMudW5nemlwICA9IGluZmxhdGU7XG4iXSwibmFtZXMiOlsiemxpYl9pbmZsYXRlIiwicmVxdWlyZSIsInV0aWxzIiwic3RyaW5ncyIsImMiLCJtc2ciLCJaU3RyZWFtIiwiR1poZWFkZXIiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsIkluZmxhdGUiLCJvcHRpb25zIiwiYXNzaWduIiwiY2h1bmtTaXplIiwid2luZG93Qml0cyIsInRvIiwib3B0IiwicmF3IiwiZXJyIiwiZW5kZWQiLCJjaHVua3MiLCJzdHJtIiwiYXZhaWxfb3V0Iiwic3RhdHVzIiwiaW5mbGF0ZUluaXQyIiwiWl9PSyIsIkVycm9yIiwiaGVhZGVyIiwiaW5mbGF0ZUdldEhlYWRlciIsImRpY3Rpb25hcnkiLCJzdHJpbmcyYnVmIiwiY2FsbCIsIlVpbnQ4QXJyYXkiLCJpbmZsYXRlU2V0RGljdGlvbmFyeSIsInB1c2giLCJkYXRhIiwibW9kZSIsIl9tb2RlIiwibmV4dF9vdXRfdXRmOCIsInRhaWwiLCJ1dGY4c3RyIiwiYWxsb3dCdWZFcnJvciIsIlpfRklOSVNIIiwiWl9OT19GTFVTSCIsImlucHV0IiwiYmluc3RyaW5nMmJ1ZiIsIm5leHRfaW4iLCJhdmFpbF9pbiIsImxlbmd0aCIsIm91dHB1dCIsIkJ1ZjgiLCJuZXh0X291dCIsImluZmxhdGUiLCJaX05FRURfRElDVCIsIlpfQlVGX0VSUk9SIiwiWl9TVFJFQU1fRU5EIiwib25FbmQiLCJaX1NZTkNfRkxVU0giLCJ1dGY4Ym9yZGVyIiwiYnVmMnN0cmluZyIsImFycmF5U2V0Iiwib25EYXRhIiwic2hyaW5rQnVmIiwiaW5mbGF0ZUVuZCIsImNodW5rIiwicmVzdWx0Iiwiam9pbiIsImZsYXR0ZW5DaHVua3MiLCJpbmZsYXRvciIsImluZmxhdGVSYXciLCJleHBvcnRzIiwidW5nemlwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/inflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nvar TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\nfunction _has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexports.assign = function(obj /*from1, from2, from3, ...*/ ) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    while(sources.length){\n        var source = sources.shift();\n        if (!source) {\n            continue;\n        }\n        if (typeof source !== \"object\") {\n            throw new TypeError(source + \"must be non-object\");\n        }\n        for(var p in source){\n            if (_has(source, p)) {\n                obj[p] = source[p];\n            }\n        }\n    }\n    return obj;\n};\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function(buf, size) {\n    if (buf.length === size) {\n        return buf;\n    }\n    if (buf.subarray) {\n        return buf.subarray(0, size);\n    }\n    buf.length = size;\n    return buf;\n};\nvar fnTyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        if (src.subarray && dest.subarray) {\n            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n            return;\n        }\n        // Fallback to ordinary array\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        var i, l, len, pos, chunk, result;\n        // calculate data length\n        len = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            len += chunks[i].length;\n        }\n        // join chunks\n        result = new Uint8Array(len);\n        pos = 0;\n        for(i = 0, l = chunks.length; i < l; i++){\n            chunk = chunks[i];\n            result.set(chunk, pos);\n            pos += chunk.length;\n        }\n        return result;\n    }\n};\nvar fnUntyped = {\n    arraySet: function(dest, src, src_offs, len, dest_offs) {\n        for(var i = 0; i < len; i++){\n            dest[dest_offs + i] = src[src_offs + i];\n        }\n    },\n    // Join array of chunks to single array.\n    flattenChunks: function(chunks) {\n        return [].concat.apply([], chunks);\n    }\n};\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function(on) {\n    if (on) {\n        exports.Buf8 = Uint8Array;\n        exports.Buf16 = Uint16Array;\n        exports.Buf32 = Int32Array;\n        exports.assign(exports, fnTyped);\n    } else {\n        exports.Buf8 = Array;\n        exports.Buf16 = Array;\n        exports.Buf32 = Array;\n        exports.assign(exports, fnUntyped);\n    }\n};\nexports.setTyped(TYPED_OK);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBR0EsSUFBSUEsV0FBWSxPQUFRQyxlQUFlLGVBQ3RCLE9BQU9DLGdCQUFnQixlQUN2QixPQUFPQyxlQUFlO0FBRXZDLFNBQVNDLEtBQUtDLEdBQUcsRUFBRUMsR0FBRztJQUNwQixPQUFPQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDTCxLQUFLQztBQUNuRDtBQUVBSyxjQUFjLEdBQUcsU0FBVU4sSUFBSSwwQkFBMEIsR0FBM0I7SUFDNUIsSUFBSVEsVUFBVUMsTUFBTU4sU0FBUyxDQUFDTyxLQUFLLENBQUNMLElBQUksQ0FBQ00sV0FBVztJQUNwRCxNQUFPSCxRQUFRSSxNQUFNLENBQUU7UUFDckIsSUFBSUMsU0FBU0wsUUFBUU0sS0FBSztRQUMxQixJQUFJLENBQUNELFFBQVE7WUFBRTtRQUFVO1FBRXpCLElBQUksT0FBT0EsV0FBVyxVQUFVO1lBQzlCLE1BQU0sSUFBSUUsVUFBVUYsU0FBUztRQUMvQjtRQUVBLElBQUssSUFBSUcsS0FBS0gsT0FBUTtZQUNwQixJQUFJZCxLQUFLYyxRQUFRRyxJQUFJO2dCQUNuQmhCLEdBQUcsQ0FBQ2dCLEVBQUUsR0FBR0gsTUFBTSxDQUFDRyxFQUFFO1lBQ3BCO1FBQ0Y7SUFDRjtJQUVBLE9BQU9oQjtBQUNUO0FBR0Esd0NBQXdDO0FBQ3hDTSxpQkFBaUIsR0FBRyxTQUFVWSxHQUFHLEVBQUVDLElBQUk7SUFDckMsSUFBSUQsSUFBSU4sTUFBTSxLQUFLTyxNQUFNO1FBQUUsT0FBT0Q7SUFBSztJQUN2QyxJQUFJQSxJQUFJRSxRQUFRLEVBQUU7UUFBRSxPQUFPRixJQUFJRSxRQUFRLENBQUMsR0FBR0Q7SUFBTztJQUNsREQsSUFBSU4sTUFBTSxHQUFHTztJQUNiLE9BQU9EO0FBQ1Q7QUFHQSxJQUFJRyxVQUFVO0lBQ1pDLFVBQVUsU0FBVUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxTQUFTO1FBQ3JELElBQUlILElBQUlKLFFBQVEsSUFBSUcsS0FBS0gsUUFBUSxFQUFFO1lBQ2pDRyxLQUFLSyxHQUFHLENBQUNKLElBQUlKLFFBQVEsQ0FBQ0ssVUFBVUEsV0FBV0MsTUFBTUM7WUFDakQ7UUFDRjtRQUNBLDZCQUE2QjtRQUM3QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUgsS0FBS0csSUFBSztZQUM1Qk4sSUFBSSxDQUFDSSxZQUFZRSxFQUFFLEdBQUdMLEdBQUcsQ0FBQ0MsV0FBV0ksRUFBRTtRQUN6QztJQUNGO0lBQ0Esd0NBQXdDO0lBQ3hDQyxlQUFlLFNBQVVDLE1BQU07UUFDN0IsSUFBSUYsR0FBR0csR0FBR04sS0FBS08sS0FBS0MsT0FBT0M7UUFFM0Isd0JBQXdCO1FBQ3hCVCxNQUFNO1FBQ04sSUFBS0csSUFBSSxHQUFHRyxJQUFJRCxPQUFPbkIsTUFBTSxFQUFFaUIsSUFBSUcsR0FBR0gsSUFBSztZQUN6Q0gsT0FBT0ssTUFBTSxDQUFDRixFQUFFLENBQUNqQixNQUFNO1FBQ3pCO1FBRUEsY0FBYztRQUNkdUIsU0FBUyxJQUFJdkMsV0FBVzhCO1FBQ3hCTyxNQUFNO1FBQ04sSUFBS0osSUFBSSxHQUFHRyxJQUFJRCxPQUFPbkIsTUFBTSxFQUFFaUIsSUFBSUcsR0FBR0gsSUFBSztZQUN6Q0ssUUFBUUgsTUFBTSxDQUFDRixFQUFFO1lBQ2pCTSxPQUFPUCxHQUFHLENBQUNNLE9BQU9EO1lBQ2xCQSxPQUFPQyxNQUFNdEIsTUFBTTtRQUNyQjtRQUVBLE9BQU91QjtJQUNUO0FBQ0Y7QUFFQSxJQUFJQyxZQUFZO0lBQ2RkLFVBQVUsU0FBVUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxTQUFTO1FBQ3JELElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJSCxLQUFLRyxJQUFLO1lBQzVCTixJQUFJLENBQUNJLFlBQVlFLEVBQUUsR0FBR0wsR0FBRyxDQUFDQyxXQUFXSSxFQUFFO1FBQ3pDO0lBQ0Y7SUFDQSx3Q0FBd0M7SUFDeENDLGVBQWUsU0FBVUMsTUFBTTtRQUM3QixPQUFPLEVBQUUsQ0FBQ00sTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRSxFQUFFUDtJQUM3QjtBQUNGO0FBR0EsK0NBQStDO0FBQy9DLEVBQUU7QUFDRnpCLGdCQUFnQixHQUFHLFNBQVVrQyxFQUFFO0lBQzdCLElBQUlBLElBQUk7UUFDTmxDLFlBQVksR0FBSVY7UUFDaEJVLGFBQWEsR0FBR1Q7UUFDaEJTLGFBQWEsR0FBR1I7UUFDaEJRLFFBQVFDLE1BQU0sQ0FBQ0QsU0FBU2U7SUFDMUIsT0FBTztRQUNMZixZQUFZLEdBQUlHO1FBQ2hCSCxhQUFhLEdBQUdHO1FBQ2hCSCxhQUFhLEdBQUdHO1FBQ2hCSCxRQUFRQyxNQUFNLENBQUNELFNBQVM4QjtJQUMxQjtBQUNGO0FBRUE5QixRQUFRaUMsUUFBUSxDQUFDNUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanM/ZDlhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbmZ1bmN0aW9uIF9oYXMob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKF9oYXMoc291cmNlLCBwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcyArIGxlbiksIGRlc3Rfb2Zmcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG9yZGluYXJ5IGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgdmFyIGksIGwsIGxlbiwgcG9zLCBjaHVuaywgcmVzdWx0O1xuXG4gICAgLy8gY2FsY3VsYXRlIGRhdGEgbGVuZ3RoXG4gICAgbGVuID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGVuICs9IGNodW5rc1tpXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gam9pbiBjaHVua3NcbiAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xuICAgICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICAgIHBvcyArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxudmFyIGZuVW50eXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcbiJdLCJuYW1lcyI6WyJUWVBFRF9PSyIsIlVpbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJfaGFzIiwib2JqIiwia2V5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXhwb3J0cyIsImFzc2lnbiIsInNvdXJjZXMiLCJBcnJheSIsInNsaWNlIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwic2hpZnQiLCJUeXBlRXJyb3IiLCJwIiwic2hyaW5rQnVmIiwiYnVmIiwic2l6ZSIsInN1YmFycmF5IiwiZm5UeXBlZCIsImFycmF5U2V0IiwiZGVzdCIsInNyYyIsInNyY19vZmZzIiwibGVuIiwiZGVzdF9vZmZzIiwic2V0IiwiaSIsImZsYXR0ZW5DaHVua3MiLCJjaHVua3MiLCJsIiwicG9zIiwiY2h1bmsiLCJyZXN1bHQiLCJmblVudHlwZWQiLCJjb25jYXQiLCJhcHBseSIsInNldFR5cGVkIiwib24iLCJCdWY4IiwiQnVmMTYiLCJCdWYzMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// String encode/decode helpers\n\nvar utils = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\ntry {\n    String.fromCharCode.apply(null, [\n        0\n    ]);\n} catch (__) {\n    STR_APPLY_OK = false;\n}\ntry {\n    String.fromCharCode.apply(null, new Uint8Array(1));\n} catch (__) {\n    STR_APPLY_UIA_OK = false;\n}\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor(var q = 0; q < 256; q++){\n    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\nexports.string2buf = function(str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n    // count binary size\n    for(m_pos = 0; m_pos < str_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n    // allocate buffer\n    buf = new utils.Buf8(buf_len);\n    // convert\n    for(i = 0, m_pos = 0; i < buf_len; m_pos++){\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n            c2 = str.charCodeAt(m_pos + 1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */ buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */ buf[i++] = 0xC0 | c >>> 6;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else if (c < 0x10000) {\n            /* three bytes */ buf[i++] = 0xE0 | c >>> 12;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        } else {\n            /* four bytes */ buf[i++] = 0xf0 | c >>> 18;\n            buf[i++] = 0x80 | c >>> 12 & 0x3f;\n            buf[i++] = 0x80 | c >>> 6 & 0x3f;\n            buf[i++] = 0x80 | c & 0x3f;\n        }\n    }\n    return buf;\n};\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n    // On Chrome, the arguments in a function call that are allowed is `65534`.\n    // If the length of the buffer is smaller than that, we can use this optimization,\n    // otherwise we will take a slower path.\n    if (len < 65534) {\n        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {\n            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n        }\n    }\n    var result = \"\";\n    for(var i = 0; i < len; i++){\n        result += String.fromCharCode(buf[i]);\n    }\n    return result;\n}\n// Convert byte array to binary string\nexports.buf2binstring = function(buf) {\n    return buf2binstring(buf, buf.length);\n};\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function(str) {\n    var buf = new utils.Buf8(str.length);\n    for(var i = 0, len = buf.length; i < len; i++){\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n};\n// convert array to string\nexports.buf2string = function(buf, max) {\n    var i, out, c, c_len;\n    var len = max || buf.length;\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len * 2);\n    for(out = 0, i = 0; i < len;){\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) {\n            utf16buf[out++] = c;\n            continue;\n        }\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) {\n            utf16buf[out++] = 0xfffd;\n            i += c_len - 1;\n            continue;\n        }\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while(c_len > 1 && i < len){\n            c = c << 6 | buf[i++] & 0x3f;\n            c_len--;\n        }\n        // terminated by end of string?\n        if (c_len > 1) {\n            utf16buf[out++] = 0xfffd;\n            continue;\n        }\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n            utf16buf[out++] = 0xdc00 | c & 0x3ff;\n        }\n    }\n    return buf2binstring(utf16buf, out);\n};\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function(buf, max) {\n    var pos;\n    max = max || buf.length;\n    if (max > buf.length) {\n        max = buf.length;\n    }\n    // go back from last position, until start of sequence found\n    pos = max - 1;\n    while(pos >= 0 && (buf[pos] & 0xC0) === 0x80){\n        pos--;\n    }\n    // Very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) {\n        return max;\n    }\n    // If we came to start of buffer - that means buffer is too small,\n    // return max too.\n    if (pos === 0) {\n        return max;\n    }\n    return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwrQkFBK0I7QUFDL0I7QUFHQSxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUdwQixnRUFBZ0U7QUFDaEUsRUFBRTtBQUNGLHlDQUF5QztBQUN6QyxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLElBQUlDLGVBQWU7QUFDbkIsSUFBSUMsbUJBQW1CO0FBRXZCLElBQUk7SUFBRUMsT0FBT0MsWUFBWSxDQUFDQyxLQUFLLENBQUMsTUFBTTtRQUFFO0tBQUc7QUFBRyxFQUFFLE9BQU9DLElBQUk7SUFBRUwsZUFBZTtBQUFPO0FBQ25GLElBQUk7SUFBRUUsT0FBT0MsWUFBWSxDQUFDQyxLQUFLLENBQUMsTUFBTSxJQUFJRSxXQUFXO0FBQUssRUFBRSxPQUFPRCxJQUFJO0lBQUVKLG1CQUFtQjtBQUFPO0FBR25HLGlFQUFpRTtBQUNqRSxvRkFBb0Y7QUFDcEYsNkNBQTZDO0FBQzdDLElBQUlNLFdBQVcsSUFBSVQsTUFBTVUsSUFBSSxDQUFDO0FBQzlCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEtBQUtBLElBQUs7SUFDNUJGLFFBQVEsQ0FBQ0UsRUFBRSxHQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUlBLEtBQUssTUFBTSxJQUFJQSxLQUFLLE1BQU0sSUFBSUEsS0FBSyxNQUFNLElBQUk7QUFDNUY7QUFDQUYsUUFBUSxDQUFDLElBQUksR0FBR0EsUUFBUSxDQUFDLElBQUksR0FBRyxHQUFHLHlCQUF5QjtBQUc1RCxpREFBaUQ7QUFDakRHLGtCQUFrQixHQUFHLFNBQVVFLEdBQUc7SUFDaEMsSUFBSUMsS0FBS0MsR0FBR0MsSUFBSUMsT0FBT0MsR0FBR0MsVUFBVU4sSUFBSU8sTUFBTSxFQUFFQyxVQUFVO0lBRTFELG9CQUFvQjtJQUNwQixJQUFLSixRQUFRLEdBQUdBLFFBQVFFLFNBQVNG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LENBQUNGLE1BQU0sR0FBRyxTQUFVaEIsSUFBSTtRQUNsQztJQUNGO0lBRUEsT0FBT1EsY0FBY1UsVUFBVUY7QUFDakM7QUFHQSxrREFBa0Q7QUFDbEQsdURBQXVEO0FBQ3ZELCtDQUErQztBQUMvQyxFQUFFO0FBQ0YsMkJBQTJCO0FBQzNCLG9DQUFvQztBQUNwQ3BCLGtCQUFrQixHQUFHLFNBQVVHLEdBQUcsRUFBRWdCLEdBQUc7SUFDckMsSUFBSU07SUFFSk4sTUFBTUEsT0FBT2hCLElBQUlNLE1BQU07SUFDdkIsSUFBSVUsTUFBTWhCLElBQUlNLE1BQU0sRUFBRTtRQUFFVSxNQUFNaEIsSUFBSU0sTUFBTTtJQUFFO0lBRTFDLDREQUE0RDtJQUM1RGdCLE1BQU1OLE1BQU07SUFDWixNQUFPTSxPQUFPLEtBQUssQ0FBQ3RCLEdBQUcsQ0FBQ3NCLElBQUksR0FBRyxJQUFHLE1BQU8sS0FBTTtRQUFFQTtJQUFPO0lBRXhELGtDQUFrQztJQUNsQyx5REFBeUQ7SUFDekQsSUFBSUEsTUFBTSxHQUFHO1FBQUUsT0FBT047SUFBSztJQUUzQixrRUFBa0U7SUFDbEUsa0JBQWtCO0lBQ2xCLElBQUlNLFFBQVEsR0FBRztRQUFFLE9BQU9OO0lBQUs7SUFFN0IsT0FBTyxNQUFPdEIsUUFBUSxDQUFDTSxHQUFHLENBQUNzQixJQUFJLENBQUMsR0FBR04sTUFBT00sTUFBTU47QUFDbEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzP2RmM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU3RyaW5nIGVuY29kZS9kZWNvZGUgaGVscGVyc1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuLy8gUXVpY2sgY2hlY2sgaWYgd2UgY2FuIHVzZSBmYXN0IGFycmF5IHRvIGJpbiBzdHJpbmcgY29udmVyc2lvblxuLy9cbi8vIC0gYXBwbHkoQXJyYXkpIGNhbiBmYWlsIG9uIEFuZHJvaWQgMi4yXG4vLyAtIGFwcGx5KFVpbnQ4QXJyYXkpIGNhbiBmYWlsIG9uIGlPUyA1LjEgU2FmYXJpXG4vL1xudmFyIFNUUl9BUFBMWV9PSyA9IHRydWU7XG52YXIgU1RSX0FQUExZX1VJQV9PSyA9IHRydWU7XG5cbnRyeSB7IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgWyAwIF0pOyB9IGNhdGNoIChfXykgeyBTVFJfQVBQTFlfT0sgPSBmYWxzZTsgfVxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgxKSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9VSUFfT0sgPSBmYWxzZTsgfVxuXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IHV0aWxzLkJ1ZjgoMjU2KTtcbmZvciAodmFyIHEgPSAwOyBxIDwgMjU2OyBxKyspIHtcbiAgX3V0ZjhsZW5bcV0gPSAocSA+PSAyNTIgPyA2IDogcSA+PSAyNDggPyA1IDogcSA+PSAyNDAgPyA0IDogcSA+PSAyMjQgPyAzIDogcSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdID0gX3V0ZjhsZW5bMjU0XSA9IDE7IC8vIEludmFsaWQgc2VxdWVuY2Ugc3RhcnRcblxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobV9wb3MgPSAwOyBtX3BvcyA8IHN0cl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgYnVmID0gbmV3IHV0aWxzLkJ1ZjgoYnVmX2xlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zICsgMSA8IHN0cl9sZW4pKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtX3BvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEMwIHwgKGMgPj4+IDYpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmO1xufTtcblxuLy8gSGVscGVyICh1c2VkIGluIDIgcGxhY2VzKVxuZnVuY3Rpb24gYnVmMmJpbnN0cmluZyhidWYsIGxlbikge1xuICAvLyBPbiBDaHJvbWUsIHRoZSBhcmd1bWVudHMgaW4gYSBmdW5jdGlvbiBjYWxsIHRoYXQgYXJlIGFsbG93ZWQgaXMgYDY1NTM0YC5cbiAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0LCB3ZSBjYW4gdXNlIHRoaXMgb3B0aW1pemF0aW9uLFxuICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCB0YWtlIGEgc2xvd2VyIHBhdGguXG4gIGlmIChsZW4gPCA2NTUzNCkge1xuICAgIGlmICgoYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9VSUFfT0spIHx8ICghYnVmLnN1YmFycmF5ICYmIFNUUl9BUFBMWV9PSykpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0aWxzLnNocmlua0J1ZihidWYsIGxlbikpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vLyBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gYmluYXJ5IHN0cmluZ1xuZXhwb3J0cy5idWYyYmluc3RyaW5nID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gYnVmMmJpbnN0cmluZyhidWYsIGJ1Zi5sZW5ndGgpO1xufTtcblxuXG4vLyBDb252ZXJ0IGJpbmFyeSBzdHJpbmcgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuZXhwb3J0cy5iaW5zdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICB2YXIgYnVmID0gbmV3IHV0aWxzLkJ1Zjgoc3RyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufTtcblxuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xuZXhwb3J0cy5idWYyc3RyaW5nID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBpLCBvdXQsIGMsIGNfbGVuO1xuICB2YXIgbGVuID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG5cbiAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgLy8gICAgIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkgdGhhbiBVaW50MTZBcnJheS5cbiAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbiAqIDIpO1xuXG4gIGZvciAob3V0ID0gMCwgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgYyA9IGJ1ZltpKytdO1xuICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgIGNfbGVuID0gX3V0ZjhsZW5bY107XG4gICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4gLSAxOyBjb250aW51ZTsgfVxuXG4gICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgIC8vIGpvaW4gdGhlIHJlc3RcbiAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgY19sZW4tLTtcbiAgICB9XG5cbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBzdHJpbmc/XG4gICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMgLT0gMHgxMDAwMDtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZDgwMCB8ICgoYyA+PiAxMCkgJiAweDNmZik7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGRjMDAgfCAoYyAmIDB4M2ZmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmMmJpbnN0cmluZyh1dGYxNmJ1Ziwgb3V0KTtcbn07XG5cblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbmV4cG9ydHMudXRmOGJvcmRlciA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgcG9zO1xuXG4gIG1heCA9IG1heCB8fCBidWYubGVuZ3RoO1xuICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gIHBvcyA9IG1heCAtIDE7XG4gIHdoaWxlIChwb3MgPj0gMCAmJiAoYnVmW3Bvc10gJiAweEMwKSA9PT0gMHg4MCkgeyBwb3MtLTsgfVxuXG4gIC8vIFZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gIGlmIChwb3MgPCAwKSB7IHJldHVybiBtYXg7IH1cblxuICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgYnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgLy8gcmV0dXJuIG1heCB0b28uXG4gIGlmIChwb3MgPT09IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiU1RSX0FQUExZX09LIiwiU1RSX0FQUExZX1VJQV9PSyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiX18iLCJVaW50OEFycmF5IiwiX3V0ZjhsZW4iLCJCdWY4IiwicSIsImV4cG9ydHMiLCJzdHJpbmcyYnVmIiwic3RyIiwiYnVmIiwiYyIsImMyIiwibV9wb3MiLCJpIiwic3RyX2xlbiIsImxlbmd0aCIsImJ1Zl9sZW4iLCJjaGFyQ29kZUF0IiwiYnVmMmJpbnN0cmluZyIsImxlbiIsInN1YmFycmF5Iiwic2hyaW5rQnVmIiwicmVzdWx0IiwiYmluc3RyaW5nMmJ1ZiIsImJ1ZjJzdHJpbmciLCJtYXgiLCJvdXQiLCJjX2xlbiIsInV0ZjE2YnVmIiwiQXJyYXkiLCJ1dGY4Ym9yZGVyIiwicG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction adler32(adler, buf, len, pos) {\n    var s1 = adler & 0xffff | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0;\n    while(len !== 0){\n        // Set limit ~ twice less than 5552, to keep\n        // s2 in 31-bits, because we force signed ints.\n        // in other case %= will fail.\n        n = len > 2000 ? 2000 : len;\n        len -= n;\n        do {\n            s1 = s1 + buf[pos++] | 0;\n            s2 = s2 + s1 | 0;\n        }while (--n);\n        s1 %= 65521;\n        s2 %= 65521;\n    }\n    return s1 | s2 << 16 | 0;\n}\nmodule.exports = adler32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsMERBQTBEO0FBQzFELHFFQUFxRTtBQUNyRSw0QkFBNEI7QUFFNUIsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsU0FBU0EsUUFBUUMsS0FBSyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztJQUNuQyxJQUFJQyxLQUFLLFFBQVMsU0FBUyxHQUN2QkMsS0FBSyxVQUFZLEtBQU0sU0FBUyxHQUNoQ0MsSUFBSTtJQUVSLE1BQU9KLFFBQVEsRUFBRztRQUNoQiw0Q0FBNEM7UUFDNUMsK0NBQStDO1FBQy9DLDhCQUE4QjtRQUM5QkksSUFBSUosTUFBTSxPQUFPLE9BQU9BO1FBQ3hCQSxPQUFPSTtRQUVQLEdBQUc7WUFDREYsS0FBSyxLQUFNSCxHQUFHLENBQUNFLE1BQU0sR0FBRztZQUN4QkUsS0FBSyxLQUFNRCxLQUFLO1FBQ2xCLFFBQVMsRUFBRUUsR0FBRztRQUVkRixNQUFNO1FBQ05DLE1BQU07SUFDUjtJQUVBLE9BQU8sS0FBT0EsTUFBTSxLQUFNO0FBQzVCO0FBR0FFLE9BQU9DLE9BQU8sR0FBR1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanM/NjQ5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iXSwibmFtZXMiOlsiYWRsZXIzMiIsImFkbGVyIiwiYnVmIiwibGVuIiwicG9zIiwiczEiLCJzMiIsIm4iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    /* Allowed flush values; see deflate() and inflate() below for details */ Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_TREES: 6,\n    /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */ Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    //Z_MEM_ERROR:     -4,\n    Z_BUF_ERROR: -5,\n    //Z_VERSION_ERROR: -6,\n    /* compression levels */ Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    /* Possible values of the data_type field (though see inflate()) */ Z_BINARY: 0,\n    Z_TEXT: 1,\n    //Z_ASCII:                1, // = Z_TEXT (deprecated)\n    Z_UNKNOWN: 2,\n    /* The deflate compression method */ Z_DEFLATED: 8\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELEVBQUU7QUFDRixvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0Ysd0VBQXdFO0FBQ3hFLHlFQUF5RTtBQUN6RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsMEVBQTBFO0FBQzFFLHFDQUFxQztBQUNyQyw2RUFBNkU7QUFDN0UsbURBQW1EO0FBQ25ELDZFQUE2RTtBQUU3RUEsT0FBT0MsT0FBTyxHQUFHO0lBRWYsdUVBQXVFLEdBQ3ZFQyxZQUFvQjtJQUNwQkMsaUJBQW9CO0lBQ3BCQyxjQUFvQjtJQUNwQkMsY0FBb0I7SUFDcEJDLFVBQW9CO0lBQ3BCQyxTQUFvQjtJQUNwQkMsU0FBb0I7SUFFcEI7O0VBRUEsR0FDQUMsTUFBb0I7SUFDcEJDLGNBQW9CO0lBQ3BCQyxhQUFvQjtJQUNwQkMsU0FBbUIsQ0FBQztJQUNwQkMsZ0JBQW1CLENBQUM7SUFDcEJDLGNBQW1CLENBQUM7SUFDcEIsc0JBQXNCO0lBQ3RCQyxhQUFtQixDQUFDO0lBQ3BCLHNCQUFzQjtJQUV0QixzQkFBc0IsR0FDdEJDLGtCQUEwQjtJQUMxQkMsY0FBMEI7SUFDMUJDLG9CQUEwQjtJQUMxQkMsdUJBQXlCLENBQUM7SUFHMUJDLFlBQTBCO0lBQzFCQyxnQkFBMEI7SUFDMUJDLE9BQTBCO0lBQzFCQyxTQUEwQjtJQUMxQkMsb0JBQTBCO0lBRTFCLGlFQUFpRSxHQUNqRUMsVUFBMEI7SUFDMUJDLFFBQTBCO0lBQzFCLHFEQUFxRDtJQUNyREMsV0FBMEI7SUFFMUIsa0NBQWtDLEdBQ2xDQyxZQUEwQjtBQUU1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY29uc3RhbnRzLmpzP2EzY2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiWl9OT19GTFVTSCIsIlpfUEFSVElBTF9GTFVTSCIsIlpfU1lOQ19GTFVTSCIsIlpfRlVMTF9GTFVTSCIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfVFJFRVMiLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9ORUVEX0RJQ1QiLCJaX0VSUk5PIiwiWl9TVFJFQU1fRVJST1IiLCJaX0RBVEFfRVJST1IiLCJaX0JVRl9FUlJPUiIsIlpfTk9fQ09NUFJFU1NJT04iLCJaX0JFU1RfU1BFRUQiLCJaX0JFU1RfQ09NUFJFU1NJT04iLCJaX0RFRkFVTFRfQ09NUFJFU1NJT04iLCJaX0ZJTFRFUkVEIiwiWl9IVUZGTUFOX09OTFkiLCJaX1JMRSIsIlpfRklYRUQiLCJaX0RFRkFVTFRfU1RSQVRFR1kiLCJaX0JJTkFSWSIsIlpfVEVYVCIsIlpfVU5LTk9XTiIsIlpfREVGTEFURUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js ***!
  \************************************************************************/
/***/ ((module) => {

eval("\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n    var c, table = [];\n    for(var n = 0; n < 256; n++){\n        c = n;\n        for(var k = 0; k < 8; k++){\n            c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n        }\n        table[n] = c;\n    }\n    return table;\n}\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\nfunction crc32(crc, buf, len, pos) {\n    var t = crcTable, end = pos + len;\n    crc ^= -1;\n    for(var i = pos; i < end; i++){\n        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];\n    }\n    return crc ^ -1; // >>> 0;\n}\nmodule.exports = crc32;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLG1EQUFtRDtBQUNuRCwwREFBMEQ7QUFDMUQsZ0NBQWdDO0FBRWhDLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLHdEQUF3RDtBQUN4RCxTQUFTQTtJQUNQLElBQUlDLEdBQUdDLFFBQVEsRUFBRTtJQUVqQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSSxLQUFLQSxJQUFLO1FBQzVCRixJQUFJRTtRQUNKLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQUs7WUFDMUJILElBQUssSUFBSyxJQUFNLGFBQWNBLE1BQU0sSUFBT0EsTUFBTTtRQUNuRDtRQUNBQyxLQUFLLENBQUNDLEVBQUUsR0FBR0Y7SUFDYjtJQUVBLE9BQU9DO0FBQ1Q7QUFFQSw4REFBOEQ7QUFDOUQsSUFBSUcsV0FBV0w7QUFHZixTQUFTTSxNQUFNQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQy9CLElBQUlDLElBQUlOLFVBQ0pPLE1BQU1GLE1BQU1EO0lBRWhCRixPQUFPLENBQUM7SUFFUixJQUFLLElBQUlNLElBQUlILEtBQUtHLElBQUlELEtBQUtDLElBQUs7UUFDOUJOLE1BQU0sUUFBUyxJQUFLSSxDQUFDLENBQUMsQ0FBQ0osTUFBTUMsR0FBRyxDQUFDSyxFQUFFLElBQUksS0FBSztJQUM5QztJQUVBLE9BQVFOLE1BQU8sQ0FBQyxHQUFLLFNBQVM7QUFDaEM7QUFHQU8sT0FBT0MsT0FBTyxHQUFHVCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanM/MDMwMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iXSwibmFtZXMiOlsibWFrZVRhYmxlIiwiYyIsInRhYmxlIiwibiIsImsiLCJjcmNUYWJsZSIsImNyYzMyIiwiY3JjIiwiYnVmIiwibGVuIiwicG9zIiwidCIsImVuZCIsImkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar trees = __webpack_require__(/*! ./trees */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js\");\nvar msg = __webpack_require__(/*! ./messages */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ var Z_NO_FLUSH = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\n//var Z_TREES         = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* compression levels */ //var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\nvar Z_FILTERED = 1;\nvar Z_HUFFMAN_ONLY = 2;\nvar Z_RLE = 3;\nvar Z_FIXED = 4;\nvar Z_DEFAULT_STRATEGY = 0;\n/* Possible values of the data_type field (though see inflate()) */ //var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/*============================================================================*/ var MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */ var MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_MEM_LEVEL = 8;\nvar LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nvar PRESET_DICT = 0x20;\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\nvar BS_NEED_MORE = 1; /* block not completed, need more input or more output */ \nvar BS_BLOCK_DONE = 2; /* block flush performed */ \nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */ \nvar BS_FINISH_DONE = 4; /* finish done, accept no more input or output */ \nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\nfunction err(strm, errorCode) {\n    strm.msg = msg[errorCode];\n    return errorCode;\n}\nfunction rank(f) {\n    return (f << 1) - (f > 4 ? 9 : 0);\n}\nfunction zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */ function flush_pending(strm) {\n    var s = strm.state;\n    //_tr_flush_bits(s);\n    var len = s.pending;\n    if (len > strm.avail_out) {\n        len = strm.avail_out;\n    }\n    if (len === 0) {\n        return;\n    }\n    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n    strm.next_out += len;\n    s.pending_out += len;\n    strm.total_out += len;\n    strm.avail_out -= len;\n    s.pending -= len;\n    if (s.pending === 0) {\n        s.pending_out = 0;\n    }\n}\nfunction flush_block_only(s, last) {\n    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n    s.block_start = s.strstart;\n    flush_pending(s.strm);\n}\nfunction put_byte(s, b) {\n    s.pending_buf[s.pending++] = b;\n}\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */ function putShortMSB(s, b) {\n    //  put_byte(s, (Byte)(b >> 8));\n    //  put_byte(s, (Byte)(b & 0xff));\n    s.pending_buf[s.pending++] = b >>> 8 & 0xff;\n    s.pending_buf[s.pending++] = b & 0xff;\n}\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */ function read_buf(strm, buf, start, size) {\n    var len = strm.avail_in;\n    if (len > size) {\n        len = size;\n    }\n    if (len === 0) {\n        return 0;\n    }\n    strm.avail_in -= len;\n    // zmemcpy(buf, strm->next_in, len);\n    utils.arraySet(buf, strm.input, strm.next_in, len, start);\n    if (strm.state.wrap === 1) {\n        strm.adler = adler32(strm.adler, buf, len, start);\n    } else if (strm.state.wrap === 2) {\n        strm.adler = crc32(strm.adler, buf, len, start);\n    }\n    strm.next_in += len;\n    strm.total_in += len;\n    return len;\n}\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */ function longest_match(s, cur_match) {\n    var chain_length = s.max_chain_length; /* max hash chain length */ \n    var scan = s.strstart; /* current string */ \n    var match; /* matched string */ \n    var len; /* length of current match */ \n    var best_len = s.prev_length; /* best match length so far */ \n    var nice_match = s.nice_match; /* stop if match long enough */ \n    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0 /*NIL*/ ;\n    var _win = s.window; // shortcut\n    var wmask = s.w_mask;\n    var prev = s.prev;\n    /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */ var strend = s.strstart + MAX_MATCH;\n    var scan_end1 = _win[scan + best_len - 1];\n    var scan_end = _win[scan + best_len];\n    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */ // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n    /* Do not waste too much time if we already have a good match: */ if (s.prev_length >= s.good_match) {\n        chain_length >>= 2;\n    }\n    /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */ if (nice_match > s.lookahead) {\n        nice_match = s.lookahead;\n    }\n    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n    do {\n        // Assert(cur_match < s->strstart, \"no future\");\n        match = cur_match;\n        /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */ if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n            continue;\n        }\n        /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */ scan += 2;\n        match++;\n        // Assert(*scan == *match, \"match[2]?\");\n        /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */ do {\n        /*jshint noempty:false*/ }while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n        // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n        len = MAX_MATCH - (strend - scan);\n        scan = strend - MAX_MATCH;\n        if (len > best_len) {\n            s.match_start = cur_match;\n            best_len = len;\n            if (len >= nice_match) {\n                break;\n            }\n            scan_end1 = _win[scan + best_len - 1];\n            scan_end = _win[scan + best_len];\n        }\n    }while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n    if (best_len <= s.lookahead) {\n        return best_len;\n    }\n    return s.lookahead;\n}\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */ function fill_window(s) {\n    var _w_size = s.w_size;\n    var p, n, m, more, str;\n    //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n    do {\n        more = s.window_size - s.lookahead - s.strstart;\n        // JS ints have 32 bit, block below not needed\n        /* Deal with !@#$% 64K limit: */ //if (sizeof(int) <= 2) {\n        //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n        //        more = wsize;\n        //\n        //  } else if (more == (unsigned)(-1)) {\n        //        /* Very unlikely, but possible on 16 bit machine if\n        //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n        //         */\n        //        more--;\n        //    }\n        //}\n        /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */ if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n            s.match_start -= _w_size;\n            s.strstart -= _w_size;\n            /* we now have strstart >= MAX_DIST */ s.block_start -= _w_size;\n            /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */ n = s.hash_size;\n            p = n;\n            do {\n                m = s.head[--p];\n                s.head[p] = m >= _w_size ? m - _w_size : 0;\n            }while (--n);\n            n = _w_size;\n            p = n;\n            do {\n                m = s.prev[--p];\n                s.prev[p] = m >= _w_size ? m - _w_size : 0;\n            /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */ }while (--n);\n            more += _w_size;\n        }\n        if (s.strm.avail_in === 0) {\n            break;\n        }\n        /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */ //Assert(more >= 2, \"more < 2\");\n        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n        s.lookahead += n;\n        /* Initialize the hash value now that we have some input: */ if (s.lookahead + s.insert >= MIN_MATCH) {\n            str = s.strstart - s.insert;\n            s.ins_h = s.window[str];\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //        Call update_hash() MIN_MATCH-3 more times\n            //#endif\n            while(s.insert){\n                /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n                s.prev[str & s.w_mask] = s.head[s.ins_h];\n                s.head[s.ins_h] = str;\n                str++;\n                s.insert--;\n                if (s.lookahead + s.insert < MIN_MATCH) {\n                    break;\n                }\n            }\n        }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */ }while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n/* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */ //  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */ function deflate_stored(s, flush) {\n    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */ var max_block_size = 0xffff;\n    if (max_block_size > s.pending_buf_size - 5) {\n        max_block_size = s.pending_buf_size - 5;\n    }\n    /* Copy as much as possible from input to output: */ for(;;){\n        /* Fill the window as much as possible: */ if (s.lookahead <= 1) {\n            //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n            //  s->block_start >= (long)s->w_size, \"slide too late\");\n            //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n            //        s.block_start >= s.w_size)) {\n            //        throw  new Error(\"slide too late\");\n            //      }\n            fill_window(s);\n            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            }\n        /* flush the current block */ }\n        //Assert(s->block_start >= 0L, \"block gone\");\n        //    if (s.block_start < 0) throw new Error(\"block gone\");\n        s.strstart += s.lookahead;\n        s.lookahead = 0;\n        /* Emit a stored block if pending_buf will be full: */ var max_start = s.block_start + max_block_size;\n        if (s.strstart === 0 || s.strstart >= max_start) {\n            /* strstart == 0 is possible when wraparound on 16-bit machine */ s.lookahead = s.strstart - max_start;\n            s.strstart = max_start;\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n        /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */ if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.strstart > s.block_start) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_NEED_MORE;\n}\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */ function deflate_fast(s, flush) {\n    var hash_head; /* head of the hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break; /* flush the current block */ \n            }\n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */ if (hash_head !== 0 /*NIL*/  && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n        /* longest_match() sets match_start */ }\n        if (s.match_length >= MIN_MATCH) {\n            // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n            /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */ if (s.match_length <= s.max_lazy_match /*max_insert_length*/  && s.lookahead >= MIN_MATCH) {\n                s.match_length--; /* string at strstart already in table */ \n                do {\n                    s.strstart++;\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */ }while (--s.match_length !== 0);\n                s.strstart++;\n            } else {\n                s.strstart += s.match_length;\n                s.match_length = 0;\n                s.ins_h = s.window[s.strstart];\n                /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;\n            //#if MIN_MATCH != 3\n            //                Call UPDATE_HASH() MIN_MATCH-3 more times\n            //#endif\n            /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */ }\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */ function deflate_slow(s, flush) {\n    var hash_head; /* head of hash chain */ \n    var bflush; /* set if current block must be flushed */ \n    var max_insert;\n    /* Process the input block. */ for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */ if (s.lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */ hash_head = 0 /*NIL*/ ;\n        if (s.lookahead >= MIN_MATCH) {\n            /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = s.strstart;\n        /***/ }\n        /* Find the longest match, discarding those <= prev_length.\n     */ s.prev_length = s.match_length;\n        s.prev_match = s.match_start;\n        s.match_length = MIN_MATCH - 1;\n        if (hash_head !== 0 /*NIL*/  && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n            /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */ s.match_length = longest_match(s, hash_head);\n            /* longest_match() sets match_start */ if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096 /*TOO_FAR*/ )) {\n                /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */ s.match_length = MIN_MATCH - 1;\n            }\n        }\n        /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */ if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n            max_insert = s.strstart + s.lookahead - MIN_MATCH;\n            /* Do not insert strings in hash table beyond this. */ //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n            /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/ bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n            /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */ s.lookahead -= s.prev_length - 1;\n            s.prev_length -= 2;\n            do {\n                if (++s.strstart <= max_insert) {\n                    /*** INSERT_STRING(s, s.strstart, hash_head); ***/ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n                    s.head[s.ins_h] = s.strstart;\n                /***/ }\n            }while (--s.prev_length !== 0);\n            s.match_available = 0;\n            s.match_length = MIN_MATCH - 1;\n            s.strstart++;\n            if (bflush) {\n                /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n                if (s.strm.avail_out === 0) {\n                    return BS_NEED_MORE;\n                }\n            /***/ }\n        } else if (s.match_available) {\n            /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */ //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n            /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n            if (bflush) {\n                /*** FLUSH_BLOCK_ONLY(s, 0) ***/ flush_block_only(s, false);\n            /***/ }\n            s.strstart++;\n            s.lookahead--;\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        } else {\n            /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */ s.match_available = 1;\n            s.strstart++;\n            s.lookahead--;\n        }\n    }\n    //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n    if (s.match_available) {\n        //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n        s.match_available = 0;\n    }\n    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */ function deflate_rle(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    var prev; /* byte at distance one to match */ \n    var scan, strend; /* scan goes up to strend for length of run */ \n    var _win = s.window;\n    for(;;){\n        /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */ if (s.lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n                return BS_NEED_MORE;\n            }\n            if (s.lookahead === 0) {\n                break;\n            } /* flush the current block */ \n        }\n        /* See how many times the previous byte repeats */ s.match_length = 0;\n        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n            scan = s.strstart - 1;\n            prev = _win[scan];\n            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n                strend = s.strstart + MAX_MATCH;\n                do {\n                /*jshint noempty:false*/ }while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n                s.match_length = MAX_MATCH - (strend - scan);\n                if (s.match_length > s.lookahead) {\n                    s.match_length = s.lookahead;\n                }\n            }\n        //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        /* Emit match if have run of MIN_MATCH or longer, else emit literal */ if (s.match_length >= MIN_MATCH) {\n            //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n            /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/ bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n            s.lookahead -= s.match_length;\n            s.strstart += s.match_length;\n            s.match_length = 0;\n        } else {\n            /* No match, output a literal byte */ //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n            s.lookahead--;\n            s.strstart++;\n        }\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */ function deflate_huff(s, flush) {\n    var bflush; /* set if current block must be flushed */ \n    for(;;){\n        /* Make sure that we have a literal to write. */ if (s.lookahead === 0) {\n            fill_window(s);\n            if (s.lookahead === 0) {\n                if (flush === Z_NO_FLUSH) {\n                    return BS_NEED_MORE;\n                }\n                break; /* flush the current block */ \n            }\n        }\n        /* Output a literal byte */ s.match_length = 0;\n        //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/ bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n        s.lookahead--;\n        s.strstart++;\n        if (bflush) {\n            /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n            if (s.strm.avail_out === 0) {\n                return BS_NEED_MORE;\n            }\n        /***/ }\n    }\n    s.insert = 0;\n    if (flush === Z_FINISH) {\n        /*** FLUSH_BLOCK(s, 1); ***/ flush_block_only(s, true);\n        if (s.strm.avail_out === 0) {\n            return BS_FINISH_STARTED;\n        }\n        /***/ return BS_FINISH_DONE;\n    }\n    if (s.last_lit) {\n        /*** FLUSH_BLOCK(s, 0); ***/ flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n            return BS_NEED_MORE;\n        }\n    /***/ }\n    return BS_BLOCK_DONE;\n}\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */ function Config(good_length, max_lazy, nice_length, max_chain, func) {\n    this.good_length = good_length;\n    this.max_lazy = max_lazy;\n    this.nice_length = nice_length;\n    this.max_chain = max_chain;\n    this.func = func;\n}\nvar configuration_table;\nconfiguration_table = [\n    /*      good lazy nice chain */ new Config(0, 0, 0, 0, deflate_stored),\n    /* 0 store only */ new Config(4, 4, 8, 4, deflate_fast),\n    /* 1 max speed, no lazy matches */ new Config(4, 5, 16, 8, deflate_fast),\n    /* 2 */ new Config(4, 6, 32, 32, deflate_fast),\n    /* 3 */ new Config(4, 4, 16, 16, deflate_slow),\n    /* 4 lazy matches */ new Config(8, 16, 32, 32, deflate_slow),\n    /* 5 */ new Config(8, 16, 128, 128, deflate_slow),\n    /* 6 */ new Config(8, 32, 128, 256, deflate_slow),\n    /* 7 */ new Config(32, 128, 258, 1024, deflate_slow),\n    /* 8 */ new Config(32, 258, 258, 4096, deflate_slow)\n];\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */ function lm_init(s) {\n    s.window_size = 2 * s.w_size;\n    /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n    /* Set the default configuration parameters:\n   */ s.max_lazy_match = configuration_table[s.level].max_lazy;\n    s.good_match = configuration_table[s.level].good_length;\n    s.nice_match = configuration_table[s.level].nice_length;\n    s.max_chain_length = configuration_table[s.level].max_chain;\n    s.strstart = 0;\n    s.block_start = 0;\n    s.lookahead = 0;\n    s.insert = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    s.ins_h = 0;\n}\nfunction DeflateState() {\n    this.strm = null; /* pointer back to this zlib stream */ \n    this.status = 0; /* as the name implies */ \n    this.pending_buf = null; /* output still pending */ \n    this.pending_buf_size = 0; /* size of pending_buf */ \n    this.pending_out = 0; /* next pending byte to output to the stream */ \n    this.pending = 0; /* nb of bytes in the pending buffer */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.gzhead = null; /* gzip header information to write */ \n    this.gzindex = 0; /* where in extra, name, or comment */ \n    this.method = Z_DEFLATED; /* can only be DEFLATED */ \n    this.last_flush = -1; /* value of flush param for previous deflate call */ \n    this.w_size = 0; /* LZ77 window size (32K by default) */ \n    this.w_bits = 0; /* log2(w_size)  (8..16) */ \n    this.w_mask = 0; /* w_size - 1 */ \n    this.window = null;\n    /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */ this.window_size = 0;\n    /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */ this.prev = null;\n    /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */ this.head = null; /* Heads of the hash chains or NIL. */ \n    this.ins_h = 0; /* hash index of string to be inserted */ \n    this.hash_size = 0; /* number of elements in hash table */ \n    this.hash_bits = 0; /* log2(hash_size) */ \n    this.hash_mask = 0; /* hash_size-1 */ \n    this.hash_shift = 0;\n    /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */ this.block_start = 0;\n    /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */ this.match_length = 0; /* length of best match */ \n    this.prev_match = 0; /* previous match */ \n    this.match_available = 0; /* set if previous match exists */ \n    this.strstart = 0; /* start of string to insert */ \n    this.match_start = 0; /* start of matching string */ \n    this.lookahead = 0; /* number of valid bytes ahead in window */ \n    this.prev_length = 0;\n    /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */ this.max_chain_length = 0;\n    /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */ this.max_lazy_match = 0;\n    /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */ // That's alias to max_lazy_match, don't use directly\n    //this.max_insert_length = 0;\n    /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */ this.level = 0; /* compression level (1..9) */ \n    this.strategy = 0; /* favor or force Huffman coding*/ \n    this.good_match = 0;\n    /* Use a faster search when the previous match is longer than this */ this.nice_match = 0; /* Stop searching when current match exceeds this */ \n    /* used by trees.c: */ /* Didn't use ct_data typedef below to suppress compiler warning */ // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n    // Use flat array of DOUBLE size, with interleaved fata,\n    // because JS does not support effective\n    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n    zero(this.dyn_ltree);\n    zero(this.dyn_dtree);\n    zero(this.bl_tree);\n    this.l_desc = null; /* desc. for literal tree */ \n    this.d_desc = null; /* desc. for distance tree */ \n    this.bl_desc = null; /* desc. for bit length tree */ \n    //ush bl_count[MAX_BITS+1];\n    this.bl_count = new utils.Buf16(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n    this.heap = new utils.Buf16(2 * L_CODES + 1); /* heap used to build the Huffman trees */ \n    zero(this.heap);\n    this.heap_len = 0; /* number of elements in the heap */ \n    this.heap_max = 0; /* element of largest frequency */ \n    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */ this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n    zero(this.depth);\n    /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */ this.l_buf = 0; /* buffer index for literals or lengths */ \n    this.lit_bufsize = 0;\n    /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */ this.last_lit = 0; /* running index in l_buf */ \n    this.d_buf = 0;\n    /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */ this.opt_len = 0; /* bit length of current block with optimal trees */ \n    this.static_len = 0; /* bit length of current block with static trees */ \n    this.matches = 0; /* number of string matches in current block */ \n    this.insert = 0; /* bytes at end of window left to insert */ \n    this.bi_buf = 0;\n    /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */ this.bi_valid = 0;\n/* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */ // Used for window memory init. We safely ignore it for JS. That makes\n// sense only for pointers and memory check tools.\n//this.high_water = 0;\n/* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */ }\nfunction deflateResetKeep(strm) {\n    var s;\n    if (!strm || !strm.state) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.total_in = strm.total_out = 0;\n    strm.data_type = Z_UNKNOWN;\n    s = strm.state;\n    s.pending = 0;\n    s.pending_out = 0;\n    if (s.wrap < 0) {\n        s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */ }\n    s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n    strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)\n     : 1; // adler32(0, Z_NULL, 0)\n    s.last_flush = Z_NO_FLUSH;\n    trees._tr_init(s);\n    return Z_OK;\n}\nfunction deflateReset(strm) {\n    var ret = deflateResetKeep(strm);\n    if (ret === Z_OK) {\n        lm_init(strm.state);\n    }\n    return ret;\n}\nfunction deflateSetHeader(strm, head) {\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    if (strm.state.wrap !== 2) {\n        return Z_STREAM_ERROR;\n    }\n    strm.state.gzhead = head;\n    return Z_OK;\n}\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    var wrap = 1;\n    if (level === Z_DEFAULT_COMPRESSION) {\n        level = 6;\n    }\n    if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else if (windowBits > 15) {\n        wrap = 2; /* write gzip wrapper instead */ \n        windowBits -= 16;\n    }\n    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    if (windowBits === 8) {\n        windowBits = 9;\n    }\n    /* until 256-byte window bug fixed */ var s = new DeflateState();\n    strm.state = s;\n    s.strm = strm;\n    s.wrap = wrap;\n    s.gzhead = null;\n    s.w_bits = windowBits;\n    s.w_size = 1 << s.w_bits;\n    s.w_mask = s.w_size - 1;\n    s.hash_bits = memLevel + 7;\n    s.hash_size = 1 << s.hash_bits;\n    s.hash_mask = s.hash_size - 1;\n    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n    s.window = new utils.Buf8(s.w_size * 2);\n    s.head = new utils.Buf16(s.hash_size);\n    s.prev = new utils.Buf16(s.w_size);\n    // Don't need mem init magic for JS.\n    //s.high_water = 0;  /* nothing written to s->window yet */\n    s.lit_bufsize = 1 << memLevel + 6; /* 16K elements by default */ \n    s.pending_buf_size = s.lit_bufsize * 4;\n    //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n    //s->pending_buf = (uchf *) overlay;\n    s.pending_buf = new utils.Buf8(s.pending_buf_size);\n    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n    //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n    s.d_buf = 1 * s.lit_bufsize;\n    //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n    s.l_buf = (1 + 2) * s.lit_bufsize;\n    s.level = level;\n    s.strategy = strategy;\n    s.method = method;\n    return deflateReset(strm);\n}\nfunction deflateInit(strm, level) {\n    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\nfunction deflate(strm, flush) {\n    var old_flush, s;\n    var beg, val; // for gzip header write only\n    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {\n        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n    }\n    s.strm = strm; /* just in case */ \n    old_flush = s.last_flush;\n    s.last_flush = flush;\n    /* Write the header */ if (s.status === INIT_STATE) {\n        if (s.wrap === 2) {\n            strm.adler = 0; //crc32(0L, Z_NULL, 0);\n            put_byte(s, 31);\n            put_byte(s, 139);\n            put_byte(s, 8);\n            if (!s.gzhead) {\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, 0);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, OS_CODE);\n                s.status = BUSY_STATE;\n            } else {\n                put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n                put_byte(s, s.gzhead.time & 0xff);\n                put_byte(s, s.gzhead.time >> 8 & 0xff);\n                put_byte(s, s.gzhead.time >> 16 & 0xff);\n                put_byte(s, s.gzhead.time >> 24 & 0xff);\n                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n                put_byte(s, s.gzhead.os & 0xff);\n                if (s.gzhead.extra && s.gzhead.extra.length) {\n                    put_byte(s, s.gzhead.extra.length & 0xff);\n                    put_byte(s, s.gzhead.extra.length >> 8 & 0xff);\n                }\n                if (s.gzhead.hcrc) {\n                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n                }\n                s.gzindex = 0;\n                s.status = EXTRA_STATE;\n            }\n        } else {\n            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n            var level_flags = -1;\n            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n                level_flags = 0;\n            } else if (s.level < 6) {\n                level_flags = 1;\n            } else if (s.level === 6) {\n                level_flags = 2;\n            } else {\n                level_flags = 3;\n            }\n            header |= level_flags << 6;\n            if (s.strstart !== 0) {\n                header |= PRESET_DICT;\n            }\n            header += 31 - header % 31;\n            s.status = BUSY_STATE;\n            putShortMSB(s, header);\n            /* Save the adler32 of the preset dictionary: */ if (s.strstart !== 0) {\n                putShortMSB(s, strm.adler >>> 16);\n                putShortMSB(s, strm.adler & 0xffff);\n            }\n            strm.adler = 1; // adler32(0L, Z_NULL, 0);\n        }\n    }\n    //#ifdef GZIP\n    if (s.status === EXTRA_STATE) {\n        if (s.gzhead.extra /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            while(s.gzindex < (s.gzhead.extra.length & 0xffff)){\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        break;\n                    }\n                }\n                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n                s.gzindex++;\n            }\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (s.gzindex === s.gzhead.extra.length) {\n                s.gzindex = 0;\n                s.status = NAME_STATE;\n            }\n        } else {\n            s.status = NAME_STATE;\n        }\n    }\n    if (s.status === NAME_STATE) {\n        if (s.gzhead.name /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.name.length) {\n                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.gzindex = 0;\n                s.status = COMMENT_STATE;\n            }\n        } else {\n            s.status = COMMENT_STATE;\n        }\n    }\n    if (s.status === COMMENT_STATE) {\n        if (s.gzhead.comment /* != Z_NULL*/ ) {\n            beg = s.pending; /* start of bytes to update crc */ \n            //int val;\n            do {\n                if (s.pending === s.pending_buf_size) {\n                    if (s.gzhead.hcrc && s.pending > beg) {\n                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n                    }\n                    flush_pending(strm);\n                    beg = s.pending;\n                    if (s.pending === s.pending_buf_size) {\n                        val = 1;\n                        break;\n                    }\n                }\n                // JS specific: little magic to add zero terminator to end of string\n                if (s.gzindex < s.gzhead.comment.length) {\n                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n                } else {\n                    val = 0;\n                }\n                put_byte(s, val);\n            }while (val !== 0);\n            if (s.gzhead.hcrc && s.pending > beg) {\n                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n            }\n            if (val === 0) {\n                s.status = HCRC_STATE;\n            }\n        } else {\n            s.status = HCRC_STATE;\n        }\n    }\n    if (s.status === HCRC_STATE) {\n        if (s.gzhead.hcrc) {\n            if (s.pending + 2 > s.pending_buf_size) {\n                flush_pending(strm);\n            }\n            if (s.pending + 2 <= s.pending_buf_size) {\n                put_byte(s, strm.adler & 0xff);\n                put_byte(s, strm.adler >> 8 & 0xff);\n                strm.adler = 0; //crc32(0L, Z_NULL, 0);\n                s.status = BUSY_STATE;\n            }\n        } else {\n            s.status = BUSY_STATE;\n        }\n    }\n    //#endif\n    /* Flush as much pending output as possible */ if (s.pending !== 0) {\n        flush_pending(strm);\n        if (strm.avail_out === 0) {\n            /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */ s.last_flush = -1;\n            return Z_OK;\n        }\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */ } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* User must not provide more input after the first FINISH: */ if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n        return err(strm, Z_BUF_ERROR);\n    }\n    /* Start a new block or continue the current one.\n   */ if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n            s.status = FINISH_STATE;\n        }\n        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n            if (strm.avail_out === 0) {\n                s.last_flush = -1;\n            /* avoid BUF_ERROR next call, see above */ }\n            return Z_OK;\n        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */ }\n        if (bstate === BS_BLOCK_DONE) {\n            if (flush === Z_PARTIAL_FLUSH) {\n                trees._tr_align(s);\n            } else if (flush !== Z_BLOCK) {\n                trees._tr_stored_block(s, 0, 0, false);\n                /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */ if (flush === Z_FULL_FLUSH) {\n                    /*** CLEAR_HASH(s); ***/ /* forget history */ zero(s.head); // Fill with NIL (= 0);\n                    if (s.lookahead === 0) {\n                        s.strstart = 0;\n                        s.block_start = 0;\n                        s.insert = 0;\n                    }\n                }\n            }\n            flush_pending(strm);\n            if (strm.avail_out === 0) {\n                s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */ \n                return Z_OK;\n            }\n        }\n    }\n    //Assert(strm->avail_out > 0, \"bug2\");\n    //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n    if (flush !== Z_FINISH) {\n        return Z_OK;\n    }\n    if (s.wrap <= 0) {\n        return Z_STREAM_END;\n    }\n    /* Write the trailer */ if (s.wrap === 2) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, strm.adler >> 8 & 0xff);\n        put_byte(s, strm.adler >> 16 & 0xff);\n        put_byte(s, strm.adler >> 24 & 0xff);\n        put_byte(s, strm.total_in & 0xff);\n        put_byte(s, strm.total_in >> 8 & 0xff);\n        put_byte(s, strm.total_in >> 16 & 0xff);\n        put_byte(s, strm.total_in >> 24 & 0xff);\n    } else {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n    }\n    flush_pending(strm);\n    /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */ if (s.wrap > 0) {\n        s.wrap = -s.wrap;\n    }\n    /* write the trailer only once! */ return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\nfunction deflateEnd(strm) {\n    var status;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    status = strm.state.status;\n    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n        return err(strm, Z_STREAM_ERROR);\n    }\n    strm.state = null;\n    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */ function deflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var s;\n    var str, n;\n    var wrap;\n    var avail;\n    var next;\n    var input;\n    var tmpDict;\n    if (!strm /*== Z_NULL*/  || !strm.state /*== Z_NULL*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    s = strm.state;\n    wrap = s.wrap;\n    if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n        return Z_STREAM_ERROR;\n    }\n    /* when using zlib wrappers, compute Adler-32 for provided dictionary */ if (wrap === 1) {\n        /* adler32(strm->adler, dictionary, dictLength); */ strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n    }\n    s.wrap = 0; /* avoid computing Adler-32 in read_buf */ \n    /* if dictionary would fill window, just replace the history */ if (dictLength >= s.w_size) {\n        if (wrap === 0) {\n            /*** CLEAR_HASH(s); ***/ zero(s.head); // Fill with NIL (= 0);\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n        }\n        /* use the tail */ // dictionary = dictionary.slice(dictLength - s.w_size);\n        tmpDict = new utils.Buf8(s.w_size);\n        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n        dictionary = tmpDict;\n        dictLength = s.w_size;\n    }\n    /* insert dictionary into window and hash */ avail = strm.avail_in;\n    next = strm.next_in;\n    input = strm.input;\n    strm.avail_in = dictLength;\n    strm.next_in = 0;\n    strm.input = dictionary;\n    fill_window(s);\n    while(s.lookahead >= MIN_MATCH){\n        str = s.strstart;\n        n = s.lookahead - (MIN_MATCH - 1);\n        do {\n            /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */ s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n            s.prev[str & s.w_mask] = s.head[s.ins_h];\n            s.head[s.ins_h] = str;\n            str++;\n        }while (--n);\n        s.strstart = str;\n        s.lookahead = MIN_MATCH - 1;\n        fill_window(s);\n    }\n    s.strstart += s.lookahead;\n    s.block_start = s.strstart;\n    s.insert = s.lookahead;\n    s.lookahead = 0;\n    s.match_length = s.prev_length = MIN_MATCH - 1;\n    s.match_available = 0;\n    strm.next_in = next;\n    strm.input = input;\n    strm.avail_in = avail;\n    s.wrap = wrap;\n    return Z_OK;\n}\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = \"pako deflate (from Nodeca project)\"; /* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsSUFBSUEsUUFBVUMsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUMsUUFBVUQsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsUUFBVUgsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUksTUFBVUosbUJBQU9BLENBQUM7QUFFdEIsOEVBQThFLEdBQzlFLDhFQUE4RSxHQUc5RSx1RUFBdUUsR0FDdkUsSUFBSUssYUFBa0I7QUFDdEIsSUFBSUMsa0JBQWtCO0FBQ3RCLDBCQUEwQjtBQUMxQixJQUFJQyxlQUFrQjtBQUN0QixJQUFJQyxXQUFrQjtBQUN0QixJQUFJQyxVQUFrQjtBQUN0QiwwQkFBMEI7QUFHMUI7O0NBRUMsR0FDRCxJQUFJQyxPQUFrQjtBQUN0QixJQUFJQyxlQUFrQjtBQUN0QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLElBQUlDLGlCQUFrQixDQUFDO0FBQ3ZCLElBQUlDLGVBQWtCLENBQUM7QUFDdkIsMkJBQTJCO0FBQzNCLElBQUlDLGNBQWtCLENBQUM7QUFDdkIsMkJBQTJCO0FBRzNCLHNCQUFzQixHQUN0QixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxJQUFJQyx3QkFBd0IsQ0FBQztBQUc3QixJQUFJQyxh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Q0FBLEVBQUVjLFFBQVEsSUFBSWQsRUFBRStDLFNBQVM7SUFDekIvQyxFQUFFYSxXQUFXLEdBQUdiLEVBQUVjLFFBQVE7SUFDMUJkLEVBQUUyRCxNQUFNLEdBQUczRCxFQUFFK0MsU0FBUztJQUN0Qi9DLEVBQUUrQyxTQUFTLEdBQUc7SUFDZC9DLEVBQUV1RSxZQUFZLEdBQUd2RSxFQUFFa0MsV0FBVyxHQUFHNUQsWUFBWTtJQUM3QzBCLEVBQUUrRSxlQUFlLEdBQUc7SUFDcEJ4RixLQUFLZ0MsT0FBTyxHQUFHaUk7SUFDZmpLLEtBQUsrQixLQUFLLEdBQUdBO0lBQ2IvQixLQUFLOEIsUUFBUSxHQUFHa0k7SUFDaEJ2SixFQUFFd0IsSUFBSSxHQUFHQTtJQUNULE9BQU96RTtBQUNUO0FBR0EyTSxtQkFBbUIsR0FBR3pCO0FBQ3RCeUIsb0JBQW9CLEdBQUc3QjtBQUN2QjZCLG9CQUFvQixHQUFHaEM7QUFDdkJnQyx3QkFBd0IsR0FBR25DO0FBQzNCbUMsd0JBQXdCLEdBQUc5QjtBQUMzQjhCLGVBQWUsR0FBR3hCO0FBQ2xCd0Isa0JBQWtCLEdBQUdQO0FBQ3JCTyw0QkFBNEIsR0FBR047QUFDL0JNLG1CQUFtQixHQUFHLHNDQUV0Qjs7Ozs7OztBQU9BIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzPzViYzQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsInRyZWVzIiwiYWRsZXIzMiIsImNyYzMyIiwibXNnIiwiWl9OT19GTFVTSCIsIlpfUEFSVElBTF9GTFVTSCIsIlpfRlVMTF9GTFVTSCIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfT0siLCJaX1NUUkVBTV9FTkQiLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfQlVGX0VSUk9SIiwiWl9ERUZBVUxUX0NPTVBSRVNTSU9OIiwiWl9GSUxURVJFRCIsIlpfSFVGRk1BTl9PTkxZIiwiWl9STEUiLCJaX0ZJWEVEIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiWl9VTktOT1dOIiwiWl9ERUZMQVRFRCIsIk1BWF9NRU1fTEVWRUwiLCJNQVhfV0JJVFMiLCJERUZfTUVNX0xFVkVMIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJNSU5fTUFUQ0giLCJNQVhfTUFUQ0giLCJNSU5fTE9PS0FIRUFEIiwiUFJFU0VUX0RJQ1QiLCJJTklUX1NUQVRFIiwiRVhUUkFfU1RBVEUiLCJOQU1FX1NUQVRFIiwiQ09NTUVOVF9TVEFURSIsIkhDUkNfU1RBVEUiLCJCVVNZX1NUQVRFIiwiRklOSVNIX1NUQVRFIiwiQlNfTkVFRF9NT1JFIiwiQlNfQkxPQ0tfRE9ORSIsIkJTX0ZJTklTSF9TVEFSVEVEIiwiQlNfRklOSVNIX0RPTkUiLCJPU19DT0RFIiwiZXJyIiwic3RybSIsImVycm9yQ29kZSIsInJhbmsiLCJmIiwiemVybyIsImJ1ZiIsImxlbiIsImxlbmd0aCIsImZsdXNoX3BlbmRpbmciLCJzIiwic3RhdGUiLCJwZW5kaW5nIiwiYXZhaWxfb3V0IiwiYXJyYXlTZXQiLCJvdXRwdXQiLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmdfb3V0IiwibmV4dF9vdXQiLCJ0b3RhbF9vdXQiLCJmbHVzaF9ibG9ja19vbmx5IiwibGFzdCIsIl90cl9mbHVzaF9ibG9jayIsImJsb2NrX3N0YXJ0Iiwic3Ryc3RhcnQiLCJwdXRfYnl0ZSIsImIiLCJwdXRTaG9ydE1TQiIsInJlYWRfYnVmIiwic3RhcnQiLCJzaXplIiwiYXZhaWxfaW4iLCJpbnB1dCIsIm5leHRfaW4iLCJ3cmFwIiwiYWRsZXIiLCJ0b3RhbF9pbiIsImxvbmdlc3RfbWF0Y2giLCJjdXJfbWF0Y2giLCJjaGFpbl9sZW5ndGgiLCJtYXhfY2hhaW5fbGVuZ3RoIiwic2NhbiIsIm1hdGNoIiwiYmVzdF9sZW4iLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJsaW1pdCIsIndfc2l6ZSIsIl93aW4iLCJ3aW5kb3ciLCJ3bWFzayIsIndfbWFzayIsInByZXYiLCJzdHJlbmQiLCJzY2FuX2VuZDEiLCJzY2FuX2VuZCIsImdvb2RfbWF0Y2giLCJsb29rYWhlYWQiLCJtYXRjaF9zdGFydCIsImZpbGxfd2luZG93IiwiX3dfc2l6ZSIsInAiLCJuIiwibSIsIm1vcmUiLCJzdHIiLCJ3aW5kb3dfc2l6ZSIsImhhc2hfc2l6ZSIsImhlYWQiLCJpbnNlcnQiLCJpbnNfaCIsImhhc2hfc2hpZnQiLCJoYXNoX21hc2siLCJkZWZsYXRlX3N0b3JlZCIsImZsdXNoIiwibWF4X2Jsb2NrX3NpemUiLCJwZW5kaW5nX2J1Zl9zaXplIiwibWF4X3N0YXJ0IiwiZGVmbGF0ZV9mYXN0IiwiaGFzaF9oZWFkIiwiYmZsdXNoIiwibWF0Y2hfbGVuZ3RoIiwiX3RyX3RhbGx5IiwibWF4X2xhenlfbWF0Y2giLCJsYXN0X2xpdCIsImRlZmxhdGVfc2xvdyIsIm1heF9pbnNlcnQiLCJwcmV2X21hdGNoIiwic3RyYXRlZ3kiLCJtYXRjaF9hdmFpbGFibGUiLCJkZWZsYXRlX3JsZSIsImRlZmxhdGVfaHVmZiIsIkNvbmZpZyIsImdvb2RfbGVuZ3RoIiwibWF4X2xhenkiLCJuaWNlX2xlbmd0aCIsIm1heF9jaGFpbiIsImZ1bmMiLCJjb25maWd1cmF0aW9uX3RhYmxlIiwibG1faW5pdCIsImxldmVsIiwiRGVmbGF0ZVN0YXRlIiwic3RhdHVzIiwiZ3poZWFkIiwiZ3ppbmRleCIsIm1ldGhvZCIsImxhc3RfZmx1c2giLCJ3X2JpdHMiLCJoYXNoX2JpdHMiLCJkeW5fbHRyZWUiLCJCdWYxNiIsImR5bl9kdHJlZSIsImJsX3RyZWUiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwiYmxfY291bnQiLCJoZWFwIiwiaGVhcF9sZW4iLCJoZWFwX21heCIsImRlcHRoIiwibF9idWYiLCJsaXRfYnVmc2l6ZSIsImRfYnVmIiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJtYXRjaGVzIiwiYmlfYnVmIiwiYmlfdmFsaWQiLCJkZWZsYXRlUmVzZXRLZWVwIiwiZGF0YV90eXBlIiwiX3RyX2luaXQiLCJkZWZsYXRlUmVzZXQiLCJyZXQiLCJkZWZsYXRlU2V0SGVhZGVyIiwiZGVmbGF0ZUluaXQyIiwid2luZG93Qml0cyIsIm1lbUxldmVsIiwiQnVmOCIsImRlZmxhdGVJbml0IiwiZGVmbGF0ZSIsIm9sZF9mbHVzaCIsImJlZyIsInZhbCIsInRleHQiLCJoY3JjIiwiZXh0cmEiLCJuYW1lIiwiY29tbWVudCIsInRpbWUiLCJvcyIsImhlYWRlciIsImxldmVsX2ZsYWdzIiwiY2hhckNvZGVBdCIsImJzdGF0ZSIsIl90cl9hbGlnbiIsIl90cl9zdG9yZWRfYmxvY2siLCJkZWZsYXRlRW5kIiwiZGVmbGF0ZVNldERpY3Rpb25hcnkiLCJkaWN0aW9uYXJ5IiwiZGljdExlbmd0aCIsImF2YWlsIiwibmV4dCIsInRtcERpY3QiLCJleHBvcnRzIiwiZGVmbGF0ZUluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction GZheader() {\n    /* true if compressed data believed to be text */ this.text = 0;\n    /* modification time */ this.time = 0;\n    /* extra flags (not used when writing a gzip file) */ this.xflags = 0;\n    /* operating system */ this.os = 0;\n    /* pointer to extra field or Z_NULL if none */ this.extra = null;\n    /* extra field length (valid if extra != Z_NULL) */ this.extra_len = 0; // Actually, we don't need it in JS,\n    // but leave for few code modifications\n    //\n    // Setup limits is not necessary because in js we should not preallocate memory\n    // for inflate use constant limit in 65536 bytes\n    //\n    /* space at extra (only when reading header) */ // this.extra_max  = 0;\n    /* pointer to zero-terminated file name or Z_NULL */ this.name = \"\";\n    /* space at name (only when reading header) */ // this.name_max   = 0;\n    /* pointer to zero-terminated comment or Z_NULL */ this.comment = \"\";\n    /* space at comment (only when reading header) */ // this.comm_max   = 0;\n    /* true if there was or will be a header crc */ this.hcrc = 0;\n    /* true when done reading gzip header (not used when writing a gzip file) */ this.done = false;\n}\nmodule.exports = GZheader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLFNBQVNBO0lBQ1AsK0NBQStDLEdBQy9DLElBQUksQ0FBQ0MsSUFBSSxHQUFTO0lBQ2xCLHFCQUFxQixHQUNyQixJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQixtREFBbUQsR0FDbkQsSUFBSSxDQUFDQyxNQUFNLEdBQU87SUFDbEIsb0JBQW9CLEdBQ3BCLElBQUksQ0FBQ0MsRUFBRSxHQUFXO0lBQ2xCLDRDQUE0QyxHQUM1QyxJQUFJLENBQUNDLEtBQUssR0FBUTtJQUNsQixpREFBaUQsR0FDakQsSUFBSSxDQUFDQyxTQUFTLEdBQUksR0FBRyxvQ0FBb0M7SUFDcEMsdUNBQXVDO0lBRTVELEVBQUU7SUFDRiwrRUFBK0U7SUFDL0UsZ0RBQWdEO0lBQ2hELEVBQUU7SUFFRiw2Q0FBNkMsR0FDN0MsdUJBQXVCO0lBQ3ZCLGtEQUFrRCxHQUNsRCxJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQiw0Q0FBNEMsR0FDNUMsdUJBQXVCO0lBQ3ZCLGdEQUFnRCxHQUNoRCxJQUFJLENBQUNDLE9BQU8sR0FBTTtJQUNsQiwrQ0FBK0MsR0FDL0MsdUJBQXVCO0lBQ3ZCLDZDQUE2QyxHQUM3QyxJQUFJLENBQUNDLElBQUksR0FBUztJQUNsQiwwRUFBMEUsR0FDMUUsSUFBSSxDQUFDQyxJQUFJLEdBQVM7QUFDcEI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZ3poZWFkZXIuanM/NDBlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iXSwibmFtZXMiOlsiR1poZWFkZXIiLCJ0ZXh0IiwidGltZSIsInhmbGFncyIsIm9zIiwiZXh0cmEiLCJleHRyYV9sZW4iLCJuYW1lIiwiY29tbWVudCIsImhjcmMiLCJkb25lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/gzheader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n// See state defs from inflate.js\nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */ module.exports = function inflate_fast(strm, start) {\n    var state;\n    var _in; /* local strm.input */ \n    var last; /* have enough input while in < last */ \n    var _out; /* local strm.output */ \n    var beg; /* inflate()'s initial strm.output */ \n    var end; /* while out < end, enough space available */ \n    //#ifdef INFLATE_STRICT\n    var dmax; /* maximum distance from zlib header */ \n    //#endif\n    var wsize; /* window size or zero if not using window */ \n    var whave; /* valid bytes in the window */ \n    var wnext; /* window write index */ \n    // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n    var s_window; /* allocated sliding window, if wsize != 0 */ \n    var hold; /* local strm.hold */ \n    var bits; /* local strm.bits */ \n    var lcode; /* local strm.lencode */ \n    var dcode; /* local strm.distcode */ \n    var lmask; /* mask for first level of length codes */ \n    var dmask; /* mask for first level of distance codes */ \n    var here; /* retrieved table entry */ \n    var op; /* code bits, operation, extra bits, or */ \n    /*  window position, window bytes to copy */ var len; /* match length, unused bytes */ \n    var dist; /* match distance */ \n    var from; /* where to copy match from */ \n    var from_source;\n    var input, output; // JS specific, because we have no pointers\n    /* copy state to local variables */ state = strm.state;\n    //here = state.here;\n    _in = strm.next_in;\n    input = strm.input;\n    last = _in + (strm.avail_in - 5);\n    _out = strm.next_out;\n    output = strm.output;\n    beg = _out - (start - strm.avail_out);\n    end = _out + (strm.avail_out - 257);\n    //#ifdef INFLATE_STRICT\n    dmax = state.dmax;\n    //#endif\n    wsize = state.wsize;\n    whave = state.whave;\n    wnext = state.wnext;\n    s_window = state.window;\n    hold = state.hold;\n    bits = state.bits;\n    lcode = state.lencode;\n    dcode = state.distcode;\n    lmask = (1 << state.lenbits) - 1;\n    dmask = (1 << state.distbits) - 1;\n    /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */ top: do {\n        if (bits < 15) {\n            hold += input[_in++] << bits;\n            bits += 8;\n            hold += input[_in++] << bits;\n            bits += 8;\n        }\n        here = lcode[hold & lmask];\n        dolen: for(;;){\n            op = here >>> 24 /*here.bits*/ ;\n            hold >>>= op;\n            bits -= op;\n            op = here >>> 16 & 0xff /*here.op*/ ;\n            if (op === 0) {\n                //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                //        \"inflate:         literal '%c'\\n\" :\n                //        \"inflate:         literal 0x%02x\\n\", here.val));\n                output[_out++] = here & 0xffff /*here.val*/ ;\n            } else if (op & 16) {\n                len = here & 0xffff /*here.val*/ ;\n                op &= 15; /* number of extra bits */ \n                if (op) {\n                    if (bits < op) {\n                        hold += input[_in++] << bits;\n                        bits += 8;\n                    }\n                    len += hold & (1 << op) - 1;\n                    hold >>>= op;\n                    bits -= op;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n                if (bits < 15) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                }\n                here = dcode[hold & dmask];\n                dodist: for(;;){\n                    op = here >>> 24 /*here.bits*/ ;\n                    hold >>>= op;\n                    bits -= op;\n                    op = here >>> 16 & 0xff /*here.op*/ ;\n                    if (op & 16) {\n                        dist = here & 0xffff /*here.val*/ ;\n                        op &= 15; /* number of extra bits */ \n                        if (bits < op) {\n                            hold += input[_in++] << bits;\n                            bits += 8;\n                            if (bits < op) {\n                                hold += input[_in++] << bits;\n                                bits += 8;\n                            }\n                        }\n                        dist += hold & (1 << op) - 1;\n                        //#ifdef INFLATE_STRICT\n                        if (dist > dmax) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break top;\n                        }\n                        //#endif\n                        hold >>>= op;\n                        bits -= op;\n                        //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n                        op = _out - beg; /* max distance in output */ \n                        if (dist > op) {\n                            op = dist - op; /* distance back in window */ \n                            if (op > whave) {\n                                if (state.sane) {\n                                    strm.msg = \"invalid distance too far back\";\n                                    state.mode = BAD;\n                                    break top;\n                                }\n                            // (!) This block is disabled in zlib defaults,\n                            // don't enable it for binary compatibility\n                            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                            //                if (len <= op - whave) {\n                            //                  do {\n                            //                    output[_out++] = 0;\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //                len -= op - whave;\n                            //                do {\n                            //                  output[_out++] = 0;\n                            //                } while (--op > whave);\n                            //                if (op === 0) {\n                            //                  from = _out - dist;\n                            //                  do {\n                            //                    output[_out++] = output[from++];\n                            //                  } while (--len);\n                            //                  continue top;\n                            //                }\n                            //#endif\n                            }\n                            from = 0; // window index\n                            from_source = s_window;\n                            if (wnext === 0) {\n                                from += wsize - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            } else if (wnext < op) {\n                                from += wsize + wnext - op;\n                                op -= wnext;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = 0;\n                                    if (wnext < len) {\n                                        op = wnext;\n                                        len -= op;\n                                        do {\n                                            output[_out++] = s_window[from++];\n                                        }while (--op);\n                                        from = _out - dist; /* rest from output */ \n                                        from_source = output;\n                                    }\n                                }\n                            } else {\n                                from += wnext - op;\n                                if (op < len) {\n                                    len -= op;\n                                    do {\n                                        output[_out++] = s_window[from++];\n                                    }while (--op);\n                                    from = _out - dist; /* rest from output */ \n                                    from_source = output;\n                                }\n                            }\n                            while(len > 2){\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                output[_out++] = from_source[from++];\n                                len -= 3;\n                            }\n                            if (len) {\n                                output[_out++] = from_source[from++];\n                                if (len > 1) {\n                                    output[_out++] = from_source[from++];\n                                }\n                            }\n                        } else {\n                            from = _out - dist; /* copy direct from output */ \n                            do {\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                output[_out++] = output[from++];\n                                len -= 3;\n                            }while (len > 2);\n                            if (len) {\n                                output[_out++] = output[from++];\n                                if (len > 1) {\n                                    output[_out++] = output[from++];\n                                }\n                            }\n                        }\n                    } else if ((op & 64) === 0) {\n                        here = dcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                        continue dodist;\n                    } else {\n                        strm.msg = \"invalid distance code\";\n                        state.mode = BAD;\n                        break top;\n                    }\n                    break; // need to emulate goto via \"continue\"\n                }\n            } else if ((op & 64) === 0) {\n                here = lcode[(here & 0xffff) + (hold & (1 << op) - 1)];\n                continue dolen;\n            } else if (op & 32) {\n                //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                state.mode = TYPE;\n                break top;\n            } else {\n                strm.msg = \"invalid literal/length code\";\n                state.mode = BAD;\n                break top;\n            }\n            break; // need to emulate goto via \"continue\"\n        }\n    }while (_in < last && _out < end);\n    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */ len = bits >> 3;\n    _in -= len;\n    bits -= len << 3;\n    hold &= (1 << bits) - 1;\n    /* update state and return */ strm.next_in = _in;\n    strm.next_out = _out;\n    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n    state.hold = hold;\n    state.bits = bits;\n    return;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsaUNBQWlDO0FBQ2pDLElBQUlBLE1BQU0sSUFBVSwrQ0FBK0M7QUFDbkUsSUFBSUMsT0FBTyxJQUFTLHFEQUFxRDtBQUV6RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtDQyxHQUNEQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsYUFBYUMsSUFBSSxFQUFFQyxLQUFLO0lBQ2hELElBQUlDO0lBQ0osSUFBSUMsS0FBd0Isb0JBQW9CO0lBQ2hELElBQUlDLE1BQXdCLHFDQUFxQztJQUNqRSxJQUFJQyxNQUF3QixxQkFBcUI7SUFDakQsSUFBSUMsS0FBd0IsbUNBQW1DO0lBQy9ELElBQUlDLEtBQXdCLDJDQUEyQztJQUN6RSx1QkFBdUI7SUFDckIsSUFBSUMsTUFBd0IscUNBQXFDO0lBQ25FLFFBQVE7SUFDTixJQUFJQyxPQUF3QiwyQ0FBMkM7SUFDdkUsSUFBSUMsT0FBd0IsNkJBQTZCO0lBQ3pELElBQUlDLE9BQXdCLHNCQUFzQjtJQUNsRCw2RUFBNkU7SUFDN0UsSUFBSUMsVUFBd0IsMkNBQTJDO0lBQ3ZFLElBQUlDLE1BQXdCLG1CQUFtQjtJQUMvQyxJQUFJQyxNQUF3QixtQkFBbUI7SUFDL0MsSUFBSUMsT0FBd0Isc0JBQXNCO0lBQ2xELElBQUlDLE9BQXdCLHVCQUF1QjtJ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UjtvQkFFQSxPQUFPLHNDQUFzQztnQkFDL0M7WUFDRixPQUNLLElBQUksQ0FBQ2hCLEtBQUssRUFBQyxNQUFPLEdBQUc7Z0JBQ3hCRCxPQUFPSixLQUFLLENBQUMsQ0FBQ0ksT0FBTyxNQUFLLElBQWtCTixDQUFBQSxPQUFRLENBQUMsS0FBS08sRUFBQyxJQUFLLENBQUMsRUFBRztnQkFDcEUsU0FBU2lCO1lBQ1gsT0FDSyxJQUFJakIsS0FBSyxJQUFJO2dCQUNoQix1REFBdUQ7Z0JBQ3ZEbEIsTUFBTXNDLElBQUksR0FBRzVDO2dCQUNiLE1BQU13QztZQUNSLE9BQ0s7Z0JBQ0hwQyxLQUFLdUMsR0FBRyxHQUFHO2dCQUNYckMsTUFBTXNDLElBQUksR0FBRzdDO2dCQUNiLE1BQU15QztZQUNSO1lBRUEsT0FBTyxzQ0FBc0M7UUFDL0M7SUFDRixRQUFTakMsTUFBTUMsUUFBUUMsT0FBT0UsS0FBSztJQUVuQyx5RUFBeUUsR0FDekVjLE1BQU1QLFFBQVE7SUFDZFgsT0FBT2tCO0lBQ1BQLFFBQVFPLE9BQU87SUFDZlIsUUFBUSxDQUFDLEtBQUtDLElBQUcsSUFBSztJQUV0QiwyQkFBMkIsR0FDM0JkLEtBQUsyQixPQUFPLEdBQUd4QjtJQUNmSCxLQUFLNkIsUUFBUSxHQUFHeEI7SUFDaEJMLEtBQUs0QixRQUFRLEdBQUl6QixNQUFNQyxPQUFPLElBQUtBLENBQUFBLE9BQU9ELEdBQUUsSUFBSyxJQUFLQSxDQUFBQSxNQUFNQyxJQUFHO0lBQy9ESixLQUFLOEIsU0FBUyxHQUFJekIsT0FBT0UsTUFBTSxNQUFPQSxDQUFBQSxNQUFNRixJQUFHLElBQUssTUFBT0EsQ0FBQUEsT0FBT0UsR0FBRTtJQUNwRUwsTUFBTVcsSUFBSSxHQUFHQTtJQUNiWCxNQUFNWSxJQUFJLEdBQUdBO0lBQ2I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcz84ZWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcbiJdLCJuYW1lcyI6WyJCQUQiLCJUWVBFIiwibW9kdWxlIiwiZXhwb3J0cyIsImluZmxhdGVfZmFzdCIsInN0cm0iLCJzdGFydCIsInN0YXRlIiwiX2luIiwibGFzdCIsIl9vdXQiLCJiZWciLCJlbmQiLCJkbWF4Iiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwic193aW5kb3ciLCJob2xkIiwiYml0cyIsImxjb2RlIiwiZGNvZGUiLCJsbWFzayIsImRtYXNrIiwiaGVyZSIsIm9wIiwibGVuIiwiZGlzdCIsImZyb20iLCJmcm9tX3NvdXJjZSIsImlucHV0Iiwib3V0cHV0IiwibmV4dF9pbiIsImF2YWlsX2luIiwibmV4dF9vdXQiLCJhdmFpbF9vdXQiLCJ3aW5kb3ciLCJsZW5jb2RlIiwiZGlzdGNvZGUiLCJsZW5iaXRzIiwiZGlzdGJpdHMiLCJ0b3AiLCJkb2xlbiIsImRvZGlzdCIsIm1zZyIsIm1vZGUiLCJzYW5lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/adler32.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast = __webpack_require__(/*! ./inffast */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js\");\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n/* Public constants ==========================================================*/ /* ===========================================================================*/ /* Allowed flush values; see deflate() and inflate() below for details */ //var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH = 4;\nvar Z_BLOCK = 5;\nvar Z_TREES = 6;\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */ var Z_OK = 0;\nvar Z_STREAM_END = 1;\nvar Z_NEED_DICT = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR = -2;\nvar Z_DATA_ERROR = -3;\nvar Z_MEM_ERROR = -4;\nvar Z_BUF_ERROR = -5;\n//var Z_VERSION_ERROR = -6;\n/* The deflate compression method */ var Z_DEFLATED = 8;\n/* STATES ====================================================================*/ /* ===========================================================================*/ var HEAD = 1; /* i: waiting for magic header */ \nvar FLAGS = 2; /* i: waiting for method and flags (gzip) */ \nvar TIME = 3; /* i: waiting for modification time (gzip) */ \nvar OS = 4; /* i: waiting for extra flags and operating system (gzip) */ \nvar EXLEN = 5; /* i: waiting for extra length (gzip) */ \nvar EXTRA = 6; /* i: waiting for extra bytes (gzip) */ \nvar NAME = 7; /* i: waiting for end of file name (gzip) */ \nvar COMMENT = 8; /* i: waiting for end of comment (gzip) */ \nvar HCRC = 9; /* i: waiting for header crc (gzip) */ \nvar DICTID = 10; /* i: waiting for dictionary check value */ \nvar DICT = 11; /* waiting for inflateSetDictionary() call */ \nvar TYPE = 12; /* i: waiting for type bits, including last-flag bit */ \nvar TYPEDO = 13; /* i: same, but skip check to exit inflate on new block */ \nvar STORED = 14; /* i: waiting for stored size (length and complement) */ \nvar COPY_ = 15; /* i/o: same as COPY below, but only first time in */ \nvar COPY = 16; /* i/o: waiting for input or output to copy stored block */ \nvar TABLE = 17; /* i: waiting for dynamic block table lengths */ \nvar LENLENS = 18; /* i: waiting for code length code lengths */ \nvar CODELENS = 19; /* i: waiting for length/lit and distance code lengths */ \nvar LEN_ = 20; /* i: same as LEN below, but only first time in */ \nvar LEN = 21; /* i: waiting for length/lit/eob code */ \nvar LENEXT = 22; /* i: waiting for length extra bits */ \nvar DIST = 23; /* i: waiting for distance code */ \nvar DISTEXT = 24; /* i: waiting for distance extra bits */ \nvar MATCH = 25; /* o: waiting for output space to copy string */ \nvar LIT = 26; /* o: waiting for output space to write literal */ \nvar CHECK = 27; /* i: waiting for 32-bit check value */ \nvar LENGTH = 28; /* i: waiting for 32-bit length (gzip) */ \nvar DONE = 29; /* finished check, done -- remain here until reset */ \nvar BAD = 30; /* got a data error -- remain here until reset */ \nvar MEM = 31; /* got an inflate() memory error -- remain here until reset */ \nvar SYNC = 32; /* looking for synchronization bytes to restart inflate() */ \n/* ===========================================================================*/ var ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */ var DEF_WBITS = MAX_WBITS;\nfunction zswap32(q) {\n    return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);\n}\nfunction InflateState() {\n    this.mode = 0; /* current inflate mode */ \n    this.last = false; /* true if processing last block */ \n    this.wrap = 0; /* bit 0 true for zlib, bit 1 true for gzip */ \n    this.havedict = false; /* true if dictionary provided */ \n    this.flags = 0; /* gzip header method and flags (0 if zlib) */ \n    this.dmax = 0; /* zlib header max distance (INFLATE_STRICT) */ \n    this.check = 0; /* protected copy of check value */ \n    this.total = 0; /* protected copy of output count */ \n    // TODO: may be {}\n    this.head = null; /* where to save gzip header information */ \n    /* sliding window */ this.wbits = 0; /* log base 2 of requested window size */ \n    this.wsize = 0; /* window size or zero if not using window */ \n    this.whave = 0; /* valid bytes in the window */ \n    this.wnext = 0; /* window write index */ \n    this.window = null; /* allocated sliding window, if needed */ \n    /* bit accumulator */ this.hold = 0; /* input bit accumulator */ \n    this.bits = 0; /* number of bits in \"in\" */ \n    /* for string and stored block copying */ this.length = 0; /* literal or length of data to copy */ \n    this.offset = 0; /* distance back to copy string from */ \n    /* for table and code decoding */ this.extra = 0; /* extra bits needed */ \n    /* fixed and dynamic code tables */ this.lencode = null; /* starting table for length/literal codes */ \n    this.distcode = null; /* starting table for distance codes */ \n    this.lenbits = 0; /* index bits for lencode */ \n    this.distbits = 0; /* index bits for distcode */ \n    /* dynamic table building */ this.ncode = 0; /* number of code length code lengths */ \n    this.nlen = 0; /* number of length code lengths */ \n    this.ndist = 0; /* number of distance code lengths */ \n    this.have = 0; /* number of code lengths in lens[] */ \n    this.next = null; /* next available space in codes[] */ \n    this.lens = new utils.Buf16(320); /* temporary storage for code lengths */ \n    this.work = new utils.Buf16(288); /* work area for code table building */ \n    /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */ //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n    this.lendyn = null; /* dynamic table for length/literal codes (JS specific) */ \n    this.distdyn = null; /* dynamic table for distance codes (JS specific) */ \n    this.sane = 0; /* if false, allow invalid distance too far */ \n    this.back = 0; /* bits back of last unprocessed length/lit */ \n    this.was = 0; /* initial length of match */ \n}\nfunction inflateResetKeep(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    strm.total_in = strm.total_out = state.total = 0;\n    strm.msg = \"\"; /*Z_NULL*/ \n    if (state.wrap) {\n        strm.adler = state.wrap & 1;\n    }\n    state.mode = HEAD;\n    state.last = 0;\n    state.havedict = 0;\n    state.dmax = 32768;\n    state.head = null /*Z_NULL*/ ;\n    state.hold = 0;\n    state.bits = 0;\n    //state.lencode = state.distcode = state.next = state.codes;\n    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n    state.sane = 1;\n    state.back = -1;\n    //Tracev((stderr, \"inflate: reset\\n\"));\n    return Z_OK;\n}\nfunction inflateReset(strm) {\n    var state;\n    if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    state.wsize = 0;\n    state.whave = 0;\n    state.wnext = 0;\n    return inflateResetKeep(strm);\n}\nfunction inflateReset2(strm, windowBits) {\n    var wrap;\n    var state;\n    /* get the state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    /* extract wrap request from windowBits parameter */ if (windowBits < 0) {\n        wrap = 0;\n        windowBits = -windowBits;\n    } else {\n        wrap = (windowBits >> 4) + 1;\n        if (windowBits < 48) {\n            windowBits &= 15;\n        }\n    }\n    /* set number of window bits, free window if different */ if (windowBits && (windowBits < 8 || windowBits > 15)) {\n        return Z_STREAM_ERROR;\n    }\n    if (state.window !== null && state.wbits !== windowBits) {\n        state.window = null;\n    }\n    /* update state and reset the rest of it */ state.wrap = wrap;\n    state.wbits = windowBits;\n    return inflateReset(strm);\n}\nfunction inflateInit2(strm, windowBits) {\n    var ret;\n    var state;\n    if (!strm) {\n        return Z_STREAM_ERROR;\n    }\n    //strm.msg = Z_NULL;                 /* in case we return an error */\n    state = new InflateState();\n    //if (state === Z_NULL) return Z_MEM_ERROR;\n    //Tracev((stderr, \"inflate: allocated\\n\"));\n    strm.state = state;\n    state.window = null /*Z_NULL*/ ;\n    ret = inflateReset2(strm, windowBits);\n    if (ret !== Z_OK) {\n        strm.state = null /*Z_NULL*/ ;\n    }\n    return ret;\n}\nfunction inflateInit(strm) {\n    return inflateInit2(strm, DEF_WBITS);\n}\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */ var virgin = true;\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\nfunction fixedtables(state) {\n    /* build fixed huffman tables if first call (may not be thread safe) */ if (virgin) {\n        var sym;\n        lenfix = new utils.Buf32(512);\n        distfix = new utils.Buf32(32);\n        /* literal/length table */ sym = 0;\n        while(sym < 144){\n            state.lens[sym++] = 8;\n        }\n        while(sym < 256){\n            state.lens[sym++] = 9;\n        }\n        while(sym < 280){\n            state.lens[sym++] = 7;\n        }\n        while(sym < 288){\n            state.lens[sym++] = 8;\n        }\n        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n            bits: 9\n        });\n        /* distance table */ sym = 0;\n        while(sym < 32){\n            state.lens[sym++] = 5;\n        }\n        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n            bits: 5\n        });\n        /* do this just once */ virgin = false;\n    }\n    state.lencode = lenfix;\n    state.lenbits = 9;\n    state.distcode = distfix;\n    state.distbits = 5;\n}\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */ function updatewindow(strm, src, end, copy) {\n    var dist;\n    var state = strm.state;\n    /* if it hasn't been done already, allocate space for the window */ if (state.window === null) {\n        state.wsize = 1 << state.wbits;\n        state.wnext = 0;\n        state.whave = 0;\n        state.window = new utils.Buf8(state.wsize);\n    }\n    /* copy state->wsize or less output bytes into the circular window */ if (copy >= state.wsize) {\n        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n        state.wnext = 0;\n        state.whave = state.wsize;\n    } else {\n        dist = state.wsize - state.wnext;\n        if (dist > copy) {\n            dist = copy;\n        }\n        //zmemcpy(state->window + state->wnext, end - copy, dist);\n        utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n        copy -= dist;\n        if (copy) {\n            //zmemcpy(state->window, end - copy, copy);\n            utils.arraySet(state.window, src, end - copy, copy, 0);\n            state.wnext = copy;\n            state.whave = state.wsize;\n        } else {\n            state.wnext += dist;\n            if (state.wnext === state.wsize) {\n                state.wnext = 0;\n            }\n            if (state.whave < state.wsize) {\n                state.whave += dist;\n            }\n        }\n    }\n    return 0;\n}\nfunction inflate(strm, flush) {\n    var state;\n    var input, output; // input/output buffers\n    var next; /* next input INDEX */ \n    var put; /* next output INDEX */ \n    var have, left; /* available input and output */ \n    var hold; /* bit buffer */ \n    var bits; /* bits in bit buffer */ \n    var _in, _out; /* save starting available input and output */ \n    var copy; /* number of stored or match bytes to copy */ \n    var from; /* where to copy match bytes from */ \n    var from_source;\n    var here = 0; /* current decoding table entry */ \n    var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n    //var last;                   /* parent table entry */\n    var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n    var len; /* length to copy for repeats, bits to drop */ \n    var ret; /* return code */ \n    var hbuf = new utils.Buf8(4); /* buffer for gzip header crc calculation */ \n    var opts;\n    var n; // temporary var for NEED_BITS\n    var order = /* permutation of code lengths */ [\n        16,\n        17,\n        18,\n        0,\n        8,\n        7,\n        9,\n        6,\n        10,\n        5,\n        11,\n        4,\n        12,\n        3,\n        13,\n        2,\n        14,\n        1,\n        15\n    ];\n    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.mode === TYPE) {\n        state.mode = TYPEDO;\n    } /* skip check */ \n    //--- LOAD() ---\n    put = strm.next_out;\n    output = strm.output;\n    left = strm.avail_out;\n    next = strm.next_in;\n    input = strm.input;\n    have = strm.avail_in;\n    hold = state.hold;\n    bits = state.bits;\n    //---\n    _in = have;\n    _out = left;\n    ret = Z_OK;\n    inf_leave: for(;;){\n        switch(state.mode){\n            case HEAD:\n                if (state.wrap === 0) {\n                    state.mode = TYPEDO;\n                    break;\n                }\n                //=== NEEDBITS(16);\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.wrap & 2 && hold === 0x8b1f) {\n                    state.check = 0 /*crc32(0L, Z_NULL, 0)*/ ;\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                    //===//\n                    state.mode = FLAGS;\n                    break;\n                }\n                state.flags = 0; /* expect zlib header */ \n                if (state.head) {\n                    state.head.done = false;\n                }\n                if (!(state.wrap & 1) || /* check if zlib header allowed */ (((hold & 0xff) << 8) + (hold >> 8)) % 31) {\n                    strm.msg = \"incorrect header check\";\n                    state.mode = BAD;\n                    break;\n                }\n                if ((hold & 0x0f) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                len = (hold & 0x0f) + 8;\n                if (state.wbits === 0) {\n                    state.wbits = len;\n                } else if (len > state.wbits) {\n                    strm.msg = \"invalid window size\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.dmax = 1 << len;\n                //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = hold & 0x200 ? DICTID : TYPE;\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                break;\n            case FLAGS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.flags = hold;\n                if ((state.flags & 0xff) !== Z_DEFLATED) {\n                    strm.msg = \"unknown compression method\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.flags & 0xe000) {\n                    strm.msg = \"unknown header flags set\";\n                    state.mode = BAD;\n                    break;\n                }\n                if (state.head) {\n                    state.head.text = hold >> 8 & 1;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = TIME;\n            /* falls through */ case TIME:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.time = hold;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC4(state.check, hold)\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    hbuf[2] = hold >>> 16 & 0xff;\n                    hbuf[3] = hold >>> 24 & 0xff;\n                    state.check = crc32(state.check, hbuf, 4, 0);\n                //===\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = OS;\n            /* falls through */ case OS:\n                //=== NEEDBITS(16); */\n                while(bits < 16){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if (state.head) {\n                    state.head.xflags = hold & 0xff;\n                    state.head.os = hold >> 8;\n                }\n                if (state.flags & 0x0200) {\n                    //=== CRC2(state.check, hold);\n                    hbuf[0] = hold & 0xff;\n                    hbuf[1] = hold >>> 8 & 0xff;\n                    state.check = crc32(state.check, hbuf, 2, 0);\n                //===//\n                }\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = EXLEN;\n            /* falls through */ case EXLEN:\n                if (state.flags & 0x0400) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length = hold;\n                    if (state.head) {\n                        state.head.extra_len = hold;\n                    }\n                    if (state.flags & 0x0200) {\n                        //=== CRC2(state.check, hold);\n                        hbuf[0] = hold & 0xff;\n                        hbuf[1] = hold >>> 8 & 0xff;\n                        state.check = crc32(state.check, hbuf, 2, 0);\n                    //===//\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                } else if (state.head) {\n                    state.head.extra = null /*Z_NULL*/ ;\n                }\n                state.mode = EXTRA;\n            /* falls through */ case EXTRA:\n                if (state.flags & 0x0400) {\n                    copy = state.length;\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy) {\n                        if (state.head) {\n                            len = state.head.extra_len - state.length;\n                            if (!state.head.extra) {\n                                // Use untyped array for more convenient processing later\n                                state.head.extra = new Array(state.head.extra_len);\n                            }\n                            utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes\n                            // - no need for additional size check\n                            copy, /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/ len);\n                        //zmemcpy(state.head.extra + len, next,\n                        //        len + copy > state.head.extra_max ?\n                        //        state.head.extra_max - len : copy);\n                        }\n                        if (state.flags & 0x0200) {\n                            state.check = crc32(state.check, input, copy, next);\n                        }\n                        have -= copy;\n                        next += copy;\n                        state.length -= copy;\n                    }\n                    if (state.length) {\n                        break inf_leave;\n                    }\n                }\n                state.length = 0;\n                state.mode = NAME;\n            /* falls through */ case NAME:\n                if (state.flags & 0x0800) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        // TODO: 2 or 1 bytes?\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.name_max*/ ) {\n                            state.head.name += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.name = null;\n                }\n                state.length = 0;\n                state.mode = COMMENT;\n            /* falls through */ case COMMENT:\n                if (state.flags & 0x1000) {\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    copy = 0;\n                    do {\n                        len = input[next + copy++];\n                        /* use constant limit because in js we should not preallocate memory */ if (state.head && len && state.length < 65536 /*state.head.comm_max*/ ) {\n                            state.head.comment += String.fromCharCode(len);\n                        }\n                    }while (len && copy < have);\n                    if (state.flags & 0x0200) {\n                        state.check = crc32(state.check, input, copy, next);\n                    }\n                    have -= copy;\n                    next += copy;\n                    if (len) {\n                        break inf_leave;\n                    }\n                } else if (state.head) {\n                    state.head.comment = null;\n                }\n                state.mode = HCRC;\n            /* falls through */ case HCRC:\n                if (state.flags & 0x0200) {\n                    //=== NEEDBITS(16); */\n                    while(bits < 16){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.check & 0xffff)) {\n                        strm.msg = \"header crc mismatch\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                }\n                if (state.head) {\n                    state.head.hcrc = state.flags >> 9 & 1;\n                    state.head.done = true;\n                }\n                strm.adler = state.check = 0;\n                state.mode = TYPE;\n                break;\n            case DICTID:\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                strm.adler = state.check = zswap32(hold);\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = DICT;\n            /* falls through */ case DICT:\n                if (state.havedict === 0) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    return Z_NEED_DICT;\n                }\n                strm.adler = state.check = 1 /*adler32(0L, Z_NULL, 0)*/ ;\n                state.mode = TYPE;\n            /* falls through */ case TYPE:\n                if (flush === Z_BLOCK || flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case TYPEDO:\n                if (state.last) {\n                    //--- BYTEBITS() ---//\n                    hold >>>= bits & 7;\n                    bits -= bits & 7;\n                    //---//\n                    state.mode = CHECK;\n                    break;\n                }\n                //=== NEEDBITS(3); */\n                while(bits < 3){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.last = hold & 0x01 /*BITS(1)*/ ;\n                //--- DROPBITS(1) ---//\n                hold >>>= 1;\n                bits -= 1;\n                //---//\n                switch(hold & 0x03){\n                    case 0:\n                        /* stored block */ //Tracev((stderr, \"inflate:     stored block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = STORED;\n                        break;\n                    case 1:\n                        /* fixed block */ fixedtables(state);\n                        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = LEN_; /* decode codes */ \n                        if (flush === Z_TREES) {\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                            break inf_leave;\n                        }\n                        break;\n                    case 2:\n                        /* dynamic block */ //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n                        //        state.last ? \" (last)\" : \"\"));\n                        state.mode = TABLE;\n                        break;\n                    case 3:\n                        strm.msg = \"invalid block type\";\n                        state.mode = BAD;\n                }\n                //--- DROPBITS(2) ---//\n                hold >>>= 2;\n                bits -= 2;\n                break;\n            case STORED:\n                //--- BYTEBITS() ---// /* go to byte boundary */\n                hold >>>= bits & 7;\n                bits -= bits & 7;\n                //---//\n                //=== NEEDBITS(32); */\n                while(bits < 32){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {\n                    strm.msg = \"invalid stored block lengths\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.length = hold & 0xffff;\n                //Tracev((stderr, \"inflate:       stored length %u\\n\",\n                //        state.length));\n                //=== INITBITS();\n                hold = 0;\n                bits = 0;\n                //===//\n                state.mode = COPY_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case COPY_:\n                state.mode = COPY;\n            /* falls through */ case COPY:\n                copy = state.length;\n                if (copy) {\n                    if (copy > have) {\n                        copy = have;\n                    }\n                    if (copy > left) {\n                        copy = left;\n                    }\n                    if (copy === 0) {\n                        break inf_leave;\n                    }\n                    //--- zmemcpy(put, next, copy); ---\n                    utils.arraySet(output, input, next, copy, put);\n                    //---//\n                    have -= copy;\n                    next += copy;\n                    left -= copy;\n                    put += copy;\n                    state.length -= copy;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       stored end\\n\"));\n                state.mode = TYPE;\n                break;\n            case TABLE:\n                //=== NEEDBITS(14); */\n                while(bits < 14){\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                }\n                //===//\n                state.nlen = (hold & 0x1f) + 257;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ndist = (hold & 0x1f) + 1;\n                //--- DROPBITS(5) ---//\n                hold >>>= 5;\n                bits -= 5;\n                //---//\n                state.ncode = (hold & 0x0f) + 4;\n                //--- DROPBITS(4) ---//\n                hold >>>= 4;\n                bits -= 4;\n                //---//\n                //#ifndef PKZIP_BUG_WORKAROUND\n                if (state.nlen > 286 || state.ndist > 30) {\n                    strm.msg = \"too many length or distance symbols\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n                state.have = 0;\n                state.mode = LENLENS;\n            /* falls through */ case LENLENS:\n                while(state.have < state.ncode){\n                    //=== NEEDBITS(3);\n                    while(bits < 3){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.lens[order[state.have++]] = hold & 0x07; //BITS(3);\n                    //--- DROPBITS(3) ---//\n                    hold >>>= 3;\n                    bits -= 3;\n                //---//\n                }\n                while(state.have < 19){\n                    state.lens[order[state.have++]] = 0;\n                }\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                //state.next = state.codes;\n                //state.lencode = state.next;\n                // Switch to use dynamic table\n                state.lencode = state.lendyn;\n                state.lenbits = 7;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n                state.lenbits = opts.bits;\n                if (ret) {\n                    strm.msg = \"invalid code lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n                state.have = 0;\n                state.mode = CODELENS;\n            /* falls through */ case CODELENS:\n                while(state.have < state.nlen + state.ndist){\n                    for(;;){\n                        here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    if (here_val < 16) {\n                        //--- DROPBITS(here.bits) ---//\n                        hold >>>= here_bits;\n                        bits -= here_bits;\n                        //---//\n                        state.lens[state.have++] = here_val;\n                    } else {\n                        if (here_val === 16) {\n                            //=== NEEDBITS(here.bits + 2);\n                            n = here_bits + 2;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            if (state.have === 0) {\n                                strm.msg = \"invalid bit length repeat\";\n                                state.mode = BAD;\n                                break;\n                            }\n                            len = state.lens[state.have - 1];\n                            copy = 3 + (hold & 0x03); //BITS(2);\n                            //--- DROPBITS(2) ---//\n                            hold >>>= 2;\n                            bits -= 2;\n                        //---//\n                        } else if (here_val === 17) {\n                            //=== NEEDBITS(here.bits + 3);\n                            n = here_bits + 3;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 3 + (hold & 0x07); //BITS(3);\n                            //--- DROPBITS(3) ---//\n                            hold >>>= 3;\n                            bits -= 3;\n                        //---//\n                        } else {\n                            //=== NEEDBITS(here.bits + 7);\n                            n = here_bits + 7;\n                            while(bits < n){\n                                if (have === 0) {\n                                    break inf_leave;\n                                }\n                                have--;\n                                hold += input[next++] << bits;\n                                bits += 8;\n                            }\n                            //===//\n                            //--- DROPBITS(here.bits) ---//\n                            hold >>>= here_bits;\n                            bits -= here_bits;\n                            //---//\n                            len = 0;\n                            copy = 11 + (hold & 0x7f); //BITS(7);\n                            //--- DROPBITS(7) ---//\n                            hold >>>= 7;\n                            bits -= 7;\n                        //---//\n                        }\n                        if (state.have + copy > state.nlen + state.ndist) {\n                            strm.msg = \"invalid bit length repeat\";\n                            state.mode = BAD;\n                            break;\n                        }\n                        while(copy--){\n                            state.lens[state.have++] = len;\n                        }\n                    }\n                }\n                /* handle error breaks in while */ if (state.mode === BAD) {\n                    break;\n                }\n                /* check for end-of-block code (better have one) */ if (state.lens[256] === 0) {\n                    strm.msg = \"invalid code -- missing end-of-block\";\n                    state.mode = BAD;\n                    break;\n                }\n                /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */ state.lenbits = 9;\n                opts = {\n                    bits: state.lenbits\n                };\n                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.lenbits = opts.bits;\n                // state.lencode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid literal/lengths set\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.distbits = 6;\n                //state.distcode.copy(state.codes);\n                // Switch to use dynamic table\n                state.distcode = state.distdyn;\n                opts = {\n                    bits: state.distbits\n                };\n                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n                // We have separate tables & no pointers. 2 commented lines below not needed.\n                // state.next_index = opts.table_index;\n                state.distbits = opts.bits;\n                // state.distcode = state.next;\n                if (ret) {\n                    strm.msg = \"invalid distances set\";\n                    state.mode = BAD;\n                    break;\n                }\n                //Tracev((stderr, 'inflate:       codes ok\\n'));\n                state.mode = LEN_;\n                if (flush === Z_TREES) {\n                    break inf_leave;\n                }\n            /* falls through */ case LEN_:\n                state.mode = LEN;\n            /* falls through */ case LEN:\n                if (have >= 6 && left >= 258) {\n                    //--- RESTORE() ---\n                    strm.next_out = put;\n                    strm.avail_out = left;\n                    strm.next_in = next;\n                    strm.avail_in = have;\n                    state.hold = hold;\n                    state.bits = bits;\n                    //---\n                    inflate_fast(strm, _out);\n                    //--- LOAD() ---\n                    put = strm.next_out;\n                    output = strm.output;\n                    left = strm.avail_out;\n                    next = strm.next_in;\n                    input = strm.input;\n                    have = strm.avail_in;\n                    hold = state.hold;\n                    bits = state.bits;\n                    //---\n                    if (state.mode === TYPE) {\n                        state.back = -1;\n                    }\n                    break;\n                }\n                state.back = 0;\n                for(;;){\n                    here = state.lencode[hold & (1 << state.lenbits) - 1]; /*BITS(state.lenbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if (here_op && (here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                state.length = here_val;\n                if (here_op === 0) {\n                    //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n                    //        \"inflate:         literal '%c'\\n\" :\n                    //        \"inflate:         literal 0x%02x\\n\", here.val));\n                    state.mode = LIT;\n                    break;\n                }\n                if (here_op & 32) {\n                    //Tracevv((stderr, \"inflate:         end of block\\n\"));\n                    state.back = -1;\n                    state.mode = TYPE;\n                    break;\n                }\n                if (here_op & 64) {\n                    strm.msg = \"invalid literal/length code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.extra = here_op & 15;\n                state.mode = LENEXT;\n            /* falls through */ case LENEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.length += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n                state.was = state.length;\n                state.mode = DIST;\n            /* falls through */ case DIST:\n                for(;;){\n                    here = state.distcode[hold & (1 << state.distbits) - 1]; /*BITS(state.distbits)*/ \n                    here_bits = here >>> 24;\n                    here_op = here >>> 16 & 0xff;\n                    here_val = here & 0xffff;\n                    if (here_bits <= bits) {\n                        break;\n                    }\n                    //--- PULLBYTE() ---//\n                    if (have === 0) {\n                        break inf_leave;\n                    }\n                    have--;\n                    hold += input[next++] << bits;\n                    bits += 8;\n                //---//\n                }\n                if ((here_op & 0xf0) === 0) {\n                    last_bits = here_bits;\n                    last_op = here_op;\n                    last_val = here_val;\n                    for(;;){\n                        here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n                        here_bits = here >>> 24;\n                        here_op = here >>> 16 & 0xff;\n                        here_val = here & 0xffff;\n                        if (last_bits + here_bits <= bits) {\n                            break;\n                        }\n                        //--- PULLBYTE() ---//\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    //---//\n                    }\n                    //--- DROPBITS(last.bits) ---//\n                    hold >>>= last_bits;\n                    bits -= last_bits;\n                    //---//\n                    state.back += last_bits;\n                }\n                //--- DROPBITS(here.bits) ---//\n                hold >>>= here_bits;\n                bits -= here_bits;\n                //---//\n                state.back += here_bits;\n                if (here_op & 64) {\n                    strm.msg = \"invalid distance code\";\n                    state.mode = BAD;\n                    break;\n                }\n                state.offset = here_val;\n                state.extra = here_op & 15;\n                state.mode = DISTEXT;\n            /* falls through */ case DISTEXT:\n                if (state.extra) {\n                    //=== NEEDBITS(state.extra);\n                    n = state.extra;\n                    while(bits < n){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    state.offset += hold & (1 << state.extra) - 1 /*BITS(state.extra)*/ ;\n                    //--- DROPBITS(state.extra) ---//\n                    hold >>>= state.extra;\n                    bits -= state.extra;\n                    //---//\n                    state.back += state.extra;\n                }\n                //#ifdef INFLATE_STRICT\n                if (state.offset > state.dmax) {\n                    strm.msg = \"invalid distance too far back\";\n                    state.mode = BAD;\n                    break;\n                }\n                //#endif\n                //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n                state.mode = MATCH;\n            /* falls through */ case MATCH:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                copy = _out - left;\n                if (state.offset > copy) {\n                    copy = state.offset - copy;\n                    if (copy > state.whave) {\n                        if (state.sane) {\n                            strm.msg = \"invalid distance too far back\";\n                            state.mode = BAD;\n                            break;\n                        }\n                    // (!) This block is disabled in zlib defaults,\n                    // don't enable it for binary compatibility\n                    //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n                    //          Trace((stderr, \"inflate.c too far\\n\"));\n                    //          copy -= state.whave;\n                    //          if (copy > state.length) { copy = state.length; }\n                    //          if (copy > left) { copy = left; }\n                    //          left -= copy;\n                    //          state.length -= copy;\n                    //          do {\n                    //            output[put++] = 0;\n                    //          } while (--copy);\n                    //          if (state.length === 0) { state.mode = LEN; }\n                    //          break;\n                    //#endif\n                    }\n                    if (copy > state.wnext) {\n                        copy -= state.wnext;\n                        from = state.wsize - copy;\n                    } else {\n                        from = state.wnext - copy;\n                    }\n                    if (copy > state.length) {\n                        copy = state.length;\n                    }\n                    from_source = state.window;\n                } else {\n                    from_source = output;\n                    from = put - state.offset;\n                    copy = state.length;\n                }\n                if (copy > left) {\n                    copy = left;\n                }\n                left -= copy;\n                state.length -= copy;\n                do {\n                    output[put++] = from_source[from++];\n                }while (--copy);\n                if (state.length === 0) {\n                    state.mode = LEN;\n                }\n                break;\n            case LIT:\n                if (left === 0) {\n                    break inf_leave;\n                }\n                output[put++] = state.length;\n                left--;\n                state.mode = LEN;\n                break;\n            case CHECK:\n                if (state.wrap) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        // Use '|' instead of '+' to make sure that result is signed\n                        hold |= input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    _out -= left;\n                    strm.total_out += _out;\n                    state.total += _out;\n                    if (_out) {\n                        strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/ state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n                    }\n                    _out = left;\n                    // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n                        strm.msg = \"incorrect data check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n                }\n                state.mode = LENGTH;\n            /* falls through */ case LENGTH:\n                if (state.wrap && state.flags) {\n                    //=== NEEDBITS(32);\n                    while(bits < 32){\n                        if (have === 0) {\n                            break inf_leave;\n                        }\n                        have--;\n                        hold += input[next++] << bits;\n                        bits += 8;\n                    }\n                    //===//\n                    if (hold !== (state.total & 0xffffffff)) {\n                        strm.msg = \"incorrect length check\";\n                        state.mode = BAD;\n                        break;\n                    }\n                    //=== INITBITS();\n                    hold = 0;\n                    bits = 0;\n                //===//\n                //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n                }\n                state.mode = DONE;\n            /* falls through */ case DONE:\n                ret = Z_STREAM_END;\n                break inf_leave;\n            case BAD:\n                ret = Z_DATA_ERROR;\n                break inf_leave;\n            case MEM:\n                return Z_MEM_ERROR;\n            case SYNC:\n            /* falls through */ default:\n                return Z_STREAM_ERROR;\n        }\n    }\n    // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n    /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */ //--- RESTORE() ---\n    strm.next_out = put;\n    strm.avail_out = left;\n    strm.next_in = next;\n    strm.avail_in = have;\n    state.hold = hold;\n    state.bits = bits;\n    //---\n    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {\n        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n            state.mode = MEM;\n            return Z_MEM_ERROR;\n        }\n    }\n    _in -= strm.avail_in;\n    _out -= strm.avail_out;\n    strm.total_in += _in;\n    strm.total_out += _out;\n    state.total += _out;\n    if (state.wrap && _out) {\n        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/ state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n    }\n    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {\n        ret = Z_BUF_ERROR;\n    }\n    return ret;\n}\nfunction inflateEnd(strm) {\n    if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/ ) {\n        return Z_STREAM_ERROR;\n    }\n    var state = strm.state;\n    if (state.window) {\n        state.window = null;\n    }\n    strm.state = null;\n    return Z_OK;\n}\nfunction inflateGetHeader(strm, head) {\n    var state;\n    /* check state */ if (!strm || !strm.state) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if ((state.wrap & 2) === 0) {\n        return Z_STREAM_ERROR;\n    }\n    /* save header structure */ state.head = head;\n    head.done = false;\n    return Z_OK;\n}\nfunction inflateSetDictionary(strm, dictionary) {\n    var dictLength = dictionary.length;\n    var state;\n    var dictid;\n    var ret;\n    /* check state */ if (!strm /* == Z_NULL */  || !strm.state /* == Z_NULL */ ) {\n        return Z_STREAM_ERROR;\n    }\n    state = strm.state;\n    if (state.wrap !== 0 && state.mode !== DICT) {\n        return Z_STREAM_ERROR;\n    }\n    /* check for correct dictionary identifier */ if (state.mode === DICT) {\n        dictid = 1; /* adler32(0, null, 0)*/ \n        /* dictid = adler32(dictid, dictionary, dictLength); */ dictid = adler32(dictid, dictionary, dictLength, 0);\n        if (dictid !== state.check) {\n            return Z_DATA_ERROR;\n        }\n    }\n    /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */ ret = updatewindow(strm, dictionary, dictLength, dictLength);\n    if (ret) {\n        state.mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state.havedict = 1;\n    // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = \"pako inflate (from Nodeca project)\"; /* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsSUFBSUEsUUFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLFVBQWdCRCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJRSxRQUFnQkYsbUJBQU9BLENBQUM7QUFDNUIsSUFBSUcsZUFBZ0JILG1CQUFPQSxDQUFDO0FBQzVCLElBQUlJLGdCQUFnQkosbUJBQU9BLENBQUM7QUFFNUIsSUFBSUssUUFBUTtBQUNaLElBQUlDLE9BQU87QUFDWCxJQUFJQyxRQUFRO0FBRVosOEVBQThFLEdBQzlFLDhFQUE4RSxHQUc5RSx1RUFBdUUsR0FDdkUsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLElBQUlDLFdBQWtCO0FBQ3RCLElBQUlDLFVBQWtCO0FBQ3RCLElBQUlDLFVBQWtCO0FBR3RCOztDQUVDLEdBQ0QsSUFBSUMsT0FBa0I7QUFDdEIsSUFBSUMsZUFBa0I7QUFDdEIsSUFBSUMsY0FBa0I7QUFDdEIsMkJBQTJCO0FBQzNCLElBQUlDLGlCQUFrQixDQUFDO0FBQ3ZCLElBQUlDLGVBQWtCLENBQUM7QUFDdkIsSUFBSUMsY0FBa0IsQ0FBQztBQUN2QixJQUFJQyxjQUFrQixDQUFDO0FBQ3ZCLDJCQUEyQjtBQUUzQixrQ0FBa0MsR0FDbEMsSUFBSUMsYUFBYztBQUdsQiw4RUFBOEUsR0FDOUUsOEVBQThFLEdBRzlFLElBQU9DLE9BQU8sR0FBUywrQkFBK0I7QUFDdEQsSUFBT0MsUUFBUSxHQUFRLDBDQUEwQztBQUNqRSxJQUFPQyxPQUFPLEdBQVMsMkNBQTJDO0FBQ2xFLElBQU9DLEtBQUssR0FBVywwREFBMEQ7QUFDakYsSUFBT0MsUUFBUSxHQUFRLHNDQUFzQztBQUM3RCxJQUFPQyxRQUFRLEdBQVEscUNBQXFDO0FBQzVELElBQU9DLE9BQU8sR0FBUywwQ0FBMEM7QUFDakUsSUFBT0MsVUFBVSxHQUFNLHdDQUF3QztBQUMvRCxJQUFPQyxPQUFPLEdBQVMsb0NBQW9DO0FBQzNELElBQU9DLFNBQVMsSUFBTyx5Q0FBeUM7QUFDaEUsSUFBT0MsT0FBTyxJQUFTLDJDQUEyQztBQUNsRSxJQUFXQyxPQUFPLElBQVMscURBQXFEO0FBQ2hGLElBQVdDLFNBQVMsSUFBTyx3REFBd0Q7QUFDbkYsSUFBV0MsU0FBUyxJQUFPLHNEQUFzRDtBQUNqRixJQUFXQyxRQUFRLElBQVEsbURBQW1EO0FBQzlFLElBQVdDLE9BQU8sSUFBUyx5REFBeUQ7QUFDcEYsSUFBV0MsUUFBUSxJQUFRLDhDQUE4QztBQUN6RSxJQUFXQyxVQUFVLElBQU0sMkNBQTJDO0FBQ3RFLElBQVdDLFdBQVcsSUFBSyx1REFBdUQ7QUFDbEYsSUFBZUMsT0FBTyxJQUFTLGdEQUFnRDtBQUMvRSxJQUFlQyxNQUFNLElBQVUsc0NBQXNDO0FBQ3JFLElBQWVDLFNBQVMsSUFBTyxvQ0FBb0M7QUFDbkUsSUFBZUMsT0FBTyxJQUFTLGdDQUFnQztBQUMvRCxJQUFlQyxVQUFVLElBQU0sc0NBQXNDO0FBQ3JFLElBQWVDLFFBQVEsSUFBUSw4Q0FBOEM7QUFDN0UsSUFBZUMsTUFBTSxJQUFVLGdEQUFnRDtBQUMvRSxJQUFPQyxRQUFRLElBQVEscUNBQXFDO0FBQzVELElBQU9DLFNBQVMsSUFBTyx1Q0FBdUM7QUFDOUQsSUFBT0MsT0FBTyxJQUFTLG1EQUFtRDtBQUMxRSxJQUFPQyxNQUFNLElBQVUsK0NBQStDO0FBQ3RFLElBQU9DLE1BQU0sSUFBVSw0REFBNEQ7QUFDbkYsSUFBT0MsT0FBTyxJQUFTLDBEQUEwRDtBQUVqRiw4RUFBOEUsR0FJOUUsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxlQUFlO0FBQ25CLDJDQUEyQztBQUUzQyxJQUFJQyxZQUFZO0FBQ2hCLG1CQUFtQixHQUNuQixJQUFJQyxZQUFZRDtBQUdoQixTQUFTRSxRQUFRQyxDQUFDO0lBQ2hCLE9BQVMsQ0FBQyxNQUFPLEtBQU0sSUFBRyxJQUNqQixPQUFPLElBQUssTUFBSyxJQUNqQixFQUFDQSxJQUFJLE1BQUssS0FBTSxLQUNoQixFQUFDQSxJQUFJLElBQUcsS0FBTSxFQUFDO0FBQzFCO0FBR0EsU0FBU0M7SUFDUCxJQUFJLENBQUNDLElBQUksR0FBRyxHQUFlLHdCQUF3QjtJQUNuRCxJQUFJLENBQUNDLElBQUksR0FBRyxPQUFnQixpQ0FBaUM7SUFDN0QsSUFBSSxDQUFDQyxJQUFJLEdBQUcsR0FBZ0IsNENBQTRDO0lBQ3hFLElBQUksQ0FBQ0MsUUFBUSxHQUFHLE9BQVksK0JBQStCO0lBQzNELElBQUksQ0FBQ0MsS0FBSyxHQUFHLEdBQWUsNENBQTRDO0lBQ3hFLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEdBQWdCLDZDQUE2QztJQUN6RSxJQUFJLENBQUNDLEtBQUssR0FBRyxHQUFlLGlDQUFpQztJQUM3RCxJQUFJLENBQUNDLEtBQUssR0FBRyxHQUFlLGtDQUFrQztJQUM5RCxrQkFBa0I7SUFDbEIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsTUFBZ0IseUNBQXlDO0lBRXJFLGtCQUFrQixHQUNsQixJQUFJLENBQUNDLEtBQUssR0FBRyxHQUFlLHVDQUF1QztJQUNuRSxJQUFJLENBQUNDLEtBQUssR0FBRyxHQUFlLDJDQUEyQztJQUN2RSxJQUFJLENBQUNDLEtBQUssR0FBRyxHQUFlLDZCQUE2QjtJQUN6RCxJQUFJLENBQUNDLEtBQUssR0FBRyxHQUFlLHNCQUFzQjtJQUNsRCxJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFjLHVDQUF1QztJQUVuRSxtQkFBbUIsR0FDbkIsSUFBSSxDQUFDQyxJQUFJLEdBQUcsR0FBZ0IseUJBQXlCO0lBQ3JELElBQUksQ0FBQ0MsSUFBSSxHQUFHLEdBQWdCLDBCQUEwQjtJQUV0RCx1Q0FBdUMsR0FDdkMsSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBYyxxQ0FBcUM7SUFDakUsSUFBSSxDQUFDQyxNQUFNLEdBQUcsR0FBYyxxQ0FBcUM7SUFFakUsK0JBQStCLEdBQy9CLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEdBQWUscUJBQXFCO0lBRWpELGlDQUFpQyxHQUNqQyxJQUFJLENBQUNDLE9BQU8sR0FBRyxNQUFlLDJDQUEyQztJQUN6RSxJQUFJLENBQUNDLFFBQVEsR0FBRyxNQUFjLHFDQUFxQztJQUNuRSxJQUFJLENBQUNDLE9BQU8sR0FBRyxHQUFhLDBCQUEwQjtJQUN0RCxJQUFJLENBQUNDLFFBQVEsR0FBRyxHQUFZLDJCQUEyQjtJQUV2RCwwQkFBMEIsR0FDMUIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsR0FBZSxzQ0FBc0M7SUFDbEUsSUFBSSxDQUFDQyxJQUFJLEdBQUcsR0FBZ0IsaUNBQWlDO0lBQzdELElBQUksQ0FBQ0MsS0FBSyxHQUFHLEdBQWUsbUNBQW1DO0lBQy9ELElBQUksQ0FBQ0MsSUFBSSxHQUFHLEdBQWdCLG9DQUFvQztJQUNoRSxJQUFJLENBQUNDLElBQUksR0FBRyxNQUFtQixtQ0FBbUM7SUFFbEUsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSXZGLE1BQU13RixLQUFLLENBQUMsTUFBTSxzQ0FBc0M7SUFDeEUsSUFBSSxDQUFDQyxJQUFJLEdBQUcsSUFBSXpGLE1BQU13RixLQUFLLENBQUMsTUFBTSxxQ0FBcUM7SUFFdkU7OztFQUdBLEdBQ0EseUVBQXlFO0lBQ3pFLElBQUksQ0FBQ0UsTUFBTSxHQUFHLE1BQW1CLHdEQUF3RDtJQUN6RixJQUFJLENBQUNDLE9BQU8sR0FBRyxNQUFrQixrREFBa0Q7SUFDbkYsSUFBSSxDQUFDQyxJQUFJLEdBQUcsR0FBcUIsNENBQTRDO0lBQzdFLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEdBQXFCLDRDQUE0QztJQUM3RSxJQUFJLENBQUNDLEdBQUcsR0FBRyxHQUFzQiwyQkFBMkI7QUFDOUQ7QUFFQSxTQUFTQyxpQkFBaUJDLElBQUk7SUFDNUIsSUFBSUM7SUFFSixJQUFJLENBQUNELFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxFQUFFO1FBQUUsT0FBT2xGO0lBQWdCO0lBQ25Ea0YsUUFBUUQsS0FBS0MsS0FBSztJQUNsQkQsS0FBS0UsUUFBUSxHQUFHRixLQUFLRyxTQUFTLEdBQUdGLE1BQU0vQixLQUFLLEdBQUc7SUFDL0M4QixLQUFLSSxHQUFHLEdBQUcsSUFBSSxRQUFRO0lBQ3ZCLElBQUlILE1BQU1wQyxJQUFJLEVBQUU7UUFDZG1DLEtBQUtLLEtBQUssR0FBR0osTUFBTXBDLElBQUksR0FBRztJQUM1QjtJQUNBb0MsTUFBTXRDLElBQUksR0FBR3ZDO0lBQ2I2RSxNQUFNckMsSUFBSSxHQUFHO0lBQ2JxQyxNQUFNbkMsUUFBUSxHQUFHO0lBQ2pCbUMsTUFBTWpDLElBQUksR0FBRztJQUNiaUMsTUFBTTlCLElBQUksR0FBRyxLQUFJLFFBQVE7SUFDekI4QixNQUFNeEIsSUFBSSxHQUFHO0lBQ2J3QixNQUFNdkIsSUFBSSxHQUFHO0lBQ2IsNERBQTREO0lBQzVEdUIsTUFBTW5CLE9BQU8sR0FBR21CLE1BQU1QLE1BQU0sR0FBRyxJQUFJMUYsTUFBTXNHLEtBQUssQ0FBQ2xEO0lBQy9DNkMsTUFBTWxCLFFBQVEsR0FBR2tCLE1BQU1OLE9BQU8sR0FBRyxJQUFJM0YsTUFBTXNHLEtBQUssQ0FBQ2pEO0lBRWpENEMsTUFBTUwsSUFBSSxHQUFHO0lBQ2JLLE1BQU1KLElBQUksR0FBRyxDQUFDO0lBQ2QsdUNBQXVDO0lBQ3ZDLE9BQU9qRjtBQUNUO0FBRUEsU0FBUzJGLGFBQWFQLElBQUk7SUFDeEIsSUFBSUM7SUFFSixJQUFJLENBQUNELFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxFQUFFO1FBQUUsT0FBT2xGO0lBQWdCO0lBQ25Ea0YsUUFBUUQsS0FBS0MsS0FBSztJQUNsQkEsTUFBTTVCLEtBQUssR0FBRztJQUNkNEIsTUFBTTNCLEtBQUssR0FBRztJQUNkMkIsTUFBTTFCLEtBQUssR0FBRztJQUNkLE9BQU93QixpQkFBaUJDO0FBRTFCO0FBRUEsU0FBU1EsY0FBY1IsSUFBSSxFQUFFUyxVQUFVO0lBQ3JDLElBQUk1QztJQUNKLElBQUlvQztJQUVKLGlCQUFpQixHQUNqQixJQUFJLENBQUNELFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxFQUFFO1FBQUUsT0FBT2xGO0lBQWdCO0lBQ25Ea0YsUUFBUUQsS0FBS0MsS0FBSztJQUVsQixrREFBa0QsR0FDbEQsSUFBSVEsYUFBYSxHQUFHO1FBQ2xCNUMsT0FBTztRQUNQNEMsYUFBYSxDQUFDQTtJQUNoQixPQUNLO1FBQ0g1QyxPQUFPLENBQUM0QyxjQUFjLEtBQUs7UUFDM0IsSUFBSUEsYUFBYSxJQUFJO1lBQ25CQSxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSx1REFBdUQsR0FDdkQsSUFBSUEsY0FBZUEsQ0FBQUEsYUFBYSxLQUFLQSxhQUFhLEVBQUMsR0FBSTtRQUNyRCxPQUFPMUY7SUFDVDtJQUNBLElBQUlrRixNQUFNekIsTUFBTSxLQUFLLFFBQVF5QixNQUFNN0IsS0FBSyxLQUFLcUMsWUFBWTtRQUN2RFIsTUFBTXpCLE1BQU0sR0FBRztJQUNqQjtJQUVBLHlDQUF5QyxHQUN6Q3lCLE1BQU1wQyxJQUFJLEdBQUdBO0lBQ2JvQyxNQUFNN0IsS0FBSyxHQUFHcUM7SUFDZCxPQUFPRixhQUFhUDtBQUN0QjtBQUVBLFNBQVNVLGFBQWFWLElBQUksRUFBRVMsVUFBVTtJQUNwQyxJQUFJRTtJQUNKLElBQUlWO0lBRUosSUFBSSxDQUFDRCxNQUFNO1FBQUUsT0FBT2pGO0lBQWdCO0lBQ3BDLHFFQUFxRTtJQUVyRWtGLFFBQVEsSUFBSXZDO0lBRVosMkNBQTJDO0lBQzNDLDJDQUEyQztJQUMzQ3NDLEtBQUtDLEtBQUssR0FBR0E7SUFDYkEsTUFBTXpCLE1BQU0sR0FBRyxLQUFJLFFBQVE7SUFDM0JtQyxNQUFNSCxjQUFjUixNQUFNUztJQUMxQixJQUFJRSxRQUFRL0YsTUFBTTtRQUNoQm9GLEtBQUtDLEtBQUssR0FBRyxLQUFJLFFBQVE7SUFDM0I7SUFDQSxPQUFPVTtBQUNUO0FBRUEsU0FBU0MsWUFBWVosSUFBSTtJQUN2QixPQUFPVSxhQUFhVixNQUFNekM7QUFDNUI7QUFHQTs7Ozs7Ozs7O0NBU0MsR0FDRCxJQUFJc0QsU0FBUztBQUViLElBQUlDLFFBQVFDLFNBQVMscURBQXFEO0FBRTFFLFNBQVNDLFlBQVlmLEtBQUs7SUFDeEIscUVBQXFFLEdBQ3JFLElBQUlZLFFBQVE7UUFDVixJQUFJSTtRQUVKSCxTQUFTLElBQUk5RyxNQUFNc0csS0FBSyxDQUFDO1FBQ3pCUyxVQUFVLElBQUkvRyxNQUFNc0csS0FBSyxDQUFDO1FBRTFCLHdCQUF3QixHQUN4QlcsTUFBTTtRQUNOLE1BQU9BLE1BQU0sSUFBSztZQUFFaEIsTUFBTVYsSUFBSSxDQUFDMEIsTUFBTSxHQUFHO1FBQUc7UUFDM0MsTUFBT0EsTUFBTSxJQUFLO1lBQUVoQixNQUFNVixJQUFJLENBQUMwQixNQUFNLEdBQUc7UUFBRztRQUMzQyxNQUFPQSxNQUFNLElBQUs7WUFBRWhCLE1BQU1WLElBQUksQ0FBQzBCLE1BQU0sR0FBRztRQUFHO1FBQzNDLE1BQU9BLE1BQU0sSUFBSztZQUFFaEIsTUFBTVYsSUFBSSxDQUFDMEIsTUFBTSxHQUFHO1FBQUc7UUFFM0M1RyxjQUFjRSxNQUFPMEYsTUFBTVYsSUFBSSxFQUFFLEdBQUcsS0FBS3VCLFFBQVUsR0FBR2IsTUFBTVIsSUFBSSxFQUFFO1lBQUVmLE1BQU07UUFBRTtRQUU1RSxrQkFBa0IsR0FDbEJ1QyxNQUFNO1FBQ04sTUFBT0EsTUFBTSxHQUFJO1lBQUVoQixNQUFNVixJQUFJLENBQUMwQixNQUFNLEdBQUc7UUFBRztRQUUxQzVHLGNBQWNHLE9BQU95RixNQUFNVixJQUFJLEVBQUUsR0FBRyxJQUFNd0IsU0FBUyxHQUFHZCxNQUFNUixJQUFJLEVBQUU7WUFBRWYsTUFBTTtRQUFFO1FBRTVFLHFCQUFxQixHQUNyQm1DLFNBQVM7SUFDWDtJQUVBWixNQUFNbkIsT0FBTyxHQUFHZ0M7SUFDaEJiLE1BQU1qQixPQUFPLEdBQUc7SUFDaEJpQixNQUFNbEIsUUFBUSxHQUFHZ0M7SUFDakJkLE1BQU1oQixRQUFRLEdBQUc7QUFDbkI7QUFHQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ0QsU0FBU2lDLGFBQWFsQixJQUFJLEVBQUVtQixHQUFHLEVBQUVDLEdBQUcsRUFBRUMsSUFBSTtJQUN4QyxJQUFJQztJQUNKLElBQUlyQixRQUFRRCxLQUFLQyxLQUFLO0lBRXRCLGlFQUFpRSxHQUNqRSxJQUFJQSxNQUFNekIsTUFBTSxLQUFLLE1BQU07UUFDekJ5QixNQUFNNUIsS0FBSyxHQUFHLEtBQUs0QixNQUFNN0IsS0FBSztRQUM5QjZCLE1BQU0xQixLQUFLLEdBQUc7UUFDZDBCLE1BQU0zQixLQUFLLEdBQUc7UUFFZDJCLE1BQU16QixNQUFNLEdBQUcsSUFBSXhFLE1BQU11SCxJQUFJLENBQUN0QixNQUFNNUIsS0FBSztJQUMzQztJQUVBLG1FQUFtRSxHQUNuRSxJQUFJZ0QsUUFBUXBCLE1BQU01QixLQUFLLEVBQUU7UUFDdkJyRSxNQUFNd0gsUUFBUSxDQUFDdkIsTUFBTXpCLE1BQU0sRUFBRTJDLEtBQUtDLE1BQU1uQixNQUFNNUIsS0FBSyxFQUFFNEIsTUFBTTVCLEtBQUssRUFBRTtRQUNsRTRCLE1BQU0xQixLQUFLLEdBQUc7UUFDZDBCLE1BQU0zQixLQUFLLEdBQUcyQixNQUFNNUIsS0FBSztJQUMzQixPQUNLO1FBQ0hpRCxPQUFPckIsTUFBTTVCLEtBQUssR0FBRzRCLE1BQU0xQixLQUFLO1FBQ2hDLElBQUkrQyxPQUFPRCxNQUFNO1lBQ2ZDLE9BQU9EO1FBQ1Q7UUFDQSwwREFBMEQ7UUFDMURySCxNQUFNd0gsUUFBUSxDQUFDdkIsTUFBTXpCLE1BQU0sRUFBRTJDLEtBQUtDLE1BQU1DLE1BQU1DLE1BQU1yQixNQUFNMUIsS0FBSztRQUMvRDhDLFFBQVFDO1FBQ1IsSUFBSUQsTUFBTTtZQUNSLDJDQUEyQztZQUMzQ3JILE1BQU13SCxRQUFRLENBQUN2QixNQUFNekIsTUFBTSxFQUFFMkMsS0FBS0MsTUFBTUMsTUFBTUEsTUFBTTtZQUNwRHBCLE1BQU0xQixLQUFLLEdBQUc4QztZQUNkcEIsTUFBTTNCLEtBQUssR0FBRzJCLE1BQU01QixLQUFLO1FBQzNCLE9BQ0s7WUFDSDRCLE1BQU0xQixLQUFLLElBQUkrQztZQUNmLElBQUlyQixNQUFNMUIsS0FBSyxLQUFLMEIsTUFBTTVCLEtBQUssRUFBRTtnQkFBRTRCLE1BQU0xQixLQUFLLEdBQUc7WUFBRztZQUNwRCxJQUFJMEIsTUFBTTNCLEtBQUssR0FBRzJCLE1BQU01QixLQUFLLEVBQUU7Z0JBQUU0QixNQUFNM0IsS0FBSyxJQUFJZ0Q7WUFBTTtRQUN4RDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUEsU0FBU0csUUFBUXpCLElBQUksRUFBRTBCLEtBQUs7SUFDMUIsSUFBSXpCO0lBQ0osSUFBSTBCLE9BQU9DLFFBQWlCLHVCQUF1QjtJQUNuRCxJQUFJdEMsTUFBd0Isb0JBQW9CO0lBQ2hELElBQUl1QyxLQUF3QixxQkFBcUI7SUFDakQsSUFBSXhDLE1BQU15QyxNQUFrQiw4QkFBOEI7SUFDMUQsSUFBSXJELE1BQXdCLGNBQWM7SUFDMUMsSUFBSUMsTUFBd0Isc0JBQXNCO0lBQ2xELElBQUlxRCxLQUFLQyxNQUFtQiw0Q0FBNEM7SUFDeEUsSUFBSVgsTUFBd0IsMkNBQTJDO0lBQ3ZFLElBQUlZLE1BQXdCLGtDQUFrQztJQUM5RCxJQUFJQztJQUNKLElBQUlDLE9BQU8sR0FBaUIsZ0NBQWdDO0lBQzVELElBQUlDLFdBQVdDLFNBQVNDLFVBQVUsMENBQTBDO0lBQzVFLHNEQUFzRDtJQUN0RCxJQUFJQyxXQUFXQyxTQUFTQyxVQUFVLDBDQUEwQztJQUM1RSxJQUFJQyxLQUF3Qiw0Q0FBNEM7SUFDeEUsSUFBSS9CLEtBQXdCLGVBQWU7SUFDM0MsSUFBSWdDLE9BQU8sSUFBSTNJLE1BQU11SCxJQUFJLENBQUMsSUFBTywwQ0FBMEM7SUFDM0UsSUFBSXFCO0lBRUosSUFBSUMsR0FBRyw4QkFBOEI7SUFFckMsSUFBSUMsUUFBUSwrQkFBK0IsR0FDekM7UUFBRTtRQUFJO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBRztLQUFJO0lBR3RFLElBQUksQ0FBQzlDLFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxJQUFJLENBQUNELEtBQUs0QixNQUFNLElBQ25DLENBQUM1QixLQUFLMkIsS0FBSyxJQUFJM0IsS0FBSytDLFFBQVEsS0FBSyxHQUFJO1FBQ3hDLE9BQU9oSTtJQUNUO0lBRUFrRixRQUFRRCxLQUFLQyxLQUFLO0lBQ2xCLElBQUlBLE1BQU10QyxJQUFJLEtBQUs1QixNQUFNO1FBQUVrRSxNQUFNdEMsSUFBSSxHQUFHM0I7SUFBUSxFQUFLLGNBQWM7SUFHbkUsZ0JBQWdCO0lBQ2hCNkYsTUFBTTdCLEtBQUtnRCxRQUFRO0lBQ25CcEIsU0FBUzVCLEtBQUs0QixNQUFNO0lBQ3BCRSxPQUFPOUIsS0FBS2lELFNBQVM7SUFDckIzRCxPQUFPVSxLQUFLa0QsT0FBTztJQUNuQnZCLFFBQVEzQixLQUFLMkIsS0FBSztJQUNsQnRDLE9BQU9XLEtBQUsrQyxRQUFRO0lBQ3BCdEUsT0FBT3dCLE1BQU14QixJQUFJO0lBQ2pCQyxPQUFPdUIsTUFBTXZCLElBQUk7SUFDakIsS0FBSztJQUVMcUQsTUFBTTFDO0lBQ04yQyxPQUFPRjtJQUNQbkIsTUFBTS9GO0lBRU51SSxXQUNBLE9BQVM7UUFDUCxPQUFRbEQsTUFBTXRDLElBQUk7WUFDaEIsS0FBS3ZDO2dCQUNILElBQUk2RSxNQUFNcEMsSUFBSSxLQUFLLEdBQUc7b0JBQ3BCb0MsTUFBTXRDLElBQUksR0FBRzNCO29CQUNiO2dCQUNGO2dCQUNBLG1CQUFtQjtnQkFDbkIsTUFBTzBDLE9BQU8sR0FBSTtvQkFDaEIsSUFBSVcsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5RDtvQkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7b0JBQ3pCQSxRQUFRO2dCQUNWO2dCQUNBLE9BQU87Z0JBQ1AsSUFBSSxNQUFPYixJQUFJLEdBQUcsS0FBTVksU0FBUyxRQUFRO29CQUN2Q3dCLE1BQU1oQyxLQUFLLEdBQUcsRUFBQyxzQkFBc0I7b0JBQ3JDLDhCQUE4QjtvQkFDOUIwRSxJQUFJLENBQUMsRUFBRSxHQUFHbEUsT0FBTztvQkFDakJrRSxJQUFJLENBQUMsRUFBRSxHQUFHLFNBQVUsSUFBSztvQkFDekIxQyxNQUFNaEMsS0FBSyxHQUFHOUQsTUFBTThGLE1BQU1oQyxLQUFLLEVBQUUwRSxNQUFNLEdBQUc7b0JBQzFDLE9BQU87b0JBRVAsaUJBQWlCO29CQUNqQmxFLE9BQU87b0JBQ1BDLE9BQU87b0JBQ1AsT0FBTztvQkFDUHVCLE1BQU10QyxJQUFJLEdBQUd0QztvQkFDYjtnQkFDRjtnQkFDQTRFLE1BQU1sQyxLQUFLLEdBQUcsR0FBYSxzQkFBc0I7Z0JBQ2pELElBQUlrQyxNQUFNOUIsSUFBSSxFQUFFO29CQUNkOEIsTUFBTTlCLElBQUksQ0FBQ2lGLElBQUksR0FBRztnQkFDcEI7Z0JBQ0EsSUFBSSxDQUFFbkQsQ0FBQUEsTUFBTXBDLElBQUksR0FBRyxNQUNqQixnQ0FEeUQsR0FDeEQsRUFBQyxDQUFDWSxPQUFPLElBQUcsS0FBaUIsS0FBTUEsQ0FBQUEsUUFBUSxFQUFDLElBQUssSUFBSTtvQkFDdER1QixLQUFLSSxHQUFHLEdBQUc7b0JBQ1hILE1BQU10QyxJQUFJLEdBQUdWO29CQUNiO2dCQUNGO2dCQUNBLElBQUksQ0FBQ3dCLE9BQU8sSUFBRyxNQUFrQnRELFlBQVk7b0JBQzNDNkUsS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFDQSx1QkFBdUI7Z0JBQ3ZCd0IsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUixPQUFPO2dCQUNQZ0UsTUFBTSxDQUFDakUsT0FBTyxJQUFHLElBQWdCO2dCQUNqQyxJQUFJd0IsTUFBTTdCLEtBQUssS0FBSyxHQUFHO29CQUNyQjZCLE1BQU03QixLQUFLLEdBQUdzRTtnQkFDaEIsT0FDSyxJQUFJQSxNQUFNekMsTUFBTTdCLEtBQUssRUFBRTtvQkFDMUI0QixLQUFLSSxHQUFHLEdBQUc7b0JBQ1hILE1BQU10QyxJQUFJLEdBQUdWO29CQUNiO2dCQUNGO2dCQUNBZ0QsTUFBTWpDLElBQUksR0FBRyxLQUFLMEU7Z0JBQ2xCLGtEQUFrRDtnQkFDbEQxQyxLQUFLSyxLQUFLLEdBQUdKLE1BQU1oQyxLQUFLLEdBQUcsRUFBQyx3QkFBd0I7Z0JBQ3BEZ0MsTUFBTXRDLElBQUksR0FBR2MsT0FBTyxRQUFRNUMsU0FBU0U7Z0JBQ3JDLGlCQUFpQjtnQkFDakIwQyxPQUFPO2dCQUNQQyxPQUFPO2dCQUVQO1lBQ0YsS0FBS3JEO2dCQUNILHNCQUFzQjtnQkFDdEIsTUFBT3FELE9BQU8sR0FBSTtvQkFDaEIsSUFBSVcsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5RDtvQkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7b0JBQ3pCQSxRQUFRO2dCQUNWO2dCQUNBLE9BQU87Z0JBQ1B1QixNQUFNbEMsS0FBSyxHQUFHVTtnQkFDZCxJQUFJLENBQUN3QixNQUFNbEMsS0FBSyxHQUFHLElBQUcsTUFBTzVDLFlBQVk7b0JBQ3ZDNkUsS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFDQSxJQUFJZ0QsTUFBTWxDLEtBQUssR0FBRyxRQUFRO29CQUN4QmlDLEtBQUtJLEdBQUcsR0FBRztvQkFDWEgsTUFBTXRDLElBQUksR0FBR1Y7b0JBQ2I7Z0JBQ0Y7Z0JBQ0EsSUFBSWdELE1BQU05QixJQUFJLEVBQUU7b0JBQ2Q4QixNQUFNOUIsSUFBSSxDQUFDa0YsSUFBSSxHQUFJLFFBQVMsSUFBSztnQkFDbkM7Z0JBQ0EsSUFBSXBELE1BQU1sQyxLQUFLLEdBQUcsUUFBUTtvQkFDeEIsOEJBQThCO29CQUM5QjRFLElBQUksQ0FBQyxFQUFFLEdBQUdsRSxPQUFPO29CQUNqQmtFLElBQUksQ0FBQyxFQUFFLEdBQUcsU0FBVSxJQUFLO29CQUN6QjFDLE1BQU1oQyxLQUFLLEdBQUc5RCxNQUFNOEYsTUFBTWhDLEtBQUssRUFBRTBFLE1BQU0sR0FBRztnQkFDMUMsT0FBTztnQkFDVDtnQkFDQSxpQkFBaUI7Z0JBQ2pCbEUsT0FBTztnQkFDUEMsT0FBTztnQkFDUCxPQUFPO2dCQUNQdUIsTUFBTXRDLElBQUksR0FBR3JDO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILHNCQUFzQjtnQkFDdEIsTUFBT29ELE9BQU8sR0FBSTtvQkFDaEIsSUFBSVcsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5RDtvQkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7b0JBQ3pCQSxRQUFRO2dCQUNWO2dCQUNBLE9BQU87Z0JBQ1AsSUFBSXVCLE1BQU05QixJQUFJLEVBQUU7b0JBQ2Q4QixNQUFNOUIsSUFBSSxDQUFDbUYsSUFBSSxHQUFHN0U7Z0JBQ3BCO2dCQUNBLElBQUl3QixNQUFNbEMsS0FBSyxHQUFHLFFBQVE7b0JBQ3hCLDZCQUE2QjtvQkFDN0I0RSxJQUFJLENBQUMsRUFBRSxHQUFHbEUsT0FBTztvQkFDakJrRSxJQUFJLENBQUMsRUFBRSxHQUFHLFNBQVUsSUFBSztvQkFDekJBLElBQUksQ0FBQyxFQUFFLEdBQUcsU0FBVSxLQUFNO29CQUMxQkEsSUFBSSxDQUFDLEVBQUUsR0FBRyxTQUFVLEtBQU07b0JBQzFCMUMsTUFBTWhDLEtBQUssR0FBRzlELE1BQU04RixNQUFNaEMsS0FBSyxFQUFFMEUsTUFBTSxHQUFHO2dCQUMxQyxLQUFLO2dCQUNQO2dCQUNBLGlCQUFpQjtnQkFDakJsRSxPQUFPO2dCQUNQQyxPQUFPO2dCQUNQLE9BQU87Z0JBQ1B1QixNQUFNdEMsSUFBSSxHQUFHcEM7WUFDYixpQkFBaUIsR0FDbkIsS0FBS0E7Z0JBQ0gsc0JBQXNCO2dCQUN0QixNQUFPbUQsT0FBTyxHQUFJO29CQUNoQixJQUFJVyxTQUFTLEdBQUc7d0JBQUUsTUFBTThEO29CQUFXO29CQUNuQzlEO29CQUNBWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjtvQkFDekJBLFFBQVE7Z0JBQ1Y7Z0JBQ0EsT0FBTztnQkFDUCxJQUFJdUIsTUFBTTlCLElBQUksRUFBRTtvQkFDZDhCLE1BQU05QixJQUFJLENBQUNvRixNQUFNLEdBQUk5RSxPQUFPO29CQUM1QndCLE1BQU05QixJQUFJLENBQUNxRixFQUFFLEdBQUkvRSxRQUFRO2dCQUMzQjtnQkFDQSxJQUFJd0IsTUFBTWxDLEtBQUssR0FBRyxRQUFRO29CQUN4Qiw4QkFBOEI7b0JBQzlCNEUsSUFBSSxDQUFDLEVBQUUsR0FBR2xFLE9BQU87b0JBQ2pCa0UsSUFBSSxDQUFDLEVBQUUsR0FBRyxTQUFVLElBQUs7b0JBQ3pCMUMsTUFBTWhDLEtBQUssR0FBRzlELE1BQU04RixNQUFNaEMsS0FBSyxFQUFFMEUsTUFBTSxHQUFHO2dCQUMxQyxPQUFPO2dCQUNUO2dCQUNBLGlCQUFpQjtnQkFDakJsRSxPQUFPO2dCQUNQQyxPQUFPO2dCQUNQLE9BQU87Z0JBQ1B1QixNQUFNdEMsSUFBSSxHQUFHbkM7WUFDYixpQkFBaUIsR0FDbkIsS0FBS0E7Z0JBQ0gsSUFBSXlFLE1BQU1sQyxLQUFLLEdBQUcsUUFBUTtvQkFDeEIsc0JBQXNCO29CQUN0QixNQUFPVyxPQUFPLEdBQUk7d0JBQ2hCLElBQUlXLFNBQVMsR0FBRzs0QkFBRSxNQUFNOEQ7d0JBQVc7d0JBQ25DOUQ7d0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO3dCQUN6QkEsUUFBUTtvQkFDVjtvQkFDQSxPQUFPO29CQUNQdUIsTUFBTXRCLE1BQU0sR0FBR0Y7b0JBQ2YsSUFBSXdCLE1BQU05QixJQUFJLEVBQUU7d0JBQ2Q4QixNQUFNOUIsSUFBSSxDQUFDc0YsU0FBUyxHQUFHaEY7b0JBQ3pCO29CQUNBLElBQUl3QixNQUFNbEMsS0FBSyxHQUFHLFFBQVE7d0JBQ3hCLDhCQUE4Qjt3QkFDOUI0RSxJQUFJLENBQUMsRUFBRSxHQUFHbEUsT0FBTzt3QkFDakJrRSxJQUFJLENBQUMsRUFBRSxHQUFHLFNBQVUsSUFBSzt3QkFDekIxQyxNQUFNaEMsS0FBSyxHQUFHOUQsTUFBTThGLE1BQU1oQyxLQUFLLEVBQUUwRSxNQUFNLEdBQUc7b0JBQzFDLE9BQU87b0JBQ1Q7b0JBQ0EsaUJBQWlCO29CQUNqQmxFLE9BQU87b0JBQ1BDLE9BQU87Z0JBQ1AsT0FBTztnQkFDVCxPQUNLLElBQUl1QixNQUFNOUIsSUFBSSxFQUFFO29CQUNuQjhCLE1BQU05QixJQUFJLENBQUNVLEtBQUssR0FBRyxLQUFJLFFBQVE7Z0JBQ2pDO2dCQUNBb0IsTUFBTXRDLElBQUksR0FBR2xDO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILElBQUl3RSxNQUFNbEMsS0FBSyxHQUFHLFFBQVE7b0JBQ3hCc0QsT0FBT3BCLE1BQU10QixNQUFNO29CQUNuQixJQUFJMEMsT0FBT2hDLE1BQU07d0JBQUVnQyxPQUFPaEM7b0JBQU07b0JBQ2hDLElBQUlnQyxNQUFNO3dCQUNSLElBQUlwQixNQUFNOUIsSUFBSSxFQUFFOzRCQUNkdUUsTUFBTXpDLE1BQU05QixJQUFJLENBQUNzRixTQUFTLEdBQUd4RCxNQUFNdEIsTUFBTTs0QkFDekMsSUFBSSxDQUFDc0IsTUFBTTlCLElBQUksQ0FBQ1UsS0FBSyxFQUFFO2dDQUNyQix5REFBeUQ7Z0NBQ3pEb0IsTUFBTTlCLElBQUksQ0FBQ1UsS0FBSyxHQUFHLElBQUk2RSxNQUFNekQsTUFBTTlCLElBQUksQ0FBQ3NGLFNBQVM7NEJBQ25EOzRCQUNBekosTUFBTXdILFFBQVEsQ0FDWnZCLE1BQU05QixJQUFJLENBQUNVLEtBQUssRUFDaEI4QyxPQUNBckMsTUFDQSx3Q0FBd0M7NEJBQ3hDLHNDQUFzQzs0QkFDdEMrQixNQUNBLHdFQUF3RSxHQUN4RXFCO3dCQUVGLHVDQUF1Qzt3QkFDdkMsNkNBQTZDO3dCQUM3Qyw2Q0FBNkM7d0JBQy9DO3dCQUNBLElBQUl6QyxNQUFNbEMsS0FBSyxHQUFHLFFBQVE7NEJBQ3hCa0MsTUFBTWhDLEtBQUssR0FBRzlELE1BQU04RixNQUFNaEMsS0FBSyxFQUFFMEQsT0FBT04sTUFBTS9CO3dCQUNoRDt3QkFDQUQsUUFBUWdDO3dCQUNSL0IsUUFBUStCO3dCQUNScEIsTUFBTXRCLE1BQU0sSUFBSTBDO29CQUNsQjtvQkFDQSxJQUFJcEIsTUFBTXRCLE1BQU0sRUFBRTt3QkFBRSxNQUFNd0U7b0JBQVc7Z0JBQ3ZDO2dCQUNBbEQsTUFBTXRCLE1BQU0sR0FBRztnQkFDZnNCLE1BQU10QyxJQUFJLEdBQUdqQztZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSCxJQUFJdUUsTUFBTWxDLEtBQUssR0FBRyxRQUFRO29CQUN4QixJQUFJc0IsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5QixPQUFPO29CQUNQLEdBQUc7d0JBQ0Qsc0JBQXNCO3dCQUN0QnFCLE1BQU1mLEtBQUssQ0FBQ3JDLE9BQU8rQixPQUFPO3dCQUMxQixxRUFBcUUsR0FDckUsSUFBSXBCLE1BQU05QixJQUFJLElBQUl1RSxPQUNiekMsTUFBTXRCLE1BQU0sR0FBRyxNQUFNLHFCQUFxQixLQUFLOzRCQUNsRHNCLE1BQU05QixJQUFJLENBQUN3RixJQUFJLElBQUlDLE9BQU9DLFlBQVksQ0FBQ25CO3dCQUN6QztvQkFDRixRQUFTQSxPQUFPckIsT0FBT2hDLE1BQU07b0JBRTdCLElBQUlZLE1BQU1sQyxLQUFLLEdBQUcsUUFBUTt3QkFDeEJrQyxNQUFNaEMsS0FBSyxHQUFHOUQsTUFBTThGLE1BQU1oQyxLQUFLLEVBQUUwRCxPQUFPTixNQUFNL0I7b0JBQ2hEO29CQUNBRCxRQUFRZ0M7b0JBQ1IvQixRQUFRK0I7b0JBQ1IsSUFBSXFCLEtBQUs7d0JBQUUsTUFBTVM7b0JBQVc7Z0JBQzlCLE9BQ0ssSUFBSWxELE1BQU05QixJQUFJLEVBQUU7b0JBQ25COEIsTUFBTTlCLElBQUksQ0FBQ3dGLElBQUksR0FBRztnQkFDcEI7Z0JBQ0ExRCxNQUFNdEIsTUFBTSxHQUFHO2dCQUNmc0IsTUFBTXRDLElBQUksR0FBR2hDO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILElBQUlzRSxNQUFNbEMsS0FBSyxHQUFHLFFBQVE7b0JBQ3hCLElBQUlzQixTQUFTLEdBQUc7d0JBQUUsTUFBTThEO29CQUFXO29CQUNuQzlCLE9BQU87b0JBQ1AsR0FBRzt3QkFDRHFCLE1BQU1mLEtBQUssQ0FBQ3JDLE9BQU8rQixPQUFPO3dCQUMxQixxRUFBcUUsR0FDckUsSUFBSXBCLE1BQU05QixJQUFJLElBQUl1RSxPQUNiekMsTUFBTXRCLE1BQU0sR0FBRyxNQUFNLHFCQUFxQixLQUFLOzRCQUNsRHNCLE1BQU05QixJQUFJLENBQUMyRixPQUFPLElBQUlGLE9BQU9DLFlBQVksQ0FBQ25CO3dCQUM1QztvQkFDRixRQUFTQSxPQUFPckIsT0FBT2hDLE1BQU07b0JBQzdCLElBQUlZLE1BQU1sQyxLQUFLLEdBQUcsUUFBUTt3QkFDeEJrQyxNQUFNaEMsS0FBSyxHQUFHOUQsTUFBTThGLE1BQU1oQyxLQUFLLEVBQUUwRCxPQUFPTixNQUFNL0I7b0JBQ2hEO29CQUNBRCxRQUFRZ0M7b0JBQ1IvQixRQUFRK0I7b0JBQ1IsSUFBSXFCLEtBQUs7d0JBQUUsTUFBTVM7b0JBQVc7Z0JBQzlCLE9BQ0ssSUFBSWxELE1BQU05QixJQUFJLEVBQUU7b0JBQ25COEIsTUFBTTlCLElBQUksQ0FBQzJGLE9BQU8sR0FBRztnQkFDdkI7Z0JBQ0E3RCxNQUFNdEMsSUFBSSxHQUFHL0I7WUFDYixpQkFBaUIsR0FDbkIsS0FBS0E7Z0JBQ0gsSUFBSXFFLE1BQU1sQyxLQUFLLEdBQUcsUUFBUTtvQkFDeEIsc0JBQXNCO29CQUN0QixNQUFPVyxPQUFPLEdBQUk7d0JBQ2hCLElBQUlXLFNBQVMsR0FBRzs0QkFBRSxNQUFNOEQ7d0JBQVc7d0JBQ25DOUQ7d0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO3dCQUN6QkEsUUFBUTtvQkFDVjtvQkFDQSxPQUFPO29CQUNQLElBQUlELFNBQVV3QixDQUFBQSxNQUFNaEMsS0FBSyxHQUFHLE1BQUssR0FBSTt3QkFDbkMrQixLQUFLSSxHQUFHLEdBQUc7d0JBQ1hILE1BQU10QyxJQUFJLEdBQUdWO3dCQUNiO29CQUNGO29CQUNBLGlCQUFpQjtvQkFDakJ3QixPQUFPO29CQUNQQyxPQUFPO2dCQUNQLE9BQU87Z0JBQ1Q7Z0JBQ0EsSUFBSXVCLE1BQU05QixJQUFJLEVBQUU7b0JBQ2Q4QixNQUFNOUIsSUFBSSxDQUFDNEYsSUFBSSxHQUFJLE1BQU9oRyxLQUFLLElBQUksSUFBSztvQkFDeENrQyxNQUFNOUIsSUFBSSxDQUFDaUYsSUFBSSxHQUFHO2dCQUNwQjtnQkFDQXBELEtBQUtLLEtBQUssR0FBR0osTUFBTWhDLEtBQUssR0FBRztnQkFDM0JnQyxNQUFNdEMsSUFBSSxHQUFHNUI7Z0JBQ2I7WUFDRixLQUFLRjtnQkFDSCxzQkFBc0I7Z0JBQ3RCLE1BQU82QyxPQUFPLEdBQUk7b0JBQ2hCLElBQUlXLFNBQVMsR0FBRzt3QkFBRSxNQUFNOEQ7b0JBQVc7b0JBQ25DOUQ7b0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO29CQUN6QkEsUUFBUTtnQkFDVjtnQkFDQSxPQUFPO2dCQUNQc0IsS0FBS0ssS0FBSyxHQUFHSixNQUFNaEMsS0FBSyxHQUFHVCxRQUFRaUI7Z0JBQ25DLGlCQUFpQjtnQkFDakJBLE9BQU87Z0JBQ1BDLE9BQU87Z0JBQ1AsT0FBTztnQkFDUHVCLE1BQU10QyxJQUFJLEdBQUc3QjtZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSCxJQUFJbUUsTUFBTW5DLFFBQVEsS0FBSyxHQUFHO29CQUN4QixtQkFBbUI7b0JBQ25Ca0MsS0FBS2dELFFBQVEsR0FBR25CO29CQUNoQjdCLEtBQUtpRCxTQUFTLEdBQUduQjtvQkFDakI5QixLQUFLa0QsT0FBTyxHQUFHNUQ7b0JBQ2ZVLEtBQUsrQyxRQUFRLEdBQUcxRDtvQkFDaEJZLE1BQU14QixJQUFJLEdBQUdBO29CQUNid0IsTUFBTXZCLElBQUksR0FBR0E7b0JBQ2IsS0FBSztvQkFDTCxPQUFPNUQ7Z0JBQ1Q7Z0JBQ0FrRixLQUFLSyxLQUFLLEdBQUdKLE1BQU1oQyxLQUFLLEdBQUcsRUFBQyx3QkFBd0I7Z0JBQ3BEZ0MsTUFBTXRDLElBQUksR0FBRzVCO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILElBQUkyRixVQUFVaEgsV0FBV2dILFVBQVUvRyxTQUFTO29CQUFFLE1BQU13STtnQkFBVztZQUMvRCxpQkFBaUIsR0FDbkIsS0FBS25IO2dCQUNILElBQUlpRSxNQUFNckMsSUFBSSxFQUFFO29CQUNkLHNCQUFzQjtvQkFDdEJhLFVBQVVDLE9BQU87b0JBQ2pCQSxRQUFRQSxPQUFPO29CQUNmLE9BQU87b0JBQ1B1QixNQUFNdEMsSUFBSSxHQUFHYjtvQkFDYjtnQkFDRjtnQkFDQSxxQkFBcUI7Z0JBQ3JCLE1BQU80QixPQUFPLEVBQUc7b0JBQ2YsSUFBSVcsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5RDtvQkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7b0JBQ3pCQSxRQUFRO2dCQUNWO2dCQUNBLE9BQU87Z0JBQ1B1QixNQUFNckMsSUFBSSxHQUFJYSxPQUFPLEtBQUssU0FBUztnQkFDbkMsdUJBQXVCO2dCQUN2QkEsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUixPQUFPO2dCQUVQLE9BQVNELE9BQU87b0JBQ2QsS0FBSzt3QkFBK0IsZ0JBQWdCLEdBQ2xELGtEQUFrRDt3QkFDbEQsd0NBQXdDO3dCQUN4Q3dCLE1BQU10QyxJQUFJLEdBQUcxQjt3QkFDYjtvQkFDRixLQUFLO3dCQUErQixlQUFlLEdBQ2pEK0UsWUFBWWY7d0JBQ1osdURBQXVEO3dCQUN2RCx3Q0FBd0M7d0JBQ3hDQSxNQUFNdEMsSUFBSSxHQUFHcEIsTUFBa0IsZ0JBQWdCO3dCQUMvQyxJQUFJbUYsVUFBVS9HLFNBQVM7NEJBQ3JCLHVCQUF1Qjs0QkFDdkI4RCxVQUFVOzRCQUNWQyxRQUFROzRCQUVSLE1BQU15RTt3QkFDUjt3QkFDQTtvQkFDRixLQUFLO3dCQUErQixpQkFBaUIsR0FDbkQseURBQXlEO3dCQUN6RCx3Q0FBd0M7d0JBQ3hDbEQsTUFBTXRDLElBQUksR0FBR3ZCO3dCQUNiO29CQUNGLEtBQUs7d0JBQ0g0RCxLQUFLSSxHQUFHLEdBQUc7d0JBQ1hILE1BQU10QyxJQUFJLEdBQUdWO2dCQUNqQjtnQkFDQSx1QkFBdUI7Z0JBQ3ZCd0IsVUFBVTtnQkFDVkMsUUFBUTtnQkFFUjtZQUNGLEtBQUt6QztnQkFDSCxnREFBZ0Q7Z0JBQ2hEd0MsVUFBVUMsT0FBTztnQkFDakJBLFFBQVFBLE9BQU87Z0JBQ2YsT0FBTztnQkFDUCxzQkFBc0I7Z0JBQ3RCLE1BQU9BLE9BQU8sR0FBSTtvQkFDaEIsSUFBSVcsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5RDtvQkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7b0JBQ3pCQSxRQUFRO2dCQUNWO2dCQUNBLE9BQU87Z0JBQ1AsSUFBSSxDQUFDRCxPQUFPLE1BQUssTUFBUSxVQUFVLEtBQU0sTUFBSyxHQUFJO29CQUNoRHVCLEtBQUtJLEdBQUcsR0FBRztvQkFDWEgsTUFBTXRDLElBQUksR0FBR1Y7b0JBQ2I7Z0JBQ0Y7Z0JBQ0FnRCxNQUFNdEIsTUFBTSxHQUFHRixPQUFPO2dCQUN0QixzREFBc0Q7Z0JBQ3RELHlCQUF5QjtnQkFDekIsaUJBQWlCO2dCQUNqQkEsT0FBTztnQkFDUEMsT0FBTztnQkFDUCxPQUFPO2dCQUNQdUIsTUFBTXRDLElBQUksR0FBR3pCO2dCQUNiLElBQUl3RixVQUFVL0csU0FBUztvQkFBRSxNQUFNd0k7Z0JBQVc7WUFDMUMsaUJBQWlCLEdBQ25CLEtBQUtqSDtnQkFDSCtELE1BQU10QyxJQUFJLEdBQUd4QjtZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSGtGLE9BQU9wQixNQUFNdEIsTUFBTTtnQkFDbkIsSUFBSTBDLE1BQU07b0JBQ1IsSUFBSUEsT0FBT2hDLE1BQU07d0JBQUVnQyxPQUFPaEM7b0JBQU07b0JBQ2hDLElBQUlnQyxPQUFPUyxNQUFNO3dCQUFFVCxPQUFPUztvQkFBTTtvQkFDaEMsSUFBSVQsU0FBUyxHQUFHO3dCQUFFLE1BQU04QjtvQkFBVztvQkFDbkMsbUNBQW1DO29CQUNuQ25KLE1BQU13SCxRQUFRLENBQUNJLFFBQVFELE9BQU9yQyxNQUFNK0IsTUFBTVE7b0JBQzFDLE9BQU87b0JBQ1B4QyxRQUFRZ0M7b0JBQ1IvQixRQUFRK0I7b0JBQ1JTLFFBQVFUO29CQUNSUSxPQUFPUjtvQkFDUHBCLE1BQU10QixNQUFNLElBQUkwQztvQkFDaEI7Z0JBQ0Y7Z0JBQ0Esa0RBQWtEO2dCQUNsRHBCLE1BQU10QyxJQUFJLEdBQUc1QjtnQkFDYjtZQUNGLEtBQUtLO2dCQUNILHNCQUFzQjtnQkFDdEIsTUFBT3NDLE9BQU8sR0FBSTtvQkFDaEIsSUFBSVcsU0FBUyxHQUFHO3dCQUFFLE1BQU04RDtvQkFBVztvQkFDbkM5RDtvQkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7b0JBQ3pCQSxRQUFRO2dCQUNWO2dCQUNBLE9BQU87Z0JBQ1B1QixNQUFNZCxJQUFJLEdBQUcsQ0FBQ1YsT0FBTyxJQUFHLElBQWdCO2dCQUN4Qyx1QkFBdUI7Z0JBQ3ZCQSxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSLE9BQU87Z0JBQ1B1QixNQUFNYixLQUFLLEdBQUcsQ0FBQ1gsT0FBTyxJQUFHLElBQWdCO2dCQUN6Qyx1QkFBdUI7Z0JBQ3ZCQSxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSLE9BQU87Z0JBQ1B1QixNQUFNZixLQUFLLEdBQUcsQ0FBQ1QsT0FBTyxJQUFHLElBQWdCO2dCQUN6Qyx1QkFBdUI7Z0JBQ3ZCQSxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSLE9BQU87Z0JBQ2YsOEJBQThCO2dCQUN0QixJQUFJdUIsTUFBTWQsSUFBSSxHQUFHLE9BQU9jLE1BQU1iLEtBQUssR0FBRyxJQUFJO29CQUN4Q1ksS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFDUixRQUFRO2dCQUNBLHNEQUFzRDtnQkFDdERnRCxNQUFNWixJQUFJLEdBQUc7Z0JBQ2JZLE1BQU10QyxJQUFJLEdBQUd0QjtZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSCxNQUFPNEQsTUFBTVosSUFBSSxHQUFHWSxNQUFNZixLQUFLLENBQUU7b0JBQy9CLGtCQUFrQjtvQkFDbEIsTUFBT1IsT0FBTyxFQUFHO3dCQUNmLElBQUlXLFNBQVMsR0FBRzs0QkFBRSxNQUFNOEQ7d0JBQVc7d0JBQ25DOUQ7d0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO3dCQUN6QkEsUUFBUTtvQkFDVjtvQkFDQSxPQUFPO29CQUNQdUIsTUFBTVYsSUFBSSxDQUFDdUQsS0FBSyxDQUFDN0MsTUFBTVosSUFBSSxHQUFHLENBQUMsR0FBSVosT0FBTyxNQUFNLFVBQVU7b0JBQzFELHVCQUF1QjtvQkFDdkJBLFVBQVU7b0JBQ1ZDLFFBQVE7Z0JBQ1IsT0FBTztnQkFDVDtnQkFDQSxNQUFPdUIsTUFBTVosSUFBSSxHQUFHLEdBQUk7b0JBQ3RCWSxNQUFNVixJQUFJLENBQUN1RCxLQUFLLENBQUM3QyxNQUFNWixJQUFJLEdBQUcsQ0FBQyxHQUFHO2dCQUNwQztnQkFDQSw2RUFBNkU7Z0JBQzdFLDJCQUEyQjtnQkFDM0IsNkJBQTZCO2dCQUM3Qiw4QkFBOEI7Z0JBQzlCWSxNQUFNbkIsT0FBTyxHQUFHbUIsTUFBTVAsTUFBTTtnQkFDNUJPLE1BQU1qQixPQUFPLEdBQUc7Z0JBRWhCNEQsT0FBTztvQkFBRWxFLE1BQU11QixNQUFNakIsT0FBTztnQkFBQztnQkFDN0IyQixNQUFNdEcsY0FBY0MsT0FBTzJGLE1BQU1WLElBQUksRUFBRSxHQUFHLElBQUlVLE1BQU1uQixPQUFPLEVBQUUsR0FBR21CLE1BQU1SLElBQUksRUFBRW1EO2dCQUM1RTNDLE1BQU1qQixPQUFPLEdBQUc0RCxLQUFLbEUsSUFBSTtnQkFFekIsSUFBSWlDLEtBQUs7b0JBQ1BYLEtBQUtJLEdBQUcsR0FBRztvQkFDWEgsTUFBTXRDLElBQUksR0FBR1Y7b0JBQ2I7Z0JBQ0Y7Z0JBQ0EsdURBQXVEO2dCQUN2RGdELE1BQU1aLElBQUksR0FBRztnQkFDYlksTUFBTXRDLElBQUksR0FBR3JCO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILE1BQU8yRCxNQUFNWixJQUFJLEdBQUdZLE1BQU1kLElBQUksR0FBR2MsTUFBTWIsS0FBSyxDQUFFO29CQUM1QyxPQUFTO3dCQUNQK0MsT0FBT2xDLE1BQU1uQixPQUFPLENBQUNMLE9BQVEsQ0FBQyxLQUFLd0IsTUFBTWpCLE9BQU8sSUFBSSxFQUFHLEVBQUMscUJBQXFCO3dCQUM3RW9ELFlBQVlELFNBQVM7d0JBQ3JCRSxVQUFVLFNBQVUsS0FBTTt3QkFDMUJDLFdBQVdILE9BQU87d0JBRWxCLElBQUksYUFBZXpELE1BQU07NEJBQUU7d0JBQU87d0JBQ2xDLHNCQUFzQjt3QkFDdEIsSUFBSVcsU0FBUyxHQUFHOzRCQUFFLE1BQU04RDt3QkFBVzt3QkFDbkM5RDt3QkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7d0JBQ3pCQSxRQUFRO29CQUNSLE9BQU87b0JBQ1Q7b0JBQ0EsSUFBSTRELFdBQVcsSUFBSTt3QkFDakIsK0JBQStCO3dCQUMvQjdELFVBQVUyRDt3QkFDVjFELFFBQVEwRDt3QkFDUixPQUFPO3dCQUNQbkMsTUFBTVYsSUFBSSxDQUFDVSxNQUFNWixJQUFJLEdBQUcsR0FBR2lEO29CQUM3QixPQUNLO3dCQUNILElBQUlBLGFBQWEsSUFBSTs0QkFDbkIsOEJBQThCOzRCQUM5Qk8sSUFBSVQsWUFBWTs0QkFDaEIsTUFBTzFELE9BQU9tRSxFQUFHO2dDQUNmLElBQUl4RCxTQUFTLEdBQUc7b0NBQUUsTUFBTThEO2dDQUFXO2dDQUNuQzlEO2dDQUNBWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjtnQ0FDekJBLFFBQVE7NEJBQ1Y7NEJBQ0EsT0FBTzs0QkFDUCwrQkFBK0I7NEJBQy9CRCxVQUFVMkQ7NEJBQ1YxRCxRQUFRMEQ7NEJBQ1IsT0FBTzs0QkFDUCxJQUFJbkMsTUFBTVosSUFBSSxLQUFLLEdBQUc7Z0NBQ3BCVyxLQUFLSSxHQUFHLEdBQUc7Z0NBQ1hILE1BQU10QyxJQUFJLEdBQUdWO2dDQUNiOzRCQUNGOzRCQUNBeUYsTUFBTXpDLE1BQU1WLElBQUksQ0FBQ1UsTUFBTVosSUFBSSxHQUFHLEVBQUU7NEJBQ2hDZ0MsT0FBTyxJQUFLNUMsQ0FBQUEsT0FBTyxJQUFHLEdBQUcsVUFBVTs0QkFDbkMsdUJBQXVCOzRCQUN2QkEsVUFBVTs0QkFDVkMsUUFBUTt3QkFDUixPQUFPO3dCQUNULE9BQ0ssSUFBSTRELGFBQWEsSUFBSTs0QkFDeEIsOEJBQThCOzRCQUM5Qk8sSUFBSVQsWUFBWTs0QkFDaEIsTUFBTzFELE9BQU9tRSxFQUFHO2dDQUNmLElBQUl4RCxTQUFTLEdBQUc7b0NBQUUsTUFBTThEO2dDQUFXO2dDQUNuQzlEO2dDQUNBWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjtnQ0FDekJBLFFBQVE7NEJBQ1Y7NEJBQ0EsT0FBTzs0QkFDUCwrQkFBK0I7NEJBQy9CRCxVQUFVMkQ7NEJBQ1YxRCxRQUFRMEQ7NEJBQ1IsT0FBTzs0QkFDUE0sTUFBTTs0QkFDTnJCLE9BQU8sSUFBSzVDLENBQUFBLE9BQU8sSUFBRyxHQUFHLFVBQVU7NEJBQ25DLHVCQUF1Qjs0QkFDdkJBLFVBQVU7NEJBQ1ZDLFFBQVE7d0JBQ1IsT0FBTzt3QkFDVCxPQUNLOzRCQUNILDhCQUE4Qjs0QkFDOUJtRSxJQUFJVCxZQUFZOzRCQUNoQixNQUFPMUQsT0FBT21FLEVBQUc7Z0NBQ2YsSUFBSXhELFNBQVMsR0FBRztvQ0FBRSxNQUFNOEQ7Z0NBQVc7Z0NBQ25DOUQ7Z0NBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO2dDQUN6QkEsUUFBUTs0QkFDVjs0QkFDQSxPQUFPOzRCQUNQLCtCQUErQjs0QkFDL0JELFVBQVUyRDs0QkFDVjFELFFBQVEwRDs0QkFDUixPQUFPOzRCQUNQTSxNQUFNOzRCQUNOckIsT0FBTyxLQUFNNUMsQ0FBQUEsT0FBTyxJQUFHLEdBQUcsVUFBVTs0QkFDcEMsdUJBQXVCOzRCQUN2QkEsVUFBVTs0QkFDVkMsUUFBUTt3QkFDUixPQUFPO3dCQUNUO3dCQUNBLElBQUl1QixNQUFNWixJQUFJLEdBQUdnQyxPQUFPcEIsTUFBTWQsSUFBSSxHQUFHYyxNQUFNYixLQUFLLEVBQUU7NEJBQ2hEWSxLQUFLSSxHQUFHLEdBQUc7NEJBQ1hILE1BQU10QyxJQUFJLEdBQUdWOzRCQUNiO3dCQUNGO3dCQUNBLE1BQU9vRSxPQUFROzRCQUNicEIsTUFBTVYsSUFBSSxDQUFDVSxNQUFNWixJQUFJLEdBQUcsR0FBR3FEO3dCQUM3QjtvQkFDRjtnQkFDRjtnQkFFQSxnQ0FBZ0MsR0FDaEMsSUFBSXpDLE1BQU10QyxJQUFJLEtBQUtWLEtBQUs7b0JBQUU7Z0JBQU87Z0JBRWpDLGlEQUFpRCxHQUNqRCxJQUFJZ0QsTUFBTVYsSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHO29CQUN6QlMsS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFFQTs7eUVBRWlFLEdBQ2pFZ0QsTUFBTWpCLE9BQU8sR0FBRztnQkFFaEI0RCxPQUFPO29CQUFFbEUsTUFBTXVCLE1BQU1qQixPQUFPO2dCQUFDO2dCQUM3QjJCLE1BQU10RyxjQUFjRSxNQUFNMEYsTUFBTVYsSUFBSSxFQUFFLEdBQUdVLE1BQU1kLElBQUksRUFBRWMsTUFBTW5CLE9BQU8sRUFBRSxHQUFHbUIsTUFBTVIsSUFBSSxFQUFFbUQ7Z0JBQ25GLDZFQUE2RTtnQkFDN0UsdUNBQXVDO2dCQUN2QzNDLE1BQU1qQixPQUFPLEdBQUc0RCxLQUFLbEUsSUFBSTtnQkFDekIsOEJBQThCO2dCQUU5QixJQUFJaUMsS0FBSztvQkFDUFgsS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFFQWdELE1BQU1oQixRQUFRLEdBQUc7Z0JBQ2pCLG1DQUFtQztnQkFDbkMsOEJBQThCO2dCQUM5QmdCLE1BQU1sQixRQUFRLEdBQUdrQixNQUFNTixPQUFPO2dCQUM5QmlELE9BQU87b0JBQUVsRSxNQUFNdUIsTUFBTWhCLFFBQVE7Z0JBQUM7Z0JBQzlCMEIsTUFBTXRHLGNBQWNHLE9BQU95RixNQUFNVixJQUFJLEVBQUVVLE1BQU1kLElBQUksRUFBRWMsTUFBTWIsS0FBSyxFQUFFYSxNQUFNbEIsUUFBUSxFQUFFLEdBQUdrQixNQUFNUixJQUFJLEVBQUVtRDtnQkFDL0YsNkVBQTZFO2dCQUM3RSx1Q0FBdUM7Z0JBQ3ZDM0MsTUFBTWhCLFFBQVEsR0FBRzJELEtBQUtsRSxJQUFJO2dCQUMxQiwrQkFBK0I7Z0JBRS9CLElBQUlpQyxLQUFLO29CQUNQWCxLQUFLSSxHQUFHLEdBQUc7b0JBQ1hILE1BQU10QyxJQUFJLEdBQUdWO29CQUNiO2dCQUNGO2dCQUNBLGdEQUFnRDtnQkFDaERnRCxNQUFNdEMsSUFBSSxHQUFHcEI7Z0JBQ2IsSUFBSW1GLFVBQVUvRyxTQUFTO29CQUFFLE1BQU13STtnQkFBVztZQUMxQyxpQkFBaUIsR0FDbkIsS0FBSzVHO2dCQUNIMEQsTUFBTXRDLElBQUksR0FBR25CO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILElBQUk2QyxRQUFRLEtBQUt5QyxRQUFRLEtBQUs7b0JBQzVCLG1CQUFtQjtvQkFDbkI5QixLQUFLZ0QsUUFBUSxHQUFHbkI7b0JBQ2hCN0IsS0FBS2lELFNBQVMsR0FBR25CO29CQUNqQjlCLEtBQUtrRCxPQUFPLEdBQUc1RDtvQkFDZlUsS0FBSytDLFFBQVEsR0FBRzFEO29CQUNoQlksTUFBTXhCLElBQUksR0FBR0E7b0JBQ2J3QixNQUFNdkIsSUFBSSxHQUFHQTtvQkFDYixLQUFLO29CQUNMdEUsYUFBYTRGLE1BQU1nQztvQkFDbkIsZ0JBQWdCO29CQUNoQkgsTUFBTTdCLEtBQUtnRCxRQUFRO29CQUNuQnBCLFNBQVM1QixLQUFLNEIsTUFBTTtvQkFDcEJFLE9BQU85QixLQUFLaUQsU0FBUztvQkFDckIzRCxPQUFPVSxLQUFLa0QsT0FBTztvQkFDbkJ2QixRQUFRM0IsS0FBSzJCLEtBQUs7b0JBQ2xCdEMsT0FBT1csS0FBSytDLFFBQVE7b0JBQ3BCdEUsT0FBT3dCLE1BQU14QixJQUFJO29CQUNqQkMsT0FBT3VCLE1BQU12QixJQUFJO29CQUNqQixLQUFLO29CQUVMLElBQUl1QixNQUFNdEMsSUFBSSxLQUFLNUIsTUFBTTt3QkFDdkJrRSxNQUFNSixJQUFJLEdBQUcsQ0FBQztvQkFDaEI7b0JBQ0E7Z0JBQ0Y7Z0JBQ0FJLE1BQU1KLElBQUksR0FBRztnQkFDYixPQUFTO29CQUNQc0MsT0FBT2xDLE1BQU1uQixPQUFPLENBQUNMLE9BQVEsQ0FBQyxLQUFLd0IsTUFBTWpCLE9BQU8sSUFBSSxFQUFHLEVBQUcscUJBQXFCO29CQUMvRW9ELFlBQVlELFNBQVM7b0JBQ3JCRSxVQUFVLFNBQVUsS0FBTTtvQkFDMUJDLFdBQVdILE9BQU87b0JBRWxCLElBQUlDLGFBQWExRCxNQUFNO3dCQUFFO29CQUFPO29CQUNoQyxzQkFBc0I7b0JBQ3RCLElBQUlXLFNBQVMsR0FBRzt3QkFBRSxNQUFNOEQ7b0JBQVc7b0JBQ25DOUQ7b0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO29CQUN6QkEsUUFBUTtnQkFDUixPQUFPO2dCQUNUO2dCQUNBLElBQUkyRCxXQUFXLENBQUNBLFVBQVUsSUFBRyxNQUFPLEdBQUc7b0JBQ3JDRSxZQUFZSDtvQkFDWkksVUFBVUg7b0JBQ1ZJLFdBQVdIO29CQUNYLE9BQVM7d0JBQ1BILE9BQU9sQyxNQUFNbkIsT0FBTyxDQUFDMkQsV0FDWixFQUFDaEUsT0FBUSxDQUFDLEtBQU04RCxZQUFZQyxPQUFPLElBQUssQ0FBQyxLQUFtQ0QsU0FBUSxFQUFHO3dCQUNoR0gsWUFBWUQsU0FBUzt3QkFDckJFLFVBQVUsU0FBVSxLQUFNO3dCQUMxQkMsV0FBV0gsT0FBTzt3QkFFbEIsSUFBSSxZQUFhQyxhQUFjMUQsTUFBTTs0QkFBRTt3QkFBTzt3QkFDOUMsc0JBQXNCO3dCQUN0QixJQUFJVyxTQUFTLEdBQUc7NEJBQUUsTUFBTThEO3dCQUFXO3dCQUNuQzlEO3dCQUNBWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjt3QkFDekJBLFFBQVE7b0JBQ1IsT0FBTztvQkFDVDtvQkFDQSwrQkFBK0I7b0JBQy9CRCxVQUFVOEQ7b0JBQ1Y3RCxRQUFRNkQ7b0JBQ1IsT0FBTztvQkFDUHRDLE1BQU1KLElBQUksSUFBSTBDO2dCQUNoQjtnQkFDQSwrQkFBK0I7Z0JBQy9COUQsVUFBVTJEO2dCQUNWMUQsUUFBUTBEO2dCQUNSLE9BQU87Z0JBQ1BuQyxNQUFNSixJQUFJLElBQUl1QztnQkFDZG5DLE1BQU10QixNQUFNLEdBQUcyRDtnQkFDZixJQUFJRCxZQUFZLEdBQUc7b0JBQ2pCLHdEQUF3RDtvQkFDeEQsNkNBQTZDO29CQUM3QywwREFBMEQ7b0JBQzFEcEMsTUFBTXRDLElBQUksR0FBR2Q7b0JBQ2I7Z0JBQ0Y7Z0JBQ0EsSUFBSXdGLFVBQVUsSUFBSTtvQkFDaEIsdURBQXVEO29CQUN2RHBDLE1BQU1KLElBQUksR0FBRyxDQUFDO29CQUNkSSxNQUFNdEMsSUFBSSxHQUFHNUI7b0JBQ2I7Z0JBQ0Y7Z0JBQ0EsSUFBSXNHLFVBQVUsSUFBSTtvQkFDaEJyQyxLQUFLSSxHQUFHLEdBQUc7b0JBQ1hILE1BQU10QyxJQUFJLEdBQUdWO29CQUNiO2dCQUNGO2dCQUNBZ0QsTUFBTXBCLEtBQUssR0FBR3dELFVBQVU7Z0JBQ3hCcEMsTUFBTXRDLElBQUksR0FBR2xCO1lBQ2IsaUJBQWlCLEdBQ25CLEtBQUtBO2dCQUNILElBQUl3RCxNQUFNcEIsS0FBSyxFQUFFO29CQUNmLDRCQUE0QjtvQkFDNUJnRSxJQUFJNUMsTUFBTXBCLEtBQUs7b0JBQ2YsTUFBT0gsT0FBT21FLEVBQUc7d0JBQ2YsSUFBSXhELFNBQVMsR0FBRzs0QkFBRSxNQUFNOEQ7d0JBQVc7d0JBQ25DOUQ7d0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO3dCQUN6QkEsUUFBUTtvQkFDVjtvQkFDQSxPQUFPO29CQUNQdUIsTUFBTXRCLE1BQU0sSUFBSUYsT0FBUSxDQUFDLEtBQUt3QixNQUFNcEIsS0FBSyxJQUFJLEVBQUUsbUJBQW1CO29CQUNsRSxpQ0FBaUM7b0JBQ2pDSixVQUFVd0IsTUFBTXBCLEtBQUs7b0JBQ3JCSCxRQUFRdUIsTUFBTXBCLEtBQUs7b0JBQ25CLE9BQU87b0JBQ1BvQixNQUFNSixJQUFJLElBQUlJLE1BQU1wQixLQUFLO2dCQUMzQjtnQkFDQSxrRUFBa0U7Z0JBQ2xFb0IsTUFBTUgsR0FBRyxHQUFHRyxNQUFNdEIsTUFBTTtnQkFDeEJzQixNQUFNdEMsSUFBSSxHQUFHakI7WUFDYixpQkFBaUIsR0FDbkIsS0FBS0E7Z0JBQ0gsT0FBUztvQkFDUHlGLE9BQU9sQyxNQUFNbEIsUUFBUSxDQUFDTixPQUFRLENBQUMsS0FBS3dCLE1BQU1oQixRQUFRLElBQUksRUFBRyxFQUFDLHNCQUFzQjtvQkFDaEZtRCxZQUFZRCxTQUFTO29CQUNyQkUsVUFBVSxTQUFVLEtBQU07b0JBQzFCQyxXQUFXSCxPQUFPO29CQUVsQixJQUFJLGFBQWV6RCxNQUFNO3dCQUFFO29CQUFPO29CQUNsQyxzQkFBc0I7b0JBQ3RCLElBQUlXLFNBQVMsR0FBRzt3QkFBRSxNQUFNOEQ7b0JBQVc7b0JBQ25DOUQ7b0JBQ0FaLFFBQVFrRCxLQUFLLENBQUNyQyxPQUFPLElBQUlaO29CQUN6QkEsUUFBUTtnQkFDUixPQUFPO2dCQUNUO2dCQUNBLElBQUksQ0FBQzJELFVBQVUsSUFBRyxNQUFPLEdBQUc7b0JBQzFCRSxZQUFZSDtvQkFDWkksVUFBVUg7b0JBQ1ZJLFdBQVdIO29CQUNYLE9BQVM7d0JBQ1BILE9BQU9sQyxNQUFNbEIsUUFBUSxDQUFDMEQsV0FDYixFQUFDaEUsT0FBUSxDQUFDLEtBQU04RCxZQUFZQyxPQUFPLElBQUssQ0FBQyxLQUFtQ0QsU0FBUSxFQUFHO3dCQUNoR0gsWUFBWUQsU0FBUzt3QkFDckJFLFVBQVUsU0FBVSxLQUFNO3dCQUMxQkMsV0FBV0gsT0FBTzt3QkFFbEIsSUFBSSxZQUFhQyxhQUFjMUQsTUFBTTs0QkFBRTt3QkFBTzt3QkFDOUMsc0JBQXNCO3dCQUN0QixJQUFJVyxTQUFTLEdBQUc7NEJBQUUsTUFBTThEO3dCQUFXO3dCQUNuQzlEO3dCQUNBWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjt3QkFDekJBLFFBQVE7b0JBQ1IsT0FBTztvQkFDVDtvQkFDQSwrQkFBK0I7b0JBQy9CRCxVQUFVOEQ7b0JBQ1Y3RCxRQUFRNkQ7b0JBQ1IsT0FBTztvQkFDUHRDLE1BQU1KLElBQUksSUFBSTBDO2dCQUNoQjtnQkFDQSwrQkFBK0I7Z0JBQy9COUQsVUFBVTJEO2dCQUNWMUQsUUFBUTBEO2dCQUNSLE9BQU87Z0JBQ1BuQyxNQUFNSixJQUFJLElBQUl1QztnQkFDZCxJQUFJQyxVQUFVLElBQUk7b0JBQ2hCckMsS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFDQWdELE1BQU1yQixNQUFNLEdBQUcwRDtnQkFDZnJDLE1BQU1wQixLQUFLLEdBQUcsVUFBWTtnQkFDMUJvQixNQUFNdEMsSUFBSSxHQUFHaEI7WUFDYixpQkFBaUIsR0FDbkIsS0FBS0E7Z0JBQ0gsSUFBSXNELE1BQU1wQixLQUFLLEVBQUU7b0JBQ2YsNEJBQTRCO29CQUM1QmdFLElBQUk1QyxNQUFNcEIsS0FBSztvQkFDZixNQUFPSCxPQUFPbUUsRUFBRzt3QkFDZixJQUFJeEQsU0FBUyxHQUFHOzRCQUFFLE1BQU04RDt3QkFBVzt3QkFDbkM5RDt3QkFDQVosUUFBUWtELEtBQUssQ0FBQ3JDLE9BQU8sSUFBSVo7d0JBQ3pCQSxRQUFRO29CQUNWO29CQUNBLE9BQU87b0JBQ1B1QixNQUFNckIsTUFBTSxJQUFJSCxPQUFRLENBQUMsS0FBS3dCLE1BQU1wQixLQUFLLElBQUksRUFBRSxtQkFBbUI7b0JBQ2xFLGlDQUFpQztvQkFDakNKLFVBQVV3QixNQUFNcEIsS0FBSztvQkFDckJILFFBQVF1QixNQUFNcEIsS0FBSztvQkFDbkIsT0FBTztvQkFDUG9CLE1BQU1KLElBQUksSUFBSUksTUFBTXBCLEtBQUs7Z0JBQzNCO2dCQUNSLHVCQUF1QjtnQkFDZixJQUFJb0IsTUFBTXJCLE1BQU0sR0FBR3FCLE1BQU1qQyxJQUFJLEVBQUU7b0JBQzdCZ0MsS0FBS0ksR0FBRyxHQUFHO29CQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjtvQkFDYjtnQkFDRjtnQkFDUixRQUFRO2dCQUNBLG9FQUFvRTtnQkFDcEVnRCxNQUFNdEMsSUFBSSxHQUFHZjtZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSCxJQUFJa0YsU0FBUyxHQUFHO29CQUFFLE1BQU1xQjtnQkFBVztnQkFDbkM5QixPQUFPVyxPQUFPRjtnQkFDZCxJQUFJN0IsTUFBTXJCLE1BQU0sR0FBR3lDLE1BQU07b0JBQ3ZCQSxPQUFPcEIsTUFBTXJCLE1BQU0sR0FBR3lDO29CQUN0QixJQUFJQSxPQUFPcEIsTUFBTTNCLEtBQUssRUFBRTt3QkFDdEIsSUFBSTJCLE1BQU1MLElBQUksRUFBRTs0QkFDZEksS0FBS0ksR0FBRyxHQUFHOzRCQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjs0QkFDYjt3QkFDRjtvQkFDWiwrQ0FBK0M7b0JBQy9DLDJDQUEyQztvQkFDM0MsbURBQW1EO29CQUNuRCxtREFBbUQ7b0JBQ25ELGdDQUFnQztvQkFDaEMsNkRBQTZEO29CQUM3RCw2Q0FBNkM7b0JBQzdDLHlCQUF5QjtvQkFDekIsaUNBQWlDO29CQUNqQyxnQkFBZ0I7b0JBQ2hCLGdDQUFnQztvQkFDaEMsNkJBQTZCO29CQUM3Qix5REFBeUQ7b0JBQ3pELGtCQUFrQjtvQkFDbEIsUUFBUTtvQkFDRTtvQkFDQSxJQUFJb0UsT0FBT3BCLE1BQU0xQixLQUFLLEVBQUU7d0JBQ3RCOEMsUUFBUXBCLE1BQU0xQixLQUFLO3dCQUNuQjBELE9BQU9oQyxNQUFNNUIsS0FBSyxHQUFHZ0Q7b0JBQ3ZCLE9BQ0s7d0JBQ0hZLE9BQU9oQyxNQUFNMUIsS0FBSyxHQUFHOEM7b0JBQ3ZCO29CQUNBLElBQUlBLE9BQU9wQixNQUFNdEIsTUFBTSxFQUFFO3dCQUFFMEMsT0FBT3BCLE1BQU10QixNQUFNO29CQUFFO29CQUNoRHVELGNBQWNqQyxNQUFNekIsTUFBTTtnQkFDNUIsT0FDSztvQkFDSDBELGNBQWNOO29CQUNkSyxPQUFPSixNQUFNNUIsTUFBTXJCLE1BQU07b0JBQ3pCeUMsT0FBT3BCLE1BQU10QixNQUFNO2dCQUNyQjtnQkFDQSxJQUFJMEMsT0FBT1MsTUFBTTtvQkFBRVQsT0FBT1M7Z0JBQU07Z0JBQ2hDQSxRQUFRVDtnQkFDUnBCLE1BQU10QixNQUFNLElBQUkwQztnQkFDaEIsR0FBRztvQkFDRE8sTUFBTSxDQUFDQyxNQUFNLEdBQUdLLFdBQVcsQ0FBQ0QsT0FBTztnQkFDckMsUUFBUyxFQUFFWixNQUFNO2dCQUNqQixJQUFJcEIsTUFBTXRCLE1BQU0sS0FBSyxHQUFHO29CQUFFc0IsTUFBTXRDLElBQUksR0FBR25CO2dCQUFLO2dCQUM1QztZQUNGLEtBQUtLO2dCQUNILElBQUlpRixTQUFTLEdBQUc7b0JBQUUsTUFBTXFCO2dCQUFXO2dCQUNuQ3ZCLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHNUIsTUFBTXRCLE1BQU07Z0JBQzVCbUQ7Z0JBQ0E3QixNQUFNdEMsSUFBSSxHQUFHbkI7Z0JBQ2I7WUFDRixLQUFLTTtnQkFDSCxJQUFJbUQsTUFBTXBDLElBQUksRUFBRTtvQkFDZCxtQkFBbUI7b0JBQ25CLE1BQU9hLE9BQU8sR0FBSTt3QkFDaEIsSUFBSVcsU0FBUyxHQUFHOzRCQUFFLE1BQU04RDt3QkFBVzt3QkFDbkM5RDt3QkFDQSw0REFBNEQ7d0JBQzVEWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjt3QkFDekJBLFFBQVE7b0JBQ1Y7b0JBQ0EsT0FBTztvQkFDUHNELFFBQVFGO29CQUNSOUIsS0FBS0csU0FBUyxJQUFJNkI7b0JBQ2xCL0IsTUFBTS9CLEtBQUssSUFBSThEO29CQUNmLElBQUlBLE1BQU07d0JBQ1JoQyxLQUFLSyxLQUFLLEdBQUdKLE1BQU1oQyxLQUFLLEdBQ3BCLHdDQUF3QyxHQUN2Q2dDLE1BQU1sQyxLQUFLLEdBQUc1RCxNQUFNOEYsTUFBTWhDLEtBQUssRUFBRTJELFFBQVFJLE1BQU1ILE1BQU1HLFFBQVE5SCxRQUFRK0YsTUFBTWhDLEtBQUssRUFBRTJELFFBQVFJLE1BQU1ILE1BQU1HO29CQUU3RztvQkFDQUEsT0FBT0Y7b0JBQ1Asb0VBQW9FO29CQUNwRSxJQUFJLENBQUM3QixNQUFNbEMsS0FBSyxHQUFHVSxPQUFPakIsUUFBUWlCLEtBQUksTUFBT3dCLE1BQU1oQyxLQUFLLEVBQUU7d0JBQ3hEK0IsS0FBS0ksR0FBRyxHQUFHO3dCQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjt3QkFDYjtvQkFDRjtvQkFDQSxpQkFBaUI7b0JBQ2pCd0IsT0FBTztvQkFDUEMsT0FBTztnQkFDUCxPQUFPO2dCQUNQLHlEQUF5RDtnQkFDM0Q7Z0JBQ0F1QixNQUFNdEMsSUFBSSxHQUFHWjtZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSCxJQUFJa0QsTUFBTXBDLElBQUksSUFBSW9DLE1BQU1sQyxLQUFLLEVBQUU7b0JBQzdCLG1CQUFtQjtvQkFDbkIsTUFBT1csT0FBTyxHQUFJO3dCQUNoQixJQUFJVyxTQUFTLEdBQUc7NEJBQUUsTUFBTThEO3dCQUFXO3dCQUNuQzlEO3dCQUNBWixRQUFRa0QsS0FBSyxDQUFDckMsT0FBTyxJQUFJWjt3QkFDekJBLFFBQVE7b0JBQ1Y7b0JBQ0EsT0FBTztvQkFDUCxJQUFJRCxTQUFVd0IsQ0FBQUEsTUFBTS9CLEtBQUssR0FBRyxVQUFTLEdBQUk7d0JBQ3ZDOEIsS0FBS0ksR0FBRyxHQUFHO3dCQUNYSCxNQUFNdEMsSUFBSSxHQUFHVjt3QkFDYjtvQkFDRjtvQkFDQSxpQkFBaUI7b0JBQ2pCd0IsT0FBTztvQkFDUEMsT0FBTztnQkFDUCxPQUFPO2dCQUNQLDBEQUEwRDtnQkFDNUQ7Z0JBQ0F1QixNQUFNdEMsSUFBSSxHQUFHWDtZQUNiLGlCQUFpQixHQUNuQixLQUFLQTtnQkFDSDJELE1BQU05RjtnQkFDTixNQUFNc0k7WUFDUixLQUFLbEc7Z0JBQ0gwRCxNQUFNM0Y7Z0JBQ04sTUFBTW1JO1lBQ1IsS0FBS2pHO2dCQUNILE9BQU9qQztZQUNULEtBQUtrQztZQUNILGlCQUFpQixHQUNuQjtnQkFDRSxPQUFPcEM7UUFDWDtJQUNGO0lBRUEsdUZBQXVGO0lBRXZGOzs7OztHQUtDLEdBRUQsbUJBQW1CO0lBQ25CaUYsS0FBS2dELFFBQVEsR0FBR25CO0lBQ2hCN0IsS0FBS2lELFNBQVMsR0FBR25CO0lBQ2pCOUIsS0FBS2tELE9BQU8sR0FBRzVEO0lBQ2ZVLEtBQUsrQyxRQUFRLEdBQUcxRDtJQUNoQlksTUFBTXhCLElBQUksR0FBR0E7SUFDYndCLE1BQU12QixJQUFJLEdBQUdBO0lBQ2IsS0FBSztJQUVMLElBQUl1QixNQUFNNUIsS0FBSyxJQUFLMkQsU0FBU2hDLEtBQUtpRCxTQUFTLElBQUloRCxNQUFNdEMsSUFBSSxHQUFHVixPQUN2Q2dELENBQUFBLE1BQU10QyxJQUFJLEdBQUdiLFNBQVM0RSxVQUFVakgsUUFBTyxHQUFLO1FBQy9ELElBQUl5RyxhQUFhbEIsTUFBTUEsS0FBSzRCLE1BQU0sRUFBRTVCLEtBQUtnRCxRQUFRLEVBQUVoQixPQUFPaEMsS0FBS2lELFNBQVMsR0FBRztZQUN6RWhELE1BQU10QyxJQUFJLEdBQUdUO1lBQ2IsT0FBT2pDO1FBQ1Q7SUFDRjtJQUNBOEcsT0FBTy9CLEtBQUsrQyxRQUFRO0lBQ3BCZixRQUFRaEMsS0FBS2lELFNBQVM7SUFDdEJqRCxLQUFLRSxRQUFRLElBQUk2QjtJQUNqQi9CLEtBQUtHLFNBQVMsSUFBSTZCO0lBQ2xCL0IsTUFBTS9CLEtBQUssSUFBSThEO0lBQ2YsSUFBSS9CLE1BQU1wQyxJQUFJLElBQUltRSxNQUFNO1FBQ3RCaEMsS0FBS0ssS0FBSyxHQUFHSixNQUFNaEMsS0FBSyxHQUFHLGtEQUFrRCxHQUMxRWdDLE1BQU1sQyxLQUFLLEdBQUc1RCxNQUFNOEYsTUFBTWhDLEtBQUssRUFBRTJELFFBQVFJLE1BQU1oQyxLQUFLZ0QsUUFBUSxHQUFHaEIsUUFBUTlILFFBQVErRixNQUFNaEMsS0FBSyxFQUFFMkQsUUFBUUksTUFBTWhDLEtBQUtnRCxRQUFRLEdBQUdoQjtJQUMvSDtJQUNBaEMsS0FBS2dFLFNBQVMsR0FBRy9ELE1BQU12QixJQUFJLEdBQUl1QixDQUFBQSxNQUFNckMsSUFBSSxHQUFHLEtBQUssS0FDOUJxQyxDQUFBQSxNQUFNdEMsSUFBSSxLQUFLNUIsT0FBTyxNQUFNLEtBQzVCa0UsQ0FBQUEsTUFBTXRDLElBQUksS0FBS3BCLFFBQVEwRCxNQUFNdEMsSUFBSSxLQUFLekIsUUFBUSxNQUFNO0lBQ3ZFLElBQUksQ0FBQyxRQUFTLEtBQUs4RixTQUFTLEtBQU1OLFVBQVVqSCxRQUFPLEtBQU1rRyxRQUFRL0YsTUFBTTtRQUNyRStGLE1BQU16RjtJQUNSO0lBQ0EsT0FBT3lGO0FBQ1Q7QUFFQSxTQUFTc0QsV0FBV2pFLElBQUk7SUFFdEIsSUFBSSxDQUFDQSxRQUFRLENBQUNBLEtBQUtDLEtBQUssQ0FBQyxnQ0FBZ0MsS0FBSTtRQUMzRCxPQUFPbEY7SUFDVDtJQUVBLElBQUlrRixRQUFRRCxLQUFLQyxLQUFLO0lBQ3RCLElBQUlBLE1BQU16QixNQUFNLEVBQUU7UUFDaEJ5QixNQUFNekIsTUFBTSxHQUFHO0lBQ2pCO0lBQ0F3QixLQUFLQyxLQUFLLEdBQUc7SUFDYixPQUFPckY7QUFDVDtBQUVBLFNBQVNzSixpQkFBaUJsRSxJQUFJLEVBQUU3QixJQUFJO0lBQ2xDLElBQUk4QjtJQUVKLGVBQWUsR0FDZixJQUFJLENBQUNELFFBQVEsQ0FBQ0EsS0FBS0MsS0FBSyxFQUFFO1FBQUUsT0FBT2xGO0lBQWdCO0lBQ25Ea0YsUUFBUUQsS0FBS0MsS0FBSztJQUNsQixJQUFJLENBQUNBLE1BQU1wQyxJQUFJLEdBQUcsT0FBTyxHQUFHO1FBQUUsT0FBTzlDO0lBQWdCO0lBRXJELHlCQUF5QixHQUN6QmtGLE1BQU05QixJQUFJLEdBQUdBO0lBQ2JBLEtBQUtpRixJQUFJLEdBQUc7SUFDWixPQUFPeEk7QUFDVDtBQUVBLFNBQVN1SixxQkFBcUJuRSxJQUFJLEVBQUVvRSxVQUFVO0lBQzVDLElBQUlDLGFBQWFELFdBQVd6RixNQUFNO0lBRWxDLElBQUlzQjtJQUNKLElBQUlxRTtJQUNKLElBQUkzRDtJQUVKLGVBQWUsR0FDZixJQUFJLENBQUNYLEtBQUssYUFBYSxPQUFNLENBQUNBLEtBQUtDLEtBQUssQ0FBQyxhQUFhLEtBQUk7UUFBRSxPQUFPbEY7SUFBZ0I7SUFDbkZrRixRQUFRRCxLQUFLQyxLQUFLO0lBRWxCLElBQUlBLE1BQU1wQyxJQUFJLEtBQUssS0FBS29DLE1BQU10QyxJQUFJLEtBQUs3QixNQUFNO1FBQzNDLE9BQU9mO0lBQ1Q7SUFFQSwyQ0FBMkMsR0FDM0MsSUFBSWtGLE1BQU10QyxJQUFJLEtBQUs3QixNQUFNO1FBQ3ZCd0ksU0FBUyxHQUFHLHNCQUFzQjtRQUNsQyxxREFBcUQsR0FDckRBLFNBQVNwSyxRQUFRb0ssUUFBUUYsWUFBWUMsWUFBWTtRQUNqRCxJQUFJQyxXQUFXckUsTUFBTWhDLEtBQUssRUFBRTtZQUMxQixPQUFPakQ7UUFDVDtJQUNGO0lBQ0E7c0NBQ29DLEdBQ3BDMkYsTUFBTU8sYUFBYWxCLE1BQU1vRSxZQUFZQyxZQUFZQTtJQUNqRCxJQUFJMUQsS0FBSztRQUNQVixNQUFNdEMsSUFBSSxHQUFHVDtRQUNiLE9BQU9qQztJQUNUO0lBQ0FnRixNQUFNbkMsUUFBUSxHQUFHO0lBQ2pCLG1EQUFtRDtJQUNuRCxPQUFPbEQ7QUFDVDtBQUVBMkosb0JBQW9CLEdBQUdoRTtBQUN2QmdFLHFCQUFxQixHQUFHL0Q7QUFDeEIrRCx3QkFBd0IsR0FBR3hFO0FBQzNCd0UsbUJBQW1CLEdBQUczRDtBQUN0QjJELG9CQUFvQixHQUFHN0Q7QUFDdkI2RCxlQUFlLEdBQUc5QztBQUNsQjhDLGtCQUFrQixHQUFHTjtBQUNyQk0sd0JBQXdCLEdBQUdMO0FBQzNCSyw0QkFBNEIsR0FBR0o7QUFDL0JJLG1CQUFtQixHQUFHLHNDQUV0Qjs7Ozs7Ozs7QUFRQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL0BwZGYtbGliL3Vwbmcvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcz9jM2ViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgICAgICAgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgICAgICAgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgICAgICAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCAgPSByZXF1aXJlKCcuL2luZmZhc3QnKTtcbnZhciBpbmZsYXRlX3RhYmxlID0gcmVxdWlyZSgnLi9pbmZ0cmVlcycpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuLy92YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbi8vdmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuLy92YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG52YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xudmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuXG4vKiBTVEFURVMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgICAgSEVBRCA9IDE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1hZ2ljIGhlYWRlciAqL1xudmFyICAgIEZMQUdTID0gMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtZXRob2QgYW5kIGZsYWdzIChnemlwKSAqL1xudmFyICAgIFRJTUUgPSAzOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtb2RpZmljYXRpb24gdGltZSAoZ3ppcCkgKi9cbnZhciAgICBPUyA9IDQ7ICAgICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgZmxhZ3MgYW5kIG9wZXJhdGluZyBzeXN0ZW0gKGd6aXApICovXG52YXIgICAgRVhMRU4gPSA1OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBFWFRSQSA9IDY7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgYnl0ZXMgKGd6aXApICovXG52YXIgICAgTkFNRSA9IDc7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBmaWxlIG5hbWUgKGd6aXApICovXG52YXIgICAgQ09NTUVOVCA9IDg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGVuZCBvZiBjb21tZW50IChnemlwKSAqL1xudmFyICAgIEhDUkMgPSA5OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBoZWFkZXIgY3JjIChnemlwKSAqL1xudmFyICAgIERJQ1RJRCA9IDEwOyAgICAvKiBpOiB3YWl0aW5nIGZvciBkaWN0aW9uYXJ5IGNoZWNrIHZhbHVlICovXG52YXIgICAgRElDVCA9IDExOyAgICAgIC8qIHdhaXRpbmcgZm9yIGluZmxhdGVTZXREaWN0aW9uYXJ5KCkgY2FsbCAqL1xudmFyICAgICAgICBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xudmFyICAgICAgICBUWVBFRE8gPSAxMzsgICAgLyogaTogc2FtZSwgYnV0IHNraXAgY2hlY2sgdG8gZXhpdCBpbmZsYXRlIG9uIG5ldyBibG9jayAqL1xudmFyICAgICAgICBTVE9SRUQgPSAxNDsgICAgLyogaTogd2FpdGluZyBmb3Igc3RvcmVkIHNpemUgKGxlbmd0aCBhbmQgY29tcGxlbWVudCkgKi9cbnZhciAgICAgICAgQ09QWV8gPSAxNTsgICAgIC8qIGkvbzogc2FtZSBhcyBDT1BZIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgIENPUFkgPSAxNjsgICAgICAvKiBpL286IHdhaXRpbmcgZm9yIGlucHV0IG9yIG91dHB1dCB0byBjb3B5IHN0b3JlZCBibG9jayAqL1xudmFyICAgICAgICBUQUJMRSA9IDE3OyAgICAgLyogaTogd2FpdGluZyBmb3IgZHluYW1pYyBibG9jayB0YWJsZSBsZW5ndGhzICovXG52YXIgICAgICAgIExFTkxFTlMgPSAxODsgICAvKiBpOiB3YWl0aW5nIGZvciBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgQ09ERUxFTlMgPSAxOTsgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQgYW5kIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICAgICAgTEVOXyA9IDIwOyAgICAgIC8qIGk6IHNhbWUgYXMgTEVOIGJlbG93LCBidXQgb25seSBmaXJzdCB0aW1lIGluICovXG52YXIgICAgICAgICAgICBMRU4gPSAyMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdC9lb2IgY29kZSAqL1xudmFyICAgICAgICAgICAgTEVORVhUID0gMjI7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aCBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBESVNUID0gMjM7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgY29kZSAqL1xudmFyICAgICAgICAgICAgRElTVEVYVCA9IDI0OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIE1BVENIID0gMjU7ICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gY29weSBzdHJpbmcgKi9cbnZhciAgICAgICAgICAgIExJVCA9IDI2OyAgICAgICAvKiBvOiB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2UgdG8gd3JpdGUgbGl0ZXJhbCAqL1xudmFyICAgIENIRUNLID0gMjc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBMRU5HVEggPSAyODsgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGxlbmd0aCAoZ3ppcCkgKi9cbnZhciAgICBET05FID0gMjk7ICAgICAgLyogZmluaXNoZWQgY2hlY2ssIGRvbmUgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIE1FTSA9IDMxOyAgICAgICAvKiBnb3QgYW4gaW5mbGF0ZSgpIG1lbW9yeSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIFNZTkMgPSAzMjsgICAgICAvKiBsb29raW5nIGZvciBzeW5jaHJvbml6YXRpb24gYnl0ZXMgdG8gcmVzdGFydCBpbmZsYXRlKCkgKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAgKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9XQklUUyA9IE1BWF9XQklUUztcblxuXG5mdW5jdGlvbiB6c3dhcDMyKHEpIHtcbiAgcmV0dXJuICAoKChxID4+PiAyNCkgJiAweGZmKSArXG4gICAgICAgICAgKChxID4+PiA4KSAmIDB4ZmYwMCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYwMCkgPDwgOCkgK1xuICAgICAgICAgICgocSAmIDB4ZmYpIDw8IDI0KSk7XG59XG5cblxuZnVuY3Rpb24gSW5mbGF0ZVN0YXRlKCkge1xuICB0aGlzLm1vZGUgPSAwOyAgICAgICAgICAgICAvKiBjdXJyZW50IGluZmxhdGUgbW9kZSAqL1xuICB0aGlzLmxhc3QgPSBmYWxzZTsgICAgICAgICAgLyogdHJ1ZSBpZiBwcm9jZXNzaW5nIGxhc3QgYmxvY2sgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5oYXZlZGljdCA9IGZhbHNlOyAgICAgIC8qIHRydWUgaWYgZGljdGlvbmFyeSBwcm92aWRlZCAqL1xuICB0aGlzLmZsYWdzID0gMDsgICAgICAgICAgICAgLyogZ3ppcCBoZWFkZXIgbWV0aG9kIGFuZCBmbGFncyAoMCBpZiB6bGliKSAqL1xuICB0aGlzLmRtYXggPSAwOyAgICAgICAgICAgICAgLyogemxpYiBoZWFkZXIgbWF4IGRpc3RhbmNlIChJTkZMQVRFX1NUUklDVCkgKi9cbiAgdGhpcy5jaGVjayA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIGNoZWNrIHZhbHVlICovXG4gIHRoaXMudG90YWwgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBvdXRwdXQgY291bnQgKi9cbiAgLy8gVE9ETzogbWF5IGJlIHt9XG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgICAgICAgICAvKiB3aGVyZSB0byBzYXZlIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uICovXG5cbiAgLyogc2xpZGluZyB3aW5kb3cgKi9cbiAgdGhpcy53Yml0cyA9IDA7ICAgICAgICAgICAgIC8qIGxvZyBiYXNlIDIgb2YgcmVxdWVzdGVkIHdpbmRvdyBzaXplICovXG4gIHRoaXMud3NpemUgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdGhpcy53aGF2ZSA9IDA7ICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdGhpcy53bmV4dCA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICB0aGlzLndpbmRvdyA9IG51bGw7ICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiBuZWVkZWQgKi9cblxuICAvKiBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5ob2xkID0gMDsgICAgICAgICAgICAgIC8qIGlucHV0IGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmJpdHMgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGJpdHMgaW4gXCJpblwiICovXG5cbiAgLyogZm9yIHN0cmluZyBhbmQgc3RvcmVkIGJsb2NrIGNvcHlpbmcgKi9cbiAgdGhpcy5sZW5ndGggPSAwOyAgICAgICAgICAgIC8qIGxpdGVyYWwgb3IgbGVuZ3RoIG9mIGRhdGEgdG8gY29weSAqL1xuICB0aGlzLm9mZnNldCA9IDA7ICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayB0byBjb3B5IHN0cmluZyBmcm9tICovXG5cbiAgLyogZm9yIHRhYmxlIGFuZCBjb2RlIGRlY29kaW5nICovXG4gIHRoaXMuZXh0cmEgPSAwOyAgICAgICAgICAgICAvKiBleHRyYSBiaXRzIG5lZWRlZCAqL1xuXG4gIC8qIGZpeGVkIGFuZCBkeW5hbWljIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuY29kZSA9IG51bGw7ICAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAqL1xuICB0aGlzLmRpc3Rjb2RlID0gbnVsbDsgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbiAgdGhpcy5sZW5iaXRzID0gMDsgICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGxlbmNvZGUgKi9cbiAgdGhpcy5kaXN0Yml0cyA9IDA7ICAgICAgICAgIC8qIGluZGV4IGJpdHMgZm9yIGRpc3Rjb2RlICovXG5cbiAgLyogZHluYW1pYyB0YWJsZSBidWlsZGluZyAqL1xuICB0aGlzLm5jb2RlID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5sZW4gPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5uZGlzdCA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5oYXZlID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aHMgaW4gbGVuc1tdICovXG4gIHRoaXMubmV4dCA9IG51bGw7ICAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiBjb2Rlc1tdICovXG5cbiAgdGhpcy5sZW5zID0gbmV3IHV0aWxzLkJ1ZjE2KDMyMCk7IC8qIHRlbXBvcmFyeSBzdG9yYWdlIGZvciBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy53b3JrID0gbmV3IHV0aWxzLkJ1ZjE2KDI4OCk7IC8qIHdvcmsgYXJlYSBmb3IgY29kZSB0YWJsZSBidWlsZGluZyAqL1xuXG4gIC8qXG4gICBiZWNhdXNlIHdlIGRvbid0IGhhdmUgcG9pbnRlcnMgaW4ganMsIHdlIHVzZSBsZW5jb2RlIGFuZCBkaXN0Y29kZSBkaXJlY3RseVxuICAgYXMgYnVmZmVycyBzbyB3ZSBkb24ndCBuZWVkIGNvZGVzXG4gICovXG4gIC8vdGhpcy5jb2RlcyA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0gpOyAgICAgICAvKiBzcGFjZSBmb3IgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5keW4gPSBudWxsOyAgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLmRpc3RkeW4gPSBudWxsOyAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuc2FuZSA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGlmIGZhbHNlLCBhbGxvdyBpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgKi9cbiAgdGhpcy5iYWNrID0gMDsgICAgICAgICAgICAgICAgICAgLyogYml0cyBiYWNrIG9mIGxhc3QgdW5wcm9jZXNzZWQgbGVuZ3RoL2xpdCAqL1xuICB0aGlzLndhcyA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBpbml0aWFsIGxlbmd0aCBvZiBtYXRjaCAqL1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSBzdGF0ZS50b3RhbCA9IDA7XG4gIHN0cm0ubXNnID0gJyc7IC8qWl9OVUxMKi9cbiAgaWYgKHN0YXRlLndyYXApIHsgICAgICAgLyogdG8gc3VwcG9ydCBpbGwtY29uY2VpdmVkIEphdmEgdGVzdCBzdWl0ZSAqL1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS53cmFwICYgMTtcbiAgfVxuICBzdGF0ZS5tb2RlID0gSEVBRDtcbiAgc3RhdGUubGFzdCA9IDA7XG4gIHN0YXRlLmhhdmVkaWN0ID0gMDtcbiAgc3RhdGUuZG1heCA9IDMyNzY4O1xuICBzdGF0ZS5oZWFkID0gbnVsbC8qWl9OVUxMKi87XG4gIHN0YXRlLmhvbGQgPSAwO1xuICBzdGF0ZS5iaXRzID0gMDtcbiAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0xFTlMpO1xuICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW4gPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIX0RJU1RTKTtcblxuICBzdGF0ZS5zYW5lID0gMTtcbiAgc3RhdGUuYmFjayA9IC0xO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IHJlc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RhdGUud3NpemUgPSAwO1xuICBzdGF0ZS53aGF2ZSA9IDA7XG4gIHN0YXRlLnduZXh0ID0gMDtcbiAgcmV0dXJuIGluZmxhdGVSZXNldEtlZXAoc3RybSk7XG5cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciB3cmFwO1xuICB2YXIgc3RhdGU7XG5cbiAgLyogZ2V0IHRoZSBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBleHRyYWN0IHdyYXAgcmVxdWVzdCBmcm9tIHdpbmRvd0JpdHMgcGFyYW1ldGVyICovXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkge1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuICBlbHNlIHtcbiAgICB3cmFwID0gKHdpbmRvd0JpdHMgPj4gNCkgKyAxO1xuICAgIGlmICh3aW5kb3dCaXRzIDwgNDgpIHtcbiAgICAgIHdpbmRvd0JpdHMgJj0gMTU7XG4gICAgfVxuICB9XG5cbiAgLyogc2V0IG51bWJlciBvZiB3aW5kb3cgYml0cywgZnJlZSB3aW5kb3cgaWYgZGlmZmVyZW50ICovXG4gIGlmICh3aW5kb3dCaXRzICYmICh3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUpKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIGlmIChzdGF0ZS53aW5kb3cgIT09IG51bGwgJiYgc3RhdGUud2JpdHMgIT09IHdpbmRvd0JpdHMpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXNldCB0aGUgcmVzdCBvZiBpdCAqL1xuICBzdGF0ZS53cmFwID0gd3JhcDtcbiAgc3RhdGUud2JpdHMgPSB3aW5kb3dCaXRzO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgcmV0O1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICAvL3N0cm0ubXNnID0gWl9OVUxMOyAgICAgICAgICAgICAgICAgLyogaW4gY2FzZSB3ZSByZXR1cm4gYW4gZXJyb3IgKi9cblxuICBzdGF0ZSA9IG5ldyBJbmZsYXRlU3RhdGUoKTtcblxuICAvL2lmIChzdGF0ZSA9PT0gWl9OVUxMKSByZXR1cm4gWl9NRU1fRVJST1I7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogYWxsb2NhdGVkXFxuXCIpKTtcbiAgc3RybS5zdGF0ZSA9IHN0YXRlO1xuICBzdGF0ZS53aW5kb3cgPSBudWxsLypaX05VTEwqLztcbiAgcmV0ID0gaW5mbGF0ZVJlc2V0MihzdHJtLCB3aW5kb3dCaXRzKTtcbiAgaWYgKHJldCAhPT0gWl9PSykge1xuICAgIHN0cm0uc3RhdGUgPSBudWxsLypaX05VTEwqLztcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlSW5pdChzdHJtKSB7XG4gIHJldHVybiBpbmZsYXRlSW5pdDIoc3RybSwgREVGX1dCSVRTKTtcbn1cblxuXG4vKlxuIFJldHVybiBzdGF0ZSB3aXRoIGxlbmd0aCBhbmQgZGlzdGFuY2UgZGVjb2RpbmcgdGFibGVzIGFuZCBpbmRleCBzaXplcyBzZXQgdG9cbiBmaXhlZCBjb2RlIGRlY29kaW5nLiAgTm9ybWFsbHkgdGhpcyByZXR1cm5zIGZpeGVkIHRhYmxlcyBmcm9tIGluZmZpeGVkLmguXG4gSWYgQlVJTERGSVhFRCBpcyBkZWZpbmVkLCB0aGVuIGluc3RlYWQgdGhpcyByb3V0aW5lIGJ1aWxkcyB0aGUgdGFibGVzIHRoZVxuIGZpcnN0IHRpbWUgaXQncyBjYWxsZWQsIGFuZCByZXR1cm5zIHRob3NlIHRhYmxlcyB0aGUgZmlyc3QgdGltZSBhbmRcbiB0aGVyZWFmdGVyLiAgVGhpcyByZWR1Y2VzIHRoZSBzaXplIG9mIHRoZSBjb2RlIGJ5IGFib3V0IDJLIGJ5dGVzLCBpblxuIGV4Y2hhbmdlIGZvciBhIGxpdHRsZSBleGVjdXRpb24gdGltZS4gIEhvd2V2ZXIsIEJVSUxERklYRUQgc2hvdWxkIG5vdCBiZVxuIHVzZWQgZm9yIHRocmVhZGVkIGFwcGxpY2F0aW9ucywgc2luY2UgdGhlIHJld3JpdGluZyBvZiB0aGUgdGFibGVzIGFuZCB2aXJnaW5cbiBtYXkgbm90IGJlIHRocmVhZC1zYWZlLlxuICovXG52YXIgdmlyZ2luID0gdHJ1ZTtcblxudmFyIGxlbmZpeCwgZGlzdGZpeDsgLy8gV2UgaGF2ZSBubyBwb2ludGVycyBpbiBKUywgc28ga2VlcCB0YWJsZXMgc2VwYXJhdGVcblxuZnVuY3Rpb24gZml4ZWR0YWJsZXMoc3RhdGUpIHtcbiAgLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0YWJsZXMgaWYgZmlyc3QgY2FsbCAobWF5IG5vdCBiZSB0aHJlYWQgc2FmZSkgKi9cbiAgaWYgKHZpcmdpbikge1xuICAgIHZhciBzeW07XG5cbiAgICBsZW5maXggPSBuZXcgdXRpbHMuQnVmMzIoNTEyKTtcbiAgICBkaXN0Zml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDMyKTtcblxuICAgIC8qIGxpdGVyYWwvbGVuZ3RoIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMTQ0KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuICAgIHdoaWxlIChzeW0gPCAyNTYpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA5OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4MCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDc7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjg4KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gODsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShMRU5TLCAgc3RhdGUubGVucywgMCwgMjg4LCBsZW5maXgsICAgMCwgc3RhdGUud29yaywgeyBiaXRzOiA5IH0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHsgYml0czogNSB9KTtcblxuICAgIC8qIGRvIHRoaXMganVzdCBvbmNlICovXG4gICAgdmlyZ2luID0gZmFsc2U7XG4gIH1cblxuICBzdGF0ZS5sZW5jb2RlID0gbGVuZml4O1xuICBzdGF0ZS5sZW5iaXRzID0gOTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBkaXN0Zml4O1xuICBzdGF0ZS5kaXN0Yml0cyA9IDU7XG59XG5cblxuLypcbiBVcGRhdGUgdGhlIHdpbmRvdyB3aXRoIHRoZSBsYXN0IHdzaXplIChub3JtYWxseSAzMkspIGJ5dGVzIHdyaXR0ZW4gYmVmb3JlXG4gcmV0dXJuaW5nLiAgSWYgd2luZG93IGRvZXMgbm90IGV4aXN0IHlldCwgY3JlYXRlIGl0LiAgVGhpcyBpcyBvbmx5IGNhbGxlZFxuIHdoZW4gYSB3aW5kb3cgaXMgYWxyZWFkeSBpbiB1c2UsIG9yIHdoZW4gb3V0cHV0IGhhcyBiZWVuIHdyaXR0ZW4gZHVyaW5nIHRoaXNcbiBpbmZsYXRlIGNhbGwsIGJ1dCB0aGUgZW5kIG9mIHRoZSBkZWZsYXRlIHN0cmVhbSBoYXMgbm90IGJlZW4gcmVhY2hlZCB5ZXQuXG4gSXQgaXMgYWxzbyBjYWxsZWQgdG8gY3JlYXRlIGEgd2luZG93IGZvciBkaWN0aW9uYXJ5IGRhdGEgd2hlbiBhIGRpY3Rpb25hcnlcbiBpcyBsb2FkZWQuXG5cbiBQcm92aWRpbmcgb3V0cHV0IGJ1ZmZlcnMgbGFyZ2VyIHRoYW4gMzJLIHRvIGluZmxhdGUoKSBzaG91bGQgcHJvdmlkZSBhIHNwZWVkXG4gYWR2YW50YWdlLCBzaW5jZSBvbmx5IHRoZSBsYXN0IDMySyBvZiBvdXRwdXQgaXMgY29waWVkIHRvIHRoZSBzbGlkaW5nIHdpbmRvd1xuIHVwb24gcmV0dXJuIGZyb20gaW5mbGF0ZSgpLCBhbmQgc2luY2UgYWxsIGRpc3RhbmNlcyBhZnRlciB0aGUgZmlyc3QgMzJLIG9mXG4gb3V0cHV0IHdpbGwgZmFsbCBpbiB0aGUgb3V0cHV0IGRhdGEsIG1ha2luZyBtYXRjaCBjb3BpZXMgc2ltcGxlciBhbmQgZmFzdGVyLlxuIFRoZSBhZHZhbnRhZ2UgbWF5IGJlIGRlcGVuZGVudCBvbiB0aGUgc2l6ZSBvZiB0aGUgcHJvY2Vzc29yJ3MgZGF0YSBjYWNoZXMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZXdpbmRvdyhzdHJtLCBzcmMsIGVuZCwgY29weSkge1xuICB2YXIgZGlzdDtcbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICAvKiBpZiBpdCBoYXNuJ3QgYmVlbiBkb25lIGFscmVhZHksIGFsbG9jYXRlIHNwYWNlIGZvciB0aGUgd2luZG93ICovXG4gIGlmIChzdGF0ZS53aW5kb3cgPT09IG51bGwpIHtcbiAgICBzdGF0ZS53c2l6ZSA9IDEgPDwgc3RhdGUud2JpdHM7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gMDtcblxuICAgIHN0YXRlLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHN0YXRlLndzaXplKTtcbiAgfVxuXG4gIC8qIGNvcHkgc3RhdGUtPndzaXplIG9yIGxlc3Mgb3V0cHV0IGJ5dGVzIGludG8gdGhlIGNpcmN1bGFyIHdpbmRvdyAqL1xuICBpZiAoY29weSA+PSBzdGF0ZS53c2l6ZSkge1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgZGlzdCwgc3RhdGUud25leHQpO1xuICAgIGNvcHkgLT0gZGlzdDtcbiAgICBpZiAoY29weSkge1xuICAgICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3csIGVuZCAtIGNvcHksIGNvcHkpO1xuICAgICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGNvcHksIDApO1xuICAgICAgc3RhdGUud25leHQgPSBjb3B5O1xuICAgICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzdGF0ZS53bmV4dCArPSBkaXN0O1xuICAgICAgaWYgKHN0YXRlLnduZXh0ID09PSBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53bmV4dCA9IDA7IH1cbiAgICAgIGlmIChzdGF0ZS53aGF2ZSA8IHN0YXRlLndzaXplKSB7IHN0YXRlLndoYXZlICs9IGRpc3Q7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgaW5wdXQsIG91dHB1dDsgICAgICAgICAgLy8gaW5wdXQvb3V0cHV0IGJ1ZmZlcnNcbiAgdmFyIG5leHQ7ICAgICAgICAgICAgICAgICAgIC8qIG5leHQgaW5wdXQgSU5ERVggKi9cbiAgdmFyIHB1dDsgICAgICAgICAgICAgICAgICAgIC8qIG5leHQgb3V0cHV0IElOREVYICovXG4gIHZhciBoYXZlLCBsZWZ0OyAgICAgICAgICAgICAvKiBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogYml0IGJ1ZmZlciAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogYml0cyBpbiBiaXQgYnVmZmVyICovXG4gIHZhciBfaW4sIF9vdXQ7ICAgICAgICAgICAgICAvKiBzYXZlIHN0YXJ0aW5nIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBjb3B5OyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2Ygc3RvcmVkIG9yIG1hdGNoIGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggYnl0ZXMgZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG4gIHZhciBoZXJlID0gMDsgICAgICAgICAgICAgICAvKiBjdXJyZW50IGRlY29kaW5nIHRhYmxlIGVudHJ5ICovXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsOyAvLyBwYWtlZCBcImhlcmVcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICAvL3ZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBwYXJlbnQgdGFibGUgZW50cnkgKi9cbiAgdmFyIGxhc3RfYml0cywgbGFzdF9vcCwgbGFzdF92YWw7IC8vIHBha2VkIFwibGFzdFwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggdG8gY29weSBmb3IgcmVwZWF0cywgYml0cyB0byBkcm9wICovXG4gIHZhciByZXQ7ICAgICAgICAgICAgICAgICAgICAvKiByZXR1cm4gY29kZSAqL1xuICB2YXIgaGJ1ZiA9IG5ldyB1dGlscy5CdWY4KDQpOyAgICAvKiBidWZmZXIgZm9yIGd6aXAgaGVhZGVyIGNyYyBjYWxjdWxhdGlvbiAqL1xuICB2YXIgb3B0cztcblxuICB2YXIgbjsgLy8gdGVtcG9yYXJ5IHZhciBmb3IgTkVFRF9CSVRTXG5cbiAgdmFyIG9yZGVyID0gLyogcGVybXV0YXRpb24gb2YgY29kZSBsZW5ndGhzICovXG4gICAgWyAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1IF07XG5cblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHwgIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7IHN0YXRlLm1vZGUgPSBUWVBFRE87IH0gICAgLyogc2tpcCBjaGVjayAqL1xuXG5cbiAgLy8tLS0gTE9BRCgpIC0tLVxuICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIC8vLS0tXG5cbiAgX2luID0gaGF2ZTtcbiAgX291dCA9IGxlZnQ7XG4gIHJldCA9IFpfT0s7XG5cbiAgaW5mX2xlYXZlOiAvLyBnb3RvIGVtdWxhdGlvblxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChzdGF0ZS5tb2RlKSB7XG4gICAgICBjYXNlIEhFQUQ6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEVETztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gMC8qY3JjMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuXG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgICAoKChob2xkICYgMHhmZikvKkJJVFMoOCkqLyA8PCA4KSArIChob2xkID4+IDgpKSAlIDMxKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgICBpZiAoc3RhdGUud2JpdHMgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPiBzdGF0ZS53Yml0cykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgemxpYiBoZWFkZXIgb2tcXG5cIikpO1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZMQUdTOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzICYgMHhmZikgIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGhlYWRlciBmbGFncyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gVElNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUSU1FOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnRpbWUgPSBob2xkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzQoc3RhdGUuY2hlY2ssIGhvbGQpXG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIGhidWZbMl0gPSAoaG9sZCA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgICAgLy89PT1cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IE9TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE9TOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLnhmbGFncyA9IChob2xkICYgMHhmZik7XG4gICAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWExFTjpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBFWFRSQTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBFWFRSQTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICghc3RhdGUuaGVhZC5leHRyYSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbnQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgICAgLy8gLSBubyBuZWVkIGZvciBhZGRpdGlvbmFsIHNpemUgY2hlY2tcbiAgICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgICAgbGVuXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgICAvLyAgICAgICAgbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4ID9cbiAgICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTkFNRTpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5uYW1lX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT01NRU5UO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPTU1FTlQ6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MTAwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEhDUkM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgSENSQzpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLmNoZWNrICYgMHhmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICAgIHN0YXRlLmhlYWQuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUNUSUQ6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElDVDpcbiAgICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICAgIH1cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFOlxuICAgICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRURPOlxuICAgICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICAgIGJpdHMgLT0gMTtcbiAgICAgICAgLy8tLS0vL1xuXG4gICAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNUT1JFRDpcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWV86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFk6XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRBQkxFOlxuICAgICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPREVMRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07LypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhlcmVfdmFsIDwgMTYpIHtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMik7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGVuID0gc3RhdGUubGVuc1tzdGF0ZS5oYXZlIC0gMV07XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDM7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDc7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGxlbiA9IDA7XG4gICAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gNztcbiAgICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNvcHktLSkge1xuICAgICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gQkFEKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgICAgY29uY2VybmluZyB0aGUgRU5PVUdIIGNvbnN0YW50cywgd2hpY2ggZGVwZW5kIG9uIHRob3NlIHZhbHVlcyAqL1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoTEVOUywgc3RhdGUubGVucywgMCwgc3RhdGUubmxlbiwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5fOlxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTjpcbiAgICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgICAvLy0tLVxuXG4gICAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOyAgLypCSVRTKHN0YXRlLmxlbmJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYmIChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgICAgaWYgKGhlcmVfb3AgPT09IDApIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZXh0cmEgPSBoZXJlX29wICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVORVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1Q6XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxKV07LypCSVRTKHN0YXRlLmRpc3RiaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBESVNURVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJU1RFWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBNQVRDSDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExJVDpcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIGxlZnQtLTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENIRUNLOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIC8vIFVzZSAnfCcgaW5zdGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgICB9XG4gICAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IHpzd2FwMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkdUSDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBET05FOlxuICAgICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgQkFEOlxuICAgICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgIGNhc2UgTUVNOlxuICAgICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgICBjYXNlIFNZTkM6XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsImFkbGVyMzIiLCJjcmMzMiIsImluZmxhdGVfZmFzdCIsImluZmxhdGVfdGFibGUiLCJDT0RFUyIsIkxFTlMiLCJESVNUUyIsIlpfRklOSVNIIiwiWl9CTE9DSyIsIlpfVFJFRVMiLCJaX09LIiwiWl9TVFJFQU1fRU5EIiwiWl9ORUVEX0RJQ1QiLCJaX1NUUkVBTV9FUlJPUiIsIlpfREFUQV9FUlJPUiIsIlpfTUVNX0VSUk9SIiwiWl9CVUZfRVJST1IiLCJaX0RFRkxBVEVEIiwiSEVBRCIsIkZMQUdTIiwiVElNRSIsIk9TIiwiRVhMRU4iLCJFWFRSQSIsIk5BTUUiLCJDT01NRU5UIiwiSENSQyIsIkRJQ1RJRCIsIkRJQ1QiLCJUWVBFIiwiVFlQRURPIiwiU1RPUkVEIiwiQ09QWV8iLCJDT1BZIiwiVEFCTEUiLCJMRU5MRU5TIiwiQ09ERUxFTlMiLCJMRU5fIiwiTEVOIiwiTEVORVhUIiwiRElTVCIsIkRJU1RFWFQiLCJNQVRDSCIsIkxJVCIsIkNIRUNLIiwiTEVOR1RIIiwiRE9ORSIsIkJBRCIsIk1FTSIsIlNZTkMiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIk1BWF9XQklUUyIsIkRFRl9XQklUUyIsInpzd2FwMzIiLCJxIiwiSW5mbGF0ZVN0YXRlIiwibW9kZSIsImxhc3QiLCJ3cmFwIiwiaGF2ZWRpY3QiLCJmbGFncyIsImRtYXgiLCJjaGVjayIsInRvdGFsIiwiaGVhZCIsIndiaXRzIiwid3NpemUiLCJ3aGF2ZSIsInduZXh0Iiwid2luZG93IiwiaG9sZCIsImJpdHMiLCJsZW5ndGgiLCJvZmZzZXQiLCJleHRyYSIsImxlbmNvZGUiLCJkaXN0Y29kZSIsImxlbmJpdHMiLCJkaXN0Yml0cyIsIm5jb2RlIiwibmxlbiIsIm5kaXN0IiwiaGF2ZSIsIm5leHQiLCJsZW5zIiwiQnVmMTYiLCJ3b3JrIiwibGVuZHluIiwiZGlzdGR5biIsInNhbmUiLCJiYWNrIiwid2FzIiwiaW5mbGF0ZVJlc2V0S2VlcCIsInN0cm0iLCJzdGF0ZSIsInRvdGFsX2luIiwidG90YWxfb3V0IiwibXNnIiwiYWRsZXIiLCJCdWYzMiIsImluZmxhdGVSZXNldCIsImluZmxhdGVSZXNldDIiLCJ3aW5kb3dCaXRzIiwiaW5mbGF0ZUluaXQyIiwicmV0IiwiaW5mbGF0ZUluaXQiLCJ2aXJnaW4iLCJsZW5maXgiLCJkaXN0Zml4IiwiZml4ZWR0YWJsZXMiLCJzeW0iLCJ1cGRhdGV3aW5kb3ciLCJzcmMiLCJlbmQiLCJjb3B5IiwiZGlzdCIsIkJ1ZjgiLCJhcnJheVNldCIsImluZmxhdGUiLCJmbHVzaCIsImlucHV0Iiwib3V0cHV0IiwicHV0IiwibGVmdCIsIl9pbiIsIl9vdXQiLCJmcm9tIiwiZnJvbV9zb3VyY2UiLCJoZXJlIiwiaGVyZV9iaXRzIiwiaGVyZV9vcCIsImhlcmVfdmFsIiwibGFzdF9iaXRzIiwibGFzdF9vcCIsImxhc3RfdmFsIiwibGVuIiwiaGJ1ZiIsIm9wdHMiLCJuIiwib3JkZXIiLCJhdmFpbF9pbiIsIm5leHRfb3V0IiwiYXZhaWxfb3V0IiwibmV4dF9pbiIsImluZl9sZWF2ZSIsImRvbmUiLCJ0ZXh0IiwidGltZSIsInhmbGFncyIsIm9zIiwiZXh0cmFfbGVuIiwiQXJyYXkiLCJuYW1lIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiY29tbWVudCIsImhjcmMiLCJkYXRhX3R5cGUiLCJpbmZsYXRlRW5kIiwiaW5mbGF0ZUdldEhlYWRlciIsImluZmxhdGVTZXREaWN0aW9uYXJ5IiwiZGljdGlvbmFyeSIsImRpY3RMZW5ndGgiLCJkaWN0aWQiLCJleHBvcnRzIiwiaW5mbGF0ZUluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nvar utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar lbase = [\n    /* Length codes 257..285 base */ 3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    13,\n    15,\n    17,\n    19,\n    23,\n    27,\n    31,\n    35,\n    43,\n    51,\n    59,\n    67,\n    83,\n    99,\n    115,\n    131,\n    163,\n    195,\n    227,\n    258,\n    0,\n    0\n];\nvar lext = [\n    /* Length codes 257..285 extra */ 16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    17,\n    17,\n    18,\n    18,\n    18,\n    18,\n    19,\n    19,\n    19,\n    19,\n    20,\n    20,\n    20,\n    20,\n    21,\n    21,\n    21,\n    21,\n    16,\n    72,\n    78\n];\nvar dbase = [\n    /* Distance codes 0..29 base */ 1,\n    2,\n    3,\n    4,\n    5,\n    7,\n    9,\n    13,\n    17,\n    25,\n    33,\n    49,\n    65,\n    97,\n    129,\n    193,\n    257,\n    385,\n    513,\n    769,\n    1025,\n    1537,\n    2049,\n    3073,\n    4097,\n    6145,\n    8193,\n    12289,\n    16385,\n    24577,\n    0,\n    0\n];\nvar dext = [\n    /* Distance codes 0..29 extra */ 16,\n    16,\n    16,\n    16,\n    17,\n    17,\n    18,\n    18,\n    19,\n    19,\n    20,\n    20,\n    21,\n    21,\n    22,\n    22,\n    23,\n    23,\n    24,\n    24,\n    25,\n    25,\n    26,\n    26,\n    27,\n    27,\n    28,\n    28,\n    29,\n    29,\n    64,\n    64\n];\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n    var bits = opts.bits;\n    //here = opts.here; /* table entry for duplication */\n    var len = 0; /* a code's length in bits */ \n    var sym = 0; /* index of code symbols */ \n    var min = 0, max = 0; /* minimum and maximum code lengths */ \n    var root = 0; /* number of index bits for root table */ \n    var curr = 0; /* number of index bits for current table */ \n    var drop = 0; /* code bits to drop for sub-table */ \n    var left = 0; /* number of prefix codes available */ \n    var used = 0; /* code entries in table used */ \n    var huff = 0; /* Huffman code */ \n    var incr; /* for incrementing code, index */ \n    var fill; /* index for replicating entries */ \n    var low; /* low bits for current root entry */ \n    var mask; /* mask for low root bits */ \n    var next; /* next available space in table */ \n    var base = null; /* base value table to use */ \n    var base_index = 0;\n    //  var shoextra;    /* extra bits table to use */\n    var end; /* use base and extra for symbol > end */ \n    var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n    var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n    var extra = null;\n    var extra_index = 0;\n    var here_bits, here_op, here_val;\n    /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */ /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */ for(len = 0; len <= MAXBITS; len++){\n        count[len] = 0;\n    }\n    for(sym = 0; sym < codes; sym++){\n        count[lens[lens_index + sym]]++;\n    }\n    /* bound code lengths, force root to be within code lengths */ root = bits;\n    for(max = MAXBITS; max >= 1; max--){\n        if (count[max] !== 0) {\n            break;\n        }\n    }\n    if (root > max) {\n        root = max;\n    }\n    if (max === 0) {\n        //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n        //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n        //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        //table.op[opts.table_index] = 64;\n        //table.bits[opts.table_index] = 1;\n        //table.val[opts.table_index++] = 0;\n        table[table_index++] = 1 << 24 | 64 << 16 | 0;\n        opts.bits = 1;\n        return 0; /* no symbols, but wait for decoding to report error */ \n    }\n    for(min = 1; min < max; min++){\n        if (count[min] !== 0) {\n            break;\n        }\n    }\n    if (root < min) {\n        root = min;\n    }\n    /* check for an over-subscribed or incomplete set of lengths */ left = 1;\n    for(len = 1; len <= MAXBITS; len++){\n        left <<= 1;\n        left -= count[len];\n        if (left < 0) {\n            return -1;\n        } /* over-subscribed */ \n    }\n    if (left > 0 && (type === CODES || max !== 1)) {\n        return -1; /* incomplete set */ \n    }\n    /* generate offsets into symbol table for each length for sorting */ offs[1] = 0;\n    for(len = 1; len < MAXBITS; len++){\n        offs[len + 1] = offs[len] + count[len];\n    }\n    /* sort symbols by length, by symbol order within each length */ for(sym = 0; sym < codes; sym++){\n        if (lens[lens_index + sym] !== 0) {\n            work[offs[lens[lens_index + sym]]++] = sym;\n        }\n    }\n    /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */ /* set up for code type */ // poor man optimization - use if-else instead of switch,\n    // to avoid deopts in old v8\n    if (type === CODES) {\n        base = extra = work; /* dummy value--not used */ \n        end = 19;\n    } else if (type === LENS) {\n        base = lbase;\n        base_index -= 257;\n        extra = lext;\n        extra_index -= 257;\n        end = 256;\n    } else {\n        base = dbase;\n        extra = dext;\n        end = -1;\n    }\n    /* initialize opts for loop */ huff = 0; /* starting code */ \n    sym = 0; /* starting code symbol */ \n    len = min; /* starting code length */ \n    next = table_index; /* current table to fill in */ \n    curr = root; /* current table index bits */ \n    drop = 0; /* current bits to drop from code for index */ \n    low = -1; /* trigger new sub-table when len > root */ \n    used = 1 << root; /* use root table entries */ \n    mask = used - 1; /* mask for comparing low */ \n    /* check available table space */ if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n        return 1;\n    }\n    /* process all codes and make table entries */ for(;;){\n        /* create table entry */ here_bits = len - drop;\n        if (work[sym] < end) {\n            here_op = 0;\n            here_val = work[sym];\n        } else if (work[sym] > end) {\n            here_op = extra[extra_index + work[sym]];\n            here_val = base[base_index + work[sym]];\n        } else {\n            here_op = 32 + 64; /* end of block */ \n            here_val = 0;\n        }\n        /* replicate for those indices with low len bits equal to huff */ incr = 1 << len - drop;\n        fill = 1 << curr;\n        min = fill; /* save offset to next table */ \n        do {\n            fill -= incr;\n            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n        }while (fill !== 0);\n        /* backwards increment the len-bit code huff */ incr = 1 << len - 1;\n        while(huff & incr){\n            incr >>= 1;\n        }\n        if (incr !== 0) {\n            huff &= incr - 1;\n            huff += incr;\n        } else {\n            huff = 0;\n        }\n        /* go to next symbol, update count, len */ sym++;\n        if (--count[len] === 0) {\n            if (len === max) {\n                break;\n            }\n            len = lens[lens_index + work[sym]];\n        }\n        /* create new sub-table if needed */ if (len > root && (huff & mask) !== low) {\n            /* if first time, transition to sub-tables */ if (drop === 0) {\n                drop = root;\n            }\n            /* increment past last table */ next += min; /* here min is 1 << curr */ \n            /* determine length of next table */ curr = len - drop;\n            left = 1 << curr;\n            while(curr + drop < max){\n                left -= count[curr + drop];\n                if (left <= 0) {\n                    break;\n                }\n                curr++;\n                left <<= 1;\n            }\n            /* check for enough space */ used += 1 << curr;\n            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {\n                return 1;\n            }\n            /* point entry in root table to sub-table */ low = huff & mask;\n            /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/ table[low] = root << 24 | curr << 16 | next - table_index | 0;\n        }\n    }\n    /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */ if (huff !== 0) {\n        //table.op[next + huff] = 64;            /* invalid code marker */\n        //table.bits[next + huff] = len - drop;\n        //table.val[next + huff] = 0;\n        table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n    }\n    /* set return parameters */ //opts.table_index += used;\n    opts.bits = root;\n    return 0;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCLElBQUlDLFVBQVU7QUFDZCxJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGVBQWU7QUFDbkIsMENBQTBDO0FBRTFDLElBQUlDLFFBQVE7QUFDWixJQUFJQyxPQUFPO0FBQ1gsSUFBSUMsUUFBUTtBQUVaLElBQUlDLFFBQVE7SUFBRSw4QkFBOEIsR0FDMUM7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDckQ7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFHO0NBQzlEO0FBRUQsSUFBSUMsT0FBTztJQUFFLCtCQUErQixHQUMxQztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUM1RDtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7Q0FDekQ7QUFFRCxJQUFJQyxRQUFRO0lBQUUsNkJBQTZCLEdBQ3pDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFLO0lBQ3REO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQ2xEO0lBQU07SUFBTztJQUFPO0lBQU87SUFBRztDQUMvQjtBQUVELElBQUlDLE9BQU87SUFBRSw4QkFBOEIsR0FDekM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDNUQ7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFDcEM7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFJO0NBQ3JCO0FBRURDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxjQUFjQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUVDLElBQUk7SUFFbkcsSUFBSUMsT0FBT0QsS0FBS0MsSUFBSTtJQUNoQixxREFBcUQ7SUFFekQsSUFBSUMsTUFBTSxHQUFpQiwyQkFBMkI7SUFDdEQsSUFBSUMsTUFBTSxHQUFpQix5QkFBeUI7SUFDcEQsSUFBSUMsTUFBTSxHQUFHQyxNQUFNLEdBQVksb0NBQW9DO0lBQ25FLElBQUlDLE9BQU8sR0FBZ0IsdUNBQXVDO0lBQ2xFLElBQUlDLE9BQU8sR0FBZ0IsMENBQTBDO0lBQ3JFLElBQUlDLE9BQU8sR0FBZ0IsbUNBQW1DO0lBQzlELElBQUlDLE9BQU8sR0FBcUIsb0NBQW9DO0lBQ3BFLElBQUlDLE9BQU8sR0FBZ0IsOEJBQThCO0lBQ3pELElBQUlDLE9BQU8sR0FBZ0IsZ0JBQWdCO0lBQzNDLElBQUlDLE1BQW1CLGdDQUFnQztJQUN2RCxJQUFJQyxNQUFtQixpQ0FBaUM7SUFDeEQsSUFBSUMsS0FBbUIsbUNBQW1DO0lBQzFELElBQUlDLE1BQW1CLDBCQUEwQjtJQUNqRCxJQUFJQyxNQUFrQixpQ0FBaUM7SUFDdkQsSUFBSUMsT0FBTyxNQUFVLDJCQUEyQjtJQUNoRCxJQUFJQyxhQUFhO0lBQ25CLGtEQUFrRDtJQUNoRCxJQUFJQyxLQUF3Qix1Q0FBdUM7SUFDbkUsSUFBSUMsUUFBUSxJQUFJMUMsTUFBTTJDLEtBQUssQ0FBQ3pDLFVBQVUsSUFBSSxzREFBc0Q7SUFDaEcsSUFBSTBDLE9BQU8sSUFBSTVDLE1BQU0yQyxLQUFLLENBQUN6QyxVQUFVLElBQUkseURBQXlEO0lBQ2xHLElBQUkyQyxRQUFRO0lBQ1osSUFBSUMsY0FBYztJQUVsQixJQUFJQyxXQUFXQyxTQUFTQztJQUV4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2QkMsR0FFRCxtRUFBbUUsR0FDbkUsSUFBS3pCLE1BQU0sR0FBR0EsT0FBT3RCLFNBQVNzQixNQUFPO1FBQ25Da0IsS0FBSyxDQUFDbEIsSUFBSSxHQUFHO0lBQ2Y7SUFDQSxJQUFLQyxNQUFNLEdBQUdBLE1BQU1QLE9BQU9PLE1BQU87UUFDaENpQixLQUFLLENBQUMxQixJQUFJLENBQUNDLGFBQWFRLElBQUksQ0FBQztJQUMvQjtJQUVBLDREQUE0RCxHQUM1REcsT0FBT0w7SUFDUCxJQUFLSSxNQUFNekIsU0FBU3lCLE9BQU8sR0FBR0EsTUFBTztRQUNuQyxJQUFJZSxLQUFLLENBQUNmLElBQUksS0FBSyxHQUFHO1lBQUU7UUFBTztJQUNqQztJQUNBLElBQUlDLE9BQU9ELEtBQUs7UUFDZEMsT0FBT0Q7SUFDVDtJQUNBLElBQUlBLFFBQVEsR0FBRztRQUNiLDBGQUEwRjtRQUMxRixnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFUixLQUFLLENBQUNDLGNBQWMsR0FBRyxLQUFNLEtBQU8sTUFBTSxLQUFNO1FBR2hELGtDQUFrQztRQUNsQyxtQ0FBbUM7UUFDbkMsb0NBQW9DO1FBQ3BDRCxLQUFLLENBQUNDLGNBQWMsR0FBRyxLQUFNLEtBQU8sTUFBTSxLQUFNO1FBRWhERSxLQUFLQyxJQUFJLEdBQUc7UUFDWixPQUFPLEdBQU8scURBQXFEO0lBQ3JFO0lBQ0EsSUFBS0csTUFBTSxHQUFHQSxNQUFNQyxLQUFLRCxNQUFPO1FBQzlCLElBQUlnQixLQUFLLENBQUNoQixJQUFJLEtBQUssR0FBRztZQUFFO1FBQU87SUFDakM7SUFDQSxJQUFJRSxPQUFPRixLQUFLO1FBQ2RFLE9BQU9GO0lBQ1Q7SUFFQSw2REFBNkQsR0FDN0RLLE9BQU87SUFDUCxJQUFLUCxNQUFNLEdBQUdBLE9BQU90QixTQUFTc0IsTUFBTztRQUNuQ08sU0FBUztRQUNUQSxRQUFRVyxLQUFLLENBQUNsQixJQUFJO1FBQ2xCLElBQUlPLE9BQU8sR0FBRztZQUNaLE9BQU8sQ0FBQztRQUNWLEVBQVMsbUJBQW1CO0lBQzlCO0lBQ0EsSUFBSUEsT0FBTyxLQUFNaEIsQ0FBQUEsU0FBU1YsU0FBU3NCLFFBQVEsSUFBSTtRQUM3QyxPQUFPLENBQUMsR0FBd0Isa0JBQWtCO0lBQ3BEO0lBRUEsa0VBQWtFLEdBQ2xFaUIsSUFBSSxDQUFDLEVBQUUsR0FBRztJQUNWLElBQUtwQixNQUFNLEdBQUdBLE1BQU10QixTQUFTc0IsTUFBTztRQUNsQ29CLElBQUksQ0FBQ3BCLE1BQU0sRUFBRSxHQUFHb0IsSUFBSSxDQUFDcEIsSUFBSSxHQUFHa0IsS0FBSyxDQUFDbEIsSUFBSTtJQUN4QztJQUVBLDhEQUE4RCxHQUM5RCxJQUFLQyxNQUFNLEdBQUdBLE1BQU1QLE9BQU9PLE1BQU87UUFDaEMsSUFBSVQsSUFBSSxDQUFDQyxhQUFhUSxJQUFJLEtBQUssR0FBRztZQUNoQ0osSUFBSSxDQUFDdUIsSUFBSSxDQUFDNUIsSUFBSSxDQUFDQyxhQUFhUSxJQUFJLENBQUMsR0FBRyxHQUFHQTtRQUN6QztJQUNGO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBNkJDLEdBRUQsd0JBQXdCLEdBQ3hCLHlEQUF5RDtJQUN6RCw0QkFBNEI7SUFDNUIsSUFBSVYsU0FBU1YsT0FBTztRQUNsQmtDLE9BQU9NLFFBQVF4QixNQUFTLHlCQUF5QjtRQUNqRG9CLE1BQU07SUFFUixPQUFPLElBQUkxQixTQUFTVCxNQUFNO1FBQ3hCaUMsT0FBTy9CO1FBQ1BnQyxjQUFjO1FBQ2RLLFFBQVFwQztRQUNScUMsZUFBZTtRQUNmTCxNQUFNO0lBRVIsT0FBTztRQUNMRixPQUFPN0I7UUFDUG1DLFFBQVFsQztRQUNSOEIsTUFBTSxDQUFDO0lBQ1Q7SUFFQSw0QkFBNEIsR0FDNUJSLE9BQU8sR0FBcUIsaUJBQWlCO0lBQzdDUixNQUFNLEdBQXNCLHdCQUF3QjtJQUNwREQsTUFBTUUsS0FBc0Isd0JBQXdCO0lBQ3BEWSxPQUFPbEIsYUFBMEIsNEJBQTRCO0lBQzdEUyxPQUFPRCxNQUFxQiw0QkFBNEI7SUFDeERFLE9BQU8sR0FBcUIsNENBQTRDO0lBQ3hFTSxNQUFNLENBQUMsR0FBcUIseUNBQXlDO0lBQ3JFSixPQUFPLEtBQUtKLE1BQWUsMEJBQTBCO0lBQ3JEUyxPQUFPTCxPQUFPLEdBQWMsMEJBQTBCO0lBRXRELCtCQUErQixHQUMvQixJQUFJLFNBQVUxQixRQUFRMEIsT0FBTzdCLGVBQzFCWSxTQUFTUixTQUFTeUIsT0FBTzVCLGNBQWU7UUFDekMsT0FBTztJQUNUO0lBRUEsNENBQTRDLEdBQzVDLE9BQVM7UUFDUCxzQkFBc0IsR0FDdEIyQyxZQUFZdkIsTUFBTU07UUFDbEIsSUFBSVQsSUFBSSxDQUFDSSxJQUFJLEdBQUdnQixLQUFLO1lBQ25CTyxVQUFVO1lBQ1ZDLFdBQVc1QixJQUFJLENBQUNJLElBQUk7UUFDdEIsT0FDSyxJQUFJSixJQUFJLENBQUNJLElBQUksR0FBR2dCLEtBQUs7WUFDeEJPLFVBQVVILEtBQUssQ0FBQ0MsY0FBY3pCLElBQUksQ0FBQ0ksSUFBSSxDQUFDO1lBQ3hDd0IsV0FBV1YsSUFBSSxDQUFDQyxhQUFhbkIsSUFBSSxDQUFDSSxJQUFJLENBQUM7UUFDekMsT0FDSztZQUNIdUIsVUFBVSxLQUFLLElBQVksZ0JBQWdCO1lBQzNDQyxXQUFXO1FBQ2I7UUFFQSwrREFBK0QsR0FDL0RmLE9BQU8sS0FBTVYsTUFBTU07UUFDbkJLLE9BQU8sS0FBS047UUFDWkgsTUFBTVMsTUFBc0IsNkJBQTZCO1FBQ3pELEdBQUc7WUFDREEsUUFBUUQ7WUFDUmYsS0FBSyxDQUFDbUIsT0FBUUwsQ0FBQUEsUUFBUUgsSUFBRyxJQUFLSyxLQUFLLEdBQUcsYUFBYyxLQUFPYSxXQUFXLEtBQU1DLFdBQVU7UUFDeEYsUUFBU2QsU0FBUyxHQUFHO1FBRXJCLDZDQUE2QyxHQUM3Q0QsT0FBTyxLQUFNVixNQUFNO1FBQ25CLE1BQU9TLE9BQU9DLEtBQU07WUFDbEJBLFNBQVM7UUFDWDtRQUNBLElBQUlBLFNBQVMsR0FBRztZQUNkRCxRQUFRQyxPQUFPO1lBQ2ZELFFBQVFDO1FBQ1YsT0FBTztZQUNMRCxPQUFPO1FBQ1Q7UUFFQSx3Q0FBd0MsR0FDeENSO1FBQ0EsSUFBSSxFQUFFaUIsS0FBSyxDQUFDbEIsSUFBSSxLQUFLLEdBQUc7WUFDdEIsSUFBSUEsUUFBUUcsS0FBSztnQkFBRTtZQUFPO1lBQzFCSCxNQUFNUixJQUFJLENBQUNDLGFBQWFJLElBQUksQ0FBQ0ksSUFBSSxDQUFDO1FBQ3BDO1FBRUEsa0NBQWtDLEdBQ2xDLElBQUlELE1BQU1JLFFBQVEsQ0FBQ0ssT0FBT0ksSUFBRyxNQUFPRCxLQUFLO1lBQ3ZDLDJDQUEyQyxHQUMzQyxJQUFJTixTQUFTLEdBQUc7Z0JBQ2RBLE9BQU9GO1lBQ1Q7WUFFQSw2QkFBNkIsR0FDN0JVLFFBQVFaLEtBQWdCLHlCQUF5QjtZQUVqRCxrQ0FBa0MsR0FDbENHLE9BQU9MLE1BQU1NO1lBQ2JDLE9BQU8sS0FBS0Y7WUFDWixNQUFPQSxPQUFPQyxPQUFPSCxJQUFLO2dCQUN4QkksUUFBUVcsS0FBSyxDQUFDYixPQUFPQyxLQUFLO2dCQUMxQixJQUFJQyxRQUFRLEdBQUc7b0JBQUU7Z0JBQU87Z0JBQ3hCRjtnQkFDQUUsU0FBUztZQUNYO1lBRUEsMEJBQTBCLEdBQzFCQyxRQUFRLEtBQUtIO1lBQ2IsSUFBSSxTQUFVdkIsUUFBUTBCLE9BQU83QixlQUMxQlksU0FBU1IsU0FBU3lCLE9BQU81QixjQUFlO2dCQUN6QyxPQUFPO1lBQ1Q7WUFFQSwwQ0FBMEMsR0FDMUNnQyxNQUFNSCxPQUFPSTtZQUNiOzsrQ0FFeUMsR0FDekNsQixLQUFLLENBQUNpQixJQUFJLEdBQUcsUUFBUyxLQUFPUCxRQUFRLEtBQU9TLE9BQU9sQixjQUFjO1FBQ25FO0lBQ0Y7SUFFQTs7b0VBRWtFLEdBQ2xFLElBQUlhLFNBQVMsR0FBRztRQUNkLGtFQUFrRTtRQUNsRSx1Q0FBdUM7UUFDdkMsNkJBQTZCO1FBQzdCZCxLQUFLLENBQUNtQixPQUFPTCxLQUFLLEdBQUcsTUFBUUgsUUFBUyxLQUFPLE1BQU0sS0FBSztJQUMxRDtJQUVBLHlCQUF5QixHQUN6QiwyQkFBMkI7SUFDM0JSLEtBQUtDLElBQUksR0FBR0s7SUFDWixPQUFPO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzP2Y1NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG52YXIgTUFYQklUUyA9IDE1O1xudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9IChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgQ09ERVMgPSAwO1xudmFyIExFTlMgPSAxO1xudmFyIERJU1RTID0gMjtcblxudmFyIGxiYXNlID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgYmFzZSAqL1xuICAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEzLCAxNSwgMTcsIDE5LCAyMywgMjcsIDMxLFxuICAzNSwgNDMsIDUxLCA1OSwgNjcsIDgzLCA5OSwgMTE1LCAxMzEsIDE2MywgMTk1LCAyMjcsIDI1OCwgMCwgMFxuXTtcblxudmFyIGxleHQgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTcsIDE3LCAxOCwgMTgsIDE4LCAxOCxcbiAgMTksIDE5LCAxOSwgMTksIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMTYsIDcyLCA3OFxuXTtcblxudmFyIGRiYXNlID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBiYXNlICovXG4gIDEsIDIsIDMsIDQsIDUsIDcsIDksIDEzLCAxNywgMjUsIDMzLCA0OSwgNjUsIDk3LCAxMjksIDE5MyxcbiAgMjU3LCAzODUsIDUxMywgNzY5LCAxMDI1LCAxNTM3LCAyMDQ5LCAzMDczLCA0MDk3LCA2MTQ1LFxuICA4MTkzLCAxMjI4OSwgMTYzODUsIDI0NTc3LCAwLCAwXG5dO1xuXG52YXIgZGV4dCA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE3LCAxNywgMTgsIDE4LCAxOSwgMTksIDIwLCAyMCwgMjEsIDIxLCAyMiwgMjIsXG4gIDIzLCAyMywgMjQsIDI0LCAyNSwgMjUsIDI2LCAyNiwgMjcsIDI3LFxuICAyOCwgMjgsIDI5LCAyOSwgNjQsIDY0XG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfdGFibGUodHlwZSwgbGVucywgbGVuc19pbmRleCwgY29kZXMsIHRhYmxlLCB0YWJsZV9pbmRleCwgd29yaywgb3B0cylcbntcbiAgdmFyIGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvL2hlcmUgPSBvcHRzLmhlcmU7IC8qIHRhYmxlIGVudHJ5IGZvciBkdXBsaWNhdGlvbiAqL1xuXG4gIHZhciBsZW4gPSAwOyAgICAgICAgICAgICAgIC8qIGEgY29kZSdzIGxlbmd0aCBpbiBiaXRzICovXG4gIHZhciBzeW0gPSAwOyAgICAgICAgICAgICAgIC8qIGluZGV4IG9mIGNvZGUgc3ltYm9scyAqL1xuICB2YXIgbWluID0gMCwgbWF4ID0gMDsgICAgICAgICAgLyogbWluaW11bSBhbmQgbWF4aW11bSBjb2RlIGxlbmd0aHMgKi9cbiAgdmFyIHJvb3QgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHJvb3QgdGFibGUgKi9cbiAgdmFyIGN1cnIgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIGN1cnJlbnQgdGFibGUgKi9cbiAgdmFyIGRyb3AgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBiaXRzIHRvIGRyb3AgZm9yIHN1Yi10YWJsZSAqL1xuICB2YXIgbGVmdCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBwcmVmaXggY29kZXMgYXZhaWxhYmxlICovXG4gIHZhciB1c2VkID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgZW50cmllcyBpbiB0YWJsZSB1c2VkICovXG4gIHZhciBodWZmID0gMDsgICAgICAgICAgICAgIC8qIEh1ZmZtYW4gY29kZSAqL1xuICB2YXIgaW5jcjsgICAgICAgICAgICAgIC8qIGZvciBpbmNyZW1lbnRpbmcgY29kZSwgaW5kZXggKi9cbiAgdmFyIGZpbGw7ICAgICAgICAgICAgICAvKiBpbmRleCBmb3IgcmVwbGljYXRpbmcgZW50cmllcyAqL1xuICB2YXIgbG93OyAgICAgICAgICAgICAgIC8qIGxvdyBiaXRzIGZvciBjdXJyZW50IHJvb3QgZW50cnkgKi9cbiAgdmFyIG1hc2s7ICAgICAgICAgICAgICAvKiBtYXNrIGZvciBsb3cgcm9vdCBiaXRzICovXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAvKiBuZXh0IGF2YWlsYWJsZSBzcGFjZSBpbiB0YWJsZSAqL1xuICB2YXIgYmFzZSA9IG51bGw7ICAgICAvKiBiYXNlIHZhbHVlIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgYmFzZV9pbmRleCA9IDA7XG4vLyAgdmFyIHNob2V4dHJhOyAgICAvKiBleHRyYSBiaXRzIHRhYmxlIHRvIHVzZSAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogdXNlIGJhc2UgYW5kIGV4dHJhIGZvciBzeW1ib2wgPiBlbmQgKi9cbiAgdmFyIGNvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgLyogbnVtYmVyIG9mIGNvZGVzIG9mIGVhY2ggbGVuZ3RoICovXG4gIHZhciBvZmZzID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWEJJVFMgKyAxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogY3JlYXRlIHRhYmxlIGVudHJ5ICovXG4gICAgaGVyZV9iaXRzID0gbGVuIC0gZHJvcDtcbiAgICBpZiAod29ya1tzeW1dIDwgZW5kKSB7XG4gICAgICBoZXJlX29wID0gMDtcbiAgICAgIGhlcmVfdmFsID0gd29ya1tzeW1dO1xuICAgIH1cbiAgICBlbHNlIGlmICh3b3JrW3N5bV0gPiBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSBleHRyYVtleHRyYV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgICBoZXJlX3ZhbCA9IGJhc2VbYmFzZV9pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaGVyZV9vcCA9IDMyICsgNjQ7ICAgICAgICAgLyogZW5kIG9mIGJsb2NrICovXG4gICAgICBoZXJlX3ZhbCA9IDA7XG4gICAgfVxuXG4gICAgLyogcmVwbGljYXRlIGZvciB0aG9zZSBpbmRpY2VzIHdpdGggbG93IGxlbiBiaXRzIGVxdWFsIHRvIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gZHJvcCk7XG4gICAgZmlsbCA9IDEgPDwgY3VycjtcbiAgICBtaW4gPSBmaWxsOyAgICAgICAgICAgICAgICAgLyogc2F2ZSBvZmZzZXQgdG8gbmV4dCB0YWJsZSAqL1xuICAgIGRvIHtcbiAgICAgIGZpbGwgLT0gaW5jcjtcbiAgICAgIHRhYmxlW25leHQgKyAoaHVmZiA+PiBkcm9wKSArIGZpbGxdID0gKGhlcmVfYml0cyA8PCAyNCkgfCAoaGVyZV9vcCA8PCAxNikgfCBoZXJlX3ZhbCB8MDtcbiAgICB9IHdoaWxlIChmaWxsICE9PSAwKTtcblxuICAgIC8qIGJhY2t3YXJkcyBpbmNyZW1lbnQgdGhlIGxlbi1iaXQgY29kZSBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIDEpO1xuICAgIHdoaWxlIChodWZmICYgaW5jcikge1xuICAgICAgaW5jciA+Pj0gMTtcbiAgICB9XG4gICAgaWYgKGluY3IgIT09IDApIHtcbiAgICAgIGh1ZmYgJj0gaW5jciAtIDE7XG4gICAgICBodWZmICs9IGluY3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGh1ZmYgPSAwO1xuICAgIH1cblxuICAgIC8qIGdvIHRvIG5leHQgc3ltYm9sLCB1cGRhdGUgY291bnQsIGxlbiAqL1xuICAgIHN5bSsrO1xuICAgIGlmICgtLWNvdW50W2xlbl0gPT09IDApIHtcbiAgICAgIGlmIChsZW4gPT09IG1heCkgeyBicmVhazsgfVxuICAgICAgbGVuID0gbGVuc1tsZW5zX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG5cbiAgICAvKiBjcmVhdGUgbmV3IHN1Yi10YWJsZSBpZiBuZWVkZWQgKi9cbiAgICBpZiAobGVuID4gcm9vdCAmJiAoaHVmZiAmIG1hc2spICE9PSBsb3cpIHtcbiAgICAgIC8qIGlmIGZpcnN0IHRpbWUsIHRyYW5zaXRpb24gdG8gc3ViLXRhYmxlcyAqL1xuICAgICAgaWYgKGRyb3AgPT09IDApIHtcbiAgICAgICAgZHJvcCA9IHJvb3Q7XG4gICAgICB9XG5cbiAgICAgIC8qIGluY3JlbWVudCBwYXN0IGxhc3QgdGFibGUgKi9cbiAgICAgIG5leHQgKz0gbWluOyAgICAgICAgICAgIC8qIGhlcmUgbWluIGlzIDEgPDwgY3VyciAqL1xuXG4gICAgICAvKiBkZXRlcm1pbmUgbGVuZ3RoIG9mIG5leHQgdGFibGUgKi9cbiAgICAgIGN1cnIgPSBsZW4gLSBkcm9wO1xuICAgICAgbGVmdCA9IDEgPDwgY3VycjtcbiAgICAgIHdoaWxlIChjdXJyICsgZHJvcCA8IG1heCkge1xuICAgICAgICBsZWZ0IC09IGNvdW50W2N1cnIgKyBkcm9wXTtcbiAgICAgICAgaWYgKGxlZnQgPD0gMCkgeyBicmVhazsgfVxuICAgICAgICBjdXJyKys7XG4gICAgICAgIGxlZnQgPDw9IDE7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrIGZvciBlbm91Z2ggc3BhY2UgKi9cbiAgICAgIHVzZWQgKz0gMSA8PCBjdXJyO1xuICAgICAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAgICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICAvKiBwb2ludCBlbnRyeSBpbiByb290IHRhYmxlIHRvIHN1Yi10YWJsZSAqL1xuICAgICAgbG93ID0gaHVmZiAmIG1hc2s7XG4gICAgICAvKnRhYmxlLm9wW2xvd10gPSBjdXJyO1xuICAgICAgdGFibGUuYml0c1tsb3ddID0gcm9vdDtcbiAgICAgIHRhYmxlLnZhbFtsb3ddID0gbmV4dCAtIG9wdHMudGFibGVfaW5kZXg7Ki9cbiAgICAgIHRhYmxlW2xvd10gPSAocm9vdCA8PCAyNCkgfCAoY3VyciA8PCAxNikgfCAobmV4dCAtIHRhYmxlX2luZGV4KSB8MDtcbiAgICB9XG4gIH1cblxuICAvKiBmaWxsIGluIHJlbWFpbmluZyB0YWJsZSBlbnRyeSBpZiBjb2RlIGlzIGluY29tcGxldGUgKGd1YXJhbnRlZWQgdG8gaGF2ZVxuICAgYXQgbW9zdCBvbmUgcmVtYWluaW5nIGVudHJ5LCBzaW5jZSBpZiB0aGUgY29kZSBpcyBpbmNvbXBsZXRlLCB0aGVcbiAgIG1heGltdW0gY29kZSBsZW5ndGggdGhhdCB3YXMgYWxsb3dlZCB0byBnZXQgdGhpcyBmYXIgaXMgb25lIGJpdCkgKi9cbiAgaWYgKGh1ZmYgIT09IDApIHtcbiAgICAvL3RhYmxlLm9wW25leHQgKyBodWZmXSA9IDY0OyAgICAgICAgICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbbmV4dCArIGh1ZmZdID0gbGVuIC0gZHJvcDtcbiAgICAvL3RhYmxlLnZhbFtuZXh0ICsgaHVmZl0gPSAwO1xuICAgIHRhYmxlW25leHQgKyBodWZmXSA9ICgobGVuIC0gZHJvcCkgPDwgMjQpIHwgKDY0IDw8IDE2KSB8MDtcbiAgfVxuXG4gIC8qIHNldCByZXR1cm4gcGFyYW1ldGVycyAqL1xuICAvL29wdHMudGFibGVfaW5kZXggKz0gdXNlZDtcbiAgb3B0cy5iaXRzID0gcm9vdDtcbiAgcmV0dXJuIDA7XG59O1xuIl0sIm5hbWVzIjpbInV0aWxzIiwicmVxdWlyZSIsIk1BWEJJVFMiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIkNPREVTIiwiTEVOUyIsIkRJU1RTIiwibGJhc2UiLCJsZXh0IiwiZGJhc2UiLCJkZXh0IiwibW9kdWxlIiwiZXhwb3J0cyIsImluZmxhdGVfdGFibGUiLCJ0eXBlIiwibGVucyIsImxlbnNfaW5kZXgiLCJjb2RlcyIsInRhYmxlIiwidGFibGVfaW5kZXgiLCJ3b3JrIiwib3B0cyIsImJpdHMiLCJsZW4iLCJzeW0iLCJtaW4iLCJtYXgiLCJyb290IiwiY3VyciIsImRyb3AiLCJsZWZ0IiwidXNlZCIsImh1ZmYiLCJpbmNyIiwiZmlsbCIsImxvdyIsIm1hc2siLCJuZXh0IiwiYmFzZSIsImJhc2VfaW5kZXgiLCJlbmQiLCJjb3VudCIsIkJ1ZjE2Iiwib2ZmcyIsImV4dHJhIiwiZXh0cmFfaW5kZXgiLCJoZXJlX2JpdHMiLCJoZXJlX29wIiwiaGVyZV92YWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/inftrees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js ***!
  \***************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nmodule.exports = {\n    2: \"need dictionary\",\n    /* Z_NEED_DICT       2  */ 1: \"stream end\",\n    /* Z_STREAM_END      1  */ 0: \"\",\n    /* Z_OK              0  */ \"-1\": \"file error\",\n    /* Z_ERRNO         (-1) */ \"-2\": \"stream error\",\n    /* Z_STREAM_ERROR  (-2) */ \"-3\": \"data error\",\n    /* Z_DATA_ERROR    (-3) */ \"-4\": \"insufficient memory\",\n    /* Z_MEM_ERROR     (-4) */ \"-5\": \"buffer error\",\n    /* Z_BUF_ERROR     (-5) */ \"-6\": \"incompatible version\" /* Z_VERSION_ERROR (-6) */ \n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFQSxPQUFPQyxPQUFPLEdBQUc7SUFDZixHQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxHQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxHQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRO0lBQXVCLHdCQUF3QixHQUN2RCxNQUFRLHVCQUF1Qix3QkFBd0I7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzP2E2ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js":
/*!************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n/* eslint-disable space-unary-ops */ var utils = __webpack_require__(/*! ../utils/common */ \"(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/utils/common.js\");\n/* Public constants ==========================================================*/ /* ===========================================================================*/ //var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n/* Possible values of the data_type field (though see inflate()) */ var Z_BINARY = 0;\nvar Z_TEXT = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN = 2;\n/*============================================================================*/ function zero(buf) {\n    var len = buf.length;\n    while(--len >= 0){\n        buf[len] = 0;\n    }\n}\n// From zutil.h\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\n/* The three kinds of block type */ var MIN_MATCH = 3;\nvar MAX_MATCH = 258;\n/* The minimum and maximum match lengths */ // From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */ var LENGTH_CODES = 29;\n/* number of length codes, not counting the special END_BLOCK code */ var LITERALS = 256;\n/* number of literal bytes 0..255 */ var L_CODES = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */ var D_CODES = 30;\n/* number of distance codes */ var BL_CODES = 19;\n/* number of codes used to transfer the bit lengths */ var HEAP_SIZE = 2 * L_CODES + 1;\n/* maximum heap size */ var MAX_BITS = 15;\n/* All codes must not exceed MAX_BITS bits */ var Buf_size = 16;\n/* size of bit buffer in bi_buf */ /* ===========================================================================\n * Constants\n */ var MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */ var END_BLOCK = 256;\n/* end of block literal code */ var REP_3_6 = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */ var REPZ_3_10 = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */ var REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */ /* eslint-disable comma-spacing,array-bracket-spacing */ var extra_lbits = /* extra bits for each length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0\n];\nvar extra_dbits = /* extra bits for each distance code */ [\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13\n];\nvar extra_blbits = /* extra bits for each bit length code */ [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    2,\n    3,\n    7\n];\nvar bl_order = [\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n];\n/* eslint-enable comma-spacing,array-bracket-spacing */ /* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */ /* ===========================================================================\n * Local data. These are initialized only once.\n */ // We pre-fill arrays with 0 to avoid uninitialized gaps\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */ \n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */ var static_dtree = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */ var _dist_code = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */ var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */ var base_length = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */ var base_dist = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */ function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n    this.static_tree = static_tree; /* static tree or NULL */ \n    this.extra_bits = extra_bits; /* extra bits for each code or NULL */ \n    this.extra_base = extra_base; /* base index for extra_bits */ \n    this.elems = elems; /* max number of elements in the tree */ \n    this.max_length = max_length; /* max bit length for the codes */ \n    // show if `static_tree` has data or dummy - needed for monomorphic objects\n    this.has_stree = static_tree && static_tree.length;\n}\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\nfunction TreeDesc(dyn_tree, stat_desc) {\n    this.dyn_tree = dyn_tree; /* the dynamic tree */ \n    this.max_code = 0; /* largest code with non zero frequency */ \n    this.stat_desc = stat_desc; /* the corresponding static tree */ \n}\nfunction d_code(dist) {\n    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */ function put_short(s, w) {\n    //    put_byte(s, (uch)((w) & 0xff));\n    //    put_byte(s, (uch)((ush)(w) >> 8));\n    s.pending_buf[s.pending++] = w & 0xff;\n    s.pending_buf[s.pending++] = w >>> 8 & 0xff;\n}\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */ function send_bits(s, value, length) {\n    if (s.bi_valid > Buf_size - length) {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        put_short(s, s.bi_buf);\n        s.bi_buf = value >> Buf_size - s.bi_valid;\n        s.bi_valid += length - Buf_size;\n    } else {\n        s.bi_buf |= value << s.bi_valid & 0xffff;\n        s.bi_valid += length;\n    }\n}\nfunction send_code(s, c, tree) {\n    send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n}\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */ function bi_reverse(code, len) {\n    var res = 0;\n    do {\n        res |= code & 1;\n        code >>>= 1;\n        res <<= 1;\n    }while (--len > 0);\n    return res >>> 1;\n}\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */ function bi_flush(s) {\n    if (s.bi_valid === 16) {\n        put_short(s, s.bi_buf);\n        s.bi_buf = 0;\n        s.bi_valid = 0;\n    } else if (s.bi_valid >= 8) {\n        s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n        s.bi_buf >>= 8;\n        s.bi_valid -= 8;\n    }\n}\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */ function gen_bitlen(s, desc) //    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var max_code = desc.max_code;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var extra = desc.stat_desc.extra_bits;\n    var base = desc.stat_desc.extra_base;\n    var max_length = desc.stat_desc.max_length;\n    var h; /* heap index */ \n    var n, m; /* iterate over the tree elements */ \n    var bits; /* bit length */ \n    var xbits; /* extra bits */ \n    var f; /* frequency */ \n    var overflow = 0; /* number of elements with bit length too large */ \n    for(bits = 0; bits <= MAX_BITS; bits++){\n        s.bl_count[bits] = 0;\n    }\n    /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */ tree[s.heap[s.heap_max] * 2 + 1] = 0; /* root of the heap */ \n    for(h = s.heap_max + 1; h < HEAP_SIZE; h++){\n        n = s.heap[h];\n        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n        if (bits > max_length) {\n            bits = max_length;\n            overflow++;\n        }\n        tree[n * 2 + 1] = bits;\n        /* We overwrite tree[n].Dad which is no longer needed */ if (n > max_code) {\n            continue;\n        } /* not a leaf node */ \n        s.bl_count[bits]++;\n        xbits = 0;\n        if (n >= base) {\n            xbits = extra[n - base];\n        }\n        f = tree[n * 2] /*.Freq*/ ;\n        s.opt_len += f * (bits + xbits);\n        if (has_stree) {\n            s.static_len += f * (stree[n * 2 + 1] + xbits);\n        }\n    }\n    if (overflow === 0) {\n        return;\n    }\n    // Trace((stderr,\"\\nbit length overflow\\n\"));\n    /* This happens for example on obj2 and pic of the Calgary corpus */ /* Find the first bit length which could increase: */ do {\n        bits = max_length - 1;\n        while(s.bl_count[bits] === 0){\n            bits--;\n        }\n        s.bl_count[bits]--; /* move one leaf down the tree */ \n        s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */ \n        s.bl_count[max_length]--;\n        /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */ overflow -= 2;\n    }while (overflow > 0);\n    /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */ for(bits = max_length; bits !== 0; bits--){\n        n = s.bl_count[bits];\n        while(n !== 0){\n            m = s.heap[--h];\n            if (m > max_code) {\n                continue;\n            }\n            if (tree[m * 2 + 1] !== bits) {\n                // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2] /*.Freq*/ ;\n                tree[m * 2 + 1] = bits;\n            }\n            n--;\n        }\n    }\n}\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */ function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n    var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */ \n    var code = 0; /* running code value */ \n    var bits; /* bit index */ \n    var n; /* code index */ \n    /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */ for(bits = 1; bits <= MAX_BITS; bits++){\n        next_code[bits] = code = code + bl_count[bits - 1] << 1;\n    }\n    /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */ //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n    //        \"inconsistent bit counts\");\n    //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n    for(n = 0; n <= max_code; n++){\n        var len = tree[n * 2 + 1] /*.Len*/ ;\n        if (len === 0) {\n            continue;\n        }\n        /* Now reverse the bits */ tree[n * 2] = bi_reverse(next_code[len]++, len);\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n    }\n}\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */ function tr_static_init() {\n    var n; /* iterates over tree elements */ \n    var bits; /* bit counter */ \n    var length; /* length value */ \n    var code; /* code value */ \n    var dist; /* distance index */ \n    var bl_count = new Array(MAX_BITS + 1);\n    /* number of codes at each bit length for an optimal tree */ // do check in _tr_init()\n    //if (static_init_done) return;\n    /* For some embedded targets, global variables are not initialized: */ /*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/ /* Initialize the mapping length (0..255) -> length code (0..28) */ length = 0;\n    for(code = 0; code < LENGTH_CODES - 1; code++){\n        base_length[code] = length;\n        for(n = 0; n < 1 << extra_lbits[code]; n++){\n            _length_code[length++] = code;\n        }\n    }\n    //Assert (length == 256, \"tr_static_init: length != 256\");\n    /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */ _length_code[length - 1] = code;\n    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */ dist = 0;\n    for(code = 0; code < 16; code++){\n        base_dist[code] = dist;\n        for(n = 0; n < 1 << extra_dbits[code]; n++){\n            _dist_code[dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: dist != 256\");\n    dist >>= 7; /* from now on, all distances are divided by 128 */ \n    for(; code < D_CODES; code++){\n        base_dist[code] = dist << 7;\n        for(n = 0; n < 1 << extra_dbits[code] - 7; n++){\n            _dist_code[256 + dist++] = code;\n        }\n    }\n    //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n    /* Construct the codes of the static literal tree */ for(bits = 0; bits <= MAX_BITS; bits++){\n        bl_count[bits] = 0;\n    }\n    n = 0;\n    while(n <= 143){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    while(n <= 255){\n        static_ltree[n * 2 + 1] = 9;\n        n++;\n        bl_count[9]++;\n    }\n    while(n <= 279){\n        static_ltree[n * 2 + 1] = 7;\n        n++;\n        bl_count[7]++;\n    }\n    while(n <= 287){\n        static_ltree[n * 2 + 1] = 8;\n        n++;\n        bl_count[8]++;\n    }\n    /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */ gen_codes(static_ltree, L_CODES + 1, bl_count);\n    /* The static distance tree is trivial: */ for(n = 0; n < D_CODES; n++){\n        static_dtree[n * 2 + 1] = 5;\n        static_dtree[n * 2] = bi_reverse(n, 5);\n    }\n    // Now data ready and we can init static trees\n    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);\n    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);\n//static_init_done = true;\n}\n/* ===========================================================================\n * Initialize a new block.\n */ function init_block(s) {\n    var n; /* iterates over tree elements */ \n    /* Initialize the trees. */ for(n = 0; n < L_CODES; n++){\n        s.dyn_ltree[n * 2] = 0;\n    }\n    for(n = 0; n < D_CODES; n++){\n        s.dyn_dtree[n * 2] = 0;\n    }\n    for(n = 0; n < BL_CODES; n++){\n        s.bl_tree[n * 2] = 0;\n    }\n    s.dyn_ltree[END_BLOCK * 2] = 1;\n    s.opt_len = s.static_len = 0;\n    s.last_lit = s.matches = 0;\n}\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */ function bi_windup(s) {\n    if (s.bi_valid > 8) {\n        put_short(s, s.bi_buf);\n    } else if (s.bi_valid > 0) {\n        //put_byte(s, (Byte)s->bi_buf);\n        s.pending_buf[s.pending++] = s.bi_buf;\n    }\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n}\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */ function copy_block(s, buf, len, header) //DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n    bi_windup(s); /* align on byte boundary */ \n    if (header) {\n        put_short(s, len);\n        put_short(s, ~len);\n    }\n    //  while (len--) {\n    //    put_byte(s, *buf++);\n    //  }\n    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n    s.pending += len;\n}\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */ function smaller(tree, n, m, depth) {\n    var _n2 = n * 2;\n    var _m2 = m * 2;\n    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n}\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */ function pqdownheap(s, tree, k) //    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n    var v = s.heap[k];\n    var j = k << 1; /* left son of k */ \n    while(j <= s.heap_len){\n        /* Set j to the smallest of the two sons: */ if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n            j++;\n        }\n        /* Exit if v is smaller than both sons */ if (smaller(tree, v, s.heap[j], s.depth)) {\n            break;\n        }\n        /* Exchange v with the smallest son */ s.heap[k] = s.heap[j];\n        k = j;\n        /* And continue down the tree, setting j to the left son of k */ j <<= 1;\n    }\n    s.heap[k] = v;\n}\n// inlined manually\n// var SMALLEST = 1;\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */ function compress_block(s, ltree, dtree) //    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n    var dist; /* distance of matched string */ \n    var lc; /* match length or unmatched char (if dist == 0) */ \n    var lx = 0; /* running index in l_buf */ \n    var code; /* the code to send */ \n    var extra; /* number of extra bits to send */ \n    if (s.last_lit !== 0) {\n        do {\n            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n            lc = s.pending_buf[s.l_buf + lx];\n            lx++;\n            if (dist === 0) {\n                send_code(s, lc, ltree); /* send a literal byte */ \n            //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n            } else {\n                /* Here, lc is the match length - MIN_MATCH */ code = _length_code[lc];\n                send_code(s, code + LITERALS + 1, ltree); /* send the length code */ \n                extra = extra_lbits[code];\n                if (extra !== 0) {\n                    lc -= base_length[code];\n                    send_bits(s, lc, extra); /* send the extra length bits */ \n                }\n                dist--; /* dist is now the match distance - 1 */ \n                code = d_code(dist);\n                //Assert (code < D_CODES, \"bad d_code\");\n                send_code(s, code, dtree); /* send the distance code */ \n                extra = extra_dbits[code];\n                if (extra !== 0) {\n                    dist -= base_dist[code];\n                    send_bits(s, dist, extra); /* send the extra distance bits */ \n                }\n            } /* literal or match pair ? */ \n        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */ //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n        //       \"pendingBuf overflow\");\n        }while (lx < s.last_lit);\n    }\n    send_code(s, END_BLOCK, ltree);\n}\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */ function build_tree(s, desc) //    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n    var tree = desc.dyn_tree;\n    var stree = desc.stat_desc.static_tree;\n    var has_stree = desc.stat_desc.has_stree;\n    var elems = desc.stat_desc.elems;\n    var n, m; /* iterate over heap elements */ \n    var max_code = -1; /* largest code with non zero frequency */ \n    var node; /* new node being created */ \n    /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */ s.heap_len = 0;\n    s.heap_max = HEAP_SIZE;\n    for(n = 0; n < elems; n++){\n        if (tree[n * 2] !== 0) {\n            s.heap[++s.heap_len] = max_code = n;\n            s.depth[n] = 0;\n        } else {\n            tree[n * 2 + 1] = 0;\n        }\n    }\n    /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */ while(s.heap_len < 2){\n        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n        tree[node * 2] = 1;\n        s.depth[node] = 0;\n        s.opt_len--;\n        if (has_stree) {\n            s.static_len -= stree[node * 2 + 1] /*.Len*/ ;\n        }\n    /* node is 0 or 1 so it does not have extra bits */ }\n    desc.max_code = max_code;\n    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */ for(n = s.heap_len >> 1 /*int /2*/ ; n >= 1; n--){\n        pqdownheap(s, tree, n);\n    }\n    /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */ node = elems; /* next internal node of the tree */ \n    do {\n        //pqremove(s, tree, n);  /* n = node of least frequency */\n        /*** pqremove ***/ n = s.heap[1 /*SMALLEST*/ ];\n        s.heap[1 /*SMALLEST*/ ] = s.heap[s.heap_len--];\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n        /***/ m = s.heap[1 /*SMALLEST*/ ]; /* m = node of next least frequency */ \n        s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */ \n        s.heap[--s.heap_max] = m;\n        /* Create a new node father of n and m */ tree[node * 2] = tree[n * 2] + tree[m * 2] /*.Freq*/ ;\n        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n        tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n        /* and insert the new node in the heap */ s.heap[1 /*SMALLEST*/ ] = node++;\n        pqdownheap(s, tree, 1 /*SMALLEST*/ );\n    }while (s.heap_len >= 2);\n    s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/ ];\n    /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */ gen_bitlen(s, desc);\n    /* The field len is now set, we can generate the bit codes */ gen_codes(tree, max_code, s.bl_count);\n}\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */ function scan_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    tree[(max_code + 1) * 2 + 1] = 0xffff; /* guard */ \n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            s.bl_tree[curlen * 2] += count;\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                s.bl_tree[curlen * 2]++;\n            }\n            s.bl_tree[REP_3_6 * 2]++;\n        } else if (count <= 10) {\n            s.bl_tree[REPZ_3_10 * 2]++;\n        } else {\n            s.bl_tree[REPZ_11_138 * 2]++;\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */ function send_tree(s, tree, max_code) //    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n    var n; /* iterates over all tree elements */ \n    var prevlen = -1; /* last emitted length */ \n    var curlen; /* length of current code */ \n    var nextlen = tree[0 * 2 + 1] /*.Len*/ ; /* length of next code */ \n    var count = 0; /* repeat count of the current code */ \n    var max_count = 7; /* max repeat count */ \n    var min_count = 4; /* min repeat count */ \n    /* tree[max_code+1].Len = -1; */ /* guard already set */ if (nextlen === 0) {\n        max_count = 138;\n        min_count = 3;\n    }\n    for(n = 0; n <= max_code; n++){\n        curlen = nextlen;\n        nextlen = tree[(n + 1) * 2 + 1] /*.Len*/ ;\n        if (++count < max_count && curlen === nextlen) {\n            continue;\n        } else if (count < min_count) {\n            do {\n                send_code(s, curlen, s.bl_tree);\n            }while (--count !== 0);\n        } else if (curlen !== 0) {\n            if (curlen !== prevlen) {\n                send_code(s, curlen, s.bl_tree);\n                count--;\n            }\n            //Assert(count >= 3 && count <= 6, \" 3_6?\");\n            send_code(s, REP_3_6, s.bl_tree);\n            send_bits(s, count - 3, 2);\n        } else if (count <= 10) {\n            send_code(s, REPZ_3_10, s.bl_tree);\n            send_bits(s, count - 3, 3);\n        } else {\n            send_code(s, REPZ_11_138, s.bl_tree);\n            send_bits(s, count - 11, 7);\n        }\n        count = 0;\n        prevlen = curlen;\n        if (nextlen === 0) {\n            max_count = 138;\n            min_count = 3;\n        } else if (curlen === nextlen) {\n            max_count = 6;\n            min_count = 3;\n        } else {\n            max_count = 7;\n            min_count = 4;\n        }\n    }\n}\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */ function build_bl_tree(s) {\n    var max_blindex; /* index of last bit length code of non zero freq */ \n    /* Determine the bit length frequencies for literal and distance trees */ scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n    /* Build the bit length tree: */ build_tree(s, s.bl_desc);\n    /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */ /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */ for(max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--){\n        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n            break;\n        }\n    }\n    /* Update opt_len to include the bit length tree and counts */ s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n    //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n    //        s->opt_len, s->static_len));\n    return max_blindex;\n}\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */ function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n    var rank; /* index in bl_order */ \n    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n    //        \"too many codes\");\n    //Tracev((stderr, \"\\nbl counts: \"));\n    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */ \n    send_bits(s, dcodes - 1, 5);\n    send_bits(s, blcodes - 4, 4); /* not -3 as stated in appnote.txt */ \n    for(rank = 0; rank < blcodes; rank++){\n        //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n    }\n    //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */ \n    //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */ \n//Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */ function detect_data_type(s) {\n    /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */ var black_mask = 0xf3ffc07f;\n    var n;\n    /* Check for non-textual (\"black-listed\") bytes. */ for(n = 0; n <= 31; n++, black_mask >>>= 1){\n        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n            return Z_BINARY;\n        }\n    }\n    /* Check for textual (\"white-listed\") bytes. */ if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n        return Z_TEXT;\n    }\n    for(n = 32; n < LITERALS; n++){\n        if (s.dyn_ltree[n * 2] !== 0) {\n            return Z_TEXT;\n        }\n    }\n    /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */ return Z_BINARY;\n}\nvar static_init_done = false;\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */ function _tr_init(s) {\n    if (!static_init_done) {\n        tr_static_init();\n        static_init_done = true;\n    }\n    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n    /* Initialize the first block of the first file: */ init_block(s);\n}\n/* ===========================================================================\n * Send a stored block\n */ function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3); /* send block type */ \n    copy_block(s, buf, stored_len, true); /* with header */ \n}\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */ function _tr_align(s) {\n    send_bits(s, STATIC_TREES << 1, 3);\n    send_code(s, END_BLOCK, static_ltree);\n    bi_flush(s);\n}\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */ function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n    var opt_lenb, static_lenb; /* opt_len and static_len in bytes */ \n    var max_blindex = 0; /* index of last bit length code of non zero freq */ \n    /* Build the Huffman trees unless a stored block is forced */ if (s.level > 0) {\n        /* Check if the file is binary or text */ if (s.strm.data_type === Z_UNKNOWN) {\n            s.strm.data_type = detect_data_type(s);\n        }\n        /* Construct the literal and distance trees */ build_tree(s, s.l_desc);\n        // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        build_tree(s, s.d_desc);\n        // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n        //        s->static_len));\n        /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */ /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */ max_blindex = build_bl_tree(s);\n        /* Determine the best encoding. Compute the block lengths in bytes. */ opt_lenb = s.opt_len + 3 + 7 >>> 3;\n        static_lenb = s.static_len + 3 + 7 >>> 3;\n        // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n        //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n        //        s->last_lit));\n        if (static_lenb <= opt_lenb) {\n            opt_lenb = static_lenb;\n        }\n    } else {\n        // Assert(buf != (char*)0, \"lost buf\");\n        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */ \n    }\n    if (stored_len + 4 <= opt_lenb && buf !== -1) {\n        /* 4: two words for the lengths */ /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */ _tr_stored_block(s, buf, stored_len, last);\n    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n        compress_block(s, static_ltree, static_dtree);\n    } else {\n        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n        compress_block(s, s.dyn_ltree, s.dyn_dtree);\n    }\n    // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n    /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */ init_block(s);\n    if (last) {\n        bi_windup(s);\n    }\n// Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n//       s->compressed_len-7*last));\n}\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */ function _tr_tally(s, dist, lc) //    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n    //var out_length, in_length, dcode;\n    s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;\n    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n    s.last_lit++;\n    if (dist === 0) {\n        /* lc is the unmatched char */ s.dyn_ltree[lc * 2]++;\n    } else {\n        s.matches++;\n        /* Here, lc is the match length - MIN_MATCH */ dist--; /* dist = match distance - 1 */ \n        //Assert((ush)dist < (ush)MAX_DIST(s) &&\n        //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n        //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n        s.dyn_dtree[d_code(dist) * 2]++;\n    }\n    // (!) This block is disabled in zlib defaults,\n    // don't enable it for binary compatibility\n    //#ifdef TRUNCATE_BLOCK\n    //  /* Try to guess if it is profitable to stop the current block here */\n    //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n    //    /* Compute an upper bound for the compressed length */\n    //    out_length = s.last_lit*8;\n    //    in_length = s.strstart - s.block_start;\n    //\n    //    for (dcode = 0; dcode < D_CODES; dcode++) {\n    //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n    //    }\n    //    out_length >>>= 3;\n    //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n    //    //       s->last_lit, in_length, out_length,\n    //    //       100L - out_length*100L/in_length));\n    //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n    //      return true;\n    //    }\n    //  }\n    //#endif\n    return s.last_lit === s.lit_bufsize - 1;\n/* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */ }\nexports._tr_init = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUseUVBQXlFO0FBQ3pFLGlEQUFpRDtBQUNqRCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlFQUF5RTtBQUN6RSwwRUFBMEU7QUFDMUUscUNBQXFDO0FBQ3JDLDZFQUE2RTtBQUM3RSxtREFBbUQ7QUFDbkQsNkVBQTZFO0FBRTdFLGtDQUFrQyxHQUVsQyxJQUFJQSxRQUFRQyxtQkFBT0EsQ0FBQztBQUVwQiw4RUFBOEUsR0FDOUUsOEVBQThFLEdBRzlFLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLElBQUlDLFVBQXdCO0FBQzVCLDhCQUE4QjtBQUU5QixpRUFBaUUsR0FDakUsSUFBSUMsV0FBd0I7QUFDNUIsSUFBSUMsU0FBd0I7QUFDNUIsMENBQTBDO0FBQzFDLElBQUlDLFlBQXdCO0FBRTVCLDhFQUE4RSxHQUc5RSxTQUFTQyxLQUFLQyxHQUFHO0lBQUksSUFBSUMsTUFBTUQsSUFBSUUsTUFBTTtJQUFFLE1BQU8sRUFBRUQsT0FBTyxFQUFHO1FBQUVELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO0lBQUc7QUFBRTtBQUVoRixlQUFlO0FBRWYsSUFBSUUsZUFBZTtBQUNuQixJQUFJQyxlQUFlO0FBQ25CLElBQUlDLFlBQWU7QUFDbkIsaUNBQWlDLEdBRWpDLElBQUlDLFlBQWU7QUFDbkIsSUFBSUMsWUFBZTtBQUNuQix5Q0FBeUMsR0FFekMsaUJBQWlCO0FBQ2pCOztDQUVDLEdBRUQsSUFBSUMsZUFBZ0I7QUFDcEIsbUVBQW1FLEdBRW5FLElBQUlDLFdBQWdCO0FBQ3BCLGtDQUFrQyxHQUVsQyxJQUFJQyxV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d0JBQXdCO0lBQ3hCLGlFQUFpRTtJQUNqRSxrREFBa0Q7SUFDbEQsa0RBQWtEO0lBQ2xELDJGQUEyRjtJQUMzRixvQkFBb0I7SUFDcEIsT0FBTztJQUNQLEtBQUs7SUFDTCxRQUFRO0lBRU4sT0FBUUUsRUFBRXVDLFFBQVEsS0FBS3ZDLEVBQUVrRyxXQUFXLEdBQUc7QUFDdkM7OztHQUdDLEdBQ0g7QUFFQUMsZ0JBQWdCLEdBQUlkO0FBQ3BCYyx3QkFBd0IsR0FBR2I7QUFDM0JhLHVCQUF1QixHQUFJVDtBQUMzQlMsaUJBQWlCLEdBQUdGO0FBQ3BCRSxpQkFBaUIsR0FBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9AcGRmLWxpYi91cG5nL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3RyZWVzLmpzPzY5NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iXSwibmFtZXMiOlsidXRpbHMiLCJyZXF1aXJlIiwiWl9GSVhFRCIsIlpfQklOQVJZIiwiWl9URVhUIiwiWl9VTktOT1dOIiwiemVybyIsImJ1ZiIsImxlbiIsImxlbmd0aCIsIlNUT1JFRF9CTE9DSyIsIlNUQVRJQ19UUkVFUyIsIkRZTl9UUkVFUyIsIk1JTl9NQVRDSCIsIk1BWF9NQVRDSCIsIkxFTkdUSF9DT0RFUyIsIkxJVEVSQUxTIiwiTF9DT0RFUyIsIkRfQ09ERVMiLCJCTF9DT0RFUyIsIkhFQVBfU0laRSIsIk1BWF9CSVRTIiwiQnVmX3NpemUiLCJNQVhfQkxfQklUUyIsIkVORF9CTE9DSyIsIlJFUF8zXzYiLCJSRVBaXzNfMTAiLCJSRVBaXzExXzEzOCIsImV4dHJhX2xiaXRzIiwiZXh0cmFfZGJpdHMiLCJleHRyYV9ibGJpdHMiLCJibF9vcmRlciIsIkRJU1RfQ09ERV9MRU4iLCJzdGF0aWNfbHRyZWUiLCJBcnJheSIsInN0YXRpY19kdHJlZSIsIl9kaXN0X2NvZGUiLCJfbGVuZ3RoX2NvZGUiLCJiYXNlX2xlbmd0aCIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsInN0YXRpY19sX2Rlc2MiLCJzdGF0aWNfZF9kZXNjIiwic3RhdGljX2JsX2Rlc2MiLCJUcmVlRGVzYyIsImR5bl90cmVlIiwic3RhdF9kZXNjIiwibWF4X2NvZGUiLCJkX2NvZGUiLCJkaXN0IiwicHV0X3Nob3J0IiwicyIsInciLCJwZW5kaW5nX2J1ZiIsInBlbmRpbmciLCJzZW5kX2JpdHMiLCJ2YWx1ZSIsImJpX3ZhbGlkIiwiYmlfYnVmIiwic2VuZF9jb2RlIiwiYyIsInRyZWUiLCJiaV9yZXZlcnNlIiwiY29kZSIsInJlcyIsImJpX2ZsdXNoIiwiZ2VuX2JpdGxlbiIsImRlc2MiLCJzdHJlZSIsImV4dHJhIiwiYmFzZSIsImgiLCJuIiwibSIsImJpdHMiLCJ4Yml0cyIsImYiLCJvdmVyZmxvdyIsImJsX2NvdW50IiwiaGVhcCIsImhlYXBfbWF4Iiwib3B0X2xlbiIsInN0YXRpY19sZW4iLCJnZW5fY29kZXMiLCJuZXh0X2NvZGUiLCJ0cl9zdGF0aWNfaW5pdCIsImluaXRfYmxvY2siLCJkeW5fbHRyZWUiLCJkeW5fZHRyZWUiLCJibF90cmVlIiwibGFzdF9saXQiLCJtYXRjaGVzIiwiYmlfd2luZHVwIiwiY29weV9ibG9jayIsImhlYWRlciIsImFycmF5U2V0Iiwid2luZG93Iiwic21hbGxlciIsImRlcHRoIiwiX24yIiwiX20yIiwicHFkb3duaGVhcCIsImsiLCJ2IiwiaiIsImhlYXBfbGVuIiwiY29tcHJlc3NfYmxvY2siLCJsdHJlZSIsImR0cmVlIiwibGMiLCJseCIsImRfYnVmIiwibF9idWYiLCJidWlsZF90cmVlIiwibm9kZSIsInNjYW5fdHJlZSIsInByZXZsZW4iLCJjdXJsZW4iLCJuZXh0bGVuIiwiY291bnQiLCJtYXhfY291bnQiLCJtaW5fY291bnQiLCJzZW5kX3RyZWUiLCJidWlsZF9ibF90cmVlIiwibWF4X2JsaW5kZXgiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwic2VuZF9hbGxfdHJlZXMiLCJsY29kZXMiLCJkY29kZXMiLCJibGNvZGVzIiwicmFuayIsImRldGVjdF9kYXRhX3R5cGUiLCJibGFja19tYXNrIiwic3RhdGljX2luaXRfZG9uZSIsIl90cl9pbml0IiwiX3RyX3N0b3JlZF9ibG9jayIsInN0b3JlZF9sZW4iLCJsYXN0IiwiX3RyX2FsaWduIiwiX3RyX2ZsdXNoX2Jsb2NrIiwib3B0X2xlbmIiLCJzdGF0aWNfbGVuYiIsImxldmVsIiwic3RybSIsImRhdGFfdHlwZSIsInN0cmF0ZWd5IiwiX3RyX3RhbGx5IiwibGl0X2J1ZnNpemUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\nfunction ZStream() {\n    /* next input byte */ this.input = null; // JS specific, because we have no pointers\n    this.next_in = 0;\n    /* number of bytes available at input */ this.avail_in = 0;\n    /* total number of input bytes read so far */ this.total_in = 0;\n    /* next output byte should be put there */ this.output = null; // JS specific, because we have no pointers\n    this.next_out = 0;\n    /* remaining free space at output */ this.avail_out = 0;\n    /* total number of bytes output so far */ this.total_out = 0;\n    /* last error message, NULL if no error */ this.msg = \"\" /*Z_NULL*/ ;\n    /* not visible by applications */ this.state = null;\n    /* best guess about the data type: binary or text */ this.data_type = 2 /*Z_UNKNOWN*/ ;\n    /* adler32 value of the uncompressed data */ this.adler = 0;\n}\nmodule.exports = ZStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxFQUFFO0FBQ0Ysb0VBQW9FO0FBQ3BFLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsRUFBRTtBQUNGLHdFQUF3RTtBQUN4RSx5RUFBeUU7QUFDekUsaURBQWlEO0FBQ2pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDBFQUEwRTtBQUMxRSxxQ0FBcUM7QUFDckMsNkVBQTZFO0FBQzdFLG1EQUFtRDtBQUNuRCw2RUFBNkU7QUFFN0UsU0FBU0E7SUFDUCxtQkFBbUIsR0FDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsTUFBTSwyQ0FBMkM7SUFDOUQsSUFBSSxDQUFDQyxPQUFPLEdBQUc7SUFDZixzQ0FBc0MsR0FDdEMsSUFBSSxDQUFDQyxRQUFRLEdBQUc7SUFDaEIsMkNBQTJDLEdBQzNDLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ2hCLHdDQUF3QyxHQUN4QyxJQUFJLENBQUNDLE1BQU0sR0FBRyxNQUFNLDJDQUEyQztJQUMvRCxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUNoQixrQ0FBa0MsR0FDbEMsSUFBSSxDQUFDQyxTQUFTLEdBQUc7SUFDakIsdUNBQXVDLEdBQ3ZDLElBQUksQ0FBQ0MsU0FBUyxHQUFHO0lBQ2pCLHdDQUF3QyxHQUN4QyxJQUFJLENBQUNDLEdBQUcsR0FBRyxHQUFFLFFBQVE7SUFDckIsK0JBQStCLEdBQy9CLElBQUksQ0FBQ0MsS0FBSyxHQUFHO0lBQ2Isa0RBQWtELEdBQ2xELElBQUksQ0FBQ0MsU0FBUyxHQUFHLEVBQUMsV0FBVztJQUM3QiwwQ0FBMEMsR0FDMUMsSUFBSSxDQUFDQyxLQUFLLEdBQUc7QUFDZjtBQUVBQyxPQUFPQyxPQUFPLEdBQUdkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzPzhiMzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIFpTdHJlYW0oKSB7XG4gIC8qIG5leHQgaW5wdXQgYnl0ZSAqL1xuICB0aGlzLmlucHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfaW4gPSAwO1xuICAvKiBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlIGF0IGlucHV0ICovXG4gIHRoaXMuYXZhaWxfaW4gPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgcmVhZCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9pbiA9IDA7XG4gIC8qIG5leHQgb3V0cHV0IGJ5dGUgc2hvdWxkIGJlIHB1dCB0aGVyZSAqL1xuICB0aGlzLm91dHB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X291dCA9IDA7XG4gIC8qIHJlbWFpbmluZyBmcmVlIHNwYWNlIGF0IG91dHB1dCAqL1xuICB0aGlzLmF2YWlsX291dCA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBieXRlcyBvdXRwdXQgc28gZmFyICovXG4gIHRoaXMudG90YWxfb3V0ID0gMDtcbiAgLyogbGFzdCBlcnJvciBtZXNzYWdlLCBOVUxMIGlmIG5vIGVycm9yICovXG4gIHRoaXMubXNnID0gJycvKlpfTlVMTCovO1xuICAvKiBub3QgdmlzaWJsZSBieSBhcHBsaWNhdGlvbnMgKi9cbiAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gIC8qIGJlc3QgZ3Vlc3MgYWJvdXQgdGhlIGRhdGEgdHlwZTogYmluYXJ5IG9yIHRleHQgKi9cbiAgdGhpcy5kYXRhX3R5cGUgPSAyLypaX1VOS05PV04qLztcbiAgLyogYWRsZXIzMiB2YWx1ZSBvZiB0aGUgdW5jb21wcmVzc2VkIGRhdGEgKi9cbiAgdGhpcy5hZGxlciA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWlN0cmVhbTtcbiJdLCJuYW1lcyI6WyJaU3RyZWFtIiwiaW5wdXQiLCJuZXh0X2luIiwiYXZhaWxfaW4iLCJ0b3RhbF9pbiIsIm91dHB1dCIsIm5leHRfb3V0IiwiYXZhaWxfb3V0IiwidG90YWxfb3V0IiwibXNnIiwic3RhdGUiLCJkYXRhX3R5cGUiLCJhZGxlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@pdf-lib/upng/node_modules/pako/lib/zlib/zstream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json":
/*!******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier-Bold.compressed.json ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json":
/*!*************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier-BoldOblique.compressed.json ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json":
/*!*********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier-Oblique.compressed.json ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json":
/*!*************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Courier.compressed.json ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json":
/*!********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Bold.compressed.json ***!
  \********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica-BoldOblique.compressed.json ***!
  \***************************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json":
/*!***********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica-Oblique.compressed.json ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json":
/*!***************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Helvetica.compressed.json ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json":
/*!************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Symbol.compressed.json ***!
  \************************************************************************/
/***/ ((module) => {

module.exports = "eJx9WFlv2zgQ/iuGnnYBt5DkS85bmk13g27SoEkPbNEHWqIlIhSpklSuov99R7JIkSLtFyGZjxzN8c0h/4oueF1jpqKz6Mt1K1GJZ4s4S+PZYrvdbqJ59J4zdYNqDAfuXuodp52spdSToZrQl6n0KyZl1Sm/xgVpa5BcKURJfs5KCgdj+F++J8+4uCUqr6IzJVo8jy4qJFCusLjD3d27BucE0cGYd+/4c3T2/U2SxfM36XYxT+JtDI8k/jGPPrMCC0oYvuWSKMJZdPYmiWMLuK9I/sCwlNHZCuRfsJD9sSiOk7dxnMFbbrgieefGBW9eROfA7I/8z1myzVbz7rnpn9vuCW/unpvZecF3eHb3IhWu5eyK5Vw0XCCFi7ezc0pnvRo5E1hi8QhCeM0lHCoIK+/yCvdR67zrfd2THPA7VfzzNTrbpv2fX+BPeH8fm2usBMnBg++/oq/forO08+QGNMgGgeG/5wfxYrE4iPFzTlFt5JtkkLeMPIL/EFoNreJBE2vrXReako3YcqvVEXCTKWJdzPS7Gizyjk/mZZvsAKC66d7FCgMtF4NC2eaVqpDyLW+QwIzi/TGoD6tvPQL7BJEPNVKVb39DW2mkJnY5FALyD9eEhU6DL4SPrqTaS0mRrHyDXrHgvpQz7AvVU+CkqgQOnN3zVgSkkFVfKslzQIgfMfPFOBxWRiyDjcs5p5wFIoFr4kImprQrP59WP1ubiVpcCgxlNLq5XC4PwM8Wy77EvSs5ZyU0EpuFaXqAzmlTjVlerzcH8TuskH/4oiLj0WQQ/oWpdXadJAfxZSOJ7exmPfD01lYSD8K/kU0288JLS7Mh+hW337dINCPA5MRX8QE1jXU8Wx/E/6J6V4zyLBtCdd36Km4Cso+QTOG4N6T5dvRusxxsu6/scK5Wgw2fKovZ20HxHSnrQDjv0WjEejvw7/MkxmMD6ZQkvnEfa1xayperg/ibZfN2kN1K4lvxHw4lZAfD6QErpy1lOt2QF4H3XATa8HDP7VnrVWY6SoNZQfKWokBRt90Ak7mt2GACwTVE8bNPE+Tw3VTIzkmQqRuLqsvtUGaFw3cTcjzJxSod3tjYSnQgS4fvpgyc8KaDZuLwXR8FtYlv8YPD9rHBuGxfbQYG1q1vL2v9+3zC9nF0EF+BqoLBFBbbjRfSYbsJprLYboxtpx1Fj23esXoMhqlx7rB9uR2OPxP/aCMDmX61/Vhm8cha7HA91bzbWUR1z0/m8tLUKSyJ1qWNHqeXrTUf16lb76Or6XIzTmWFA4mHyeLOkUS3+H23UpJQPAnbE0bUS2CSUi6IdWM13Mhpu/OlBUE1t/YbA1QYCeWLYVsrRh+SeDm0RCQEf9pxa3Xpds4RcpJhqNVDbXPkzqTpOJcK/mT1VO17gUtn57C3J3cpMlUucW77Px3hRwZ83VJFGvriJ6YRHJboLmnWPUNXWAC7FbQg+/0IrjUL4RMFBxhYkEdSBLxiXB0xD8TkEZorywPXoP0I/jxhXGzWKEoJUFgeiTvs3srq2eO9Hq2Aeq92S9eDIgeYwIeawKoVY+KyVOumuBmpY0r+CgrgQVn7ohl9n6aIoc4TJjB0lEDWvmaGa05ETrGfPRd3lm1jI64b9SKtBJlbhAFTgEhuqWoUvlhCFdwRBW613cNWqnGYyDAdj+OQfdnugpBWHUa14jAKbbN2tlDrfR6mXUT9p7F3peyGvHNBb0UCl933GHgmyN6Hc/0R6+KZxiG7Ba6ReJjg6RiAos0DpTRsHWNz1s284Mr58DI+UF52N8B7vyIGzP4+nGJcWLXiNMtiR0/0S0BPtExAj3ZNwE42zh11e6duTZS/YlZaK6DebfrkOsb4aURMnsqiA+viHpPowDrwsoX1y6moRTZ20cMXtmpOgFYf8sGd8kFrRw4ptuCQagu2lJvwmpXEUu2DNSlOoEf12vY4aXOZkG6WY8OC4hzrwHRcjVhWepjd4KdYKK7jrx5H89WjRxPWoycydlS3jZ/I2VS/G9yp9gB6PG1T1aY4YAp3LfPHPPqABbtFRHS/jf34/T82FAfb";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json":
/*!****************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-Bold.compressed.json ***!
  \****************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json":
/*!**********************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-BoldItalic.compressed.json ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json":
/*!******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-Italic.compressed.json ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/Times-Roman.compressed.json ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = "eJyFnVtzG0mOhf+Kgk+7Ee5ZSdbN/aa+ebzuMdvupmjORD9QUlnmmmJpSMoSZ2L++9YNwMEBkn5xuL6TdUkkgLxUFvXv0Y/1/X212o6+H1397XEzv6sOTl6+Onx1cHry6uXJ6MXol3q1fTe/r5oCfyzuq813H+r7+aoVHpdLFA5UmN8vljuUGjitFnef27tIqTfb+XJxc7m6WzbFDpvjzS+L5+r2t8X25vPo++36sXox+vHzfD2/2Vbr36v21J+ft9XqtrrVGzWP9sMP9fPo+398d3R28eK746OLF0eHh4cvLl5d/PliNGkKr5eLVfVbvVlsF/Vq9P13jQzCH58XN19W1WYz+v604VfVetMVGx0eHv+luVBzk3f1dnHT1uTH+mG3bitx8F83/31w9Ori9EX773n376v231eH3b8vu3/PDy5v6+vq4PfdZlvdbw7erG7q9UO9nm+r278cHFwulwcf2qs1dqs21fprQ3szLjYH84Pten5b3c/XXw7qTwe/Llb1dvdQfffXqjnr8vXBfHX7P/X6YNGcvHm83ixuF/P1otr8pXncn5vb3C5Wd7/ffK66Buie4vdtc8p8fStqU/DH+cNfhzY5Ozt+MfooRyetJS43N62p14148fLF6KdKjxsjn78Y/b69/et09P3xRfffq+a/Fyd9e/2t2q4XN41B//Hv0fRjU6S93LvmQTYP88aO/3nR45cvX/a4er5Zzu+Vnxxe9Pyfj3VjqeulKqeHw4VWj/fXbUPdraJ2Wy+X87XyC7nLQ7W+ab1chPPz4Tbz+0baNNaJT9Y9QdfiUXuYr6vVsvpUkvxp+njzTXvFzRdTzk6Gs5aPG6Vqs5smOOfxFp93D5+rVSzeVGVRW02OpZKb5XzzOT7Nv6p1HWm9qiLcPiUlt5/XVVL2U/24Tujia1J2s3hOYPW1Stq2ym26WsADa5Vv6mW9SixR3S+8pC2wbNNAoNU/H+fLiO/WVRPIVs2TkxNxmmrTpRpRXh0fDW0P3nd83LNLRWdn5z36IaIf44k/Wamj4fo/21OenvXol3ji64j+Gh3sjaEmtXXof+OJb+ND/GqhJyf+LZ74LqJxfPrfYqn30Tgf4om/x+f6I15rEtGVtZq05zSW+hjRLN7x79Gq101n9qXaurShnnndaD5O+TyfU07OXklOuVksbhbrm0fLohocj23S3jQ9T5J5u/zmHka9eB6vdB1L3ST5N5ZK7vwpnngX0edopEVE/xdP/BJLWQhr5k+slSSdJO09RPTPWEfLDRpCm/hcST57jOhr9LinWCrJpLvYHP8ydHFo/uUd4VhbHTpTX556uJMj8MbtYnlb7Opv66fEzq53tp5g243TzDmOJOw/tQNDzLNW56zv+LSs14uEb6rCVW4e1003fmMGPJLad2GzWXQD1yT996MWZ01z8sdFo9zX23zk0Mrdhb8hk+kl7X1aJCwZPzUDuXQ4cDu/u6uSnrvnOBSjAUfbdtW6gtg/tbHQ/G49f4CkJqdeN9OHKqmlmfd6vtlj4f1qYfylDeD1bs7Q22a5XDxsFptEauq6/Vw/urFi6Padc1vLredfk3iY3zxuE9zn8k/L6jlqhci6n9+s6+TG1+squ/FtvZ3fuIgzadG0JBrAEhrGoT1sdduYNBujPq7u5uvH++X8MblNfdcMM78kl5tjPaBd7p3P6uDi0kY9x+eDz9fr20/NMM+NC22A4vtYG394rjcY2w1eHh3qDe6bPPe4dHeQzDRPRqO3bchvNkn3tSyMzevCc9bJILqJzmZC3Hh90mpvQoNax+z9zzp/7zXWMaVNapfzbWdjo/AEOoq+XXxdgDvbKf7JbLichIY9duGkSXKSdRYUg9pVdzMvChKoaryk3c8FiuFyQ8wpGuwc/3TWEnSCzQHCTWzG0GQImIL4KSZV9PxMxWHNI7kV5RwbFXo/sFrmdnmXPYCFR8lHfUq1cX52NZtIla7m0yqYMyZK8xBXTeCUEW3wSnc/H+6yrP9Vre6STPKhEFGvs0qac+wNkn2ee1nqRtaFJr3hutrsJ1pOxyR/fK7XSa3GdHczA0WBTvOIX0iyLZhtQjcwi/muzS1vbB67Mc46eV7vgmbFEqe0Kknw/nG5XTwsd8lz+QqCk/vmkI6vGW1tF/Pl7eJTMsHalVPDO38fc9jEWSw29rrZnl6nLN0U0t2qlAapQSGnzFM/fkMXwsW3ZsCAK3A6AVrXX6oVToM0Oa6ru8XGD3wtRAsjrzcxLs50LvLYRLWbjZixCyPIdcEyNceSxmXBpf7uLXZ68kpGrt06l18F01r+vLURiiXZYgJcZnnr5fHgvdtCkqmKvWNJuCwNH/Z4pTewzZZLoVG697jUIqWuh3Ou9iOlO5fjeLx3WMI9powLquU2We7ZuiRtOfGp3pMR40hPzrt/TGrin8hMlY4zLRbI9DZP9SOc81PM440DrxtHhkfTbiRMYaRtloWO5G06yNAZhm+4V7JuoK90spxYnpC9KYT+m1KI/0pPLWZojPZ5voSeQWK8nZnQMrc2xb6x88qPmszTvtF+hUioSt3znc+lWKGhVbNG9fnMeDbcVQfOZzjqYE2WyF541BRalgnn+XiDks2pZvPbxU2WZ38q9GfrvbV559vHHpdGuzbc3OvWe+91WfCFy2KOzmcDY38dy8NJv2kjkUJvX0oUX9Lxs47H3EDArrY3FPwj2PLu3jst67u2vVd1Moqvy7n0MUoSys2lCpF8t3fOUEFHbjYvuO8q7cbh9WHoISzll2L858f2VeSfL0Zvq/Xqt/li3b5A/sfosn1RPXrx3cnhny+Goz57ONQ/p0dDTkf42h/1WcUhrBgK4+bo9FSP5BEAgXM4rk3laB//DrnM45TBZI71i0MO9YGD6L07+qM5Ojo60kMxmmOu/qBM3KUm0QCTggEmqQEm0QCTogEmiQFk6OdYl1GQXLWVeKmH0+bwlbbprBUPVZxJnZDBwwOGfQHOSF+bw/MTOXpq73YsRzt/JDcDBPca6FAIA0ARRYFyCgXjHA+ivE4QRYbyNDxEhRhRRH6iPHMWFaPHqERuozz3HZXZgVSgMFJOsST8fUQYVco4tExI40vkSbw8R5ryfRZMYk6lggUL0adyyYIhDlXwwSgYI1IYhKUgjE1lHKAqJFEqWhqqIkK8CoKgFbRLEIWv8hjDQyhhDCuiGFZOMWycY1iU1wmiGFaexrCoEMOKyAOVZx6oYvRAlcgDleceqDJ7oAoUw8ophoW/jwhjWBnHsAlpDIs8iZfnGFa+z4JJDKtUsGAhhlUuWTDEsAo+hgVjDAuDGBaEMayMY1iFJIZFS2NYRIhhQRDDgnYJohhWHmMY2wkD2XOKZi9SSJPIce3k1yVOEe7FNMxdEYh1z8ldvZj5rC8RHdfr5L1ezF3Yl2E/9iqlAy9STnDi+wLH7OAFThGkpnnClZkUbskZw4vfbIIkd3h9XxMUsogvs7cJQj7xqk8qTsPM4gRIL45jjvECJxqvJtnGFUhTjisBecdxSD6O70qc0pAXYy4ygpkIKeUhlCgLOYlzEIivc0r5B6U0+0AByD1Iye1Rypwe9ejyqJLDo5S7O5ZgZ0eNsg1KlGtAep9SzDOIOcs4Lc0xUGKS3orzC0rfMHSSW1AtG7qQV7DEHkOHnIKazyigYD4BDNkEKOYSxJxJUEvyCMhpFgEdcghQyCBAdzml7IFSzB1D42DiUERZQzmlDOOcL0R5nSDKFMrTNCEq5AhF5LfKM6dVMXqsSuSuynNfVZkdVQVKB8opFwh/HxFmAWWcAkxI41/kSbw8R77yfRZMYl6lggUL0a5yyYIhzlXwQS4YI1wYhLcgjG1lHNgqJFEtWhrSIkI8C4JgFrRLEIWx8hjDYjgMYmMUxSZQGIPAcazS64xRJJuQhrLKEMvGyBVNyHzR1OiMppE3mpC7o+nsj6ZQSJtAMa3C+4RhVBvksAYljWvVJ8ktOLJN2GvOJLZNK5mzEN2mF80Z4tsUH+DKMcIVQogrwxg3yEFuShLlKqZhrirEuTIIdGW7jFGomxBjXWyFsW6MYt0EinUQONZVep0xinUT0lhXGWLdGDmnCZlzmhqd0zRyThNy5zSdndMUinUTKNZVeJ8wjHWDHOugpLGu+iS5Bce6CXvNmcS6aSVzFmLd9KI5Q6yb4mNdOca6Qoh1ZRjrBjnWTUliXcU01lWFWFfWxvopheguY9pMLGBD9Np6+CjbAkoIxblginLFHOOD8DoSim/BaXQPIsS2EHJFwZkjihbdUBRyQsG5C4rKDiicolkwxfKA3weCcSyIo1h5GsODOgmX5vgVvMdoSeyKkhutELeiFowWYla4j9iBYrwOCKJ1IBirgjhShSdxOkhplA4axOhAoDceyC4S6okFx3548BgMTkUUncopPI1zfIryOkEUocrTEBUVYlQR+ZvyzOFUjB6nErmc8tznVGanU4FCVTnFqvD3EWG0KuNwNSGNV5En8fIcscr3WTCJWZUKFixErcolC4a4VcEHrmCMXGEQuoIwdpVx8KqQRK9oafiKCPErCAJY0C5BFMLKQwz/0NDL5qivcnck5wKSeAPk2hc43AGotCogbTFg2ljAhnYCIs5vaNJZVo+sIRS5xwXumkapPC4g8j9QtCLAtCLAhor05KfB7id25DPmT2h3QK4iwKEiQKUigPRxgenjAhseF4jY3dCVO2rj5KUezTS4fsLgABSywLCb11lGEZlHOdlIeWYoFaO1VCKTKWe7qcDGU8FbUDGZUfhVRGBQQbNoLDat8sS+3XcA3r6C2L7C2b7CU/uKmNhXJLav8GBfEYJ9RSD7Cmb7DvwqIrTvgGbRWMG+woN9fxlM2+fsX9CqgMSggJwtgcMdgIoFAanxgKndgA0mAyLWMtSOwY60PnNNpoakBoB8fjWO+dWo5ldDlkWNWRY1JlnUiNTAUP/jUC++uzgUUju9jnWqCxWo0wrUsQI1dxCmJFWrZWAHKNZj+NUqqcj/Du51ZkdSEUDSOIBc3YBD3YBK3QBpDYBp4wAbGgeIVKpHb0f9MPylHelow5AfWhjHoYVRHVoYoqYAxQYdxqQpAOkIQ1F7dHyqR/LUgGRMjQgrAhwqglQ/5HBY6gdIawFMm8NYrWOkt+j0gJJB3FtyeqB+EPc2cXpQaHj3Fp0ekB/LtehRQ6A78qHaoSRUOx5CtaM+VDuUhmqnUKh2jLJQx1wWasnOWX4X/WMXG91NtjAuSKAQITWLFioSA4cKUAyRmocTFeLIIpmCjFSKN69WJYtxFJJKAclqEptU5FstlkUslaDgJZXjmGQOaS9DdJNAgU5qFvNUJIY/FaBMQGqeFKgQ5weSKVWQSlnDq5BASKBcQmqWVqhIzDBUgJINqXneoUKcgkjmbESyT0xe3JVcidMVqSEOfh3160r9EkJ3JMGGyK0lmdAtsRweyuFUB5+/jmRhRUVYUzHm5uyK3UqK3a17/6BPvfNj+V+pegPFb1iGK4VPWALPauu+7hgeFb/uGOrtv+7wxYIF8q87vJbZAj/boHqyVbLPNgZJJpfZHUTbxeJ8B+XJHZzzQROQQA3BatYcvgw2ilegabwwK54SmonkpLF8idSgIXxTGwXjFsN3KDAkVzSuIjKr8cygoqIphYERBc2SYsFwKiQmEy0zlmi7WE82kPJgmncjXA7tjnxv2iG/HNqhpFfteOhKO+r7zw5Rf9gxWg7tmFsO7YjvDN9J8F4miOqinCqkPKuVirFqKlH9lHMlVeCaquCrq5jqjOuGjKjOYd2QeVbnbN2QJapzXDdkgevM64aMuc4uyi+LAtffq2wFr6a28EUSi/gCbBevBut4OdjIy2QpL5K95B3IZYLIRsrJOsozu6gYLaIS2UI5W0EFrr8KvuaKfZ3HrrrjWNNxrOS4UL9xWrVxrNU4qdA4qcs4VGOc16DtpfqF2zF2UIiS177joVs61aOpu+pHV3LmStqKryHsKnoaE+24kGjHhUQ73pdox+VEOy4k2nEp0Y5LiXacJ9pxIdEqhzYJI+PAs9bBkTHZcxpv9zGeOIsncrNlI+VBcl8TQQN6Tq3oRWpKL2bt6UvERvU6tawXuXm9ym3sVd/QXqPWDp/7nSTW43bf97FfVuSq0CrTwnN8LFxnVrgOe0Xxg7dBh09FwDGQklugRE6BUuYSqEeHQJXcASV2BtTYFVDzjoAKuQF9i3US7MQuUP4SKxa4Si0/Te/+Mb3CLL0CN3vh66RBlQ8LoMUVUXMrp7ZWnjW0irGVVaImVs7tqwI3rgq+ZRVTs+KXNSfeDNyghe9qSL2K9pzG232MJ87iidx82Tcog+RX1bAJWaGWZJkalOWsXblMbF4uQa3MMjc269zmrPumZ5U8gGRwBFbIH4KcuQUVuiq22LT4RB+LV5sVr8aew3J0IP3UAFzHGDmNCeQuJmSOYmp0EdPIOUxgtzCFHcIU7wrGyQnctzgnZBFu+NKXOCxfJdadJvf8mJw7S87lRk2/Vhk0Wd2B1lREjamc2lJ51pQqxpZUiRpSObejCtyMKvhWVEyNiCt6J94M3ISFFT1Sr6I9p/F2H+OJs3giN162wjdIcZI+LkzSx4VJ+njfJH1cnqSPC5P0cWmSPi5N0sf5JH1cmqTjTt0TbwZuu8I+XVKvoj2n8XYf44mzeCK3XbantZd+G5qtX479DVsMkDQWINdOwMNe1d+wdQBpwwDTNgE2NAcQaQlDtvmpO/JvDDvkNz91KHlz2PHwurCj/h1hh+idX8foRV/H3Nu9jvhNQy2SzU/DZuIW6T6igb0f4ZbZ7shvme1QsmW242HLbEf9ltkOpVtmO4W2zHaMtsx2zG2Z/TDqN0mc2JHfs9ihZFtix8OOxI76zYgdoqcGhXYodkzeUwPy+w8/DJF9ZkcS1IhcPJswcdeZxPpOCvWdpPWdxPpyK4GS1HdCmzE/QCsZaRPQhR61uad/u/JhyDFndqQb2AzhrrSeykIOtL4iMonyzC4qRuOoRBZSnptJZbaVCuQgyslLcGHtjBD5S2FhjdRJvDa7j/J9tkocSaWCrQoupXLJVsG5VPAehmuHFx6Br+FCIfkRe122UDhI8vYFXE8RmVN5Zk4VozlVInMqz82pMptTBXI95eR6wsH1FJHrGc9cT9RJvDa7nvJ9tkpcT6WCrQqup3LJVsH1VPCuh5v1LzwC18PN+uRH7HrZZn2RwvZAeYh8e2CupgYubg/MC7Cx924PzAsFw+fbA3OVHTbsEDlLBXbefTtE0jKT0j2DO3v12zbPXNsX2Gvzkpv7QvttHl3ey+T4YevMRSZgEISdM6lfh4Ao7pvpC/wxGqYZL/VIpxmGdJphyE8zjOM0w6hOMwzZNMOYTTOMyTTDiE4zFLXRfHShRzr6NuRH38Zx9G1UR9+GePRtio2+jen3CIZ0aqHIvqnojuSpAYndAbmKAA8R0FHv9h0iN+6Y2h0uONgdiM8bLer/wrVMWXvST5f6rUotac84V103GQOSxILIfcFjPGy97ilsHIbC+mGPIdpW3TH7sEfZ8HfPZSbbosVIpvzdkV896RCtW7SsdgasYwvXhebEPcNApUaAyC9B0boCE78EJK1qSOe31ohrV611rP1aGhGR6xJMsL+NLtmtpe0+4xM70i7BkO8HjKPrG1XXN8Rp3hQLCmOW0I1JFlfy5Cy380exvXexXXGz1ZDRwmYr5pSP881WLMbMHDZbMeccHTdbseCzddhsRRzydpgGMM8yeDYNYIlyeWkawDJn9TANYE75Xfg8tjRneuWU7pVnSULFmPhVouyvnLsAFbgfUMF3BoqpRxBO3YJh1zcIhhStiHoJ5dRVGI9f7ZgYOw2TYs+hGnUfyrkPUYE7EhG4NxEOXYoiyqzKuXMRoY6twt2M8n1ulHQ4KlGvozzvelTm/kcF6oSUU08knLsj4etoDe6YlFPvZDzrokRN+imRoLNSRD2W8qzbUjH2XSpRB6Y878VU5q5MBe7PVPCdmuCn2BK7BBWcLevowg5b6Q3yHba5yl3fnh22eZGkG8x32OZq6BILO2xzmbrHfIdtqmJXmS9Y5GrabRYXLPIC3IXuXbDIC4XuNF+wyFXuWp06L3lY6Ga9yp2tV9Nc6YskHa8vwN2vV0Mn7OXQFXuZOmQvcrfsVO6cSfRdtP+CEro2L3B37VXutEnNum5fJOnAqUDSjfsS/pNcVu33HlI5dOxODt27U7GT9wL3VV4NHb7/ZLPU9qHz9+q33TobCPgCPBzwamFQ4AuFoYGXeYDgVR4mODUMFpy6LtkzDBy8ysMHUtNBhCuTDSVcARxQeIGHFV5NBxe+SDLE8AV4oOHVwnDDFwqDDi+HoYeXaQDixKdSS++Kwt4QiAOTyTAaObEjvx49wXEHoGRdekIjDKC+N5i4sQQwWkaewKgBiM/wsn6O1QjfTjCnCuXfTrAYqxa+nWDOlYzfTrDgqxu+nRh4+OYg5VT7/JuDVMzsUPzmINXJIoVvDlKVbZN+c5BqZCXafp9QslC2/T6RMusUtt8nKlkm3X6faGyVZPt9opBFcG86I7JF2JvOPLNCtjedJap/3JvOAtec96Yzpjone7oLClmgtKe7IGf22LOnu1CCrFPc013Q2VaFPd0FlSznNjMHRtaKm5mDkFko3cwcNLJKspk5KGyJsJk5cKq9/pL0Zcao9iZQ7U3Iam9qrL1pVHsTuPamcO1N8bU3TrUffqn3MhKquWCqt+Cs1qLFOotCNRbM9RXOtRXu6yrU1/RqqOXwS61XWEVkulcTmF9fAAFXFQDrWgIwWxwAaBsYAcoORkC6OGCs/Y3jIzvyW0w75IfsJoydTWgvSIeSxux4aMiO+kbsULrXoFOoaTvmd3J0KLYd7E/tDrXtgKkRgPm3rMbxdxKN6nq4IZs3G7N2gztJuwHSX0pUJBOkfurWk2Hz7fErQVSHKqmrLTgAyqtapVV16wl44WiCKjFBlZlAVwmGH99oWbs2cGZHunXDkP9ZLeP4G0JG9eexDNlvYhmjnxpsWe2NbL/oCMxHOgg4ozKqywSGeKUQrmErAsZ0URDK6eRfke3GtmI43TZvaufY5xrqOrEG5L3EOHqJUfUGQ1RDUMxPjNm6kjH5SdGOTCUx9603dYkZmAY3MGouEzAxA9bEDMwSM0DzboAS4IA0MRvrFrHtyO+Sn4b0Cjzskp9iegWU7pKfuvQKTF3MkD62Ilthno7CsvJ0FNaSpyG3Ag/LD1PMrYBojWw6iovC0xGvBE8xsxqSWHh5bqTPrP2a5XRIrHZGFWupaRVRXssq9IZTTqtQ2HeSU5dVgSWV16R6puGycCctfA8+denPWO2uWse6ZwunU859RmNz5uui01FcDJ2OwgrodBSWPaeY+awRMfFZY7eJ71RP08QHyP95AePhs6QpJj5A/PcETLE/JWDM/oqAMfkDAkraBb7zl3qk6doQpuWOzny+nCX5cpbky1kpX87yfDlL8uUsy5ezLF/OYr6cJflyNsIfMZ1hvgSUvD2ZUb4E6t+CzJJ8CQrtc5hhvgTkf2x0NuTLYZQzw4SJTFsAGOV+E3DXqlH/w8ozlzOBwYdQBvVLKEP+p5VnkDX78JqNwnh0NqRNuEyVVFYTp2OFylZpZf2IFEpHI1SJEarMCDYi7UepsyF79u8nZpg9AdEfAJkN2fPoSK9rg0dgvrogYAwb9XtvZkkCxWvQ67sZZlAsp1MORTx4nFEOtaZ/9IZ6pHnHLGRRFMIsY4ZpFFCopEk00Zi5PIoF/VxrpuvnkFrCy4EgcIbMXw8ENcmV4QVBEELWjK8IgkL5M7wkYAEyafjWjXmWU7Nv3Vii7Fr61o1lzrPhWzfmlHGFY9pVxulIBU7AKqSJSdWYnVSiVKSc85EKISmpQulZOeVo4RSthn22Fp5VO+RtFTh5m7DPUEkaNynJ5SoWrBiyugpFK4b8LgIkeUWU6ZVzuhcBc74yTvwqpNlf1dgFqET9gPJCZ6A69wgqcLegAvUNwkMHIULSS4j0mNg89BcqpJ2GqrHnUIm6D+WFPkR17khUCL2JKtSl0EtFybXZW8VM476l+F4xK5D0MNmbxUwL/Uz6bjETqbfJ3i4mGvQ5SKnbQSnreVCPnQ+q1P+glHdBWIJ7IdSoI0KJ+iKQsDtCzIkWNe6UUEvTLRaIGRdVyqsocWpFLWRXFKmbQslWkYJGWcMpvsMCqXCt0G2hxj2X075hzaT/cmrShaFetnboyFDbZ+3QnYEGPRpS6tRQ4n4NNOzaEHPvhlrawWGB2MehSt0cSoWeDotwZ4ca93eoUZcHUuj1QEs6PlAf8wYK3R9qaQ+IBWIniCr1gygVukIswr0haqFDRNH3iU3Ydn9fsu8F2qN241r/YlFSHhYQBKWG5IelBEEpt9sHijoO5eGRoTRQKCvbR6CgICiluwWgmDIo5/629VDO/W3roRz8dd2hFPx13aEM/gnPoRD+Cc++1DV6br+4ez245LEdiScCSt6yXZPfAfVv2a4TPwOF3r9dO7cCNniTka9arZtRvxYKRxpNhnBc1FNxsV2C6ALK41Xw2w9GdJXs2w+R5M8Ru+sY5CuZEq/Vd5L9Hy24vV7K3y3os5hTvdRW0H7uqTvyOwM6lO0MUM/Toyd39OxK7vyRr1puZenG8fkU0UMqT5/UpRqPniJ6jifuEkRVKHuLDDmwHoqoHsrTeogK9cAPkwg9xxN3CaJ6lP3VDY9cZRznGjkxr1bI3gl/KvDnwnV2Jc71dWKsNHQKdzmlCqOUVpc7n0CfUvqcXmGXU6okSkkVbdzq6oiYK4laXksogdUE/JTj5/wiuwLmqqIW6ypd912CqI7K0/q5YYFHTxE9xxN3CaK6KI/10LHFXcaoJiakVfFjF2JPCXtOzt1ljOpjQqyQDoLuMkYVMiGtkB9kEXtK2HNy7i5jVCETQoU+jWS2r0d+Z0eHbG6vKNns0fGw2aOjfrNHh2hLR8fohw875n74sCN+l0eLmmhaVptNN5VU+Ekt2B4tdITWHfmR5CcadfQTy7vBNnagk1IlYhkj/nW8Ynwbr1BfxiuxN+6KbLqrSN63KxCT9ESmHvNIfA0U+2ooTuqiWqiQKr5Wiqlqyql+yl0llfqaxs9JU+5rXfiYNBUTC5Q/JU11b43Sh6SpSpbJPyNNNWcl/VNgeuDsEf78VwsXLi0t4tB0URgOLdJxwyL2Q4skny+SlNgeWbR3Rz5DdcjWywzFDNXxkKF66lbFFPvE1SFKXB2jxNWy2h/FZ64LD1inD1jHJwnrS6Ykz1j7/XId8pnUdydJR5J3IV/il8bD9QpfGucqteC+L43zItFse740zkuQjUtfGucy+0D86jcX9poldZLyV795gb3VKnhR6avfXCbfKnz1m6q7kiOx85W/Be0LLIdRU3+XpVul61H8OnUQ5GfYDUleOtEje85kzJiPFleYNocrxbn6qjBXX5Xn6iucYg8XjpPnVWHyvCpPnlfeRHj5QqOxwLf6RqOtcHVwuJWgXSzFl1ceLlyPcB2udiPqWi5+qEc+CGu+ZE+xOYfrxgWa2rWwP5Fvk7ZwL4XudbhhYbWhjqsKyXX4/uVVhV6nvnx4hHQNoObZfrgC37w02+9VHDAM940T19rNUv2JfLt0ltpL9B0h3JIUuDMpu+LV+DlYjo/jBkbDgyQT3dpPaulcvm0+qe01SX9wP8yIxx7t4ol8s+yvyg4SxvtwL3wbcOzRLp7I90pTQCc9uAs8xHMf8tOG1xCFVWove03OWFaf5Fvdi1SQ58hV/0kCq8l2di4CdcoL+E3urNKudpZpMz/L7qMGFv1O+E7NjbXHUnvM9C0b7TfQHuvsM80+u5SN8m2LwP+HL6HQ5Ubtm7LTw4ibB5xvc22pTu6xDwuv0dJVUsIP/pzmYyTWYZ0/p/6kS6bJRCHV3MMmJboJ7mnEfruB1/SGmSZvu3LVP05S4mF+U+Wm6ax9ETG1RyzxVWveWFf3pZwoudPTuiNd2zOU3aIVdBvHsV5M39n2lZOG49u6d2QXHtEDlN6ReZUfJez5G56Hf79yeB73ruvCI3qe0rsur/LzhB9AlOdJf7JLnsqJ+Gxe4Cf0av6c+c9eHWc3pmcefLRL0ER81CjWFTWP/Vqa13D9ySu6fuaxrZx5TpuDlMtqmae6TubwH2o3Jbo6QTixtYj2t6eEdH96ypH2t+BfeSI2JQwG6pUmzLsFz37E1B3porYhaQpAfseEcdwxYVR3TBiyfRHGbF+EMdkXYUTMbUgi4EyJze66Iz/h65C2BaD4Z6c6HqaFPcWFIMP+r1F1iP4aVcfor1G1rNZQ6o78y4UOJdtUOh62qXTUb1PpULpNpVNom0rHpEsGpLZXpHHeG/9phK+CntChAPlXQU/BoYCHkfUTOhQgWlx6cg4FzL0KekKHMuQd6mmEK29Po7Dc9hQaB3hagTpWIF9CexrFdbOnUVgsexqFFbKn2DjPLjKeY2Q8x8h4LkTGcxoZz3lkPMfIeE4i4zmJjF1ojl2s2I5HDIS5eLLlNip40p//+X+DG1I7";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json":
/*!******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/ZapfDingbats.compressed.json ***!
  \******************************************************************************/
/***/ ((module) => {

module.exports = "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==";

/***/ }),

/***/ "(rsc)/./node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json":
/*!*******************************************************************************!*\
  !*** ./node_modules/@pdf-lib/standard-fonts/es/all-encodings.compressed.json ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = "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";

/***/ })

};
;