/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/readable-stream";
exports.ids = ["vendor-chunks/readable-stream"];
exports.modules = {

/***/ "(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\nmodule.exports = Duplex;\n/*<replacement>*/ var objectKeys = Object.keys || function(obj) {\n    var keys = [];\n    for(var key in obj)keys.push(key);\n    return keys;\n};\n/*</replacement>*/ /*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var Readable = __webpack_require__(/*! ./_stream_readable */ \"(rsc)/./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"(rsc)/./node_modules/readable-stream/lib/_stream_writable.js\");\nutil.inherits(Duplex, Readable);\nforEach(objectKeys(Writable.prototype), function(method) {\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n});\nfunction Duplex(options) {\n    if (!(this instanceof Duplex)) return new Duplex(options);\n    Readable.call(this, options);\n    Writable.call(this, options);\n    if (options && options.readable === false) this.readable = false;\n    if (options && options.writable === false) this.writable = false;\n    this.allowHalfOpen = true;\n    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n    this.once(\"end\", onend);\n}\n// the no-half-open enforcer\nfunction onend() {\n    // if we allow half-open state, or if the writable side ended,\n    // then we're ok.\n    if (this.allowHalfOpen || this._writableState.ended) return;\n    // no more data can be written.\n    // But allow more writes to happen in this tick.\n    process.nextTick(this.end.bind(this));\n}\nfunction forEach(xs, f) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        f(xs[i], i);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBRXpDLHVFQUF1RTtBQUN2RSxvRUFBb0U7QUFDcEUsbUVBQW1FO0FBQ25FLFlBQVk7QUFFWkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixlQUFlLEdBQ2YsSUFBSUMsYUFBYUMsT0FBT0MsSUFBSSxJQUFJLFNBQVVDLEdBQUc7SUFDM0MsSUFBSUQsT0FBTyxFQUFFO0lBQ2IsSUFBSyxJQUFJRSxPQUFPRCxJQUFLRCxLQUFLRyxJQUFJLENBQUNEO0lBQy9CLE9BQU9GO0FBQ1Q7QUFDQSxnQkFBZ0IsR0FHaEIsZUFBZSxHQUNmLElBQUlJLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CRCxLQUFLRSxRQUFRLEdBQUdELG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQixJQUFJRSxXQUFXRixtQkFBT0EsQ0FBQztBQUN2QixJQUFJRyxXQUFXSCxtQkFBT0EsQ0FBQztBQUV2QkQsS0FBS0UsUUFBUSxDQUFDVCxRQUFRVTtBQUV0QkUsUUFBUVgsV0FBV1UsU0FBU0UsU0FBUyxHQUFHLFNBQVNDLE1BQU07SUFDckQsSUFBSSxDQUFDZCxPQUFPYSxTQUFTLENBQUNDLE9BQU8sRUFDM0JkLE9BQU9hLFNBQVMsQ0FBQ0MsT0FBTyxHQUFHSCxTQUFTRSxTQUFTLENBQUNDLE9BQU87QUFDekQ7QUFFQSxTQUFTZCxPQUFPZSxPQUFPO0lBQ3JCLElBQUksQ0FBRSxLQUFJLFlBQVlmLE1BQUssR0FDekIsT0FBTyxJQUFJQSxPQUFPZTtJQUVwQkwsU0FBU00sSUFBSSxDQUFDLElBQUksRUFBRUQ7SUFDcEJKLFNBQVNLLElBQUksQ0FBQyxJQUFJLEVBQUVEO0lBRXBCLElBQUlBLFdBQVdBLFFBQVFFLFFBQVEsS0FBSyxPQUNsQyxJQUFJLENBQUNBLFFBQVEsR0FBRztJQUVsQixJQUFJRixXQUFXQSxRQUFRRyxRQUFRLEtBQUssT0FDbEMsSUFBSSxDQUFDQSxRQUFRLEdBQUc7SUFFbEIsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDckIsSUFBSUosV0FBV0EsUUFBUUksYUFBYSxLQUFLLE9BQ3ZDLElBQUksQ0FBQ0EsYUFBYSxHQUFHO0lBRXZCLElBQUksQ0FBQ0MsSUFBSSxDQUFDLE9BQU9DO0FBQ25CO0FBRUEsNEJBQTRCO0FBQzVCLFNBQVNBO0lBQ1AsOERBQThEO0lBQzlELGlCQUFpQjtJQUNqQixJQUFJLElBQUksQ0FBQ0YsYUFBYSxJQUFJLElBQUksQ0FBQ0csY0FBYyxDQUFDQyxLQUFLLEVBQ2pEO0lBRUYsK0JBQStCO0lBQy9CLGdEQUFnRDtJQUNoREMsUUFBUUMsUUFBUSxDQUFDLElBQUksQ0FBQ0MsR0FBRyxDQUFDQyxJQUFJLENBQUMsSUFBSTtBQUNyQztBQUVBLFNBQVNmLFFBQVNnQixFQUFFLEVBQUVDLENBQUM7SUFDckIsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUlILEdBQUdJLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBSztRQUN6Q0QsRUFBRUQsRUFBRSxDQUFDRSxFQUFFLEVBQUVBO0lBQ1g7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanM/NTA2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG5mb3JFYWNoKG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKVxuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufSk7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKHRoaXMuZW5kLmJpbmQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkR1cGxleCIsIm9iamVjdEtleXMiLCJPYmplY3QiLCJrZXlzIiwib2JqIiwia2V5IiwicHVzaCIsInV0aWwiLCJyZXF1aXJlIiwiaW5oZXJpdHMiLCJSZWFkYWJsZSIsIldyaXRhYmxlIiwiZm9yRWFjaCIsInByb3RvdHlwZSIsIm1ldGhvZCIsIm9wdGlvbnMiLCJjYWxsIiwicmVhZGFibGUiLCJ3cml0YWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmNlIiwib25lbmQiLCJfd3JpdGFibGVTdGF0ZSIsImVuZGVkIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiZW5kIiwiYmluZCIsInhzIiwiZiIsImkiLCJsIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\nmodule.exports = PassThrough;\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"(rsc)/./node_modules/readable-stream/lib/_stream_transform.js\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ util.inherits(PassThrough, Transform);\nfunction PassThrough(options) {\n    if (!(this instanceof PassThrough)) return new PassThrough(options);\n    Transform.call(this, options);\n}\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n    cb(null, chunk);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsd0JBQXdCO0FBQ3hCLDREQUE0RDtBQUM1RCx5Q0FBeUM7QUFFekNBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsWUFBWUMsbUJBQU9BLENBQUM7QUFFeEIsZUFBZSxHQUNmLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CQyxLQUFLQyxRQUFRLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQkMsS0FBS0MsUUFBUSxDQUFDSixhQUFhQztBQUUzQixTQUFTRCxZQUFZSyxPQUFPO0lBQzFCLElBQUksQ0FBRSxLQUFJLFlBQVlMLFdBQVUsR0FDOUIsT0FBTyxJQUFJQSxZQUFZSztJQUV6QkosVUFBVUssSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFDdkI7QUFFQUwsWUFBWU8sU0FBUyxDQUFDQyxVQUFVLEdBQUcsU0FBU0MsS0FBSyxFQUFFQyxRQUFRLEVBQUVDLEVBQUU7SUFDN0RBLEdBQUcsTUFBTUY7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcz84MDIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpXG4gICAgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlBhc3NUaHJvdWdoIiwiVHJhbnNmb3JtIiwicmVxdWlyZSIsInV0aWwiLCJpbmhlcml0cyIsIm9wdGlvbnMiLCJjYWxsIiwicHJvdG90eXBlIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/lib/_stream_passthrough.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nmodule.exports = Readable;\n/*<replacement>*/ var isArray = __webpack_require__(/*! isarray */ \"(rsc)/./node_modules/readable-stream/node_modules/isarray/index.js\");\n/*</replacement>*/ /*<replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n/*</replacement>*/ Readable.ReadableState = ReadableState;\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n/*<replacement>*/ if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n    return emitter.listeners(type).length;\n};\n/*</replacement>*/ var Stream = __webpack_require__(/*! stream */ \"stream\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var StringDecoder;\n/*<replacement>*/ var debug = __webpack_require__(/*! util */ \"util\");\nif (debug && debug.debuglog) {\n    debug = debug.debuglog(\"stream\");\n} else {\n    debug = function() {};\n}\n/*</replacement>*/ util.inherits(Readable, Stream);\nfunction ReadableState(options, stream) {\n    var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n    options = options || {};\n    // the point at which it stops calling _read() to fill the buffer\n    // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n    var hwm = options.highWaterMark;\n    var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n    this.buffer = [];\n    this.length = 0;\n    this.pipes = null;\n    this.pipesCount = 0;\n    this.flowing = null;\n    this.ended = false;\n    this.endEmitted = false;\n    this.reading = false;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // whenever we return null, then we set a flag to say\n    // that we're awaiting a 'readable' event emission.\n    this.needReadable = false;\n    this.emittedReadable = false;\n    this.readableListening = false;\n    // object stream flag. Used to make read(n) ignore n and to\n    // make all the buffer merging and length checks go away\n    this.objectMode = !!options.objectMode;\n    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // when piping, we only care about 'readable' events that happen\n    // after read()ing all the bytes and not getting any pushback.\n    this.ranOut = false;\n    // the number of writers that are awaiting a drain event in .pipe()s\n    this.awaitDrain = 0;\n    // if true, a maybeReadMore has been scheduled\n    this.readingMore = false;\n    this.decoder = null;\n    this.encoding = null;\n    if (options.encoding) {\n        if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(rsc)/./node_modules/string_decoder/index.js\").StringDecoder);\n        this.decoder = new StringDecoder(options.encoding);\n        this.encoding = options.encoding;\n    }\n}\nfunction Readable(options) {\n    var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n    if (!(this instanceof Readable)) return new Readable(options);\n    this._readableState = new ReadableState(options, this);\n    // legacy\n    this.readable = true;\n    Stream.call(this);\n}\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n    var state = this._readableState;\n    if (util.isString(chunk) && !state.objectMode) {\n        encoding = encoding || state.defaultEncoding;\n        if (encoding !== state.encoding) {\n            chunk = new Buffer(chunk, encoding);\n            encoding = \"\";\n        }\n    }\n    return readableAddChunk(this, state, chunk, encoding, false);\n};\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n    var state = this._readableState;\n    return readableAddChunk(this, state, chunk, \"\", true);\n};\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n    var er = chunkInvalid(state, chunk);\n    if (er) {\n        stream.emit(\"error\", er);\n    } else if (util.isNullOrUndefined(chunk)) {\n        state.reading = false;\n        if (!state.ended) onEofChunk(stream, state);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n        if (state.ended && !addToFront) {\n            var e = new Error(\"stream.push() after EOF\");\n            stream.emit(\"error\", e);\n        } else if (state.endEmitted && addToFront) {\n            var e = new Error(\"stream.unshift() after end event\");\n            stream.emit(\"error\", e);\n        } else {\n            if (state.decoder && !addToFront && !encoding) chunk = state.decoder.write(chunk);\n            if (!addToFront) state.reading = false;\n            // if we want the data now, just emit it.\n            if (state.flowing && state.length === 0 && !state.sync) {\n                stream.emit(\"data\", chunk);\n                stream.read(0);\n            } else {\n                // update the buffer info.\n                state.length += state.objectMode ? 1 : chunk.length;\n                if (addToFront) state.buffer.unshift(chunk);\n                else state.buffer.push(chunk);\n                if (state.needReadable) emitReadable(stream);\n            }\n            maybeReadMore(stream, state);\n        }\n    } else if (!addToFront) {\n        state.reading = false;\n    }\n    return needMoreData(state);\n}\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"(rsc)/./node_modules/string_decoder/index.js\").StringDecoder);\n    this._readableState.decoder = new StringDecoder(enc);\n    this._readableState.encoding = enc;\n    return this;\n};\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n    if (n >= MAX_HWM) {\n        n = MAX_HWM;\n    } else {\n        // Get the next highest power of 2\n        n--;\n        for(var p = 1; p < 32; p <<= 1)n |= n >> p;\n        n++;\n    }\n    return n;\n}\nfunction howMuchToRead(n, state) {\n    if (state.length === 0 && state.ended) return 0;\n    if (state.objectMode) return n === 0 ? 0 : 1;\n    if (isNaN(n) || util.isNull(n)) {\n        // only flow one buffer at a time\n        if (state.flowing && state.buffer.length) return state.buffer[0].length;\n        else return state.length;\n    }\n    if (n <= 0) return 0;\n    // If we're asking for more than the target buffer level,\n    // then raise the water mark.  Bump up to the next highest\n    // power of 2, to prevent increasing it excessively in tiny\n    // amounts.\n    if (n > state.highWaterMark) state.highWaterMark = roundUpToNextPowerOf2(n);\n    // don't have that much.  return null, unless we've ended.\n    if (n > state.length) {\n        if (!state.ended) {\n            state.needReadable = true;\n            return 0;\n        } else return state.length;\n    }\n    return n;\n}\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n    debug(\"read\", n);\n    var state = this._readableState;\n    var nOrig = n;\n    if (!util.isNumber(n) || n > 0) state.emittedReadable = false;\n    // if we're doing read(0) to trigger a readable event, but we\n    // already have a bunch of data in the buffer, then just trigger\n    // the 'readable' event and move on.\n    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n        debug(\"read: emitReadable\", state.length, state.ended);\n        if (state.length === 0 && state.ended) endReadable(this);\n        else emitReadable(this);\n        return null;\n    }\n    n = howMuchToRead(n, state);\n    // if we've ended, and we're now clear, then finish it up.\n    if (n === 0 && state.ended) {\n        if (state.length === 0) endReadable(this);\n        return null;\n    }\n    // All the actual chunk generation logic needs to be\n    // *below* the call to _read.  The reason is that in certain\n    // synthetic stream cases, such as passthrough streams, _read\n    // may be a completely synchronous operation which may change\n    // the state of the read buffer, providing enough data when\n    // before there was *not* enough.\n    //\n    // So, the steps are:\n    // 1. Figure out what the state of things will be after we do\n    // a read from the buffer.\n    //\n    // 2. If that resulting state will trigger a _read, then call _read.\n    // Note that this may be asynchronous, or synchronous.  Yes, it is\n    // deeply ugly to write APIs this way, but that still doesn't mean\n    // that the Readable class should behave improperly, as streams are\n    // designed to be sync/async agnostic.\n    // Take note if the _read call is sync or async (ie, if the read call\n    // has returned yet), so that we know whether or not it's safe to emit\n    // 'readable' etc.\n    //\n    // 3. Actually pull the requested chunks out of the buffer and return.\n    // if we need a readable event, then we need to do some reading.\n    var doRead = state.needReadable;\n    debug(\"need readable\", doRead);\n    // if we currently have less than the highWaterMark, then also read some\n    if (state.length === 0 || state.length - n < state.highWaterMark) {\n        doRead = true;\n        debug(\"length less than watermark\", doRead);\n    }\n    // however, if we've ended, then there's no point, and if we're already\n    // reading, then it's unnecessary.\n    if (state.ended || state.reading) {\n        doRead = false;\n        debug(\"reading or ended\", doRead);\n    }\n    if (doRead) {\n        debug(\"do read\");\n        state.reading = true;\n        state.sync = true;\n        // if the length is currently zero, then we *need* a readable event.\n        if (state.length === 0) state.needReadable = true;\n        // call internal read method\n        this._read(state.highWaterMark);\n        state.sync = false;\n    }\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (doRead && !state.reading) n = howMuchToRead(nOrig, state);\n    var ret;\n    if (n > 0) ret = fromList(n, state);\n    else ret = null;\n    if (util.isNull(ret)) {\n        state.needReadable = true;\n        n = 0;\n    }\n    state.length -= n;\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (state.length === 0 && !state.ended) state.needReadable = true;\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended && state.length === 0) endReadable(this);\n    if (!util.isNull(ret)) this.emit(\"data\", ret);\n    return ret;\n};\nfunction chunkInvalid(state, chunk) {\n    var er = null;\n    if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {\n        er = new TypeError(\"Invalid non-string/buffer chunk\");\n    }\n    return er;\n}\nfunction onEofChunk(stream, state) {\n    if (state.decoder && !state.ended) {\n        var chunk = state.decoder.end();\n        if (chunk && chunk.length) {\n            state.buffer.push(chunk);\n            state.length += state.objectMode ? 1 : chunk.length;\n        }\n    }\n    state.ended = true;\n    // emit 'readable' now to make sure it gets picked up.\n    emitReadable(stream);\n}\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n    var state = stream._readableState;\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n        debug(\"emitReadable\", state.flowing);\n        state.emittedReadable = true;\n        if (state.sync) process.nextTick(function() {\n            emitReadable_(stream);\n        });\n        else emitReadable_(stream);\n    }\n}\nfunction emitReadable_(stream) {\n    debug(\"emit readable\");\n    stream.emit(\"readable\");\n    flow(stream);\n}\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n    if (!state.readingMore) {\n        state.readingMore = true;\n        process.nextTick(function() {\n            maybeReadMore_(stream, state);\n        });\n    }\n}\nfunction maybeReadMore_(stream, state) {\n    var len = state.length;\n    while(!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark){\n        debug(\"maybeReadMore read 0\");\n        stream.read(0);\n        if (len === state.length) break;\n        else len = state.length;\n    }\n    state.readingMore = false;\n}\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n    this.emit(\"error\", new Error(\"not implemented\"));\n};\nReadable.prototype.pipe = function(dest, pipeOpts) {\n    var src = this;\n    var state = this._readableState;\n    switch(state.pipesCount){\n        case 0:\n            state.pipes = dest;\n            break;\n        case 1:\n            state.pipes = [\n                state.pipes,\n                dest\n            ];\n            break;\n        default:\n            state.pipes.push(dest);\n            break;\n    }\n    state.pipesCount += 1;\n    debug(\"pipe count=%d opts=%j\", state.pipesCount, pipeOpts);\n    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n    var endFn = doEnd ? onend : cleanup;\n    if (state.endEmitted) process.nextTick(endFn);\n    else src.once(\"end\", endFn);\n    dest.on(\"unpipe\", onunpipe);\n    function onunpipe(readable) {\n        debug(\"onunpipe\");\n        if (readable === src) {\n            cleanup();\n        }\n    }\n    function onend() {\n        debug(\"onend\");\n        dest.end();\n    }\n    // when the dest drains, it reduces the awaitDrain counter\n    // on the source.  This would be more elegant with a .once()\n    // handler in flow(), but adding and removing repeatedly is\n    // too slow.\n    var ondrain = pipeOnDrain(src);\n    dest.on(\"drain\", ondrain);\n    function cleanup() {\n        debug(\"cleanup\");\n        // cleanup event handlers once the pipe is broken\n        dest.removeListener(\"close\", onclose);\n        dest.removeListener(\"finish\", onfinish);\n        dest.removeListener(\"drain\", ondrain);\n        dest.removeListener(\"error\", onerror);\n        dest.removeListener(\"unpipe\", onunpipe);\n        src.removeListener(\"end\", onend);\n        src.removeListener(\"end\", cleanup);\n        src.removeListener(\"data\", ondata);\n        // if the reader is waiting for a drain event from this\n        // specific writer, then it would cause it to never start\n        // flowing again.\n        // So, if this is awaiting a drain, then we just call it now.\n        // If we don't know, then assume that we are waiting for one.\n        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n    }\n    src.on(\"data\", ondata);\n    function ondata(chunk) {\n        debug(\"ondata\");\n        var ret = dest.write(chunk);\n        if (false === ret) {\n            debug(\"false write response, pause\", src._readableState.awaitDrain);\n            src._readableState.awaitDrain++;\n            src.pause();\n        }\n    }\n    // if the dest has an error, then stop piping into it.\n    // however, don't suppress the throwing behavior for this.\n    function onerror(er) {\n        debug(\"onerror\", er);\n        unpipe();\n        dest.removeListener(\"error\", onerror);\n        if (EE.listenerCount(dest, \"error\") === 0) dest.emit(\"error\", er);\n    }\n    // This is a brutally ugly hack to make sure that our error handler\n    // is attached before any userland ones.  NEVER DO THIS.\n    if (!dest._events || !dest._events.error) dest.on(\"error\", onerror);\n    else if (isArray(dest._events.error)) dest._events.error.unshift(onerror);\n    else dest._events.error = [\n        onerror,\n        dest._events.error\n    ];\n    // Both close and finish should trigger unpipe, but only once.\n    function onclose() {\n        dest.removeListener(\"finish\", onfinish);\n        unpipe();\n    }\n    dest.once(\"close\", onclose);\n    function onfinish() {\n        debug(\"onfinish\");\n        dest.removeListener(\"close\", onclose);\n        unpipe();\n    }\n    dest.once(\"finish\", onfinish);\n    function unpipe() {\n        debug(\"unpipe\");\n        src.unpipe(dest);\n    }\n    // tell the dest that it's being piped to\n    dest.emit(\"pipe\", src);\n    // start the flow if it hasn't been started already.\n    if (!state.flowing) {\n        debug(\"pipe resume\");\n        src.resume();\n    }\n    return dest;\n};\nfunction pipeOnDrain(src) {\n    return function() {\n        var state = src._readableState;\n        debug(\"pipeOnDrain\", state.awaitDrain);\n        if (state.awaitDrain) state.awaitDrain--;\n        if (state.awaitDrain === 0 && EE.listenerCount(src, \"data\")) {\n            state.flowing = true;\n            flow(src);\n        }\n    };\n}\nReadable.prototype.unpipe = function(dest) {\n    var state = this._readableState;\n    // if we're not piping anywhere, then do nothing.\n    if (state.pipesCount === 0) return this;\n    // just one destination.  most common case.\n    if (state.pipesCount === 1) {\n        // passed in one, but it's not the right one.\n        if (dest && dest !== state.pipes) return this;\n        if (!dest) dest = state.pipes;\n        // got a match.\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n        if (dest) dest.emit(\"unpipe\", this);\n        return this;\n    }\n    // slow case. multiple pipe destinations.\n    if (!dest) {\n        // remove all.\n        var dests = state.pipes;\n        var len = state.pipesCount;\n        state.pipes = null;\n        state.pipesCount = 0;\n        state.flowing = false;\n        for(var i = 0; i < len; i++)dests[i].emit(\"unpipe\", this);\n        return this;\n    }\n    // try to find the right one.\n    var i = indexOf(state.pipes, dest);\n    if (i === -1) return this;\n    state.pipes.splice(i, 1);\n    state.pipesCount -= 1;\n    if (state.pipesCount === 1) state.pipes = state.pipes[0];\n    dest.emit(\"unpipe\", this);\n    return this;\n};\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n    var res = Stream.prototype.on.call(this, ev, fn);\n    // If listening to data, and it has not explicitly been paused,\n    // then call resume to start the flow of data on the next tick.\n    if (ev === \"data\" && false !== this._readableState.flowing) {\n        this.resume();\n    }\n    if (ev === \"readable\" && this.readable) {\n        var state = this._readableState;\n        if (!state.readableListening) {\n            state.readableListening = true;\n            state.emittedReadable = false;\n            state.needReadable = true;\n            if (!state.reading) {\n                var self = this;\n                process.nextTick(function() {\n                    debug(\"readable nexttick read 0\");\n                    self.read(0);\n                });\n            } else if (state.length) {\n                emitReadable(this, state);\n            }\n        }\n    }\n    return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n    var state = this._readableState;\n    if (!state.flowing) {\n        debug(\"resume\");\n        state.flowing = true;\n        if (!state.reading) {\n            debug(\"resume read 0\");\n            this.read(0);\n        }\n        resume(this, state);\n    }\n    return this;\n};\nfunction resume(stream, state) {\n    if (!state.resumeScheduled) {\n        state.resumeScheduled = true;\n        process.nextTick(function() {\n            resume_(stream, state);\n        });\n    }\n}\nfunction resume_(stream, state) {\n    state.resumeScheduled = false;\n    stream.emit(\"resume\");\n    flow(stream);\n    if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function() {\n    debug(\"call pause flowing=%j\", this._readableState.flowing);\n    if (false !== this._readableState.flowing) {\n        debug(\"pause\");\n        this._readableState.flowing = false;\n        this.emit(\"pause\");\n    }\n    return this;\n};\nfunction flow(stream) {\n    var state = stream._readableState;\n    debug(\"flow\", state.flowing);\n    if (state.flowing) {\n        do {\n            var chunk = stream.read();\n        }while (null !== chunk && state.flowing);\n    }\n}\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n    var state = this._readableState;\n    var paused = false;\n    var self = this;\n    stream.on(\"end\", function() {\n        debug(\"wrapped end\");\n        if (state.decoder && !state.ended) {\n            var chunk = state.decoder.end();\n            if (chunk && chunk.length) self.push(chunk);\n        }\n        self.push(null);\n    });\n    stream.on(\"data\", function(chunk) {\n        debug(\"wrapped data\");\n        if (state.decoder) chunk = state.decoder.write(chunk);\n        if (!chunk || !state.objectMode && !chunk.length) return;\n        var ret = self.push(chunk);\n        if (!ret) {\n            paused = true;\n            stream.pause();\n        }\n    });\n    // proxy all the other methods.\n    // important when wrapping filters and duplexes.\n    for(var i in stream){\n        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n            this[i] = function(method) {\n                return function() {\n                    return stream[method].apply(stream, arguments);\n                };\n            }(i);\n        }\n    }\n    // proxy certain important events.\n    var events = [\n        \"error\",\n        \"close\",\n        \"destroy\",\n        \"pause\",\n        \"resume\"\n    ];\n    forEach(events, function(ev) {\n        stream.on(ev, self.emit.bind(self, ev));\n    });\n    // when we try to consume some more bytes, simply unpause the\n    // underlying stream.\n    self._read = function(n) {\n        debug(\"wrapped _read\", n);\n        if (paused) {\n            paused = false;\n            stream.resume();\n        }\n    };\n    return self;\n};\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n    var list = state.buffer;\n    var length = state.length;\n    var stringMode = !!state.decoder;\n    var objectMode = !!state.objectMode;\n    var ret;\n    // nothing in the list, definitely empty.\n    if (list.length === 0) return null;\n    if (length === 0) ret = null;\n    else if (objectMode) ret = list.shift();\n    else if (!n || n >= length) {\n        // read it all, truncate the array.\n        if (stringMode) ret = list.join(\"\");\n        else ret = Buffer.concat(list, length);\n        list.length = 0;\n    } else {\n        // read just some of it.\n        if (n < list[0].length) {\n            // just take a part of the first list item.\n            // slice is the same for buffers and strings.\n            var buf = list[0];\n            ret = buf.slice(0, n);\n            list[0] = buf.slice(n);\n        } else if (n === list[0].length) {\n            // first list is a perfect match\n            ret = list.shift();\n        } else {\n            // complex case.\n            // we have enough to cover it, but it spans past the first buffer.\n            if (stringMode) ret = \"\";\n            else ret = new Buffer(n);\n            var c = 0;\n            for(var i = 0, l = list.length; i < l && c < n; i++){\n                var buf = list[0];\n                var cpy = Math.min(n - c, buf.length);\n                if (stringMode) ret += buf.slice(0, cpy);\n                else buf.copy(ret, c, 0, cpy);\n                if (cpy < buf.length) list[0] = buf.slice(cpy);\n                else list.shift();\n                c += cpy;\n            }\n        }\n    }\n    return ret;\n}\nfunction endReadable(stream) {\n    var state = stream._readableState;\n    // If we get here before consuming all the bytes, then that is a\n    // bug in node.  Should never happen.\n    if (state.length > 0) throw new Error(\"endReadable called on non-empty stream\");\n    if (!state.endEmitted) {\n        state.ended = true;\n        process.nextTick(function() {\n            // Check that we didn't get one last unshift.\n            if (!state.endEmitted && state.length === 0) {\n                state.endEmitted = true;\n                stream.readable = false;\n                stream.emit(\"end\");\n            }\n        });\n    }\n}\nfunction forEach(xs, f) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        f(xs[i], i);\n    }\n}\nfunction indexOf(xs, x) {\n    for(var i = 0, l = xs.length; i < l; i++){\n        if (xs[i] === x) return i;\n    }\n    return -1;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekNBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZUFBZSxHQUNmLElBQUlDLFVBQVVDLG1CQUFPQSxDQUFDO0FBQ3RCLGdCQUFnQixHQUdoQixlQUFlLEdBQ2YsSUFBSUMsU0FBU0Qsb0RBQXdCO0FBQ3JDLGdCQUFnQixHQUVoQkYsU0FBU0ksYUFBYSxHQUFHQTtBQUV6QixJQUFJQyxLQUFLSCwwREFBOEI7QUFFdkMsZUFBZSxHQUNmLElBQUksQ0FBQ0csR0FBR0UsYUFBYSxFQUFFRixHQUFHRSxhQUFhLEdBQUcsU0FBU0MsT0FBTyxFQUFFQyxJQUFJO0lBQzlELE9BQU9ELFFBQVFFLFNBQVMsQ0FBQ0QsTUFBTUUsTUFBTTtBQUN2QztBQUNBLGdCQUFnQixHQUVoQixJQUFJQyxTQUFTVixtQkFBT0EsQ0FBQztBQUVyQixlQUFlLEdBQ2YsSUFBSVcsT0FBT1gsbUJBQU9BLENBQUM7QUFDbkJXLEtBQUtDLFFBQVEsR0FBR1osbUJBQU9BLENBQUM7QUFDeEIsZ0JBQWdCLEdBRWhCLElBQUlhO0FBR0osZUFBZSxHQUNmLElBQUlDLFFBQVFkLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUljLFNBQVNBLE1BQU1DLFFBQVEsRUFBRTtJQUMzQkQsUUFBUUEsTUFBTUMsUUFBUSxDQUFDO0FBQ3pCLE9B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ZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanM/MjIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbmlmICghRUUubGlzdGVuZXJDb3VudCkgRUUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gb3B0aW9ucy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IChod20gfHwgaHdtID09PSAwKSA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuXG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleClcbiAgICB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNTdHJpbmcoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVuZGVkKVxuICAgICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFhZGRUb0Zyb250ICYmICFlbmNvZGluZylcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgICAgaWYgKCFhZGRUb0Zyb250KVxuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoYWRkVG9Gcm9udClcbiAgICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgIH1cblxuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuXG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmXG4gICAgICAgICAoc3RhdGUubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24oZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcilcbiAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMTI4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiByb3VuZFVwVG9OZXh0UG93ZXJPZjIobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMlxuICAgIG4tLTtcbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IDMyOyBwIDw8PSAxKSBuIHw9IG4gPj4gcDtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZClcbiAgICByZXR1cm4gMDtcblxuICBpZiAoc3RhdGUub2JqZWN0TW9kZSlcbiAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiAxO1xuXG4gIGlmIChpc05hTihuKSB8fCB1dGlsLmlzTnVsbChuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKCF1dGlsLmlzTnVtYmVyKG4pIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgZWxzZVxuICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfVxuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHV0aWwuaXNOdWxsKHJldCkpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9XG5cbiAgc3RhdGUubGVuZ3RoIC09IG47XG5cbiAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuZW5kZWQpXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgaWYgKCF1dGlsLmlzTnVsbChyZXQpKVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCF1dGlsLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgIXV0aWwuaXNTdHJpbmcoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc051bGxPclVuZGVmaW5lZChjaHVuaykgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgICBlbHNlXG4gICAgICBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJlxuICAgICAgICAgICAgICBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICAgICAgICAgIHNlbGYucmVhZCgwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgfVxuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIGlmIChzdGF0ZS5mbG93aW5nKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGNodW5rID0gc3RyZWFtLnJlYWQoKTtcbiAgICB9IHdoaWxlIChudWxsICE9PSBjaHVuayAmJiBzdGF0ZS5mbG93aW5nKTtcbiAgfVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpXG4gICAgICAgIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbihjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHV0aWwuaXNGdW5jdGlvbihzdHJlYW1baV0pICYmIHV0aWwuaXNVbmRlZmluZWQodGhpc1tpXSkpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbihtZXRob2QpIHsgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgfX0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFkYWJsZSIsImlzQXJyYXkiLCJyZXF1aXJlIiwiQnVmZmVyIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRXZlbnRFbWl0dGVyIiwibGlzdGVuZXJDb3VudCIsImVtaXR0ZXIiLCJ0eXBlIiwibGlzdGVuZXJzIiwibGVuZ3RoIiwiU3RyZWFtIiwidXRpbCIsImluaGVyaXRzIiwiU3RyaW5nRGVjb2RlciIsImRlYnVnIiwiZGVidWdsb2ciLCJvcHRpb25zIiwic3RyZWFtIiwiRHVwbGV4IiwiaHdtIiwiaGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJvYmplY3RNb2RlIiwiYnVmZmVyIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZGVkIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJzeW5jIiwibmVlZFJlYWRhYmxlIiwiZW1pdHRlZFJlYWRhYmxlIiwicmVhZGFibGVMaXN0ZW5pbmciLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJkZWZhdWx0RW5jb2RpbmciLCJyYW5PdXQiLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiZW5jb2RpbmciLCJfcmVhZGFibGVTdGF0ZSIsInJlYWRhYmxlIiwiY2FsbCIsInByb3RvdHlwZSIsInB1c2giLCJjaHVuayIsInN0YXRlIiwiaXNTdHJpbmciLCJyZWFkYWJsZUFkZENodW5rIiwidW5zaGlmdCIsImFkZFRvRnJvbnQiLCJlciIsImNodW5rSW52YWxpZCIsImVtaXQiLCJpc051bGxPclVuZGVmaW5lZCIsIm9uRW9mQ2h1bmsiLCJlIiwiRXJyb3IiLCJ3cml0ZSIsInJlYWQiLCJlbWl0UmVhZGFibGUiLCJtYXliZVJlYWRNb3JlIiwibmVlZE1vcmVEYXRhIiwic2V0RW5jb2RpbmciLCJlbmMiLCJNQVhfSFdNIiwicm91bmRVcFRvTmV4dFBvd2VyT2YyIiwibiIsInAiLCJob3dNdWNoVG9SZWFkIiwiaXNOYU4iLCJpc051bGwiLCJuT3JpZyIsImlzTnVtYmVyIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJfcmVhZCIsInJldCIsImZyb21MaXN0IiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJlbmQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJlbWl0UmVhZGFibGVfIiwiZmxvdyIsIm1heWJlUmVhZE1vcmVfIiwibGVuIiwicGlwZSIsImRlc3QiLCJwaXBlT3B0cyIsInNyYyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJvbmVuZCIsImNsZWFudXAiLCJvbmNlIiwib24iLCJvbnVucGlwZSIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsInJlbW92ZUxpc3RlbmVyIiwib25jbG9zZSIsIm9uZmluaXNoIiwib25lcnJvciIsIm9uZGF0YSIsIl93cml0YWJsZVN0YXRlIiwibmVlZERyYWluIiwicGF1c2UiLCJ1bnBpcGUiLCJfZXZlbnRzIiwiZXJyb3IiLCJyZXN1bWUiLCJkZXN0cyIsImkiLCJpbmRleE9mIiwic3BsaWNlIiwiZXYiLCJmbiIsInJlcyIsInNlbGYiLCJhZGRMaXN0ZW5lciIsInJlc3VtZVNjaGVkdWxlZCIsInJlc3VtZV8iLCJ3cmFwIiwicGF1c2VkIiwiaXNGdW5jdGlvbiIsImlzVW5kZWZpbmVkIiwibWV0aG9kIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJldmVudHMiLCJmb3JFYWNoIiwiYmluZCIsIl9mcm9tTGlzdCIsImxpc3QiLCJzdHJpbmdNb2RlIiwic2hpZnQiLCJqb2luIiwiY29uY2F0IiwiYnVmIiwic2xpY2UiLCJjIiwibCIsImNweSIsIk1hdGgiLCJtaW4iLCJjb3B5IiwieHMiLCJmIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/lib/_stream_readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\nmodule.exports = Transform;\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ util.inherits(Transform, Duplex);\nfunction TransformState(options, stream) {\n    this.afterTransform = function(er, data) {\n        return afterTransform(stream, er, data);\n    };\n    this.needTransform = false;\n    this.transforming = false;\n    this.writecb = null;\n    this.writechunk = null;\n}\nfunction afterTransform(stream, er, data) {\n    var ts = stream._transformState;\n    ts.transforming = false;\n    var cb = ts.writecb;\n    if (!cb) return stream.emit(\"error\", new Error(\"no writecb in Transform class\"));\n    ts.writechunk = null;\n    ts.writecb = null;\n    if (!util.isNullOrUndefined(data)) stream.push(data);\n    if (cb) cb(er);\n    var rs = stream._readableState;\n    rs.reading = false;\n    if (rs.needReadable || rs.length < rs.highWaterMark) {\n        stream._read(rs.highWaterMark);\n    }\n}\nfunction Transform(options) {\n    if (!(this instanceof Transform)) return new Transform(options);\n    Duplex.call(this, options);\n    this._transformState = new TransformState(options, this);\n    // when the writable side finishes, then flush out anything remaining.\n    var stream = this;\n    // start out asking for a readable event once data is transformed.\n    this._readableState.needReadable = true;\n    // we have implemented the _read method, and done the other things\n    // that Readable wants before the first _read call, so unset the\n    // sync guard flag.\n    this._readableState.sync = false;\n    this.once(\"prefinish\", function() {\n        if (util.isFunction(this._flush)) this._flush(function(er) {\n            done(stream, er);\n        });\n        else done(stream);\n    });\n}\nTransform.prototype.push = function(chunk, encoding) {\n    this._transformState.needTransform = false;\n    return Duplex.prototype.push.call(this, chunk, encoding);\n};\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n    throw new Error(\"not implemented\");\n};\nTransform.prototype._write = function(chunk, encoding, cb) {\n    var ts = this._transformState;\n    ts.writecb = cb;\n    ts.writechunk = chunk;\n    ts.writeencoding = encoding;\n    if (!ts.transforming) {\n        var rs = this._readableState;\n        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n    }\n};\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n    var ts = this._transformState;\n    if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n        ts.transforming = true;\n        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n    } else {\n        // mark that we need a transform, so that any data that comes in\n        // will get processed, now that we've asked for it.\n        ts.needTransform = true;\n    }\n};\nfunction done(stream, er) {\n    if (er) return stream.emit(\"error\", er);\n    // if there's nothing in the write buffer, then that means\n    // that nothing more will ever be provided\n    var ws = stream._writableState;\n    var ts = stream._transformState;\n    if (ws.length) throw new Error(\"calling transform done when ws.length != 0\");\n    if (ts.transforming) throw new Error(\"calling transform done when still transforming\");\n    return stream.push(null);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSxnRUFBZ0U7QUFDaEUsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUscUVBQXFFO0FBQ3JFLHdCQUF3QjtBQUN4QixFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLHlEQUF5RDtBQUN6RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLDZEQUE2RDtBQUM3RCw0RUFBNEU7QUFDNUUsMkVBQTJFO0FBQzNFLHdFQUF3RTtBQUN4RSw0RUFBNEU7QUFDNUUseUNBQXlDO0FBR3pDLGdFQUFnRTtBQUNoRSw4REFBOEQ7QUFDOUQsdUVBQXVFO0FBQ3ZFLHNFQUFzRTtBQUN0RSxpREFBaUQ7QUFDakQsRUFBRTtBQUNGLGdFQUFnRTtBQUNoRSxxRUFBcUU7QUFDckUsa0VBQWtFO0FBQ2xFLDBEQUEwRDtBQUMxRCxFQUFFO0FBQ0YseUJBQXlCO0FBQ3pCLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUsc0VBQXNFO0FBQ3RFLG1FQUFtRTtBQUNuRSxnRUFBZ0U7QUFDaEUsb0RBQW9EO0FBQ3BELEVBQUU7QUFDRix1RUFBdUU7QUFDdkUsb0VBQW9FO0FBQ3BFLHFFQUFxRTtBQUNyRSx1RUFBdUU7QUFDdkUscUVBQXFFO0FBQ3JFLHNFQUFzRTtBQUN0RSxFQUFFO0FBQ0Ysc0VBQXNFO0FBQ3RFLDBFQUEwRTtBQUMxRSx5RUFBeUU7QUFDekUsb0VBQW9FO0FBQ3BFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFLHNFQUFzRTtBQUN0RSxxRUFBcUU7QUFDckUsb0VBQW9FO0FBQ3BFLHlDQUF5QztBQUN6QyxFQUFFO0FBQ0YseUVBQXlFO0FBQ3pFLHlFQUF5RTtBQUN6RSwrREFBK0Q7QUFFL0RBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsU0FB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QUdILFlBQVksRUFDakIsTUFBTSxJQUFJTyxNQUFNO0lBRWxCLE9BQU9aLE9BQU9jLElBQUksQ0FBQztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanM/MjQyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQoZGF0YSkpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodXRpbC5pc0Z1bmN0aW9uKHRoaXMuX2ZsdXNoKSlcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICghdXRpbC5pc051bGwodHMud3JpdGVjaHVuaykgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIpIHtcbiAgaWYgKGVyKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiVHJhbnNmb3JtIiwiRHVwbGV4IiwicmVxdWlyZSIsInV0aWwiLCJpbmhlcml0cyIsIlRyYW5zZm9ybVN0YXRlIiwib3B0aW9ucyIsInN0cmVhbSIsImFmdGVyVHJhbnNmb3JtIiwiZXIiLCJkYXRhIiwibmVlZFRyYW5zZm9ybSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2IiLCJ3cml0ZWNodW5rIiwidHMiLCJfdHJhbnNmb3JtU3RhdGUiLCJjYiIsImVtaXQiLCJFcnJvciIsImlzTnVsbE9yVW5kZWZpbmVkIiwicHVzaCIsInJzIiwiX3JlYWRhYmxlU3RhdGUiLCJyZWFkaW5nIiwibmVlZFJlYWRhYmxlIiwibGVuZ3RoIiwiaGlnaFdhdGVyTWFyayIsIl9yZWFkIiwiY2FsbCIsInN5bmMiLCJvbmNlIiwiaXNGdW5jdGlvbiIsIl9mbHVzaCIsImRvbmUiLCJwcm90b3R5cGUiLCJjaHVuayIsImVuY29kaW5nIiwiX3RyYW5zZm9ybSIsIl93cml0ZSIsIndyaXRlZW5jb2RpbmciLCJuIiwiaXNOdWxsIiwid3MiLCJfd3JpdGFibGVTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/lib/_stream_transform.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\nmodule.exports = Writable;\n/*<replacement>*/ var Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n/*</replacement>*/ Writable.WritableState = WritableState;\n/*<replacement>*/ var util = __webpack_require__(/*! core-util-is */ \"(rsc)/./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\n/*</replacement>*/ var Stream = __webpack_require__(/*! stream */ \"stream\");\nutil.inherits(Writable, Stream);\nfunction WriteReq(chunk, encoding, cb) {\n    this.chunk = chunk;\n    this.encoding = encoding;\n    this.callback = cb;\n}\nfunction WritableState(options, stream) {\n    var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n    options = options || {};\n    // the point at which write() starts returning false\n    // Note: 0 is a valid value, means that we always return false if\n    // the entire buffer is not flushed immediately on write()\n    var hwm = options.highWaterMark;\n    var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n    // object stream flag to indicate whether or not this stream\n    // contains buffers or objects.\n    this.objectMode = !!options.objectMode;\n    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n    // cast to ints.\n    this.highWaterMark = ~~this.highWaterMark;\n    this.needDrain = false;\n    // at the start of calling end()\n    this.ending = false;\n    // when end() has been called, and returned\n    this.ended = false;\n    // when 'finish' is emitted\n    this.finished = false;\n    // should we decode strings into buffers before passing to _write?\n    // this is here so that some node-core streams can optimize string\n    // handling at a lower level.\n    var noDecode = options.decodeStrings === false;\n    this.decodeStrings = !noDecode;\n    // Crypto is kind of old and crusty.  Historically, its default string\n    // encoding is 'binary' so we have to make this configurable.\n    // Everything else in the universe uses 'utf8', though.\n    this.defaultEncoding = options.defaultEncoding || \"utf8\";\n    // not an actual buffer we keep track of, but a measurement\n    // of how much we're waiting to get pushed to some underlying\n    // socket or file.\n    this.length = 0;\n    // a flag to see when we're in the middle of a write.\n    this.writing = false;\n    // when true all writes will be buffered until .uncork() call\n    this.corked = 0;\n    // a flag to be able to tell if the onwrite cb is called immediately,\n    // or on a later tick.  We set this to true at first, because any\n    // actions that shouldn't happen until \"later\" should generally also\n    // not happen before the first write call.\n    this.sync = true;\n    // a flag to know if we're processing previously buffered items, which\n    // may call the _write() callback in the same tick, so that we don't\n    // end up in an overlapped onwrite situation.\n    this.bufferProcessing = false;\n    // the callback that's passed to _write(chunk,cb)\n    this.onwrite = function(er) {\n        onwrite(stream, er);\n    };\n    // the callback that the user supplies to write(chunk,encoding,cb)\n    this.writecb = null;\n    // the amount that is being written when _write is called.\n    this.writelen = 0;\n    this.buffer = [];\n    // number of pending user-supplied write callbacks\n    // this must be 0 before 'finish' can be emitted\n    this.pendingcb = 0;\n    // emit prefinish if the only thing we're waiting for is _write cbs\n    // This is relevant for synchronous Transform streams\n    this.prefinished = false;\n    // True if the error was already emitted and should not be thrown again\n    this.errorEmitted = false;\n}\nfunction Writable(options) {\n    var Duplex = __webpack_require__(/*! ./_stream_duplex */ \"(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\");\n    // Writable ctor is applied to Duplexes, though they're not\n    // instanceof Writable, they're instanceof Readable.\n    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n    this._writableState = new WritableState(options, this);\n    // legacy.\n    this.writable = true;\n    Stream.call(this);\n}\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n    this.emit(\"error\", new Error(\"Cannot pipe. Not readable.\"));\n};\nfunction writeAfterEnd(stream, state, cb) {\n    var er = new Error(\"write after end\");\n    // TODO: defer error events consistently everywhere, not just the cb\n    stream.emit(\"error\", er);\n    process.nextTick(function() {\n        cb(er);\n    });\n}\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n    var valid = true;\n    if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {\n        var er = new TypeError(\"Invalid non-string/buffer chunk\");\n        stream.emit(\"error\", er);\n        process.nextTick(function() {\n            cb(er);\n        });\n        valid = false;\n    }\n    return valid;\n}\nWritable.prototype.write = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    var ret = false;\n    if (util.isFunction(encoding)) {\n        cb = encoding;\n        encoding = null;\n    }\n    if (util.isBuffer(chunk)) encoding = \"buffer\";\n    else if (!encoding) encoding = state.defaultEncoding;\n    if (!util.isFunction(cb)) cb = function() {};\n    if (state.ended) writeAfterEnd(this, state, cb);\n    else if (validChunk(this, state, chunk, cb)) {\n        state.pendingcb++;\n        ret = writeOrBuffer(this, state, chunk, encoding, cb);\n    }\n    return ret;\n};\nWritable.prototype.cork = function() {\n    var state = this._writableState;\n    state.corked++;\n};\nWritable.prototype.uncork = function() {\n    var state = this._writableState;\n    if (state.corked) {\n        state.corked--;\n        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length) clearBuffer(this, state);\n    }\n};\nfunction decodeChunk(state, chunk, encoding) {\n    if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {\n        chunk = new Buffer(chunk, encoding);\n    }\n    return chunk;\n}\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n    chunk = decodeChunk(state, chunk, encoding);\n    if (util.isBuffer(chunk)) encoding = \"buffer\";\n    var len = state.objectMode ? 1 : chunk.length;\n    state.length += len;\n    var ret = state.length < state.highWaterMark;\n    // we must ensure that previous needDrain will not be reset to false.\n    if (!ret) state.needDrain = true;\n    if (state.writing || state.corked) state.buffer.push(new WriteReq(chunk, encoding, cb));\n    else doWrite(stream, state, false, len, chunk, encoding, cb);\n    return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n    state.writelen = len;\n    state.writecb = cb;\n    state.writing = true;\n    state.sync = true;\n    if (writev) stream._writev(chunk, state.onwrite);\n    else stream._write(chunk, encoding, state.onwrite);\n    state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n    if (sync) process.nextTick(function() {\n        state.pendingcb--;\n        cb(er);\n    });\n    else {\n        state.pendingcb--;\n        cb(er);\n    }\n    stream._writableState.errorEmitted = true;\n    stream.emit(\"error\", er);\n}\nfunction onwriteStateUpdate(state) {\n    state.writing = false;\n    state.writecb = null;\n    state.length -= state.writelen;\n    state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n    var state = stream._writableState;\n    var sync = state.sync;\n    var cb = state.writecb;\n    onwriteStateUpdate(state);\n    if (er) onwriteError(stream, state, sync, er, cb);\n    else {\n        // Check if we're actually ready to finish, but don't emit yet\n        var finished = needFinish(stream, state);\n        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {\n            clearBuffer(stream, state);\n        }\n        if (sync) {\n            process.nextTick(function() {\n                afterWrite(stream, state, finished, cb);\n            });\n        } else {\n            afterWrite(stream, state, finished, cb);\n        }\n    }\n}\nfunction afterWrite(stream, state, finished, cb) {\n    if (!finished) onwriteDrain(stream, state);\n    state.pendingcb--;\n    cb();\n    finishMaybe(stream, state);\n}\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n    if (state.length === 0 && state.needDrain) {\n        state.needDrain = false;\n        stream.emit(\"drain\");\n    }\n}\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n    state.bufferProcessing = true;\n    if (stream._writev && state.buffer.length > 1) {\n        // Fast case, write everything using _writev()\n        var cbs = [];\n        for(var c = 0; c < state.buffer.length; c++)cbs.push(state.buffer[c].callback);\n        // count the one we are adding, as well.\n        // TODO(isaacs) clean this up\n        state.pendingcb++;\n        doWrite(stream, state, true, state.length, state.buffer, \"\", function(err) {\n            for(var i = 0; i < cbs.length; i++){\n                state.pendingcb--;\n                cbs[i](err);\n            }\n        });\n        // Clear buffer\n        state.buffer = [];\n    } else {\n        // Slow case, write chunks one-by-one\n        for(var c = 0; c < state.buffer.length; c++){\n            var entry = state.buffer[c];\n            var chunk = entry.chunk;\n            var encoding = entry.encoding;\n            var cb = entry.callback;\n            var len = state.objectMode ? 1 : chunk.length;\n            doWrite(stream, state, false, len, chunk, encoding, cb);\n            // if we didn't call the onwrite immediately, then\n            // it means that we need to wait until it does.\n            // also, that means that the chunk and cb are currently\n            // being processed, so move the buffer counter past them.\n            if (state.writing) {\n                c++;\n                break;\n            }\n        }\n        if (c < state.buffer.length) state.buffer = state.buffer.slice(c);\n        else state.buffer.length = 0;\n    }\n    state.bufferProcessing = false;\n}\nWritable.prototype._write = function(chunk, encoding, cb) {\n    cb(new Error(\"not implemented\"));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function(chunk, encoding, cb) {\n    var state = this._writableState;\n    if (util.isFunction(chunk)) {\n        cb = chunk;\n        chunk = null;\n        encoding = null;\n    } else if (util.isFunction(encoding)) {\n        cb = encoding;\n        encoding = null;\n    }\n    if (!util.isNullOrUndefined(chunk)) this.write(chunk, encoding);\n    // .end() fully uncorks\n    if (state.corked) {\n        state.corked = 1;\n        this.uncork();\n    }\n    // ignore unnecessary end() calls.\n    if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\nfunction needFinish(stream, state) {\n    return state.ending && state.length === 0 && !state.finished && !state.writing;\n}\nfunction prefinish(stream, state) {\n    if (!state.prefinished) {\n        state.prefinished = true;\n        stream.emit(\"prefinish\");\n    }\n}\nfunction finishMaybe(stream, state) {\n    var need = needFinish(stream, state);\n    if (need) {\n        if (state.pendingcb === 0) {\n            prefinish(stream, state);\n            state.finished = true;\n            stream.emit(\"finish\");\n        } else prefinish(stream, state);\n    }\n    return need;\n}\nfunction endWritable(stream, state, cb) {\n    state.ending = true;\n    finishMaybe(stream, state);\n    if (cb) {\n        if (state.finished) process.nextTick(cb);\n        else stream.once(\"finish\", cb);\n    }\n    state.ended = true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7QUFFekMsdUNBQXVDO0FBQ3ZDLDhEQUE4RDtBQUM5RCwwQ0FBMEM7QUFFMUNBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsZUFBZSxHQUNmLElBQUlDLFNBQVNDLG9EQUF3QjtBQUNyQyxnQkFBZ0IsR0FFaEJGLFNBQVNHLGFBQWEsR0FBR0E7QUFHekIsZUFBZSxHQUNmLElBQUlDLE9BQU9GLG1CQUFPQSxDQUFDO0FBQ25CRSxLQUFLQyxRQUFRLEdBQUdILG1CQUFPQSxDQUFDO0FBQ3hCLGdCQUFnQixHQUVoQixJQUFJSSxTQUFTSixtQkFBT0EsQ0FBQztBQUVyQkUsS0FBS0MsUUFBUSxDQUFDTCxVQUFVTTtBQUV4QixTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsRUFBRTtJQUNuQyxJQUFJLENBQUNGLEtBQUssR0FBR0E7SUFDYixJQUFJLENBQUNDLFFBQVEsR0FBR0E7SUFDaEIsSUFBSSxDQUFDRSxRQUFRLEdBQUdEO0FBQ2xCO0FBRUEsU0FBU1AsY0FBY1MsT0FBTyxFQUFFQyxNQUFNO0lBQ3BDLElBQUlDLFNBQVNaLG1CQUFPQSxDQUFDO0lBRXJCVSxVQUFVQSxXQUFXLENBQUM7SUFFdEIsb0RBQW9EO0lBQ3BELGlFQUFpRTtJQUNqRSwwREFBMEQ7SUFDMUQsSUFBSUcs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b3JtLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcz9jZjFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSBvcHRpb25zLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgY2IoZXIpO1xuICB9KTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICBpZiAoIXV0aWwuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAhdXRpbC5pc1N0cmluZyhjaHVuaykgJiZcbiAgICAgICF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh1dGlsLmlzRnVuY3Rpb24oZW5jb2RpbmcpKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodXRpbC5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgZWxzZSBpZiAoIWVuY29kaW5nKVxuICAgIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICghdXRpbC5pc0Z1bmN0aW9uKGNiKSlcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmXG4gICAgICBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJlxuICAgICAgdXRpbC5pc1N0cmluZyhjaHVuaykpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKHV0aWwuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpXG4gICAgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpXG4gICAgc3RhdGUuYnVmZmVyLnB1c2gobmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpKTtcbiAgZWxzZVxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpXG4gICAgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO1xuICBlbHNlXG4gICAgc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcik7XG4gIH1cblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmXG4gICAgICAgIHN0YXRlLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgc3RhdGUuYnVmZmVyLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGNicyA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aDsgYysrKVxuICAgICAgY2JzLnB1c2goc3RhdGUuYnVmZmVyW2NdLmNhbGxiYWNrKTtcblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5idWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICAgIHN0YXRlLmJ1ZmZlciA9IFtdO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyW2NdO1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYysrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gICAgZWxzZVxuICAgICAgc3RhdGUuYnVmZmVyLmxlbmd0aCA9IDA7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xuXG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHV0aWwuaXNGdW5jdGlvbihjaHVuaykpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodXRpbC5pc0Z1bmN0aW9uKGVuY29kaW5nKSkge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKVxuICAgIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICByZXR1cm4gKHN0YXRlLmVuZGluZyAmJlxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAgICFzdGF0ZS53cml0aW5nKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZVxuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIldyaXRhYmxlIiwiQnVmZmVyIiwicmVxdWlyZSIsIldyaXRhYmxlU3RhdGUiLCJ1dGlsIiwiaW5oZXJpdHMiLCJTdHJlYW0iLCJXcml0ZVJlcSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImNhbGxiYWNrIiwib3B0aW9ucyIsInN0cmVhbSIsIkR1cGxleCIsImh3bSIsImhpZ2hXYXRlck1hcmsiLCJkZWZhdWx0SHdtIiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm5lZWREcmFpbiIsImVuZGluZyIsImVuZGVkIiwiZmluaXNoZWQiLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJkZWZhdWx0RW5jb2RpbmciLCJsZW5ndGgiLCJ3cml0aW5nIiwiY29ya2VkIiwic3luYyIsImJ1ZmZlclByb2Nlc3NpbmciLCJvbndyaXRlIiwiZXIiLCJ3cml0ZWNiIiwid3JpdGVsZW4iLCJidWZmZXIiLCJwZW5kaW5nY2IiLCJwcmVmaW5pc2hlZCIsImVycm9yRW1pdHRlZCIsIl93cml0YWJsZVN0YXRlIiwid3JpdGFibGUiLCJjYWxsIiwicHJvdG90eXBlIiwicGlwZSIsImVtaXQiLCJFcnJvciIsIndyaXRlQWZ0ZXJFbmQiLCJzdGF0ZSIsInByb2Nlc3MiLCJuZXh0VGljayIsInZhbGlkQ2h1bmsiLCJ2YWxpZCIsImlzQnVmZmVyIiwiaXNTdHJpbmciLCJpc051bGxPclVuZGVmaW5lZCIsIlR5cGVFcnJvciIsIndyaXRlIiwicmV0IiwiaXNGdW5jdGlvbiIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJkZWNvZGVDaHVuayIsImxlbiIsInB1c2giLCJkb1dyaXRlIiwid3JpdGV2IiwiX3dyaXRldiIsIl93cml0ZSIsIm9ud3JpdGVFcnJvciIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiZmluaXNoTWF5YmUiLCJjYnMiLCJjIiwiZXJyIiwiaSIsImVudHJ5Iiwic2xpY2UiLCJlbmQiLCJlbmRXcml0YWJsZSIsInByZWZpbmlzaCIsIm5lZWQiLCJvbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/lib/_stream_writable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readable-stream/node_modules/isarray/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/node_modules/isarray/index.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("module.exports = Array.isArray || function(arr) {\n    return Object.prototype.toString.call(arr) == \"[object Array]\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/YTAzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkFycmF5IiwiaXNBcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU9DLE9BQU8sR0FBR0MsTUFBTUMsT0FBTyxJQUFJLFNBQVVDLEdBQUc7SUFDN0MsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0osUUFBUTtBQUNoRCIsImZpbGUiOiIocnNjKS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/node_modules/isarray/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/readable-stream/readable.js":
/*!**************************************************!*\
  !*** ./node_modules/readable-stream/readable.js ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"(rsc)/./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = __webpack_require__(/*! stream */ \"stream\");\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"(rsc)/./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"(rsc)/./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"(rsc)/./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"(rsc)/./node_modules/readable-stream/lib/_stream_passthrough.js\");\nif ( true && process.env.READABLE_STREAM === \"disable\") {\n    module.exports = __webpack_require__(/*! stream */ \"stream\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBQSxVQUFVQyxxSUFBeUI7QUFDbkNELDREQUF5QjtBQUN6QkEsZ0JBQWdCLEdBQUdBO0FBQ25CQSx1SUFBMkI7QUFDM0JBLGlJQUF5QjtBQUN6QkEsMElBQTRCO0FBQzVCQSxnSkFBOEI7QUFDOUIsSUFBSSxLQUFnQixJQUFJUyxRQUFRRSxHQUFHLENBQUNDLGVBQWUsS0FBSyxXQUFXO0lBQ2pFWCw0REFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanM/YTdhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnc3RyZWFtJyk7XG59XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJTdHJlYW0iLCJSZWFkYWJsZSIsIldyaXRhYmxlIiwiRHVwbGV4IiwiVHJhbnNmb3JtIiwiUGFzc1Rocm91Z2giLCJwcm9jZXNzIiwiYnJvd3NlciIsImVudiIsIlJFQURBQkxFX1NUUkVBTSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/readable-stream/readable.js\n");

/***/ })

};
;