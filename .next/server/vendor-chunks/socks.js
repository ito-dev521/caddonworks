"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/socks";
exports.ids = ["vendor-chunks/socks"];
exports.modules = {

/***/ "(rsc)/./node_modules/socks/build/client/socksclient.js":
/*!********************************************************!*\
  !*** ./node_modules/socks/build/client/socksclient.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SocksClientError = exports.SocksClient = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst smart_buffer_1 = __webpack_require__(/*! smart-buffer */ \"(rsc)/./node_modules/smart-buffer/build/smartbuffer.js\");\nconst constants_1 = __webpack_require__(/*! ../common/constants */ \"(rsc)/./node_modules/socks/build/common/constants.js\");\nconst helpers_1 = __webpack_require__(/*! ../common/helpers */ \"(rsc)/./node_modules/socks/build/common/helpers.js\");\nconst receivebuffer_1 = __webpack_require__(/*! ../common/receivebuffer */ \"(rsc)/./node_modules/socks/build/common/receivebuffer.js\");\nconst util_1 = __webpack_require__(/*! ../common/util */ \"(rsc)/./node_modules/socks/build/common/util.js\");\nObject.defineProperty(exports, \"SocksClientError\", ({\n    enumerable: true,\n    get: function() {\n        return util_1.SocksClientError;\n    }\n}));\nconst ip_address_1 = __webpack_require__(/*! ip-address */ \"(rsc)/./node_modules/ip-address/dist/ip-address.js\");\nclass SocksClient extends events_1.EventEmitter {\n    constructor(options){\n        super();\n        this.options = Object.assign({}, options);\n        // Validate SocksClientOptions\n        (0, helpers_1.validateSocksClientOptions)(options);\n        // Default state\n        this.setState(constants_1.SocksClientState.Created);\n    }\n    /**\n     * Creates a new SOCKS connection.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect command.\n     * @param options { SocksClientOptions } Options.\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */ static createConnection(options, callback) {\n        return new Promise((resolve, reject)=>{\n            // Validate SocksClientOptions\n            try {\n                (0, helpers_1.validateSocksClientOptions)(options, [\n                    \"connect\"\n                ]);\n            } catch (err) {\n                if (typeof callback === \"function\") {\n                    callback(err);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    return resolve(err); // Resolves pending promise (prevents memory leaks).\n                } else {\n                    return reject(err);\n                }\n            }\n            const client = new SocksClient(options);\n            client.connect(options.existing_socket);\n            client.once(\"established\", (info)=>{\n                client.removeAllListeners();\n                if (typeof callback === \"function\") {\n                    callback(null, info);\n                    resolve(info); // Resolves pending promise (prevents memory leaks).\n                } else {\n                    resolve(info);\n                }\n            });\n            // Error occurred, failed to establish connection.\n            client.once(\"error\", (err)=>{\n                client.removeAllListeners();\n                if (typeof callback === \"function\") {\n                    callback(err);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    resolve(err); // Resolves pending promise (prevents memory leaks).\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    /**\n     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect method.\n     * Note: Implemented via createConnection() factory function.\n     * @param options { SocksClientChainOptions } Options\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */ static createConnectionChain(options, callback) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                // Validate SocksClientChainOptions\n                try {\n                    (0, helpers_1.validateSocksClientChainOptions)(options);\n                } catch (err) {\n                    if (typeof callback === \"function\") {\n                        callback(err);\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        return resolve(err); // Resolves pending promise (prevents memory leaks).\n                    } else {\n                        return reject(err);\n                    }\n                }\n                // Shuffle proxies\n                if (options.randomizeChain) {\n                    (0, util_1.shuffleArray)(options.proxies);\n                }\n                try {\n                    let sock;\n                    for(let i = 0; i < options.proxies.length; i++){\n                        const nextProxy = options.proxies[i];\n                        // If we've reached the last proxy in the chain, the destination is the actual destination, otherwise it's the next proxy.\n                        const nextDestination = i === options.proxies.length - 1 ? options.destination : {\n                            host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,\n                            port: options.proxies[i + 1].port\n                        };\n                        // Creates the next connection in the chain.\n                        const result = yield SocksClient.createConnection({\n                            command: \"connect\",\n                            proxy: nextProxy,\n                            destination: nextDestination,\n                            existing_socket: sock\n                        });\n                        // If sock is undefined, assign it here.\n                        sock = sock || result.socket;\n                    }\n                    if (typeof callback === \"function\") {\n                        callback(null, {\n                            socket: sock\n                        });\n                        resolve({\n                            socket: sock\n                        }); // Resolves pending promise (prevents memory leaks).\n                    } else {\n                        resolve({\n                            socket: sock\n                        });\n                    }\n                } catch (err) {\n                    if (typeof callback === \"function\") {\n                        callback(err);\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        resolve(err); // Resolves pending promise (prevents memory leaks).\n                    } else {\n                        reject(err);\n                    }\n                }\n            }));\n    }\n    /**\n     * Creates a SOCKS UDP Frame.\n     * @param options\n     */ static createUDPFrame(options) {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt16BE(0);\n        buff.writeUInt8(options.frameNumber || 0);\n        // IPv4/IPv6/Hostname\n        if (net.isIPv4(options.remoteHost.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n            buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));\n        } else if (net.isIPv6(options.remoteHost.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));\n        } else {\n            buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n            buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));\n            buff.writeString(options.remoteHost.host);\n        }\n        // Port\n        buff.writeUInt16BE(options.remoteHost.port);\n        // Data\n        buff.writeBuffer(options.data);\n        return buff.toBuffer();\n    }\n    /**\n     * Parses a SOCKS UDP frame.\n     * @param data\n     */ static parseUDPFrame(data) {\n        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n        buff.readOffset = 2;\n        const frameNumber = buff.readUInt8();\n        const hostType = buff.readUInt8();\n        let remoteHost;\n        if (hostType === constants_1.Socks5HostType.IPv4) {\n            remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());\n        } else if (hostType === constants_1.Socks5HostType.IPv6) {\n            remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();\n        } else {\n            remoteHost = buff.readString(buff.readUInt8());\n        }\n        const remotePort = buff.readUInt16BE();\n        return {\n            frameNumber,\n            remoteHost: {\n                host: remoteHost,\n                port: remotePort\n            },\n            data: buff.readBuffer()\n        };\n    }\n    /**\n     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.\n     */ setState(newState) {\n        if (this.state !== constants_1.SocksClientState.Error) {\n            this.state = newState;\n        }\n    }\n    /**\n     * Starts the connection establishment to the proxy and destination.\n     * @param existingSocket Connected socket to use instead of creating a new one (internal use).\n     */ connect(existingSocket) {\n        this.onDataReceived = (data)=>this.onDataReceivedHandler(data);\n        this.onClose = ()=>this.onCloseHandler();\n        this.onError = (err)=>this.onErrorHandler(err);\n        this.onConnect = ()=>this.onConnectHandler();\n        // Start timeout timer (defaults to 30 seconds)\n        const timer = setTimeout(()=>this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);\n        // check whether unref is available as it differs from browser to NodeJS (#33)\n        if (timer.unref && typeof timer.unref === \"function\") {\n            timer.unref();\n        }\n        // If an existing socket is provided, use it to negotiate SOCKS handshake. Otherwise create a new Socket.\n        if (existingSocket) {\n            this.socket = existingSocket;\n        } else {\n            this.socket = new net.Socket();\n        }\n        // Attach Socket error handlers.\n        this.socket.once(\"close\", this.onClose);\n        this.socket.once(\"error\", this.onError);\n        this.socket.once(\"connect\", this.onConnect);\n        this.socket.on(\"data\", this.onDataReceived);\n        this.setState(constants_1.SocksClientState.Connecting);\n        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();\n        if (existingSocket) {\n            this.socket.emit(\"connect\");\n        } else {\n            this.socket.connect(this.getSocketOptions());\n            if (this.options.set_tcp_nodelay !== undefined && this.options.set_tcp_nodelay !== null) {\n                this.socket.setNoDelay(!!this.options.set_tcp_nodelay);\n            }\n        }\n        // Listen for established event so we can re-emit any excess data received during handshakes.\n        this.prependOnceListener(\"established\", (info)=>{\n            setImmediate(()=>{\n                if (this.receiveBuffer.length > 0) {\n                    const excessData = this.receiveBuffer.get(this.receiveBuffer.length);\n                    info.socket.emit(\"data\", excessData);\n                }\n                info.socket.resume();\n            });\n        });\n    }\n    // Socket options (defaults host/port to options.proxy.host/options.proxy.port)\n    getSocketOptions() {\n        return Object.assign(Object.assign({}, this.options.socket_options), {\n            host: this.options.proxy.host || this.options.proxy.ipaddress,\n            port: this.options.proxy.port\n        });\n    }\n    /**\n     * Handles internal Socks timeout callback.\n     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.\n     */ onEstablishedTimeout() {\n        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {\n            this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);\n        }\n    }\n    /**\n     * Handles Socket connect event.\n     */ onConnectHandler() {\n        this.setState(constants_1.SocksClientState.Connected);\n        // Send initial handshake.\n        if (this.options.proxy.type === 4) {\n            this.sendSocks4InitialHandshake();\n        } else {\n            this.sendSocks5InitialHandshake();\n        }\n        this.setState(constants_1.SocksClientState.SentInitialHandshake);\n    }\n    /**\n     * Handles Socket data event.\n     * @param data\n     */ onDataReceivedHandler(data) {\n        /*\n          All received data is appended to a ReceiveBuffer.\n          This makes sure that all the data we need is received before we attempt to process it.\n        */ this.receiveBuffer.append(data);\n        // Process data that we have.\n        this.processData();\n    }\n    /**\n     * Handles processing of the data we have received.\n     */ processData() {\n        // If we have enough data to process the next step in the SOCKS handshake, proceed.\n        while(this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize){\n            // Sent initial handshake, waiting for response.\n            if (this.state === constants_1.SocksClientState.SentInitialHandshake) {\n                if (this.options.proxy.type === 4) {\n                    // Socks v4 only has one handshake response.\n                    this.handleSocks4FinalHandshakeResponse();\n                } else {\n                    // Socks v5 has two handshakes, handle initial one here.\n                    this.handleInitialSocks5HandshakeResponse();\n                }\n            // Sent auth request for Socks v5, waiting for response.\n            } else if (this.state === constants_1.SocksClientState.SentAuthentication) {\n                this.handleInitialSocks5AuthenticationHandshakeResponse();\n            // Sent final Socks v5 handshake, waiting for final response.\n            } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {\n                this.handleSocks5FinalHandshakeResponse();\n            // Socks BIND established. Waiting for remote connection via proxy.\n            } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {\n                if (this.options.proxy.type === 4) {\n                    this.handleSocks4IncomingConnectionResponse();\n                } else {\n                    this.handleSocks5IncomingConnectionResponse();\n                }\n            } else {\n                this.closeSocket(constants_1.ERRORS.InternalError);\n                break;\n            }\n        }\n    }\n    /**\n     * Handles Socket close event.\n     * @param had_error\n     */ onCloseHandler() {\n        this.closeSocket(constants_1.ERRORS.SocketClosed);\n    }\n    /**\n     * Handles Socket error event.\n     * @param err\n     */ onErrorHandler(err) {\n        this.closeSocket(err.message);\n    }\n    /**\n     * Removes internal event listeners on the underlying Socket.\n     */ removeInternalSocketHandlers() {\n        // Pauses data flow of the socket (this is internally resumed after 'established' is emitted)\n        this.socket.pause();\n        this.socket.removeListener(\"data\", this.onDataReceived);\n        this.socket.removeListener(\"close\", this.onClose);\n        this.socket.removeListener(\"error\", this.onError);\n        this.socket.removeListener(\"connect\", this.onConnect);\n    }\n    /**\n     * Closes and destroys the underlying Socket. Emits an error event.\n     * @param err { String } An error string to include in error event.\n     */ closeSocket(err) {\n        // Make sure only one 'error' event is fired for the lifetime of this SocksClient instance.\n        if (this.state !== constants_1.SocksClientState.Error) {\n            // Set internal state to Error.\n            this.setState(constants_1.SocksClientState.Error);\n            // Destroy Socket\n            this.socket.destroy();\n            // Remove internal listeners\n            this.removeInternalSocketHandlers();\n            // Fire 'error' event.\n            this.emit(\"error\", new util_1.SocksClientError(err, this.options));\n        }\n    }\n    /**\n     * Sends initial Socks v4 handshake request.\n     */ sendSocks4InitialHandshake() {\n        const userId = this.options.proxy.userId || \"\";\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x04);\n        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);\n        buff.writeUInt16BE(this.options.destination.port);\n        // Socks 4 (IPv4)\n        if (net.isIPv4(this.options.destination.host)) {\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));\n            buff.writeStringNT(userId);\n        // Socks 4a (hostname)\n        } else {\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x00);\n            buff.writeUInt8(0x01);\n            buff.writeStringNT(userId);\n            buff.writeStringNT(this.options.destination.host);\n        }\n        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;\n        this.socket.write(buff.toBuffer());\n    }\n    /**\n     * Handles Socks v4 handshake response.\n     * @param data\n     */ handleSocks4FinalHandshakeResponse() {\n        const data = this.receiveBuffer.get(8);\n        if (data[1] !== constants_1.Socks4Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);\n        } else {\n            // Bind response\n            if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {\n                const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n                buff.readOffset = 2;\n                const remoteHost = {\n                    port: buff.readUInt16BE(),\n                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())\n                };\n                // If host is 0.0.0.0, set to proxy host.\n                if (remoteHost.host === \"0.0.0.0\") {\n                    remoteHost.host = this.options.proxy.ipaddress;\n                }\n                this.setState(constants_1.SocksClientState.BoundWaitingForConnection);\n                this.emit(\"bound\", {\n                    remoteHost,\n                    socket: this.socket\n                });\n            // Connect response\n            } else {\n                this.setState(constants_1.SocksClientState.Established);\n                this.removeInternalSocketHandlers();\n                this.emit(\"established\", {\n                    socket: this.socket\n                });\n            }\n        }\n    }\n    /**\n     * Handles Socks v4 incoming connection request (BIND)\n     * @param data\n     */ handleSocks4IncomingConnectionResponse() {\n        const data = this.receiveBuffer.get(8);\n        if (data[1] !== constants_1.Socks4Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);\n        } else {\n            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n            buff.readOffset = 2;\n            const remoteHost = {\n                port: buff.readUInt16BE(),\n                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())\n            };\n            this.setState(constants_1.SocksClientState.Established);\n            this.removeInternalSocketHandlers();\n            this.emit(\"established\", {\n                remoteHost,\n                socket: this.socket\n            });\n        }\n    }\n    /**\n     * Sends initial Socks v5 handshake request.\n     */ sendSocks5InitialHandshake() {\n        const buff = new smart_buffer_1.SmartBuffer();\n        // By default we always support no auth.\n        const supportedAuthMethods = [\n            constants_1.Socks5Auth.NoAuth\n        ];\n        // We should only tell the proxy we support user/pass auth if auth info is actually provided.\n        // Note: As of Tor v0.3.5.7+, if user/pass auth is an option from the client, by default it will always take priority.\n        if (this.options.proxy.userId || this.options.proxy.password) {\n            supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);\n        }\n        // Custom auth method?\n        if (this.options.proxy.custom_auth_method !== undefined) {\n            supportedAuthMethods.push(this.options.proxy.custom_auth_method);\n        }\n        // Build handshake packet\n        buff.writeUInt8(0x05);\n        buff.writeUInt8(supportedAuthMethods.length);\n        for (const authMethod of supportedAuthMethods){\n            buff.writeUInt8(authMethod);\n        }\n        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;\n        this.socket.write(buff.toBuffer());\n        this.setState(constants_1.SocksClientState.SentInitialHandshake);\n    }\n    /**\n     * Handles initial Socks v5 handshake response.\n     * @param data\n     */ handleInitialSocks5HandshakeResponse() {\n        const data = this.receiveBuffer.get(2);\n        if (data[0] !== 0x05) {\n            this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);\n        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {\n            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);\n        } else {\n            // If selected Socks v5 auth method is no auth, send final handshake request.\n            if (data[1] === constants_1.Socks5Auth.NoAuth) {\n                this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;\n                this.sendSocks5CommandRequest();\n            // If selected Socks v5 auth method is user/password, send auth handshake.\n            } else if (data[1] === constants_1.Socks5Auth.UserPass) {\n                this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;\n                this.sendSocks5UserPassAuthentication();\n            // If selected Socks v5 auth method is the custom_auth_method, send custom handshake.\n            } else if (data[1] === this.options.proxy.custom_auth_method) {\n                this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;\n                this.sendSocks5CustomAuthentication();\n            } else {\n                this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);\n            }\n        }\n    }\n    /**\n     * Sends Socks v5 user & password auth handshake.\n     *\n     * Note: No auth and user/pass are currently supported.\n     */ sendSocks5UserPassAuthentication() {\n        const userId = this.options.proxy.userId || \"\";\n        const password = this.options.proxy.password || \"\";\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x01);\n        buff.writeUInt8(Buffer.byteLength(userId));\n        buff.writeString(userId);\n        buff.writeUInt8(Buffer.byteLength(password));\n        buff.writeString(password);\n        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;\n        this.socket.write(buff.toBuffer());\n        this.setState(constants_1.SocksClientState.SentAuthentication);\n    }\n    sendSocks5CustomAuthentication() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;\n            this.socket.write((yield this.options.proxy.custom_auth_request_handler()));\n            this.setState(constants_1.SocksClientState.SentAuthentication);\n        });\n    }\n    handleSocks5CustomAuthHandshakeResponse(data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.options.proxy.custom_auth_response_handler(data);\n        });\n    }\n    handleSocks5AuthenticationNoAuthHandshakeResponse(data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return data[1] === 0x00;\n        });\n    }\n    handleSocks5AuthenticationUserPassHandshakeResponse(data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return data[1] === 0x00;\n        });\n    }\n    /**\n     * Handles Socks v5 auth handshake response.\n     * @param data\n     */ handleInitialSocks5AuthenticationHandshakeResponse() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);\n            let authResult = false;\n            if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {\n                authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));\n            } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {\n                authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));\n            } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {\n                authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));\n            }\n            if (!authResult) {\n                this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);\n            } else {\n                this.sendSocks5CommandRequest();\n            }\n        });\n    }\n    /**\n     * Sends Socks v5 final handshake request.\n     */ sendSocks5CommandRequest() {\n        const buff = new smart_buffer_1.SmartBuffer();\n        buff.writeUInt8(0x05);\n        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);\n        buff.writeUInt8(0x00);\n        // ipv4, ipv6, domain?\n        if (net.isIPv4(this.options.destination.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));\n        } else if (net.isIPv6(this.options.destination.host)) {\n            buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n            buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));\n        } else {\n            buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n            buff.writeUInt8(this.options.destination.host.length);\n            buff.writeString(this.options.destination.host);\n        }\n        buff.writeUInt16BE(this.options.destination.port);\n        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n        this.socket.write(buff.toBuffer());\n        this.setState(constants_1.SocksClientState.SentFinalHandshake);\n    }\n    /**\n     * Handles Socks v5 final handshake response.\n     * @param data\n     */ handleSocks5FinalHandshakeResponse() {\n        // Peek at available data (we need at least 5 bytes to get the hostname length)\n        const header = this.receiveBuffer.peek(5);\n        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);\n        } else {\n            // Read address type\n            const addressType = header[3];\n            let remoteHost;\n            let buff;\n            // IPv4\n            if (addressType === constants_1.Socks5HostType.IPv4) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),\n                    port: buff.readUInt16BE()\n                };\n                // If given host is 0.0.0.0, assume remote proxy ip instead.\n                if (remoteHost.host === \"0.0.0.0\") {\n                    remoteHost.host = this.options.proxy.ipaddress;\n                }\n            // Hostname\n            } else if (addressType === constants_1.Socks5HostType.Hostname) {\n                const hostLength = header[4];\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + host + port\n                // Check if data is available.\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));\n                remoteHost = {\n                    host: buff.readString(hostLength),\n                    port: buff.readUInt16BE()\n                };\n            // IPv6\n            } else if (addressType === constants_1.Socks5HostType.IPv6) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),\n                    port: buff.readUInt16BE()\n                };\n            }\n            // We have everything we need\n            this.setState(constants_1.SocksClientState.ReceivedFinalResponse);\n            // If using CONNECT, the client is now in the established state.\n            if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {\n                this.setState(constants_1.SocksClientState.Established);\n                this.removeInternalSocketHandlers();\n                this.emit(\"established\", {\n                    remoteHost,\n                    socket: this.socket\n                });\n            } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {\n                /* If using BIND, the Socks client is now in BoundWaitingForConnection state.\n                   This means that the remote proxy server is waiting for a remote connection to the bound port. */ this.setState(constants_1.SocksClientState.BoundWaitingForConnection);\n                this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n                this.emit(\"bound\", {\n                    remoteHost,\n                    socket: this.socket\n                });\n            /*\n                  If using Associate, the Socks client is now Established. And the proxy server is now accepting UDP packets at the\n                  given bound port. This initial Socks TCP connection must remain open for the UDP relay to continue to work.\n                */ } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {\n                this.setState(constants_1.SocksClientState.Established);\n                this.removeInternalSocketHandlers();\n                this.emit(\"established\", {\n                    remoteHost,\n                    socket: this.socket\n                });\n            }\n        }\n    }\n    /**\n     * Handles Socks v5 incoming connection request (BIND).\n     */ handleSocks5IncomingConnectionResponse() {\n        // Peek at available data (we need at least 5 bytes to get the hostname length)\n        const header = this.receiveBuffer.peek(5);\n        if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n            this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);\n        } else {\n            // Read address type\n            const addressType = header[3];\n            let remoteHost;\n            let buff;\n            // IPv4\n            if (addressType === constants_1.Socks5HostType.IPv4) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),\n                    port: buff.readUInt16BE()\n                };\n                // If given host is 0.0.0.0, assume remote proxy ip instead.\n                if (remoteHost.host === \"0.0.0.0\") {\n                    remoteHost.host = this.options.proxy.ipaddress;\n                }\n            // Hostname\n            } else if (addressType === constants_1.Socks5HostType.Hostname) {\n                const hostLength = header[4];\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + port\n                // Check if data is available.\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));\n                remoteHost = {\n                    host: buff.readString(hostLength),\n                    port: buff.readUInt16BE()\n                };\n            // IPv6\n            } else if (addressType === constants_1.Socks5HostType.IPv6) {\n                // Check if data is available.\n                const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n                if (this.receiveBuffer.length < dataNeeded) {\n                    this.nextRequiredPacketBufferSize = dataNeeded;\n                    return;\n                }\n                buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n                remoteHost = {\n                    host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),\n                    port: buff.readUInt16BE()\n                };\n            }\n            this.setState(constants_1.SocksClientState.Established);\n            this.removeInternalSocketHandlers();\n            this.emit(\"established\", {\n                remoteHost,\n                socket: this.socket\n            });\n        }\n    }\n    get socksClientOptions() {\n        return Object.assign({}, this.options);\n    }\n}\nexports.SocksClient = SocksClient; //# sourceMappingURL=socksclient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY2xpZW50L3NvY2tzY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWSxJQUFLLElBQUksSUFBSSxDQUFDQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ0FPLDhDQUE2QztJQUFFYixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdEZSx3QkFBd0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN0RCxNQUFNRyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxNQUFN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ZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY2xpZW50L3NvY2tzY2xpZW50LmpzPzlkZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja3NDbGllbnRFcnJvciA9IGV4cG9ydHMuU29ja3NDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3Qgc21hcnRfYnVmZmVyXzEgPSByZXF1aXJlKFwic21hcnQtYnVmZmVyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaGVscGVyc1wiKTtcbmNvbnN0IHJlY2VpdmVidWZmZXJfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcmVjZWl2ZWJ1ZmZlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdXRpbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tzQ2xpZW50RXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yOyB9IH0pO1xuY29uc3QgaXBfYWRkcmVzc18xID0gcmVxdWlyZShcImlwLWFkZHJlc3NcIik7XG5jbGFzcyBTb2Nrc0NsaWVudCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgLy8gVmFsaWRhdGUgU29ja3NDbGllbnRPcHRpb25zXG4gICAgICAgICgwLCBoZWxwZXJzXzEudmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICAvLyBEZWZhdWx0IHN0YXRlXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5DcmVhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTT0NLUyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogTm90ZTogU3VwcG9ydHMgY2FsbGJhY2tzIGFuZCBwcm9taXNlcy4gT25seSBzdXBwb3J0cyB0aGUgY29ubmVjdCBjb21tYW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHsgU29ja3NDbGllbnRPcHRpb25zIH0gT3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgeyBGdW5jdGlvbiB9IEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHsgUHJvbWlzZSB9XG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbm5lY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIFNvY2tzQ2xpZW50T3B0aW9uc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlU29ja3NDbGllbnRPcHRpb25zKShvcHRpb25zLCBbJ2Nvbm5lY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlcnIpOyAvLyBSZXNvbHZlcyBwZW5kaW5nIHByb21pc2UgKHByZXZlbnRzIG1lbW9yeSBsZWFrcykuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IFNvY2tzQ2xpZW50KG9wdGlvbnMpO1xuICAgICAgICAgICAgY2xpZW50LmNvbm5lY3Qob3B0aW9ucy5leGlzdGluZ19zb2NrZXQpO1xuICAgICAgICAgICAgY2xpZW50Lm9uY2UoJ2VzdGFibGlzaGVkJywgKGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBjbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvKTsgLy8gUmVzb2x2ZXMgcGVuZGluZyBwcm9taXNlIChwcmV2ZW50cyBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEVycm9yIG9jY3VycmVkLCBmYWlsZWQgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBjbGllbnQub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlcnIpOyAvLyBSZXNvbHZlcyBwZW5kaW5nIHByb21pc2UgKHByZXZlbnRzIG1lbW9yeSBsZWFrcykuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU09DS1MgY29ubmVjdGlvbiBjaGFpbiB0byBhIGRlc3RpbmF0aW9uIGhvc3QgdGhyb3VnaCAyIG9yIG1vcmUgU09DS1MgcHJveGllcy5cbiAgICAgKlxuICAgICAqIE5vdGU6IFN1cHBvcnRzIGNhbGxiYWNrcyBhbmQgcHJvbWlzZXMuIE9ubHkgc3VwcG9ydHMgdGhlIGNvbm5lY3QgbWV0aG9kLlxuICAgICAqIE5vdGU6IEltcGxlbWVudGVkIHZpYSBjcmVhdGVDb25uZWN0aW9uKCkgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7IFNvY2tzQ2xpZW50Q2hhaW5PcHRpb25zIH0gT3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxsYmFjayB7IEZ1bmN0aW9uIH0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMgeyBQcm9taXNlIH1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29ubmVjdGlvbkNoYWluKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBTb2Nrc0NsaWVudENoYWluT3B0aW9uc1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAoMCwgaGVscGVyc18xLnZhbGlkYXRlU29ja3NDbGllbnRDaGFpbk9wdGlvbnMpKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZXJyKTsgLy8gUmVzb2x2ZXMgcGVuZGluZyBwcm9taXNlIChwcmV2ZW50cyBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNodWZmbGUgcHJveGllc1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9taXplQ2hhaW4pIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLnNodWZmbGVBcnJheSkob3B0aW9ucy5wcm94aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHNvY2s7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnByb3hpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFByb3h5ID0gb3B0aW9ucy5wcm94aWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIHRoZSBsYXN0IHByb3h5IGluIHRoZSBjaGFpbiwgdGhlIGRlc3RpbmF0aW9uIGlzIHRoZSBhY3R1YWwgZGVzdGluYXRpb24sIG90aGVyd2lzZSBpdCdzIHRoZSBuZXh0IHByb3h5LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVzdGluYXRpb24gPSBpID09PSBvcHRpb25zLnByb3hpZXMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBvcHRpb25zLmRlc3RpbmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBvcHRpb25zLnByb3hpZXNbaSArIDFdLmhvc3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm94aWVzW2kgKyAxXS5pcGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wcm94aWVzW2kgKyAxXS5wb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyB0aGUgbmV4dCBjb25uZWN0aW9uIGluIHRoZSBjaGFpbi5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgU29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eTogbmV4dFByb3h5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IG5leHREZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nX3NvY2tldDogc29jayxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNvY2sgaXMgdW5kZWZpbmVkLCBhc3NpZ24gaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgc29jayA9IHNvY2sgfHwgcmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IHNvY2tldDogc29jayB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvY2tldDogc29jayB9KTsgLy8gUmVzb2x2ZXMgcGVuZGluZyBwcm9taXNlIChwcmV2ZW50cyBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvY2tldDogc29jayB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVycik7IC8vIFJlc29sdmVzIHBlbmRpbmcgcHJvbWlzZSAocHJldmVudHMgbWVtb3J5IGxlYWtzKS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgU09DS1MgVURQIEZyYW1lLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVVEUEZyYW1lKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlcigpO1xuICAgICAgICBidWZmLndyaXRlVUludDE2QkUoMCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OChvcHRpb25zLmZyYW1lTnVtYmVyIHx8IDApO1xuICAgICAgICAvLyBJUHY0L0lQdjYvSG9zdG5hbWVcbiAgICAgICAgaWYgKG5ldC5pc0lQdjQob3B0aW9ucy5yZW1vdGVIb3N0Lmhvc3QpKSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSVB2NCk7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDMyQkUoKDAsIGhlbHBlcnNfMS5pcHY0VG9JbnQzMikob3B0aW9ucy5yZW1vdGVIb3N0Lmhvc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXQuaXNJUHY2KG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjYpO1xuICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcigoMCwgaGVscGVyc18xLmlwVG9CdWZmZXIpKG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSG9zdG5hbWUpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KSk7XG4gICAgICAgICAgICBidWZmLndyaXRlU3RyaW5nKG9wdGlvbnMucmVtb3RlSG9zdC5ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3J0XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50MTZCRShvcHRpb25zLnJlbW90ZUhvc3QucG9ydCk7XG4gICAgICAgIC8vIERhdGFcbiAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcihvcHRpb25zLmRhdGEpO1xuICAgICAgICByZXR1cm4gYnVmZi50b0J1ZmZlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBTT0NLUyBVRFAgZnJhbWUuXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VVRFBGcmFtZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlci5mcm9tQnVmZmVyKGRhdGEpO1xuICAgICAgICBidWZmLnJlYWRPZmZzZXQgPSAyO1xuICAgICAgICBjb25zdCBmcmFtZU51bWJlciA9IGJ1ZmYucmVhZFVJbnQ4KCk7XG4gICAgICAgIGNvbnN0IGhvc3RUeXBlID0gYnVmZi5yZWFkVUludDgoKTtcbiAgICAgICAgbGV0IHJlbW90ZUhvc3Q7XG4gICAgICAgIGlmIChob3N0VHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSVB2NCkge1xuICAgICAgICAgICAgcmVtb3RlSG9zdCA9ICgwLCBoZWxwZXJzXzEuaW50MzJUb0lwdjQpKGJ1ZmYucmVhZFVJbnQzMkJFKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhvc3RUeXBlID09PSBjb25zdGFudHNfMS5Tb2NrczVIb3N0VHlwZS5JUHY2KSB7XG4gICAgICAgICAgICByZW1vdGVIb3N0ID0gaXBfYWRkcmVzc18xLkFkZHJlc3M2LmZyb21CeXRlQXJyYXkoQXJyYXkuZnJvbShidWZmLnJlYWRCdWZmZXIoMTYpKSkuY2Fub25pY2FsRm9ybSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3RlSG9zdCA9IGJ1ZmYucmVhZFN0cmluZyhidWZmLnJlYWRVSW50OCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1vdGVQb3J0ID0gYnVmZi5yZWFkVUludDE2QkUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyYW1lTnVtYmVyLFxuICAgICAgICAgICAgcmVtb3RlSG9zdDoge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHJlbW90ZUhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogcmVtb3RlUG9ydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXRhOiBidWZmLnJlYWRCdWZmZXIoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgc3RhdGUgc2V0dGVyLiBJZiB0aGUgU29ja3NDbGllbnQgaXMgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGNhbm5vdCBiZSBjaGFuZ2VkIHRvIGEgbm9uIGVycm9yIHN0YXRlLlxuICAgICAqL1xuICAgIHNldFN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBjb25uZWN0aW9uIGVzdGFibGlzaG1lbnQgdG8gdGhlIHByb3h5IGFuZCBkZXN0aW5hdGlvbi5cbiAgICAgKiBAcGFyYW0gZXhpc3RpbmdTb2NrZXQgQ29ubmVjdGVkIHNvY2tldCB0byB1c2UgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmUgKGludGVybmFsIHVzZSkuXG4gICAgICovXG4gICAgY29ubmVjdChleGlzdGluZ1NvY2tldCkge1xuICAgICAgICB0aGlzLm9uRGF0YVJlY2VpdmVkID0gKGRhdGEpID0+IHRoaXMub25EYXRhUmVjZWl2ZWRIYW5kbGVyKGRhdGEpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSAoKSA9PiB0aGlzLm9uQ2xvc2VIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMub25FcnJvciA9IChlcnIpID0+IHRoaXMub25FcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3QgPSAoKSA9PiB0aGlzLm9uQ29ubmVjdEhhbmRsZXIoKTtcbiAgICAgICAgLy8gU3RhcnQgdGltZW91dCB0aW1lciAoZGVmYXVsdHMgdG8gMzAgc2Vjb25kcylcbiAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25Fc3RhYmxpc2hlZFRpbWVvdXQoKSwgdGhpcy5vcHRpb25zLnRpbWVvdXQgfHwgY29uc3RhbnRzXzEuREVGQVVMVF9USU1FT1VUKTtcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciB1bnJlZiBpcyBhdmFpbGFibGUgYXMgaXQgZGlmZmVycyBmcm9tIGJyb3dzZXIgdG8gTm9kZUpTICgjMzMpXG4gICAgICAgIGlmICh0aW1lci51bnJlZiAmJiB0eXBlb2YgdGltZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gZXhpc3Rpbmcgc29ja2V0IGlzIHByb3ZpZGVkLCB1c2UgaXQgdG8gbmVnb3RpYXRlIFNPQ0tTIGhhbmRzaGFrZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBTb2NrZXQuXG4gICAgICAgIGlmIChleGlzdGluZ1NvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBleGlzdGluZ1NvY2tldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IG5ldC5Tb2NrZXQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdHRhY2ggU29ja2V0IGVycm9yIGhhbmRsZXJzLlxuICAgICAgICB0aGlzLnNvY2tldC5vbmNlKCdjbG9zZScsIHRoaXMub25DbG9zZSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2UoJ2Vycm9yJywgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jZSgnY29ubmVjdCcsIHRoaXMub25Db25uZWN0KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oJ2RhdGEnLCB0aGlzLm9uRGF0YVJlY2VpdmVkKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBuZXcgcmVjZWl2ZWJ1ZmZlcl8xLlJlY2VpdmVCdWZmZXIoKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KHRoaXMuZ2V0U29ja2V0T3B0aW9ucygpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2V0X3RjcF9ub2RlbGF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2V0X3RjcF9ub2RlbGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0Tm9EZWxheSghIXRoaXMub3B0aW9ucy5zZXRfdGNwX25vZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIExpc3RlbiBmb3IgZXN0YWJsaXNoZWQgZXZlbnQgc28gd2UgY2FuIHJlLWVtaXQgYW55IGV4Y2VzcyBkYXRhIHJlY2VpdmVkIGR1cmluZyBoYW5kc2hha2VzLlxuICAgICAgICB0aGlzLnByZXBlbmRPbmNlTGlzdGVuZXIoJ2VzdGFibGlzaGVkJywgKGluZm8pID0+IHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2Vzc0RhdGEgPSB0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLnNvY2tldC5lbWl0KCdkYXRhJywgZXhjZXNzRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZm8uc29ja2V0LnJlc3VtZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTb2NrZXQgb3B0aW9ucyAoZGVmYXVsdHMgaG9zdC9wb3J0IHRvIG9wdGlvbnMucHJveHkuaG9zdC9vcHRpb25zLnByb3h5LnBvcnQpXG4gICAgZ2V0U29ja2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLnNvY2tldF9vcHRpb25zKSwgeyBob3N0OiB0aGlzLm9wdGlvbnMucHJveHkuaG9zdCB8fCB0aGlzLm9wdGlvbnMucHJveHkuaXBhZGRyZXNzLCBwb3J0OiB0aGlzLm9wdGlvbnMucHJveHkucG9ydCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBpbnRlcm5hbCBTb2NrcyB0aW1lb3V0IGNhbGxiYWNrLlxuICAgICAqIE5vdGU6IElmIHRoZSBTb2NrcyBjbGllbnQgaXMgbm90IEJvdW5kV2FpdGluZ0ZvckNvbm5lY3Rpb24gb3IgRXN0YWJsaXNoZWQsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqL1xuICAgIG9uRXN0YWJsaXNoZWRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Fc3RhYmxpc2hlZCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Cb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlU29ja2V0KGNvbnN0YW50c18xLkVSUk9SUy5Qcm94eUNvbm5lY3Rpb25UaW1lZE91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrZXQgY29ubmVjdCBldmVudC5cbiAgICAgKi9cbiAgICBvbkNvbm5lY3RIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgICAgLy8gU2VuZCBpbml0aWFsIGhhbmRzaGFrZS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm94eS50eXBlID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTb2NrczRJbml0aWFsSGFuZHNoYWtlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTb2NrczVJbml0aWFsSGFuZHNoYWtlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRJbml0aWFsSGFuZHNoYWtlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrZXQgZGF0YSBldmVudC5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIG9uRGF0YVJlY2VpdmVkSGFuZGxlcihkYXRhKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgQWxsIHJlY2VpdmVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gYSBSZWNlaXZlQnVmZmVyLlxuICAgICAgICAgIFRoaXMgbWFrZXMgc3VyZSB0aGF0IGFsbCB0aGUgZGF0YSB3ZSBuZWVkIGlzIHJlY2VpdmVkIGJlZm9yZSB3ZSBhdHRlbXB0IHRvIHByb2Nlc3MgaXQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5hcHBlbmQoZGF0YSk7XG4gICAgICAgIC8vIFByb2Nlc3MgZGF0YSB0aGF0IHdlIGhhdmUuXG4gICAgICAgIHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBwcm9jZXNzaW5nIG9mIHRoZSBkYXRhIHdlIGhhdmUgcmVjZWl2ZWQuXG4gICAgICovXG4gICAgcHJvY2Vzc0RhdGEoKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgZW5vdWdoIGRhdGEgdG8gcHJvY2VzcyB0aGUgbmV4dCBzdGVwIGluIHRoZSBTT0NLUyBoYW5kc2hha2UsIHByb2NlZWQuXG4gICAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVzdGFibGlzaGVkICYmXG4gICAgICAgICAgICB0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVycm9yICYmXG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoID49IHRoaXMubmV4dFJlcXVpcmVkUGFja2V0QnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgLy8gU2VudCBpbml0aWFsIGhhbmRzaGFrZSwgd2FpdGluZyBmb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50SW5pdGlhbEhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb2NrcyB2NCBvbmx5IGhhcyBvbmUgaGFuZHNoYWtlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tzNEZpbmFsSGFuZHNoYWtlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvY2tzIHY1IGhhcyB0d28gaGFuZHNoYWtlcywgaGFuZGxlIGluaXRpYWwgb25lIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5pdGlhbFNvY2tzNUhhbmRzaGFrZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlbnQgYXV0aCByZXF1ZXN0IGZvciBTb2NrcyB2NSwgd2FpdGluZyBmb3IgcmVzcG9uc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRBdXRoZW50aWNhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5pdGlhbFNvY2tzNUF1dGhlbnRpY2F0aW9uSGFuZHNoYWtlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBTZW50IGZpbmFsIFNvY2tzIHY1IGhhbmRzaGFrZSwgd2FpdGluZyBmb3IgZmluYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRGaW5hbEhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU29ja3M1RmluYWxIYW5kc2hha2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIC8vIFNvY2tzIEJJTkQgZXN0YWJsaXNoZWQuIFdhaXRpbmcgZm9yIHJlbW90ZSBjb25uZWN0aW9uIHZpYSBwcm94eS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuQm91bmRXYWl0aW5nRm9yQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJveHkudHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tzNEluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNvY2tzNUluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChjb25zdGFudHNfMS5FUlJPUlMuSW50ZXJuYWxFcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrZXQgY2xvc2UgZXZlbnQuXG4gICAgICogQHBhcmFtIGhhZF9lcnJvclxuICAgICAqL1xuICAgIG9uQ2xvc2VIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmNsb3NlU29ja2V0KGNvbnN0YW50c18xLkVSUk9SUy5Tb2NrZXRDbG9zZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tldCBlcnJvciBldmVudC5cbiAgICAgKiBAcGFyYW0gZXJyXG4gICAgICovXG4gICAgb25FcnJvckhhbmRsZXIoZXJyKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoZXJyLm1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGludGVybmFsIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgdW5kZXJseWluZyBTb2NrZXQuXG4gICAgICovXG4gICAgcmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpIHtcbiAgICAgICAgLy8gUGF1c2VzIGRhdGEgZmxvdyBvZiB0aGUgc29ja2V0ICh0aGlzIGlzIGludGVybmFsbHkgcmVzdW1lZCBhZnRlciAnZXN0YWJsaXNoZWQnIGlzIGVtaXR0ZWQpXG4gICAgICAgIHRoaXMuc29ja2V0LnBhdXNlKCk7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgdGhpcy5vbkRhdGFSZWNlaXZlZCk7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHRoaXMub25DbG9zZSk7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMub25FcnJvcik7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgdGhpcy5vbkNvbm5lY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYW5kIGRlc3Ryb3lzIHRoZSB1bmRlcmx5aW5nIFNvY2tldC4gRW1pdHMgYW4gZXJyb3IgZXZlbnQuXG4gICAgICogQHBhcmFtIGVyciB7IFN0cmluZyB9IEFuIGVycm9yIHN0cmluZyB0byBpbmNsdWRlIGluIGVycm9yIGV2ZW50LlxuICAgICAqL1xuICAgIGNsb3NlU29ja2V0KGVycikge1xuICAgICAgICAvLyBNYWtlIHN1cmUgb25seSBvbmUgJ2Vycm9yJyBldmVudCBpcyBmaXJlZCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoaXMgU29ja3NDbGllbnQgaW5zdGFuY2UuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVycm9yKSB7XG4gICAgICAgICAgICAvLyBTZXQgaW50ZXJuYWwgc3RhdGUgdG8gRXJyb3IuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuRXJyb3IpO1xuICAgICAgICAgICAgLy8gRGVzdHJveSBTb2NrZXRcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBpbnRlcm5hbCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpO1xuICAgICAgICAgICAgLy8gRmlyZSAnZXJyb3InIGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihlcnIsIHRoaXMub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGluaXRpYWwgU29ja3MgdjQgaGFuZHNoYWtlIHJlcXVlc3QuXG4gICAgICovXG4gICAgc2VuZFNvY2tzNEluaXRpYWxIYW5kc2hha2UoKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHRoaXMub3B0aW9ucy5wcm94eS51c2VySWQgfHwgJyc7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBuZXcgc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIoKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDQpO1xuICAgICAgICBidWZmLndyaXRlVUludDgoY29uc3RhbnRzXzEuU29ja3NDb21tYW5kW3RoaXMub3B0aW9ucy5jb21tYW5kXSk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50MTZCRSh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24ucG9ydCk7XG4gICAgICAgIC8vIFNvY2tzIDQgKElQdjQpXG4gICAgICAgIGlmIChuZXQuaXNJUHY0KHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcigoMCwgaGVscGVyc18xLmlwVG9CdWZmZXIpKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSk7XG4gICAgICAgICAgICBidWZmLndyaXRlU3RyaW5nTlQodXNlcklkKTtcbiAgICAgICAgICAgIC8vIFNvY2tzIDRhIChob3N0bmFtZSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAxKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVTdHJpbmdOVCh1c2VySWQpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZ05UKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPVxuICAgICAgICAgICAgY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNFJlc3BvbnNlO1xuICAgICAgICB0aGlzLnNvY2tldC53cml0ZShidWZmLnRvQnVmZmVyKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tzIHY0IGhhbmRzaGFrZSByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZVNvY2tzNEZpbmFsSGFuZHNoYWtlUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KDgpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gY29uc3RhbnRzXzEuU29ja3M0UmVzcG9uc2UuR3JhbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChgJHtjb25zdGFudHNfMS5FUlJPUlMuU29ja3M0UHJveHlSZWplY3RlZENvbm5lY3Rpb259IC0gKCR7Y29uc3RhbnRzXzEuU29ja3M0UmVzcG9uc2VbZGF0YVsxXV19KWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQmluZCByZXNwb25zZVxuICAgICAgICAgICAgaWYgKGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFt0aGlzLm9wdGlvbnMuY29tbWFuZF0gPT09IGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZC5iaW5kKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZiA9IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyLmZyb21CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgYnVmZi5yZWFkT2Zmc2V0ID0gMjtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3J0OiBidWZmLnJlYWRVSW50MTZCRSgpLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiAoMCwgaGVscGVyc18xLmludDMyVG9JcHY0KShidWZmLnJlYWRVSW50MzJCRSgpKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGhvc3QgaXMgMC4wLjAuMCwgc2V0IHRvIHByb3h5IGhvc3QuXG4gICAgICAgICAgICAgICAgaWYgKHJlbW90ZUhvc3QuaG9zdCA9PT0gJzAuMC4wLjAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QuaG9zdCA9IHRoaXMub3B0aW9ucy5wcm94eS5pcGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Cb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2JvdW5kJywgeyByZW1vdGVIb3N0LCBzb2NrZXQ6IHRoaXMuc29ja2V0IH0pO1xuICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgcmVzcG9uc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Fc3RhYmxpc2hlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbnRlcm5hbFNvY2tldEhhbmRsZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlc3RhYmxpc2hlZCcsIHsgc29ja2V0OiB0aGlzLnNvY2tldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tzIHY0IGluY29taW5nIGNvbm5lY3Rpb24gcmVxdWVzdCAoQklORClcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqL1xuICAgIGhhbmRsZVNvY2tzNEluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5yZWNlaXZlQnVmZmVyLmdldCg4KTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGNvbnN0YW50c18xLlNvY2tzNFJlc3BvbnNlLkdyYW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoYCR7Y29uc3RhbnRzXzEuRVJST1JTLlNvY2tzNFByb3h5UmVqZWN0ZWRJbmNvbWluZ0JvdW5kQ29ubmVjdGlvbn0gLSAoJHtjb25zdGFudHNfMS5Tb2NrczRSZXNwb25zZVtkYXRhWzFdXX0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIGJ1ZmYucmVhZE9mZnNldCA9IDI7XG4gICAgICAgICAgICBjb25zdCByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgIHBvcnQ6IGJ1ZmYucmVhZFVJbnQxNkJFKCksXG4gICAgICAgICAgICAgICAgaG9zdDogKDAsIGhlbHBlcnNfMS5pbnQzMlRvSXB2NCkoYnVmZi5yZWFkVUludDMyQkUoKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVzdGFibGlzaGVkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlc3RhYmxpc2hlZCcsIHsgcmVtb3RlSG9zdCwgc29ja2V0OiB0aGlzLnNvY2tldCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBpbml0aWFsIFNvY2tzIHY1IGhhbmRzaGFrZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmRTb2NrczVJbml0aWFsSGFuZHNoYWtlKCkge1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyKCk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgd2UgYWx3YXlzIHN1cHBvcnQgbm8gYXV0aC5cbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkQXV0aE1ldGhvZHMgPSBbY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGhdO1xuICAgICAgICAvLyBXZSBzaG91bGQgb25seSB0ZWxsIHRoZSBwcm94eSB3ZSBzdXBwb3J0IHVzZXIvcGFzcyBhdXRoIGlmIGF1dGggaW5mbyBpcyBhY3R1YWxseSBwcm92aWRlZC5cbiAgICAgICAgLy8gTm90ZTogQXMgb2YgVG9yIHYwLjMuNS43KywgaWYgdXNlci9wYXNzIGF1dGggaXMgYW4gb3B0aW9uIGZyb20gdGhlIGNsaWVudCwgYnkgZGVmYXVsdCBpdCB3aWxsIGFsd2F5cyB0YWtlIHByaW9yaXR5LlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb3h5LnVzZXJJZCB8fCB0aGlzLm9wdGlvbnMucHJveHkucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZEF1dGhNZXRob2RzLnB1c2goY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Vc2VyUGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3VzdG9tIGF1dGggbWV0aG9kP1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb3h5LmN1c3RvbV9hdXRoX21ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWRBdXRoTWV0aG9kcy5wdXNoKHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIGhhbmRzaGFrZSBwYWNrZXRcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDUpO1xuICAgICAgICBidWZmLndyaXRlVUludDgoc3VwcG9ydGVkQXV0aE1ldGhvZHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBhdXRoTWV0aG9kIG9mIHN1cHBvcnRlZEF1dGhNZXRob2RzKSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoYXV0aE1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID1cbiAgICAgICAgICAgIGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVJbml0aWFsSGFuZHNoYWtlUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGJ1ZmYudG9CdWZmZXIoKSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50SW5pdGlhbEhhbmRzaGFrZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgaW5pdGlhbCBTb2NrcyB2NSBoYW5kc2hha2UgcmVzcG9uc2UuXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKi9cbiAgICBoYW5kbGVJbml0aWFsU29ja3M1SGFuZHNoYWtlUmVzcG9uc2UoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KDIpO1xuICAgICAgICBpZiAoZGF0YVswXSAhPT0gMHgwNSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzNUludGlhaWxIYW5kc2hha2VTb2Nrc1ZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFbMV0gPT09IGNvbnN0YW50c18xLlNPQ0tTNV9OT19BQ0NFUFRBQkxFX0FVVEgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlTm9BY2NlcHRlZEF1dGhUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGVkIFNvY2tzIHY1IGF1dGggbWV0aG9kIGlzIG5vIGF1dGgsIHNlbmQgZmluYWwgaGFuZHNoYWtlIHJlcXVlc3QuXG4gICAgICAgICAgICBpZiAoZGF0YVsxXSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tzNUNob3NlbkF1dGhUeXBlID0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGg7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU29ja3M1Q29tbWFuZFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZWxlY3RlZCBTb2NrcyB2NSBhdXRoIG1ldGhvZCBpcyB1c2VyL3Bhc3N3b3JkLCBzZW5kIGF1dGggaGFuZHNoYWtlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVsxXSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Vc2VyUGFzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja3M1Q2hvc2VuQXV0aFR5cGUgPSBjb25zdGFudHNfMS5Tb2NrczVBdXRoLlVzZXJQYXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFNvY2tzNVVzZXJQYXNzQXV0aGVudGljYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBzZWxlY3RlZCBTb2NrcyB2NSBhdXRoIG1ldGhvZCBpcyB0aGUgY3VzdG9tX2F1dGhfbWV0aG9kLCBzZW5kIGN1c3RvbSBoYW5kc2hha2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhWzFdID09PSB0aGlzLm9wdGlvbnMucHJveHkuY3VzdG9tX2F1dGhfbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrczVDaG9zZW5BdXRoVHlwZSA9IHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9tZXRob2Q7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU29ja3M1Q3VzdG9tQXV0aGVudGljYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlVW5rbm93bkF1dGhUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBTb2NrcyB2NSB1c2VyICYgcGFzc3dvcmQgYXV0aCBoYW5kc2hha2UuXG4gICAgICpcbiAgICAgKiBOb3RlOiBObyBhdXRoIGFuZCB1c2VyL3Bhc3MgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuXG4gICAgICovXG4gICAgc2VuZFNvY2tzNVVzZXJQYXNzQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHRoaXMub3B0aW9ucy5wcm94eS51c2VySWQgfHwgJyc7XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gdGhpcy5vcHRpb25zLnByb3h5LnBhc3N3b3JkIHx8ICcnO1xuICAgICAgICBjb25zdCBidWZmID0gbmV3IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyKCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAxKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KEJ1ZmZlci5ieXRlTGVuZ3RoKHVzZXJJZCkpO1xuICAgICAgICBidWZmLndyaXRlU3RyaW5nKHVzZXJJZCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OChCdWZmZXIuYnl0ZUxlbmd0aChwYXNzd29yZCkpO1xuICAgICAgICBidWZmLndyaXRlU3RyaW5nKHBhc3N3b3JkKTtcbiAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID1cbiAgICAgICAgICAgIGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVVc2VyUGFzc0F1dGhlbnRpY2F0aW9uUmVzcG9uc2U7XG4gICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGJ1ZmYudG9CdWZmZXIoKSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50QXV0aGVudGljYXRpb24pO1xuICAgIH1cbiAgICBzZW5kU29ja3M1Q3VzdG9tQXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPVxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9yZXNwb25zZV9zaXplO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoeWllbGQgdGhpcy5vcHRpb25zLnByb3h5LmN1c3RvbV9hdXRoX3JlcXVlc3RfaGFuZGxlcigpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5TZW50QXV0aGVudGljYXRpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlU29ja3M1Q3VzdG9tQXV0aEhhbmRzaGFrZVJlc3BvbnNlKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLm9wdGlvbnMucHJveHkuY3VzdG9tX2F1dGhfcmVzcG9uc2VfaGFuZGxlcihkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZVNvY2tzNUF1dGhlbnRpY2F0aW9uTm9BdXRoSGFuZHNoYWtlUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbMV0gPT09IDB4MDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVTb2NrczVBdXRoZW50aWNhdGlvblVzZXJQYXNzSGFuZHNoYWtlUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFbMV0gPT09IDB4MDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIFNvY2tzIHY1IGF1dGggaGFuZHNoYWtlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlSW5pdGlhbFNvY2tzNUF1dGhlbnRpY2F0aW9uSGFuZHNoYWtlUmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuUmVjZWl2ZWRBdXRoZW50aWNhdGlvblJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxldCBhdXRoUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrczVDaG9zZW5BdXRoVHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Ob0F1dGgpIHtcbiAgICAgICAgICAgICAgICBhdXRoUmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTb2NrczVBdXRoZW50aWNhdGlvbk5vQXV0aEhhbmRzaGFrZVJlc3BvbnNlKHRoaXMucmVjZWl2ZUJ1ZmZlci5nZXQoMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zb2NrczVDaG9zZW5BdXRoVHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1QXV0aC5Vc2VyUGFzcykge1xuICAgICAgICAgICAgICAgIGF1dGhSZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmhhbmRsZVNvY2tzNUF1dGhlbnRpY2F0aW9uVXNlclBhc3NIYW5kc2hha2VSZXNwb25zZSh0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc29ja3M1Q2hvc2VuQXV0aFR5cGUgPT09IHRoaXMub3B0aW9ucy5wcm94eS5jdXN0b21fYXV0aF9tZXRob2QpIHtcbiAgICAgICAgICAgICAgICBhdXRoUmVzdWx0ID0geWllbGQgdGhpcy5oYW5kbGVTb2NrczVDdXN0b21BdXRoSGFuZHNoYWtlUmVzcG9uc2UodGhpcy5yZWNlaXZlQnVmZmVyLmdldCh0aGlzLm9wdGlvbnMucHJveHkuY3VzdG9tX2F1dGhfcmVzcG9uc2Vfc2l6ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChjb25zdGFudHNfMS5FUlJPUlMuU29ja3M1QXV0aGVudGljYXRpb25GYWlsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU29ja3M1Q29tbWFuZFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIFNvY2tzIHY1IGZpbmFsIGhhbmRzaGFrZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIHNlbmRTb2NrczVDb21tYW5kUmVxdWVzdCgpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG5ldyBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlcigpO1xuICAgICAgICBidWZmLndyaXRlVUludDgoMHgwNSk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50OChjb25zdGFudHNfMS5Tb2Nrc0NvbW1hbmRbdGhpcy5vcHRpb25zLmNvbW1hbmRdKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDApO1xuICAgICAgICAvLyBpcHY0LCBpcHY2LCBkb21haW4/XG4gICAgICAgIGlmIChuZXQuaXNJUHY0KHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjQpO1xuICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcigoMCwgaGVscGVyc18xLmlwVG9CdWZmZXIpKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5ob3N0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV0LmlzSVB2Nih0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdCkpIHtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OChjb25zdGFudHNfMS5Tb2NrczVIb3N0VHlwZS5JUHY2KTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVCdWZmZXIoKDAsIGhlbHBlcnNfMS5pcFRvQnVmZmVyKSh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLkhvc3RuYW1lKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdC5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZyh0aGlzLm9wdGlvbnMuZGVzdGluYXRpb24uaG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZi53cml0ZVVJbnQxNkJFKHRoaXMub3B0aW9ucy5kZXN0aW5hdGlvbi5wb3J0KTtcbiAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID1cbiAgICAgICAgICAgIGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVSZXNwb25zZUhlYWRlcjtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUoYnVmZi50b0J1ZmZlcigpKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLlNlbnRGaW5hbEhhbmRzaGFrZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgU29ja3MgdjUgZmluYWwgaGFuZHNoYWtlIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG4gICAgaGFuZGxlU29ja3M1RmluYWxIYW5kc2hha2VSZXNwb25zZSgpIHtcbiAgICAgICAgLy8gUGVlayBhdCBhdmFpbGFibGUgZGF0YSAod2UgbmVlZCBhdCBsZWFzdCA1IGJ5dGVzIHRvIGdldCB0aGUgaG9zdG5hbWUgbGVuZ3RoKVxuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLnJlY2VpdmVCdWZmZXIucGVlayg1KTtcbiAgICAgICAgaWYgKGhlYWRlclswXSAhPT0gMHgwNSB8fCBoZWFkZXJbMV0gIT09IGNvbnN0YW50c18xLlNvY2tzNVJlc3BvbnNlLkdyYW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VTb2NrZXQoYCR7Y29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2NrczVGaW5hbEhhbmRzaGFrZVJlamVjdGVkfSAtICR7Y29uc3RhbnRzXzEuU29ja3M1UmVzcG9uc2VbaGVhZGVyWzFdXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWQgYWRkcmVzcyB0eXBlXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVHlwZSA9IGhlYWRlclszXTtcbiAgICAgICAgICAgIGxldCByZW1vdGVIb3N0O1xuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICAvLyBJUHY0XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSVB2NDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aCA8IGRhdGFOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID0gZGF0YU5lZWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcih0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KGRhdGFOZWVkZWQpLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiAoMCwgaGVscGVyc18xLmludDMyVG9JcHY0KShidWZmLnJlYWRVSW50MzJCRSgpKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGdpdmVuIGhvc3QgaXMgMC4wLjAuMCwgYXNzdW1lIHJlbW90ZSBwcm94eSBpcCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVIb3N0Lmhvc3QgPT09ICcwLjAuMC4wJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVIb3N0Lmhvc3QgPSB0aGlzLm9wdGlvbnMucHJveHkuaXBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIb3N0bmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdExlbmd0aCA9IGhlYWRlcls0XTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSG9zdG5hbWUoaG9zdExlbmd0aCk7IC8vIGhlYWRlciArIGhvc3QgbGVuZ3RoICsgaG9zdCArIHBvcnRcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aCA8IGRhdGFOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID0gZGF0YU5lZWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcih0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KGRhdGFOZWVkZWQpLnNsaWNlKDUpKTtcbiAgICAgICAgICAgICAgICByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiBidWZmLnJlYWRTdHJpbmcoaG9zdExlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6IGJ1ZmYucmVhZFVJbnQxNkJFKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJUHY2XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZGRyZXNzVHlwZSA9PT0gY29uc3RhbnRzXzEuU29ja3M1SG9zdFR5cGUuSVB2Nikge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFOZWVkZWQgPSBjb25zdGFudHNfMS5TT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVMuU29ja3M1UmVzcG9uc2VJUHY2O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoIDwgZGF0YU5lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPSBkYXRhTmVlZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmYgPSBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlci5mcm9tQnVmZmVyKHRoaXMucmVjZWl2ZUJ1ZmZlci5nZXQoZGF0YU5lZWRlZCkuc2xpY2UoNCkpO1xuICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IGlwX2FkZHJlc3NfMS5BZGRyZXNzNi5mcm9tQnl0ZUFycmF5KEFycmF5LmZyb20oYnVmZi5yZWFkQnVmZmVyKDE2KSkpLmNhbm9uaWNhbEZvcm0oKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBldmVyeXRoaW5nIHdlIG5lZWRcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5SZWNlaXZlZEZpbmFsUmVzcG9uc2UpO1xuICAgICAgICAgICAgLy8gSWYgdXNpbmcgQ09OTkVDVCwgdGhlIGNsaWVudCBpcyBub3cgaW4gdGhlIGVzdGFibGlzaGVkIHN0YXRlLlxuICAgICAgICAgICAgaWYgKGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFt0aGlzLm9wdGlvbnMuY29tbWFuZF0gPT09IGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZC5jb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShjb25zdGFudHNfMS5Tb2Nrc0NsaWVudFN0YXRlLkVzdGFibGlzaGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUludGVybmFsU29ja2V0SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VzdGFibGlzaGVkJywgeyByZW1vdGVIb3N0LCBzb2NrZXQ6IHRoaXMuc29ja2V0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uc3RhbnRzXzEuU29ja3NDb21tYW5kW3RoaXMub3B0aW9ucy5jb21tYW5kXSA9PT0gY29uc3RhbnRzXzEuU29ja3NDb21tYW5kLmJpbmQpIHtcbiAgICAgICAgICAgICAgICAvKiBJZiB1c2luZyBCSU5ELCB0aGUgU29ja3MgY2xpZW50IGlzIG5vdyBpbiBCb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgIFRoaXMgbWVhbnMgdGhhdCB0aGUgcmVtb3RlIHByb3h5IHNlcnZlciBpcyB3YWl0aW5nIGZvciBhIHJlbW90ZSBjb25uZWN0aW9uIHRvIHRoZSBib3VuZCBwb3J0LiAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoY29uc3RhbnRzXzEuU29ja3NDbGllbnRTdGF0ZS5Cb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPVxuICAgICAgICAgICAgICAgICAgICBjb25zdGFudHNfMS5TT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVMuU29ja3M1UmVzcG9uc2VIZWFkZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdib3VuZCcsIHsgcmVtb3RlSG9zdCwgc29ja2V0OiB0aGlzLnNvY2tldCB9KTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgSWYgdXNpbmcgQXNzb2NpYXRlLCB0aGUgU29ja3MgY2xpZW50IGlzIG5vdyBFc3RhYmxpc2hlZC4gQW5kIHRoZSBwcm94eSBzZXJ2ZXIgaXMgbm93IGFjY2VwdGluZyBVRFAgcGFja2V0cyBhdCB0aGVcbiAgICAgICAgICAgICAgICAgIGdpdmVuIGJvdW5kIHBvcnQuIFRoaXMgaW5pdGlhbCBTb2NrcyBUQ1AgY29ubmVjdGlvbiBtdXN0IHJlbWFpbiBvcGVuIGZvciB0aGUgVURQIHJlbGF5IHRvIGNvbnRpbnVlIHRvIHdvcmsuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFt0aGlzLm9wdGlvbnMuY29tbWFuZF0gPT09IGNvbnN0YW50c18xLlNvY2tzQ29tbWFuZC5hc3NvY2lhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuRXN0YWJsaXNoZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXN0YWJsaXNoZWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QsXG4gICAgICAgICAgICAgICAgICAgIHNvY2tldDogdGhpcy5zb2NrZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBTb2NrcyB2NSBpbmNvbWluZyBjb25uZWN0aW9uIHJlcXVlc3QgKEJJTkQpLlxuICAgICAqL1xuICAgIGhhbmRsZVNvY2tzNUluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlKCkge1xuICAgICAgICAvLyBQZWVrIGF0IGF2YWlsYWJsZSBkYXRhICh3ZSBuZWVkIGF0IGxlYXN0IDUgYnl0ZXMgdG8gZ2V0IHRoZSBob3N0bmFtZSBsZW5ndGgpXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMucmVjZWl2ZUJ1ZmZlci5wZWVrKDUpO1xuICAgICAgICBpZiAoaGVhZGVyWzBdICE9PSAweDA1IHx8IGhlYWRlclsxXSAhPT0gY29uc3RhbnRzXzEuU29ja3M1UmVzcG9uc2UuR3JhbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVNvY2tldChgJHtjb25zdGFudHNfMS5FUlJPUlMuU29ja3M1UHJveHlSZWplY3RlZEluY29taW5nQm91bmRDb25uZWN0aW9ufSAtICR7Y29uc3RhbnRzXzEuU29ja3M1UmVzcG9uc2VbaGVhZGVyWzFdXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlYWQgYWRkcmVzcyB0eXBlXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVHlwZSA9IGhlYWRlclszXTtcbiAgICAgICAgICAgIGxldCByZW1vdGVIb3N0O1xuICAgICAgICAgICAgbGV0IGJ1ZmY7XG4gICAgICAgICAgICAvLyBJUHY0XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLklQdjQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBkYXRhIGlzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSVB2NDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aCA8IGRhdGFOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWlyZWRQYWNrZXRCdWZmZXJTaXplID0gZGF0YU5lZWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmID0gc21hcnRfYnVmZmVyXzEuU21hcnRCdWZmZXIuZnJvbUJ1ZmZlcih0aGlzLnJlY2VpdmVCdWZmZXIuZ2V0KGRhdGFOZWVkZWQpLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICByZW1vdGVIb3N0ID0ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiAoMCwgaGVscGVyc18xLmludDMyVG9JcHY0KShidWZmLnJlYWRVSW50MzJCRSgpKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElmIGdpdmVuIGhvc3QgaXMgMC4wLjAuMCwgYXNzdW1lIHJlbW90ZSBwcm94eSBpcCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgIGlmIChyZW1vdGVIb3N0Lmhvc3QgPT09ICcwLjAuMC4wJykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVIb3N0Lmhvc3QgPSB0aGlzLm9wdGlvbnMucHJveHkuaXBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIb3N0bmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRkcmVzc1R5cGUgPT09IGNvbnN0YW50c18xLlNvY2tzNUhvc3RUeXBlLkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdExlbmd0aCA9IGhlYWRlcls0XTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhTmVlZGVkID0gY29uc3RhbnRzXzEuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTLlNvY2tzNVJlc3BvbnNlSG9zdG5hbWUoaG9zdExlbmd0aCk7IC8vIGhlYWRlciArIGhvc3QgbGVuZ3RoICsgcG9ydFxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoIDwgZGF0YU5lZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUgPSBkYXRhTmVlZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmYgPSBzbWFydF9idWZmZXJfMS5TbWFydEJ1ZmZlci5mcm9tQnVmZmVyKHRoaXMucmVjZWl2ZUJ1ZmZlci5nZXQoZGF0YU5lZWRlZCkuc2xpY2UoNSkpO1xuICAgICAgICAgICAgICAgIHJlbW90ZUhvc3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IGJ1ZmYucmVhZFN0cmluZyhob3N0TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogYnVmZi5yZWFkVUludDE2QkUoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIElQdjZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFkZHJlc3NUeXBlID09PSBjb25zdGFudHNfMS5Tb2NrczVIb3N0VHlwZS5JUHY2KSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YU5lZWRlZCA9IGNvbnN0YW50c18xLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUy5Tb2NrczVSZXNwb25zZUlQdjY7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGggPCBkYXRhTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVpcmVkUGFja2V0QnVmZmVyU2l6ZSA9IGRhdGFOZWVkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZiA9IHNtYXJ0X2J1ZmZlcl8xLlNtYXJ0QnVmZmVyLmZyb21CdWZmZXIodGhpcy5yZWNlaXZlQnVmZmVyLmdldChkYXRhTmVlZGVkKS5zbGljZSg0KSk7XG4gICAgICAgICAgICAgICAgcmVtb3RlSG9zdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogaXBfYWRkcmVzc18xLkFkZHJlc3M2LmZyb21CeXRlQXJyYXkoQXJyYXkuZnJvbShidWZmLnJlYWRCdWZmZXIoMTYpKSkuY2Fub25pY2FsRm9ybSgpLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiBidWZmLnJlYWRVSW50MTZCRSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKGNvbnN0YW50c18xLlNvY2tzQ2xpZW50U3RhdGUuRXN0YWJsaXNoZWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbnRlcm5hbFNvY2tldEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VzdGFibGlzaGVkJywgeyByZW1vdGVIb3N0LCBzb2NrZXQ6IHRoaXMuc29ja2V0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzb2Nrc0NsaWVudE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU29ja3NDbGllbnQgPSBTb2Nrc0NsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tzY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJTb2Nrc0NsaWVudEVycm9yIiwiU29ja3NDbGllbnQiLCJldmVudHNfMSIsInJlcXVpcmUiLCJuZXQiLCJzbWFydF9idWZmZXJfMSIsImNvbnN0YW50c18xIiwiaGVscGVyc18xIiwicmVjZWl2ZWJ1ZmZlcl8xIiwidXRpbF8xIiwiZW51bWVyYWJsZSIsImdldCIsImlwX2FkZHJlc3NfMSIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsImFzc2lnbiIsInZhbGlkYXRlU29ja3NDbGllbnRPcHRpb25zIiwic2V0U3RhdGUiLCJTb2Nrc0NsaWVudFN0YXRlIiwiQ3JlYXRlZCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJjYWxsYmFjayIsImVyciIsImNsaWVudCIsImNvbm5lY3QiLCJleGlzdGluZ19zb2NrZXQiLCJvbmNlIiwiaW5mbyIsInJlbW92ZUFsbExpc3RlbmVycyIsImNyZWF0ZUNvbm5lY3Rpb25DaGFpbiIsInZhbGlkYXRlU29ja3NDbGllbnRDaGFpbk9wdGlvbnMiLCJyYW5kb21pemVDaGFpbiIsInNodWZmbGVBcnJheSIsInByb3hpZXMiLCJzb2NrIiwiaSIsImxlbmd0aCIsIm5leHRQcm94eSIsIm5leHREZXN0aW5hdGlvbiIsImRlc3RpbmF0aW9uIiwiaG9zdCIsImlwYWRkcmVzcyIsInBvcnQiLCJjb21tYW5kIiwicHJveHkiLCJzb2NrZXQiLCJjcmVhdGVVRFBGcmFtZSIsImJ1ZmYiLCJTbWFydEJ1ZmZlciIsIndyaXRlVUludDE2QkUiLCJ3cml0ZVVJbnQ4IiwiZnJhbWVOdW1iZXIiLCJpc0lQdjQiLCJyZW1vdGVIb3N0IiwiU29ja3M1SG9zdFR5cGUiLCJJUHY0Iiwid3JpdGVVSW50MzJCRSIsImlwdjRUb0ludDMyIiwiaXNJUHY2IiwiSVB2NiIsIndyaXRlQnVmZmVyIiwiaXBUb0J1ZmZlciIsIkhvc3RuYW1lIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsIndyaXRlU3RyaW5nIiwiZGF0YSIsInRvQnVmZmVyIiwicGFyc2VVRFBGcmFtZSIsImZyb21CdWZmZXIiLCJyZWFkT2Zmc2V0IiwicmVhZFVJbnQ4IiwiaG9zdFR5cGUiLCJpbnQzMlRvSXB2NCIsInJlYWRVSW50MzJCRSIsIkFkZHJlc3M2IiwiZnJvbUJ5dGVBcnJheSIsIkFycmF5IiwiZnJvbSIsInJlYWRCdWZmZXIiLCJjYW5vbmljYWxGb3JtIiwicmVhZFN0cmluZyIsInJlbW90ZVBvcnQiLCJyZWFkVUludDE2QkUiLCJuZXdTdGF0ZSIsInN0YXRlIiwiRXJyb3IiLCJleGlzdGluZ1NvY2tldCIsIm9uRGF0YVJlY2VpdmVkIiwib25EYXRhUmVjZWl2ZWRIYW5kbGVyIiwib25DbG9zZSIsIm9uQ2xvc2VIYW5kbGVyIiwib25FcnJvciIsIm9uRXJyb3JIYW5kbGVyIiwib25Db25uZWN0Iiwib25Db25uZWN0SGFuZGxlciIsInRpbWVyIiwic2V0VGltZW91dCIsIm9uRXN0YWJsaXNoZWRUaW1lb3V0IiwidGltZW91dCIsIkRFRkFVTFRfVElNRU9VVCIsInVucmVmIiwiU29ja2V0Iiwib24iLCJDb25uZWN0aW5nIiwicmVjZWl2ZUJ1ZmZlciIsIlJlY2VpdmVCdWZmZXIiLCJlbWl0IiwiZ2V0U29ja2V0T3B0aW9ucyIsInNldF90Y3Bfbm9kZWxheSIsInVuZGVmaW5lZCIsInNldE5vRGVsYXkiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwic2V0SW1tZWRpYXRlIiwiZXhjZXNzRGF0YSIsInJlc3VtZSIsInNvY2tldF9vcHRpb25zIiwiRXN0YWJsaXNoZWQiLCJCb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uIiwiY2xvc2VTb2NrZXQiLCJFUlJPUlMiLCJQcm94eUNvbm5lY3Rpb25UaW1lZE91dCIsIkNvbm5lY3RlZCIsInR5cGUiLCJzZW5kU29ja3M0SW5pdGlhbEhhbmRzaGFrZSIsInNlbmRTb2NrczVJbml0aWFsSGFuZHNoYWtlIiwiU2VudEluaXRpYWxIYW5kc2hha2UiLCJhcHBlbmQiLCJwcm9jZXNzRGF0YSIsIm5leHRSZXF1aXJlZFBhY2tldEJ1ZmZlclNpemUiLCJoYW5kbGVTb2NrczRGaW5hbEhhbmRzaGFrZVJlc3BvbnNlIiwiaGFuZGxlSW5pdGlhbFNvY2tzNUhhbmRzaGFrZVJlc3BvbnNlIiwiU2VudEF1dGhlbnRpY2F0aW9uIiwiaGFuZGxlSW5pdGlhbFNvY2tzNUF1dGhlbnRpY2F0aW9uSGFuZHNoYWtlUmVzcG9uc2UiLCJTZW50RmluYWxIYW5kc2hha2UiLCJoYW5kbGVTb2NrczVGaW5hbEhhbmRzaGFrZVJlc3BvbnNlIiwiaGFuZGxlU29ja3M0SW5jb21pbmdDb25uZWN0aW9uUmVzcG9uc2UiLCJoYW5kbGVTb2NrczVJbmNvbWluZ0Nvbm5lY3Rpb25SZXNwb25zZSIsIkludGVybmFsRXJyb3IiLCJTb2NrZXRDbG9zZWQiLCJtZXNzYWdlIiwicmVtb3ZlSW50ZXJuYWxTb2NrZXRIYW5kbGVycyIsInBhdXNlIiwicmVtb3ZlTGlzdGVuZXIiLCJkZXN0cm95IiwidXNlcklkIiwiU29ja3NDb21tYW5kIiwid3JpdGVTdHJpbmdOVCIsIlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUyIsIlNvY2tzNFJlc3BvbnNlIiwid3JpdGUiLCJHcmFudGVkIiwiU29ja3M0UHJveHlSZWplY3RlZENvbm5lY3Rpb24iLCJiaW5kIiwiU29ja3M0UHJveHlSZWplY3RlZEluY29taW5nQm91bmRDb25uZWN0aW9uIiwic3VwcG9ydGVkQXV0aE1ldGhvZHMiLCJTb2NrczVBdXRoIiwiTm9BdXRoIiwicGFzc3dvcmQiLCJwdXNoIiwiVXNlclBhc3MiLCJjdXN0b21fYXV0aF9tZXRob2QiLCJhdXRoTWV0aG9kIiwiU29ja3M1SW5pdGlhbEhhbmRzaGFrZVJlc3BvbnNlIiwiSW52YWxpZFNvY2tzNUludGlhaWxIYW5kc2hha2VTb2Nrc1ZlcnNpb24iLCJTT0NLUzVfTk9fQUNDRVBUQUJMRV9BVVRIIiwiSW52YWxpZFNvY2tzNUluaXRpYWxIYW5kc2hha2VOb0FjY2VwdGVkQXV0aFR5cGUiLCJzb2NrczVDaG9zZW5BdXRoVHlwZSIsInNlbmRTb2NrczVDb21tYW5kUmVxdWVzdCIsInNlbmRTb2NrczVVc2VyUGFzc0F1dGhlbnRpY2F0aW9uIiwic2VuZFNvY2tzNUN1c3RvbUF1dGhlbnRpY2F0aW9uIiwiSW52YWxpZFNvY2tzNUluaXRpYWxIYW5kc2hha2VVbmtub3duQXV0aFR5cGUiLCJTb2NrczVVc2VyUGFzc0F1dGhlbnRpY2F0aW9uUmVzcG9uc2UiLCJjdXN0b21fYXV0aF9yZXNwb25zZV9zaXplIiwiY3VzdG9tX2F1dGhfcmVxdWVzdF9oYW5kbGVyIiwiaGFuZGxlU29ja3M1Q3VzdG9tQXV0aEhhbmRzaGFrZVJlc3BvbnNlIiwiY3VzdG9tX2F1dGhfcmVzcG9uc2VfaGFuZGxlciIsImhhbmRsZVNvY2tzNUF1dGhlbnRpY2F0aW9uTm9BdXRoSGFuZHNoYWtlUmVzcG9uc2UiLCJoYW5kbGVTb2NrczVBdXRoZW50aWNhdGlvblVzZXJQYXNzSGFuZHNoYWtlUmVzcG9uc2UiLCJSZWNlaXZlZEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UiLCJhdXRoUmVzdWx0IiwiU29ja3M1QXV0aGVudGljYXRpb25GYWlsZWQiLCJTb2NrczVSZXNwb25zZUhlYWRlciIsImhlYWRlciIsInBlZWsiLCJTb2NrczVSZXNwb25zZSIsIkludmFsaWRTb2NrczVGaW5hbEhhbmRzaGFrZVJlamVjdGVkIiwiYWRkcmVzc1R5cGUiLCJkYXRhTmVlZGVkIiwiU29ja3M1UmVzcG9uc2VJUHY0Iiwic2xpY2UiLCJob3N0TGVuZ3RoIiwiU29ja3M1UmVzcG9uc2VIb3N0bmFtZSIsIlNvY2tzNVJlc3BvbnNlSVB2NiIsIlJlY2VpdmVkRmluYWxSZXNwb25zZSIsImFzc29jaWF0ZSIsIlNvY2tzNVByb3h5UmVqZWN0ZWRJbmNvbWluZ0JvdW5kQ29ubmVjdGlvbiIsInNvY2tzQ2xpZW50T3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/client/socksclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/socks/build/common/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.SOCKS5_NO_ACCEPTABLE_AUTH = exports.SOCKS5_CUSTOM_AUTH_END = exports.SOCKS5_CUSTOM_AUTH_START = exports.SOCKS_INCOMING_PACKET_SIZES = exports.SocksClientState = exports.Socks5Response = exports.Socks5HostType = exports.Socks5Auth = exports.Socks4Response = exports.SocksCommand = exports.ERRORS = exports.DEFAULT_TIMEOUT = void 0;\nconst DEFAULT_TIMEOUT = 30000;\nexports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\n// prettier-ignore\nconst ERRORS = {\n    InvalidSocksCommand: \"An invalid SOCKS command was provided. Valid options are connect, bind, and associate.\",\n    InvalidSocksCommandForOperation: \"An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.\",\n    InvalidSocksCommandChain: \"An invalid SOCKS command was provided. Chaining currently only supports the connect command.\",\n    InvalidSocksClientOptionsDestination: \"An invalid destination host was provided.\",\n    InvalidSocksClientOptionsExistingSocket: \"An invalid existing socket was provided. This should be an instance of stream.Duplex.\",\n    InvalidSocksClientOptionsProxy: \"Invalid SOCKS proxy details were provided.\",\n    InvalidSocksClientOptionsTimeout: \"An invalid timeout value was provided. Please enter a value above 0 (in ms).\",\n    InvalidSocksClientOptionsProxiesLength: \"At least two socks proxies must be provided for chaining.\",\n    InvalidSocksClientOptionsCustomAuthRange: \"Custom auth must be a value between 0x80 and 0xFE.\",\n    InvalidSocksClientOptionsCustomAuthOptions: \"When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.\",\n    NegotiationError: \"Negotiation error\",\n    SocketClosed: \"Socket closed\",\n    ProxyConnectionTimedOut: \"Proxy connection timed out\",\n    InternalError: \"SocksClient internal error (this should not happen)\",\n    InvalidSocks4HandshakeResponse: \"Received invalid Socks4 handshake response\",\n    Socks4ProxyRejectedConnection: \"Socks4 Proxy rejected connection\",\n    InvalidSocks4IncomingConnectionResponse: \"Socks4 invalid incoming connection response\",\n    Socks4ProxyRejectedIncomingBoundConnection: \"Socks4 Proxy rejected incoming bound connection\",\n    InvalidSocks5InitialHandshakeResponse: \"Received invalid Socks5 initial handshake response\",\n    InvalidSocks5IntiailHandshakeSocksVersion: \"Received invalid Socks5 initial handshake (invalid socks version)\",\n    InvalidSocks5InitialHandshakeNoAcceptedAuthType: \"Received invalid Socks5 initial handshake (no accepted authentication type)\",\n    InvalidSocks5InitialHandshakeUnknownAuthType: \"Received invalid Socks5 initial handshake (unknown authentication type)\",\n    Socks5AuthenticationFailed: \"Socks5 Authentication failed\",\n    InvalidSocks5FinalHandshake: \"Received invalid Socks5 final handshake response\",\n    InvalidSocks5FinalHandshakeRejected: \"Socks5 proxy rejected connection\",\n    InvalidSocks5IncomingConnectionResponse: \"Received invalid Socks5 incoming connection response\",\n    Socks5ProxyRejectedIncomingBoundConnection: \"Socks5 Proxy rejected incoming bound connection\"\n};\nexports.ERRORS = ERRORS;\nconst SOCKS_INCOMING_PACKET_SIZES = {\n    Socks5InitialHandshakeResponse: 2,\n    Socks5UserPassAuthenticationResponse: 2,\n    // Command response + incoming connection (bind)\n    Socks5ResponseHeader: 5,\n    Socks5ResponseIPv4: 10,\n    Socks5ResponseIPv6: 22,\n    Socks5ResponseHostname: (hostNameLength)=>hostNameLength + 7,\n    // Command response + incoming connection (bind)\n    Socks4Response: 8\n};\nexports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;\nvar SocksCommand;\n(function(SocksCommand) {\n    SocksCommand[SocksCommand[\"connect\"] = 1] = \"connect\";\n    SocksCommand[SocksCommand[\"bind\"] = 2] = \"bind\";\n    SocksCommand[SocksCommand[\"associate\"] = 3] = \"associate\";\n})(SocksCommand || (exports.SocksCommand = SocksCommand = {}));\nvar Socks4Response;\n(function(Socks4Response) {\n    Socks4Response[Socks4Response[\"Granted\"] = 90] = \"Granted\";\n    Socks4Response[Socks4Response[\"Failed\"] = 91] = \"Failed\";\n    Socks4Response[Socks4Response[\"Rejected\"] = 92] = \"Rejected\";\n    Socks4Response[Socks4Response[\"RejectedIdent\"] = 93] = \"RejectedIdent\";\n})(Socks4Response || (exports.Socks4Response = Socks4Response = {}));\nvar Socks5Auth;\n(function(Socks5Auth) {\n    Socks5Auth[Socks5Auth[\"NoAuth\"] = 0] = \"NoAuth\";\n    Socks5Auth[Socks5Auth[\"GSSApi\"] = 1] = \"GSSApi\";\n    Socks5Auth[Socks5Auth[\"UserPass\"] = 2] = \"UserPass\";\n})(Socks5Auth || (exports.Socks5Auth = Socks5Auth = {}));\nconst SOCKS5_CUSTOM_AUTH_START = 0x80;\nexports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;\nconst SOCKS5_CUSTOM_AUTH_END = 0xfe;\nexports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;\nconst SOCKS5_NO_ACCEPTABLE_AUTH = 0xff;\nexports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;\nvar Socks5Response;\n(function(Socks5Response) {\n    Socks5Response[Socks5Response[\"Granted\"] = 0] = \"Granted\";\n    Socks5Response[Socks5Response[\"Failure\"] = 1] = \"Failure\";\n    Socks5Response[Socks5Response[\"NotAllowed\"] = 2] = \"NotAllowed\";\n    Socks5Response[Socks5Response[\"NetworkUnreachable\"] = 3] = \"NetworkUnreachable\";\n    Socks5Response[Socks5Response[\"HostUnreachable\"] = 4] = \"HostUnreachable\";\n    Socks5Response[Socks5Response[\"ConnectionRefused\"] = 5] = \"ConnectionRefused\";\n    Socks5Response[Socks5Response[\"TTLExpired\"] = 6] = \"TTLExpired\";\n    Socks5Response[Socks5Response[\"CommandNotSupported\"] = 7] = \"CommandNotSupported\";\n    Socks5Response[Socks5Response[\"AddressNotSupported\"] = 8] = \"AddressNotSupported\";\n})(Socks5Response || (exports.Socks5Response = Socks5Response = {}));\nvar Socks5HostType;\n(function(Socks5HostType) {\n    Socks5HostType[Socks5HostType[\"IPv4\"] = 1] = \"IPv4\";\n    Socks5HostType[Socks5HostType[\"Hostname\"] = 3] = \"Hostname\";\n    Socks5HostType[Socks5HostType[\"IPv6\"] = 4] = \"IPv6\";\n})(Socks5HostType || (exports.Socks5HostType = Socks5HostType = {}));\nvar SocksClientState;\n(function(SocksClientState) {\n    SocksClientState[SocksClientState[\"Created\"] = 0] = \"Created\";\n    SocksClientState[SocksClientState[\"Connecting\"] = 1] = \"Connecting\";\n    SocksClientState[SocksClientState[\"Connected\"] = 2] = \"Connected\";\n    SocksClientState[SocksClientState[\"SentInitialHandshake\"] = 3] = \"SentInitialHandshake\";\n    SocksClientState[SocksClientState[\"ReceivedInitialHandshakeResponse\"] = 4] = \"ReceivedInitialHandshakeResponse\";\n    SocksClientState[SocksClientState[\"SentAuthentication\"] = 5] = \"SentAuthentication\";\n    SocksClientState[SocksClientState[\"ReceivedAuthenticationResponse\"] = 6] = \"ReceivedAuthenticationResponse\";\n    SocksClientState[SocksClientState[\"SentFinalHandshake\"] = 7] = \"SentFinalHandshake\";\n    SocksClientState[SocksClientState[\"ReceivedFinalResponse\"] = 8] = \"ReceivedFinalResponse\";\n    SocksClientState[SocksClientState[\"BoundWaitingForConnection\"] = 9] = \"BoundWaitingForConnection\";\n    SocksClientState[SocksClientState[\"Established\"] = 10] = \"Established\";\n    SocksClientState[SocksClientState[\"Disconnected\"] = 11] = \"Disconnected\";\n    SocksClientState[SocksClientState[\"Error\"] = 99] = \"Error\";\n})(SocksClientState || (exports.SocksClientState = SocksClientState = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUNBQWlDLEdBQUdBLDhCQUE4QixHQUFHQSxnQ0FBZ0MsR0FBR0EsbUNBQW1DLEdBQUdBLHdCQUF3QixHQUFHQSxzQkFBc0IsR0FBR0Esc0JBQXNCLEdBQUdBLGtCQUFrQixHQUFHQSxzQkFBc0IsR0FBR0Esb0JBQW9CLEdBQUdBLGNBQWMsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUNoVixNQUFNYSxrQkFBa0I7QUFDeEJiLHVCQUF1QixHQUFHYTtBQUMxQixrQkFBa0I7QUFDbEIsTUFBTUQsU0FBUztJQUNYRSxxQkFBcUI7SUFDckJDLGlDQUFpQztJQUNqQ0MsMEJBQTBCO0lBQzFCQyxzQ0FBc0M7SUFDdENDLHlDQUF5QztJQUN6Q0MsZ0NBQWdDO0lBQ2hDQyxrQ0FBa0M7SUFDbENDLHdDQUF3QztJQUN4Q0MsMENBQTBDO0lBQzFDQyw0Q0FBNEM7SUFDNUNDLGtCQUFrQjtJQUNsQkMsY0FBYztJQUNkQyx5QkFBeUI7SUFDekJDLGVBQWU7SUFDZkMsZ0NBQWdDO0lBQ2hDQywrQkFBK0I7SUFDL0JDLHlDQUF5QztJQUN6Q0MsNENBQTRDO0lBQzVDQyx1Q0FBdUM7SUFDdkNDLDJDQUEyQztJQUMzQ0MsaURBQWlEO0lBQ2pEQyw4Q0FBOEM7SUFDOUNDLDRCQUE0QjtJQUM1QkMsNkJBQTZCO0lBQzdCQyxxQ0FBcUM7SUFDckNDLHlDQUF5QztJQUN6Q0MsNENBQTRDO0FBQ2hEO0FBQ0F4QyxjQUFjLEdBQUdZO0FBQ2pCLE1BQU1QLDhCQUE4QjtJQUNoQ29DLGdDQUFnQztJQUNoQ0Msc0NBQXNDO0lBQ3RDLGdEQUFnRDtJQUNoREMsc0JBQXNCO0lBQ3RCQyxvQkFBb0I7SUFDcEJDLG9CQUFvQjtJQUNwQkMsd0JBQXdCLENBQUNDLGlCQUFtQkEsaUJBQWlCO0lB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LEVBQUUsR0FBRztJQUN0REEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLHVCQUF1QixHQUFHLEVBQUUsR0FBRztJQUNqRUEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLG1DQUFtQyxHQUFHLEVBQUUsR0FBRztJQUM3RUEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUMvREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLGlDQUFpQyxHQUFHLEVBQUUsR0FBRztJQUMzRUEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLHFCQUFxQixHQUFHLEVBQUUsR0FBRztJQUMvREEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLHdCQUF3QixHQUFHLEVBQUUsR0FBRztJQUNsRUEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLDRCQUE0QixHQUFHLEVBQUUsR0FBRztJQUN0RUEsZ0JBQWdCLENBQUNBLGdCQUFnQixDQUFDLGNBQWMsR0FBRyxHQUFHLEdBQUc7SUFDekRBLGdCQUFnQixDQUFDQSxnQkFBZ0IsQ0FBQyxlQUFlLEdBQUcsR0FBRyxHQUFHO0lBQzFEQSxnQkFBZ0IsQ0FBQ0EsZ0JBQWdCLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztBQUN2RCxHQUFHQSxvQkFBcUJOLENBQUFBLHdCQUF3QixHQUFHTSxtQkFBbUIsQ0FBQyxLQUN2RSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zb2Nrcy9idWlsZC9jb21tb24vY29uc3RhbnRzLmpzP2UwN2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNPQ0tTNV9OT19BQ0NFUFRBQkxFX0FVVEggPSBleHBvcnRzLlNPQ0tTNV9DVVNUT01fQVVUSF9FTkQgPSBleHBvcnRzLlNPQ0tTNV9DVVNUT01fQVVUSF9TVEFSVCA9IGV4cG9ydHMuU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTID0gZXhwb3J0cy5Tb2Nrc0NsaWVudFN0YXRlID0gZXhwb3J0cy5Tb2NrczVSZXNwb25zZSA9IGV4cG9ydHMuU29ja3M1SG9zdFR5cGUgPSBleHBvcnRzLlNvY2tzNUF1dGggPSBleHBvcnRzLlNvY2tzNFJlc3BvbnNlID0gZXhwb3J0cy5Tb2Nrc0NvbW1hbmQgPSBleHBvcnRzLkVSUk9SUyA9IGV4cG9ydHMuREVGQVVMVF9USU1FT1VUID0gdm9pZCAwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMzAwMDA7XG5leHBvcnRzLkRFRkFVTFRfVElNRU9VVCA9IERFRkFVTFRfVElNRU9VVDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRVJST1JTID0ge1xuICAgIEludmFsaWRTb2Nrc0NvbW1hbmQ6ICdBbiBpbnZhbGlkIFNPQ0tTIGNvbW1hbmQgd2FzIHByb3ZpZGVkLiBWYWxpZCBvcHRpb25zIGFyZSBjb25uZWN0LCBiaW5kLCBhbmQgYXNzb2NpYXRlLicsXG4gICAgSW52YWxpZFNvY2tzQ29tbWFuZEZvck9wZXJhdGlvbjogJ0FuIGludmFsaWQgU09DS1MgY29tbWFuZCB3YXMgcHJvdmlkZWQuIE9ubHkgYSBzdWJzZXQgb2YgY29tbWFuZHMgYXJlIHN1cHBvcnRlZCBmb3IgdGhpcyBvcGVyYXRpb24uJyxcbiAgICBJbnZhbGlkU29ja3NDb21tYW5kQ2hhaW46ICdBbiBpbnZhbGlkIFNPQ0tTIGNvbW1hbmQgd2FzIHByb3ZpZGVkLiBDaGFpbmluZyBjdXJyZW50bHkgb25seSBzdXBwb3J0cyB0aGUgY29ubmVjdCBjb21tYW5kLicsXG4gICAgSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0Rlc3RpbmF0aW9uOiAnQW4gaW52YWxpZCBkZXN0aW5hdGlvbiBob3N0IHdhcyBwcm92aWRlZC4nLFxuICAgIEludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNFeGlzdGluZ1NvY2tldDogJ0FuIGludmFsaWQgZXhpc3Rpbmcgc29ja2V0IHdhcyBwcm92aWRlZC4gVGhpcyBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2Ygc3RyZWFtLkR1cGxleC4nLFxuICAgIEludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNQcm94eTogJ0ludmFsaWQgU09DS1MgcHJveHkgZGV0YWlscyB3ZXJlIHByb3ZpZGVkLicsXG4gICAgSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1RpbWVvdXQ6ICdBbiBpbnZhbGlkIHRpbWVvdXQgdmFsdWUgd2FzIHByb3ZpZGVkLiBQbGVhc2UgZW50ZXIgYSB2YWx1ZSBhYm92ZSAwIChpbiBtcykuJyxcbiAgICBJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zUHJveGllc0xlbmd0aDogJ0F0IGxlYXN0IHR3byBzb2NrcyBwcm94aWVzIG11c3QgYmUgcHJvdmlkZWQgZm9yIGNoYWluaW5nLicsXG4gICAgSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0N1c3RvbUF1dGhSYW5nZTogJ0N1c3RvbSBhdXRoIG11c3QgYmUgYSB2YWx1ZSBiZXR3ZWVuIDB4ODAgYW5kIDB4RkUuJyxcbiAgICBJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zQ3VzdG9tQXV0aE9wdGlvbnM6ICdXaGVuIGEgY3VzdG9tX2F1dGhfbWV0aG9kIGlzIHByb3ZpZGVkLCBjdXN0b21fYXV0aF9yZXF1ZXN0X2hhbmRsZXIsIGN1c3RvbV9hdXRoX3Jlc3BvbnNlX3NpemUsIGFuZCBjdXN0b21fYXV0aF9yZXNwb25zZV9oYW5kbGVyIG11c3QgYWxzbyBiZSBwcm92aWRlZCBhbmQgdmFsaWQuJyxcbiAgICBOZWdvdGlhdGlvbkVycm9yOiAnTmVnb3RpYXRpb24gZXJyb3InLFxuICAgIFNvY2tldENsb3NlZDogJ1NvY2tldCBjbG9zZWQnLFxuICAgIFByb3h5Q29ubmVjdGlvblRpbWVkT3V0OiAnUHJveHkgY29ubmVjdGlvbiB0aW1lZCBvdXQnLFxuICAgIEludGVybmFsRXJyb3I6ICdTb2Nrc0NsaWVudCBpbnRlcm5hbCBlcnJvciAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknLFxuICAgIEludmFsaWRTb2NrczRIYW5kc2hha2VSZXNwb25zZTogJ1JlY2VpdmVkIGludmFsaWQgU29ja3M0IGhhbmRzaGFrZSByZXNwb25zZScsXG4gICAgU29ja3M0UHJveHlSZWplY3RlZENvbm5lY3Rpb246ICdTb2NrczQgUHJveHkgcmVqZWN0ZWQgY29ubmVjdGlvbicsXG4gICAgSW52YWxpZFNvY2tzNEluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlOiAnU29ja3M0IGludmFsaWQgaW5jb21pbmcgY29ubmVjdGlvbiByZXNwb25zZScsXG4gICAgU29ja3M0UHJveHlSZWplY3RlZEluY29taW5nQm91bmRDb25uZWN0aW9uOiAnU29ja3M0IFByb3h5IHJlamVjdGVkIGluY29taW5nIGJvdW5kIGNvbm5lY3Rpb24nLFxuICAgIEludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlUmVzcG9uc2U6ICdSZWNlaXZlZCBpbnZhbGlkIFNvY2tzNSBpbml0aWFsIGhhbmRzaGFrZSByZXNwb25zZScsXG4gICAgSW52YWxpZFNvY2tzNUludGlhaWxIYW5kc2hha2VTb2Nrc1ZlcnNpb246ICdSZWNlaXZlZCBpbnZhbGlkIFNvY2tzNSBpbml0aWFsIGhhbmRzaGFrZSAoaW52YWxpZCBzb2NrcyB2ZXJzaW9uKScsXG4gICAgSW52YWxpZFNvY2tzNUluaXRpYWxIYW5kc2hha2VOb0FjY2VwdGVkQXV0aFR5cGU6ICdSZWNlaXZlZCBpbnZhbGlkIFNvY2tzNSBpbml0aWFsIGhhbmRzaGFrZSAobm8gYWNjZXB0ZWQgYXV0aGVudGljYXRpb24gdHlwZSknLFxuICAgIEludmFsaWRTb2NrczVJbml0aWFsSGFuZHNoYWtlVW5rbm93bkF1dGhUeXBlOiAnUmVjZWl2ZWQgaW52YWxpZCBTb2NrczUgaW5pdGlhbCBoYW5kc2hha2UgKHVua25vd24gYXV0aGVudGljYXRpb24gdHlwZSknLFxuICAgIFNvY2tzNUF1dGhlbnRpY2F0aW9uRmFpbGVkOiAnU29ja3M1IEF1dGhlbnRpY2F0aW9uIGZhaWxlZCcsXG4gICAgSW52YWxpZFNvY2tzNUZpbmFsSGFuZHNoYWtlOiAnUmVjZWl2ZWQgaW52YWxpZCBTb2NrczUgZmluYWwgaGFuZHNoYWtlIHJlc3BvbnNlJyxcbiAgICBJbnZhbGlkU29ja3M1RmluYWxIYW5kc2hha2VSZWplY3RlZDogJ1NvY2tzNSBwcm94eSByZWplY3RlZCBjb25uZWN0aW9uJyxcbiAgICBJbnZhbGlkU29ja3M1SW5jb21pbmdDb25uZWN0aW9uUmVzcG9uc2U6ICdSZWNlaXZlZCBpbnZhbGlkIFNvY2tzNSBpbmNvbWluZyBjb25uZWN0aW9uIHJlc3BvbnNlJyxcbiAgICBTb2NrczVQcm94eVJlamVjdGVkSW5jb21pbmdCb3VuZENvbm5lY3Rpb246ICdTb2NrczUgUHJveHkgcmVqZWN0ZWQgaW5jb21pbmcgYm91bmQgY29ubmVjdGlvbicsXG59O1xuZXhwb3J0cy5FUlJPUlMgPSBFUlJPUlM7XG5jb25zdCBTT0NLU19JTkNPTUlOR19QQUNLRVRfU0laRVMgPSB7XG4gICAgU29ja3M1SW5pdGlhbEhhbmRzaGFrZVJlc3BvbnNlOiAyLFxuICAgIFNvY2tzNVVzZXJQYXNzQXV0aGVudGljYXRpb25SZXNwb25zZTogMixcbiAgICAvLyBDb21tYW5kIHJlc3BvbnNlICsgaW5jb21pbmcgY29ubmVjdGlvbiAoYmluZClcbiAgICBTb2NrczVSZXNwb25zZUhlYWRlcjogNSwgLy8gV2UgbmVlZCBhdCBsZWFzdCA1IHRvIHJlYWQgdGhlIGhvc3RuYW1lIGxlbmd0aCwgdGhlbiB3ZSB3YWl0IGZvciB0aGUgYWRkcmVzcytwb3J0IGluZm9ybWF0aW9uLlxuICAgIFNvY2tzNVJlc3BvbnNlSVB2NDogMTAsIC8vIDQgaGVhZGVyICsgNCBpcCArIDIgcG9ydFxuICAgIFNvY2tzNVJlc3BvbnNlSVB2NjogMjIsIC8vIDQgaGVhZGVyICsgMTYgaXAgKyAyIHBvcnRcbiAgICBTb2NrczVSZXNwb25zZUhvc3RuYW1lOiAoaG9zdE5hbWVMZW5ndGgpID0+IGhvc3ROYW1lTGVuZ3RoICsgNywgLy8gNCBoZWFkZXIgKyAxIGhvc3QgbGVuZ3RoICsgaG9zdCArIDIgcG9ydFxuICAgIC8vIENvbW1hbmQgcmVzcG9uc2UgKyBpbmNvbWluZyBjb25uZWN0aW9uIChiaW5kKVxuICAgIFNvY2tzNFJlc3BvbnNlOiA4LCAvLyAyIGhlYWRlciArIDIgcG9ydCArIDQgaXBcbn07XG5leHBvcnRzLlNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUyA9IFNPQ0tTX0lOQ09NSU5HX1BBQ0tFVF9TSVpFUztcbnZhciBTb2Nrc0NvbW1hbmQ7XG4oZnVuY3Rpb24gKFNvY2tzQ29tbWFuZCkge1xuICAgIFNvY2tzQ29tbWFuZFtTb2Nrc0NvbW1hbmRbXCJjb25uZWN0XCJdID0gMV0gPSBcImNvbm5lY3RcIjtcbiAgICBTb2Nrc0NvbW1hbmRbU29ja3NDb21tYW5kW1wiYmluZFwiXSA9IDJdID0gXCJiaW5kXCI7XG4gICAgU29ja3NDb21tYW5kW1NvY2tzQ29tbWFuZFtcImFzc29jaWF0ZVwiXSA9IDNdID0gXCJhc3NvY2lhdGVcIjtcbn0pKFNvY2tzQ29tbWFuZCB8fCAoZXhwb3J0cy5Tb2Nrc0NvbW1hbmQgPSBTb2Nrc0NvbW1hbmQgPSB7fSkpO1xudmFyIFNvY2tzNFJlc3BvbnNlO1xuKGZ1bmN0aW9uIChTb2NrczRSZXNwb25zZSkge1xuICAgIFNvY2tzNFJlc3BvbnNlW1NvY2tzNFJlc3BvbnNlW1wiR3JhbnRlZFwiXSA9IDkwXSA9IFwiR3JhbnRlZFwiO1xuICAgIFNvY2tzNFJlc3BvbnNlW1NvY2tzNFJlc3BvbnNlW1wiRmFpbGVkXCJdID0gOTFdID0gXCJGYWlsZWRcIjtcbiAgICBTb2NrczRSZXNwb25zZVtTb2NrczRSZXNwb25zZVtcIlJlamVjdGVkXCJdID0gOTJdID0gXCJSZWplY3RlZFwiO1xuICAgIFNvY2tzNFJlc3BvbnNlW1NvY2tzNFJlc3BvbnNlW1wiUmVqZWN0ZWRJZGVudFwiXSA9IDkzXSA9IFwiUmVqZWN0ZWRJZGVudFwiO1xufSkoU29ja3M0UmVzcG9uc2UgfHwgKGV4cG9ydHMuU29ja3M0UmVzcG9uc2UgPSBTb2NrczRSZXNwb25zZSA9IHt9KSk7XG52YXIgU29ja3M1QXV0aDtcbihmdW5jdGlvbiAoU29ja3M1QXV0aCkge1xuICAgIFNvY2tzNUF1dGhbU29ja3M1QXV0aFtcIk5vQXV0aFwiXSA9IDBdID0gXCJOb0F1dGhcIjtcbiAgICBTb2NrczVBdXRoW1NvY2tzNUF1dGhbXCJHU1NBcGlcIl0gPSAxXSA9IFwiR1NTQXBpXCI7XG4gICAgU29ja3M1QXV0aFtTb2NrczVBdXRoW1wiVXNlclBhc3NcIl0gPSAyXSA9IFwiVXNlclBhc3NcIjtcbn0pKFNvY2tzNUF1dGggfHwgKGV4cG9ydHMuU29ja3M1QXV0aCA9IFNvY2tzNUF1dGggPSB7fSkpO1xuY29uc3QgU09DS1M1X0NVU1RPTV9BVVRIX1NUQVJUID0gMHg4MDtcbmV4cG9ydHMuU09DS1M1X0NVU1RPTV9BVVRIX1NUQVJUID0gU09DS1M1X0NVU1RPTV9BVVRIX1NUQVJUO1xuY29uc3QgU09DS1M1X0NVU1RPTV9BVVRIX0VORCA9IDB4ZmU7XG5leHBvcnRzLlNPQ0tTNV9DVVNUT01fQVVUSF9FTkQgPSBTT0NLUzVfQ1VTVE9NX0FVVEhfRU5EO1xuY29uc3QgU09DS1M1X05PX0FDQ0VQVEFCTEVfQVVUSCA9IDB4ZmY7XG5leHBvcnRzLlNPQ0tTNV9OT19BQ0NFUFRBQkxFX0FVVEggPSBTT0NLUzVfTk9fQUNDRVBUQUJMRV9BVVRIO1xudmFyIFNvY2tzNVJlc3BvbnNlO1xuKGZ1bmN0aW9uIChTb2NrczVSZXNwb25zZSkge1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiR3JhbnRlZFwiXSA9IDBdID0gXCJHcmFudGVkXCI7XG4gICAgU29ja3M1UmVzcG9uc2VbU29ja3M1UmVzcG9uc2VbXCJGYWlsdXJlXCJdID0gMV0gPSBcIkZhaWx1cmVcIjtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIk5vdEFsbG93ZWRcIl0gPSAyXSA9IFwiTm90QWxsb3dlZFwiO1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiTmV0d29ya1VucmVhY2hhYmxlXCJdID0gM10gPSBcIk5ldHdvcmtVbnJlYWNoYWJsZVwiO1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiSG9zdFVucmVhY2hhYmxlXCJdID0gNF0gPSBcIkhvc3RVbnJlYWNoYWJsZVwiO1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiQ29ubmVjdGlvblJlZnVzZWRcIl0gPSA1XSA9IFwiQ29ubmVjdGlvblJlZnVzZWRcIjtcbiAgICBTb2NrczVSZXNwb25zZVtTb2NrczVSZXNwb25zZVtcIlRUTEV4cGlyZWRcIl0gPSA2XSA9IFwiVFRMRXhwaXJlZFwiO1xuICAgIFNvY2tzNVJlc3BvbnNlW1NvY2tzNVJlc3BvbnNlW1wiQ29tbWFuZE5vdFN1cHBvcnRlZFwiXSA9IDddID0gXCJDb21tYW5kTm90U3VwcG9ydGVkXCI7XG4gICAgU29ja3M1UmVzcG9uc2VbU29ja3M1UmVzcG9uc2VbXCJBZGRyZXNzTm90U3VwcG9ydGVkXCJdID0gOF0gPSBcIkFkZHJlc3NOb3RTdXBwb3J0ZWRcIjtcbn0pKFNvY2tzNVJlc3BvbnNlIHx8IChleHBvcnRzLlNvY2tzNVJlc3BvbnNlID0gU29ja3M1UmVzcG9uc2UgPSB7fSkpO1xudmFyIFNvY2tzNUhvc3RUeXBlO1xuKGZ1bmN0aW9uIChTb2NrczVIb3N0VHlwZSkge1xuICAgIFNvY2tzNUhvc3RUeXBlW1NvY2tzNUhvc3RUeXBlW1wiSVB2NFwiXSA9IDFdID0gXCJJUHY0XCI7XG4gICAgU29ja3M1SG9zdFR5cGVbU29ja3M1SG9zdFR5cGVbXCJIb3N0bmFtZVwiXSA9IDNdID0gXCJIb3N0bmFtZVwiO1xuICAgIFNvY2tzNUhvc3RUeXBlW1NvY2tzNUhvc3RUeXBlW1wiSVB2NlwiXSA9IDRdID0gXCJJUHY2XCI7XG59KShTb2NrczVIb3N0VHlwZSB8fCAoZXhwb3J0cy5Tb2NrczVIb3N0VHlwZSA9IFNvY2tzNUhvc3RUeXBlID0ge30pKTtcbnZhciBTb2Nrc0NsaWVudFN0YXRlO1xuKGZ1bmN0aW9uIChTb2Nrc0NsaWVudFN0YXRlKSB7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiQ3JlYXRlZFwiXSA9IDBdID0gXCJDcmVhdGVkXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiQ29ubmVjdGluZ1wiXSA9IDFdID0gXCJDb25uZWN0aW5nXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiQ29ubmVjdGVkXCJdID0gMl0gPSBcIkNvbm5lY3RlZFwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIlNlbnRJbml0aWFsSGFuZHNoYWtlXCJdID0gM10gPSBcIlNlbnRJbml0aWFsSGFuZHNoYWtlXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiUmVjZWl2ZWRJbml0aWFsSGFuZHNoYWtlUmVzcG9uc2VcIl0gPSA0XSA9IFwiUmVjZWl2ZWRJbml0aWFsSGFuZHNoYWtlUmVzcG9uc2VcIjtcbiAgICBTb2Nrc0NsaWVudFN0YXRlW1NvY2tzQ2xpZW50U3RhdGVbXCJTZW50QXV0aGVudGljYXRpb25cIl0gPSA1XSA9IFwiU2VudEF1dGhlbnRpY2F0aW9uXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiUmVjZWl2ZWRBdXRoZW50aWNhdGlvblJlc3BvbnNlXCJdID0gNl0gPSBcIlJlY2VpdmVkQXV0aGVudGljYXRpb25SZXNwb25zZVwiO1xuICAgIFNvY2tzQ2xpZW50U3RhdGVbU29ja3NDbGllbnRTdGF0ZVtcIlNlbnRGaW5hbEhhbmRzaGFrZVwiXSA9IDddID0gXCJTZW50RmluYWxIYW5kc2hha2VcIjtcbiAgICBTb2Nrc0NsaWVudFN0YXRlW1NvY2tzQ2xpZW50U3RhdGVbXCJSZWNlaXZlZEZpbmFsUmVzcG9uc2VcIl0gPSA4XSA9IFwiUmVjZWl2ZWRGaW5hbFJlc3BvbnNlXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiQm91bmRXYWl0aW5nRm9yQ29ubmVjdGlvblwiXSA9IDldID0gXCJCb3VuZFdhaXRpbmdGb3JDb25uZWN0aW9uXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiRXN0YWJsaXNoZWRcIl0gPSAxMF0gPSBcIkVzdGFibGlzaGVkXCI7XG4gICAgU29ja3NDbGllbnRTdGF0ZVtTb2Nrc0NsaWVudFN0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gMTFdID0gXCJEaXNjb25uZWN0ZWRcIjtcbiAgICBTb2Nrc0NsaWVudFN0YXRlW1NvY2tzQ2xpZW50U3RhdGVbXCJFcnJvclwiXSA9IDk5XSA9IFwiRXJyb3JcIjtcbn0pKFNvY2tzQ2xpZW50U3RhdGUgfHwgKGV4cG9ydHMuU29ja3NDbGllbnRTdGF0ZSA9IFNvY2tzQ2xpZW50U3RhdGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNPQ0tTNV9OT19BQ0NFUFRBQkxFX0FVVEgiLCJTT0NLUzVfQ1VTVE9NX0FVVEhfRU5EIiwiU09DS1M1X0NVU1RPTV9BVVRIX1NUQVJUIiwiU09DS1NfSU5DT01JTkdfUEFDS0VUX1NJWkVTIiwiU29ja3NDbGllbnRTdGF0ZSIsIlNvY2tzNVJlc3BvbnNlIiwiU29ja3M1SG9zdFR5cGUiLCJTb2NrczVBdXRoIiwiU29ja3M0UmVzcG9uc2UiLCJTb2Nrc0NvbW1hbmQiLCJFUlJPUlMiLCJERUZBVUxUX1RJTUVPVVQiLCJJbnZhbGlkU29ja3NDb21tYW5kIiwiSW52YWxpZFNvY2tzQ29tbWFuZEZvck9wZXJhdGlvbiIsIkludmFsaWRTb2Nrc0NvbW1hbmRDaGFpbiIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNEZXN0aW5hdGlvbiIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNFeGlzdGluZ1NvY2tldCIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNQcm94eSIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNUaW1lb3V0IiwiSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1Byb3hpZXNMZW5ndGgiLCJJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zQ3VzdG9tQXV0aFJhbmdlIiwiSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0N1c3RvbUF1dGhPcHRpb25zIiwiTmVnb3RpYXRpb25FcnJvciIsIlNvY2tldENsb3NlZCIsIlByb3h5Q29ubmVjdGlvblRpbWVkT3V0IiwiSW50ZXJuYWxFcnJvciIsIkludmFsaWRTb2NrczRIYW5kc2hha2VSZXNwb25zZSIsIlNvY2tzNFByb3h5UmVqZWN0ZWRDb25uZWN0aW9uIiwiSW52YWxpZFNvY2tzNEluY29taW5nQ29ubmVjdGlvblJlc3BvbnNlIiwiU29ja3M0UHJveHlSZWplY3RlZEluY29taW5nQm91bmRDb25uZWN0aW9uIiwiSW52YWxpZFNvY2tzNUluaXRpYWxIYW5kc2hha2VSZXNwb25zZSIsIkludmFsaWRTb2NrczVJbnRpYWlsSGFuZHNoYWtlU29ja3NWZXJzaW9uIiwiSW52YWxpZFNvY2tzNUluaXRpYWxIYW5kc2hha2VOb0FjY2VwdGVkQXV0aFR5cGUiLCJJbnZhbGlkU29ja3M1SW5pdGlhbEhhbmRzaGFrZVVua25vd25BdXRoVHlwZSIsIlNvY2tzNUF1dGhlbnRpY2F0aW9uRmFpbGVkIiwiSW52YWxpZFNvY2tzNUZpbmFsSGFuZHNoYWtlIiwiSW52YWxpZFNvY2tzNUZpbmFsSGFuZHNoYWtlUmVqZWN0ZWQiLCJJbnZhbGlkU29ja3M1SW5jb21pbmdDb25uZWN0aW9uUmVzcG9uc2UiLCJTb2NrczVQcm94eVJlamVjdGVkSW5jb21pbmdCb3VuZENvbm5lY3Rpb24iLCJTb2NrczVJbml0aWFsSGFuZHNoYWtlUmVzcG9uc2UiLCJTb2NrczVVc2VyUGFzc0F1dGhlbnRpY2F0aW9uUmVzcG9uc2UiLCJTb2NrczVSZXNwb25zZUhlYWRlciIsIlNvY2tzNVJlc3BvbnNlSVB2NCIsIlNvY2tzNVJlc3BvbnNlSVB2NiIsIlNvY2tzNVJlc3BvbnNlSG9zdG5hbWUiLCJob3N0TmFtZUxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/socks/build/common/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ipToBuffer = exports.int32ToIpv4 = exports.ipv4ToInt32 = exports.validateSocksClientChainOptions = exports.validateSocksClientOptions = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/socks/build/common/util.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/socks/build/common/constants.js\");\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst ip_address_1 = __webpack_require__(/*! ip-address */ \"(rsc)/./node_modules/ip-address/dist/ip-address.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\n/**\n * Validates the provided SocksClientOptions\n * @param options { SocksClientOptions }\n * @param acceptedCommands { string[] } A list of accepted SocksProxy commands.\n */ function validateSocksClientOptions(options, acceptedCommands = [\n    \"connect\",\n    \"bind\",\n    \"associate\"\n]) {\n    // Check SOCKs command option.\n    if (!constants_1.SocksCommand[options.command]) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);\n    }\n    // Check SocksCommand for acceptable command.\n    if (acceptedCommands.indexOf(options.command) === -1) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);\n    }\n    // Check destination\n    if (!isValidSocksRemoteHost(options.destination)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);\n    }\n    // Check SOCKS proxy to use\n    if (!isValidSocksProxy(options.proxy)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);\n    }\n    // Validate custom auth (if set)\n    validateCustomProxyAuth(options.proxy, options);\n    // Check timeout\n    if (options.timeout && !isValidTimeoutValue(options.timeout)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);\n    }\n    // Check existing_socket (if provided)\n    if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);\n    }\n}\nexports.validateSocksClientOptions = validateSocksClientOptions;\n/**\n * Validates the SocksClientChainOptions\n * @param options { SocksClientChainOptions }\n */ function validateSocksClientChainOptions(options) {\n    // Only connect is supported when chaining.\n    if (options.command !== \"connect\") {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);\n    }\n    // Check destination\n    if (!isValidSocksRemoteHost(options.destination)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);\n    }\n    // Validate proxies (length)\n    if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);\n    }\n    // Validate proxies\n    options.proxies.forEach((proxy)=>{\n        if (!isValidSocksProxy(proxy)) {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);\n        }\n        // Validate custom auth (if set)\n        validateCustomProxyAuth(proxy, options);\n    });\n    // Check timeout\n    if (options.timeout && !isValidTimeoutValue(options.timeout)) {\n        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);\n    }\n}\nexports.validateSocksClientChainOptions = validateSocksClientChainOptions;\nfunction validateCustomProxyAuth(proxy, options) {\n    if (proxy.custom_auth_method !== undefined) {\n        // Invalid auth method range\n        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);\n        }\n        // Missing custom_auth_request_handler\n        if (proxy.custom_auth_request_handler === undefined || typeof proxy.custom_auth_request_handler !== \"function\") {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);\n        }\n        // Missing custom_auth_response_size\n        if (proxy.custom_auth_response_size === undefined) {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);\n        }\n        // Missing/invalid custom_auth_response_handler\n        if (proxy.custom_auth_response_handler === undefined || typeof proxy.custom_auth_response_handler !== \"function\") {\n            throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);\n        }\n    }\n}\n/**\n * Validates a SocksRemoteHost\n * @param remoteHost { SocksRemoteHost }\n */ function isValidSocksRemoteHost(remoteHost) {\n    return remoteHost && typeof remoteHost.host === \"string\" && Buffer.byteLength(remoteHost.host) < 256 && typeof remoteHost.port === \"number\" && remoteHost.port >= 0 && remoteHost.port <= 65535;\n}\n/**\n * Validates a SocksProxy\n * @param proxy { SocksProxy }\n */ function isValidSocksProxy(proxy) {\n    return proxy && (typeof proxy.host === \"string\" || typeof proxy.ipaddress === \"string\") && typeof proxy.port === \"number\" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);\n}\n/**\n * Validates a timeout value.\n * @param value { Number }\n */ function isValidTimeoutValue(value) {\n    return typeof value === \"number\" && value > 0;\n}\nfunction ipv4ToInt32(ip) {\n    const address = new ip_address_1.Address4(ip);\n    // Convert the IPv4 address parts to an integer\n    return address.toArray().reduce((acc, part)=>(acc << 8) + part, 0) >>> 0;\n}\nexports.ipv4ToInt32 = ipv4ToInt32;\nfunction int32ToIpv4(int32) {\n    // Extract each byte (octet) from the 32-bit integer\n    const octet1 = int32 >>> 24 & 0xff;\n    const octet2 = int32 >>> 16 & 0xff;\n    const octet3 = int32 >>> 8 & 0xff;\n    const octet4 = int32 & 0xff;\n    // Combine the octets into a string in IPv4 format\n    return [\n        octet1,\n        octet2,\n        octet3,\n        octet4\n    ].join(\".\");\n}\nexports.int32ToIpv4 = int32ToIpv4;\nfunction ipToBuffer(ip) {\n    if (net.isIPv4(ip)) {\n        // Handle IPv4 addresses\n        const address = new ip_address_1.Address4(ip);\n        return Buffer.from(address.toArray());\n    } else if (net.isIPv6(ip)) {\n        // Handle IPv6 addresses\n        const address = new ip_address_1.Address6(ip);\n        return Buffer.from(address.canonicalForm().split(\":\").map((segment)=>segment.padStart(4, \"0\")).join(\"\"), \"hex\");\n    } else {\n        throw new Error(\"Invalid IP address format\");\n    }\n}\nexports.ipToBuffer = ipToBuffer; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxtQkFBbUIsR0FBR0EsbUJBQW1CLEdBQUdBLHVDQUF1QyxHQUFHQSxrQ0FBa0MsR0FBRyxLQUFLO0FBQ3JKLE1BQU1PLFNBQVNDLG1CQUFPQSxDQUFDLCtEQUFRO0FBQy9CLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLHlFQUFhO0FBQ3pDLE1BQU1FLFNBQVNGLG1CQUFPQSxDQUFDLHNCQUFRO0FBQy9CLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLHNFQUFZO0FBQ3pDLE1BQU1JLE1BQU1KLG1CQUFPQSxDQUFDLGdCQUFLO0FBQ3pCOzs7O0NBSUMsR0FDRCxTQUFTRiwyQkFBMkJPLE9BQU8sRUFBRUMsbUJBQW1CO0lBQUM7SUFBVztJQUFRO0NBQVk7SUFDNUYsOEJBQThCO0lBQzlCLElBQUksQ0FBQ0wsWUFBWU0sWUFBWSxDQUFDRixRQUFRRyxPQUFPLENBQUMsRUFBRTtRQUM1QyxNQUFNLElBQUlULE9BQU9VLGdCQUFnQixDQUFDUixZQUFZUyxNQUFNLENBQUNDLG1CQUFtQixFQUFFTjtJQUM5RTtJQUNBLDZDQUE2QztJQUM3QyxJQUFJQyxpQkFBaUJNLE9BQU8sQ0FBQ1AsUUFBUUcsT0FBTyxNQUFNLENBQUMsR0FBRztRQUNsRCxNQUFNLElBQUlULE9BQU9VLGdCQUFnQixDQUFDUixZQUFZUyxNQUFNLENBQUNHLCtCQUErQixFQUFFUjtJQUMxRjtJQUNBLG9CQUFvQjtJQUNwQixJQUFJLENBQUNTLHVCQUF1QlQsUUFBUVUsV0FBVyxHQUFHO1FBQzlDLE1BQU0sSUFBSWhCLE9BQU9VLGdCQUFnQixDQUFDUixZQUFZUyxNQUFNLENBQUNNLG9DQUFvQyxFQUFFWDtJQUMvRjtJQUNBLDJCQUEyQjtJQUMzQixJQUFJLENBQUNZLGtCQUFrQlos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QU0sT0FBTztBQUM3RTtBQUNBaEUsbUJBQW1CLEdBQUdJO0FBQ3RCLFNBQVNELFlBQVk4RCxLQUFLO0lBQ3RCLG9EQUFvRDtJQUNwRCxNQUFNQyxTQUFTLFVBQVcsS0FBTTtJQUNoQyxNQUFNQyxTQUFTLFVBQVcsS0FBTTtJQUNoQyxNQUFNQyxTQUFTLFVBQVcsSUFBSztJQUMvQixNQUFNQyxTQUFTSixRQUFRO0lBQ3ZCLGtEQUFrRDtJQUNsRCxPQUFPO1FBQUNDO1FBQVFDO1FBQVFDO1FBQVFDO0tBQU8sQ0FBQ0MsSUFBSSxDQUFDO0FBQ2pEO0FBQ0F0RSxtQkFBbUIsR0FBR0c7QUFDdEIsU0FBU0QsV0FBV3dELEVBQUU7SUFDbEIsSUFBSTlDLElBQUkyRCxNQUFNLENBQUNiLEtBQUs7UUFDaEIsd0JBQXdCO1FBQ3hCLE1BQU1DLFVBQVUsSUFBSWhELGFBQWFpRCxRQUFRLENBQUNGO1FBQzFDLE9BQU9MLE9BQU9tQixJQUFJLENBQUNiLFFBQVFFLE9BQU87SUFDdEMsT0FDSyxJQUFJakQsSUFBSTZELE1BQU0sQ0FBQ2YsS0FBSztRQUNyQix3QkFBd0I7UUFDeEIsTUFBTUMsVUFBVSxJQUFJaEQsYUFBYStELFFBQVEsQ0FBQ2hCO1FBQzFDLE9BQU9MLE9BQU9tQixJQUFJLENBQUNiLFFBQ2RnQixhQUFhLEdBQ2JDLEtBQUssQ0FBQyxLQUNOQyxHQUFHLENBQUMsQ0FBQ0MsVUFBWUEsUUFBUUMsUUFBUSxDQUFDLEdBQUcsTUFDckNULElBQUksQ0FBQyxLQUFLO0lBQ25CLE9BQ0s7UUFDRCxNQUFNLElBQUlVLE1BQU07SUFDcEI7QUFDSjtBQUNBaEYsa0JBQWtCLEdBQUdFLFlBQ3JCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tzL2J1aWxkL2NvbW1vbi9oZWxwZXJzLmpzP2E0YWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlwVG9CdWZmZXIgPSBleHBvcnRzLmludDMyVG9JcHY0ID0gZXhwb3J0cy5pcHY0VG9JbnQzMiA9IGV4cG9ydHMudmFsaWRhdGVTb2Nrc0NsaWVudENoYWluT3B0aW9ucyA9IGV4cG9ydHMudmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgaXBfYWRkcmVzc18xID0gcmVxdWlyZShcImlwLWFkZHJlc3NcIik7XG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHByb3ZpZGVkIFNvY2tzQ2xpZW50T3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnMgeyBTb2Nrc0NsaWVudE9wdGlvbnMgfVxuICogQHBhcmFtIGFjY2VwdGVkQ29tbWFuZHMgeyBzdHJpbmdbXSB9IEEgbGlzdCBvZiBhY2NlcHRlZCBTb2Nrc1Byb3h5IGNvbW1hbmRzLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNvY2tzQ2xpZW50T3B0aW9ucyhvcHRpb25zLCBhY2NlcHRlZENvbW1hbmRzID0gWydjb25uZWN0JywgJ2JpbmQnLCAnYXNzb2NpYXRlJ10pIHtcbiAgICAvLyBDaGVjayBTT0NLcyBjb21tYW5kIG9wdGlvbi5cbiAgICBpZiAoIWNvbnN0YW50c18xLlNvY2tzQ29tbWFuZFtvcHRpb25zLmNvbW1hbmRdKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ29tbWFuZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIENoZWNrIFNvY2tzQ29tbWFuZCBmb3IgYWNjZXB0YWJsZSBjb21tYW5kLlxuICAgIGlmIChhY2NlcHRlZENvbW1hbmRzLmluZGV4T2Yob3B0aW9ucy5jb21tYW5kKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDb21tYW5kRm9yT3BlcmF0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZGVzdGluYXRpb25cbiAgICBpZiAoIWlzVmFsaWRTb2Nrc1JlbW90ZUhvc3Qob3B0aW9ucy5kZXN0aW5hdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zRGVzdGluYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBDaGVjayBTT0NLUyBwcm94eSB0byB1c2VcbiAgICBpZiAoIWlzVmFsaWRTb2Nrc1Byb3h5KG9wdGlvbnMucHJveHkpKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1Byb3h5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgY3VzdG9tIGF1dGggKGlmIHNldClcbiAgICB2YWxpZGF0ZUN1c3RvbVByb3h5QXV0aChvcHRpb25zLnByb3h5LCBvcHRpb25zKTtcbiAgICAvLyBDaGVjayB0aW1lb3V0XG4gICAgaWYgKG9wdGlvbnMudGltZW91dCAmJiAhaXNWYWxpZFRpbWVvdXRWYWx1ZShvcHRpb25zLnRpbWVvdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1RpbWVvdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBDaGVjayBleGlzdGluZ19zb2NrZXQgKGlmIHByb3ZpZGVkKVxuICAgIGlmIChvcHRpb25zLmV4aXN0aW5nX3NvY2tldCAmJlxuICAgICAgICAhKG9wdGlvbnMuZXhpc3Rpbmdfc29ja2V0IGluc3RhbmNlb2Ygc3RyZWFtLkR1cGxleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zRXhpc3RpbmdTb2NrZXQsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnMgPSB2YWxpZGF0ZVNvY2tzQ2xpZW50T3B0aW9ucztcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBTb2Nrc0NsaWVudENoYWluT3B0aW9uc1xuICogQHBhcmFtIG9wdGlvbnMgeyBTb2Nrc0NsaWVudENoYWluT3B0aW9ucyB9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU29ja3NDbGllbnRDaGFpbk9wdGlvbnMob3B0aW9ucykge1xuICAgIC8vIE9ubHkgY29ubmVjdCBpcyBzdXBwb3J0ZWQgd2hlbiBjaGFpbmluZy5cbiAgICBpZiAob3B0aW9ucy5jb21tYW5kICE9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDb21tYW5kQ2hhaW4sIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBDaGVjayBkZXN0aW5hdGlvblxuICAgIGlmICghaXNWYWxpZFNvY2tzUmVtb3RlSG9zdChvcHRpb25zLmRlc3RpbmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNEZXN0aW5hdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHByb3hpZXMgKGxlbmd0aClcbiAgICBpZiAoIShvcHRpb25zLnByb3hpZXMgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zLnByb3hpZXMpICYmXG4gICAgICAgIG9wdGlvbnMucHJveGllcy5sZW5ndGggPj0gMikpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zUHJveGllc0xlbmd0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHByb3hpZXNcbiAgICBvcHRpb25zLnByb3hpZXMuZm9yRWFjaCgocHJveHkpID0+IHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkU29ja3NQcm94eShwcm94eSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc1Byb3h5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSBjdXN0b20gYXV0aCAoaWYgc2V0KVxuICAgICAgICB2YWxpZGF0ZUN1c3RvbVByb3h5QXV0aChwcm94eSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gQ2hlY2sgdGltZW91dFxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQgJiYgIWlzVmFsaWRUaW1lb3V0VmFsdWUob3B0aW9ucy50aW1lb3V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNUaW1lb3V0LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU29ja3NDbGllbnRDaGFpbk9wdGlvbnMgPSB2YWxpZGF0ZVNvY2tzQ2xpZW50Q2hhaW5PcHRpb25zO1xuZnVuY3Rpb24gdmFsaWRhdGVDdXN0b21Qcm94eUF1dGgocHJveHksIG9wdGlvbnMpIHtcbiAgICBpZiAocHJveHkuY3VzdG9tX2F1dGhfbWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSW52YWxpZCBhdXRoIG1ldGhvZCByYW5nZVxuICAgICAgICBpZiAocHJveHkuY3VzdG9tX2F1dGhfbWV0aG9kIDwgY29uc3RhbnRzXzEuU09DS1M1X0NVU1RPTV9BVVRIX1NUQVJUIHx8XG4gICAgICAgICAgICBwcm94eS5jdXN0b21fYXV0aF9tZXRob2QgPiBjb25zdGFudHNfMS5TT0NLUzVfQ1VTVE9NX0FVVEhfRU5EKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNDdXN0b21BdXRoUmFuZ2UsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1pc3NpbmcgY3VzdG9tX2F1dGhfcmVxdWVzdF9oYW5kbGVyXG4gICAgICAgIGlmIChwcm94eS5jdXN0b21fYXV0aF9yZXF1ZXN0X2hhbmRsZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIHByb3h5LmN1c3RvbV9hdXRoX3JlcXVlc3RfaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHV0aWxfMS5Tb2Nrc0NsaWVudEVycm9yKGNvbnN0YW50c18xLkVSUk9SUy5JbnZhbGlkU29ja3NDbGllbnRPcHRpb25zQ3VzdG9tQXV0aE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1pc3NpbmcgY3VzdG9tX2F1dGhfcmVzcG9uc2Vfc2l6ZVxuICAgICAgICBpZiAocHJveHkuY3VzdG9tX2F1dGhfcmVzcG9uc2Vfc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdXRpbF8xLlNvY2tzQ2xpZW50RXJyb3IoY29uc3RhbnRzXzEuRVJST1JTLkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNDdXN0b21BdXRoT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWlzc2luZy9pbnZhbGlkIGN1c3RvbV9hdXRoX3Jlc3BvbnNlX2hhbmRsZXJcbiAgICAgICAgaWYgKHByb3h5LmN1c3RvbV9hdXRoX3Jlc3BvbnNlX2hhbmRsZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIHByb3h5LmN1c3RvbV9hdXRoX3Jlc3BvbnNlX2hhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB1dGlsXzEuU29ja3NDbGllbnRFcnJvcihjb25zdGFudHNfMS5FUlJPUlMuSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0N1c3RvbUF1dGhPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgU29ja3NSZW1vdGVIb3N0XG4gKiBAcGFyYW0gcmVtb3RlSG9zdCB7IFNvY2tzUmVtb3RlSG9zdCB9XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTb2Nrc1JlbW90ZUhvc3QocmVtb3RlSG9zdCkge1xuICAgIHJldHVybiAocmVtb3RlSG9zdCAmJlxuICAgICAgICB0eXBlb2YgcmVtb3RlSG9zdC5ob3N0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aChyZW1vdGVIb3N0Lmhvc3QpIDwgMjU2ICYmXG4gICAgICAgIHR5cGVvZiByZW1vdGVIb3N0LnBvcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHJlbW90ZUhvc3QucG9ydCA+PSAwICYmXG4gICAgICAgIHJlbW90ZUhvc3QucG9ydCA8PSA2NTUzNSk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIFNvY2tzUHJveHlcbiAqIEBwYXJhbSBwcm94eSB7IFNvY2tzUHJveHkgfVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU29ja3NQcm94eShwcm94eSkge1xuICAgIHJldHVybiAocHJveHkgJiZcbiAgICAgICAgKHR5cGVvZiBwcm94eS5ob3N0ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJveHkuaXBhZGRyZXNzID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgdHlwZW9mIHByb3h5LnBvcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHByb3h5LnBvcnQgPj0gMCAmJlxuICAgICAgICBwcm94eS5wb3J0IDw9IDY1NTM1ICYmXG4gICAgICAgIChwcm94eS50eXBlID09PSA0IHx8IHByb3h5LnR5cGUgPT09IDUpKTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgdGltZW91dCB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZSB7IE51bWJlciB9XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRUaW1lb3V0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IDA7XG59XG5mdW5jdGlvbiBpcHY0VG9JbnQzMihpcCkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgaXBfYWRkcmVzc18xLkFkZHJlc3M0KGlwKTtcbiAgICAvLyBDb252ZXJ0IHRoZSBJUHY0IGFkZHJlc3MgcGFydHMgdG8gYW4gaW50ZWdlclxuICAgIHJldHVybiBhZGRyZXNzLnRvQXJyYXkoKS5yZWR1Y2UoKGFjYywgcGFydCkgPT4gKGFjYyA8PCA4KSArIHBhcnQsIDApID4+PiAwO1xufVxuZXhwb3J0cy5pcHY0VG9JbnQzMiA9IGlwdjRUb0ludDMyO1xuZnVuY3Rpb24gaW50MzJUb0lwdjQoaW50MzIpIHtcbiAgICAvLyBFeHRyYWN0IGVhY2ggYnl0ZSAob2N0ZXQpIGZyb20gdGhlIDMyLWJpdCBpbnRlZ2VyXG4gICAgY29uc3Qgb2N0ZXQxID0gKGludDMyID4+PiAyNCkgJiAweGZmO1xuICAgIGNvbnN0IG9jdGV0MiA9IChpbnQzMiA+Pj4gMTYpICYgMHhmZjtcbiAgICBjb25zdCBvY3RldDMgPSAoaW50MzIgPj4+IDgpICYgMHhmZjtcbiAgICBjb25zdCBvY3RldDQgPSBpbnQzMiAmIDB4ZmY7XG4gICAgLy8gQ29tYmluZSB0aGUgb2N0ZXRzIGludG8gYSBzdHJpbmcgaW4gSVB2NCBmb3JtYXRcbiAgICByZXR1cm4gW29jdGV0MSwgb2N0ZXQyLCBvY3RldDMsIG9jdGV0NF0uam9pbignLicpO1xufVxuZXhwb3J0cy5pbnQzMlRvSXB2NCA9IGludDMyVG9JcHY0O1xuZnVuY3Rpb24gaXBUb0J1ZmZlcihpcCkge1xuICAgIGlmIChuZXQuaXNJUHY0KGlwKSkge1xuICAgICAgICAvLyBIYW5kbGUgSVB2NCBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBpcF9hZGRyZXNzXzEuQWRkcmVzczQoaXApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYWRkcmVzcy50b0FycmF5KCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXQuaXNJUHY2KGlwKSkge1xuICAgICAgICAvLyBIYW5kbGUgSVB2NiBhZGRyZXNzZXNcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBpcF9hZGRyZXNzXzEuQWRkcmVzczYoaXApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYWRkcmVzc1xuICAgICAgICAgICAgLmNhbm9uaWNhbEZvcm0oKVxuICAgICAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHNlZ21lbnQucGFkU3RhcnQoNCwgJzAnKSlcbiAgICAgICAgICAgIC5qb2luKCcnKSwgJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElQIGFkZHJlc3MgZm9ybWF0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5pcFRvQnVmZmVyID0gaXBUb0J1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXBUb0J1ZmZlciIsImludDMyVG9JcHY0IiwiaXB2NFRvSW50MzIiLCJ2YWxpZGF0ZVNvY2tzQ2xpZW50Q2hhaW5PcHRpb25zIiwidmFsaWRhdGVTb2Nrc0NsaWVudE9wdGlvbnMiLCJ1dGlsXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJzdHJlYW0iLCJpcF9hZGRyZXNzXzEiLCJuZXQiLCJvcHRpb25zIiwiYWNjZXB0ZWRDb21tYW5kcyIsIlNvY2tzQ29tbWFuZCIsImNvbW1hbmQiLCJTb2Nrc0NsaWVudEVycm9yIiwiRVJST1JTIiwiSW52YWxpZFNvY2tzQ29tbWFuZCIsImluZGV4T2YiLCJJbnZhbGlkU29ja3NDb21tYW5kRm9yT3BlcmF0aW9uIiwiaXNWYWxpZFNvY2tzUmVtb3RlSG9zdCIsImRlc3RpbmF0aW9uIiwiSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0Rlc3RpbmF0aW9uIiwiaXNWYWxpZFNvY2tzUHJveHkiLCJwcm94eSIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNQcm94eSIsInZhbGlkYXRlQ3VzdG9tUHJveHlBdXRoIiwidGltZW91dCIsImlzVmFsaWRUaW1lb3V0VmFsdWUiLCJJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zVGltZW91dCIsImV4aXN0aW5nX3NvY2tldCIsIkR1cGxleCIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNFeGlzdGluZ1NvY2tldCIsIkludmFsaWRTb2Nrc0NvbW1hbmRDaGFpbiIsInByb3hpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJJbnZhbGlkU29ja3NDbGllbnRPcHRpb25zUHJveGllc0xlbmd0aCIsImZvckVhY2giLCJjdXN0b21fYXV0aF9tZXRob2QiLCJ1bmRlZmluZWQiLCJTT0NLUzVfQ1VTVE9NX0FVVEhfU1RBUlQiLCJTT0NLUzVfQ1VTVE9NX0FVVEhfRU5EIiwiSW52YWxpZFNvY2tzQ2xpZW50T3B0aW9uc0N1c3RvbUF1dGhSYW5nZSIsImN1c3RvbV9hdXRoX3JlcXVlc3RfaGFuZGxlciIsIkludmFsaWRTb2Nrc0NsaWVudE9wdGlvbnNDdXN0b21BdXRoT3B0aW9ucyIsImN1c3RvbV9hdXRoX3Jlc3BvbnNlX3NpemUiLCJjdXN0b21fYXV0aF9yZXNwb25zZV9oYW5kbGVyIiwicmVtb3RlSG9zdCIsImhvc3QiLCJCdWZmZXIiLCJieXRlTGVuZ3RoIiwicG9ydCIsImlwYWRkcmVzcyIsInR5cGUiLCJpcCIsImFkZHJlc3MiLCJBZGRyZXNzNCIsInRvQXJyYXkiLCJyZWR1Y2UiLCJhY2MiLCJwYXJ0IiwiaW50MzIiLCJvY3RldDEiLCJvY3RldDIiLCJvY3RldDMiLCJvY3RldDQiLCJqb2luIiwiaXNJUHY0IiwiZnJvbSIsImlzSVB2NiIsIkFkZHJlc3M2IiwiY2Fub25pY2FsRm9ybSIsInNwbGl0IiwibWFwIiwic2VnbWVudCIsInBhZFN0YXJ0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/receivebuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/socks/build/common/receivebuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ReceiveBuffer = void 0;\nclass ReceiveBuffer {\n    constructor(size = 4096){\n        this.buffer = Buffer.allocUnsafe(size);\n        this.offset = 0;\n        this.originalSize = size;\n    }\n    get length() {\n        return this.offset;\n    }\n    append(data) {\n        if (!Buffer.isBuffer(data)) {\n            throw new Error(\"Attempted to append a non-buffer instance to ReceiveBuffer.\");\n        }\n        if (this.offset + data.length >= this.buffer.length) {\n            const tmp = this.buffer;\n            this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));\n            tmp.copy(this.buffer);\n        }\n        data.copy(this.buffer, this.offset);\n        return this.offset += data.length;\n    }\n    peek(length) {\n        if (length > this.offset) {\n            throw new Error(\"Attempted to read beyond the bounds of the managed internal data.\");\n        }\n        return this.buffer.slice(0, length);\n    }\n    get(length) {\n        if (length > this.offset) {\n            throw new Error(\"Attempted to read beyond the bounds of the managed internal data.\");\n        }\n        const value = Buffer.allocUnsafe(length);\n        this.buffer.slice(0, length).copy(value);\n        this.buffer.copyWithin(0, length, length + this.offset - length);\n        this.offset -= length;\n        return value;\n    }\n}\nexports.ReceiveBuffer = ReceiveBuffer; //# sourceMappingURL=receivebuffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL3JlY2VpdmVidWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsTUFBTUU7SUFDRkMsWUFBWUMsT0FBTyxJQUFJLENBQUU7UUFDckIsSUFBSSxDQUFDQyxNQUFNLEdBQUdDLE9BQU9DLFdBQVcsQ0FBQ0g7UUFDakMsSUFBSSxDQUFDSSxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLFlBQVksR0FBR0w7SUFDeEI7SUFDQSxJQUFJTSxTQUFTO1FBQ1QsT0FBTyxJQUFJLENBQUNGLE1BQU07SUFDdEI7SUFDQUcsT0FBT0MsSUFBSSxFQUFFO1FBQ1QsSUFBSSxDQUFDTixPQUFPTyxRQUFRLENBQUNELE9BQU87WUFDeEIsTUFBTSxJQUFJRSxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxJQUFJLENBQUNOLE1BQU0sR0FBR0ksS0FBS0YsTUFBTSxJQUFJLElBQUksQ0FBQ0wsTUFBTSxDQUFDSyxNQUFNLEVBQUU7WUFDakQsTUFBTUssTUFBTSxJQUFJLENBQUNWLE1BQU07WUFDdkIsSUFBSSxDQUFDQSxNQUFNLEdBQUdDLE9BQU9DLFdBQVcsQ0FBQ1MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ1osTUFBTSxDQUFDSyxNQUFNLEdBQUcsSUFBSSxDQUFDRCxZQUFZLEVBQUUsSUFBSSxDQUFDSixNQUFNLENBQUNLLE1BQU0sR0FBR0UsS0FBS0YsTUFBTTtZQUNsSEssSUFBSUcsSUFBSSxDQUFDLElBQUksQ0FBQ2IsTUFBTTtRQUN4QjtRQUNBTyxLQUFLTSxJQUFJLENBQUMsSUFBSSxDQUFDYixNQUFNLEVBQUUsSUFBSSxDQUFDRyxNQUFNO1FBQ2xDLE9BQVEsSUFBSSxDQUFDQSxNQUFNLElBQUlJLEtBQUtGLE1BQU07SUFDdEM7SUFDQVMsS0FBS1QsTUFBTSxFQUFFO1FBQ1QsSUFBSUEsU0FBUyxJQUFJLENBQUNGLE1BQU0sRUFBRTtZQUN0QixNQUFNLElBQUlNLE1BQU07UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ1QsTUFBTSxDQUFDZSxLQUFLLENBQUMsR0FBR1Y7SUFDaEM7SUFDQVcsSUFBSVgsTUFBTSxFQUFFO1FBQ1IsSUFBSUEsU0FBUyxJQUFJLENBQUNGLE1BQU0sRUFBRTtZQUN0QixNQUFNLElBQUlNLE1BQU07UUFDcEI7UUFDQSxNQUFNYixRQUFRSyxPQUFPQyxXQUFXLENBQUNHO1FBQ2pDLElBQUksQ0FBQ0wsTUFBTSxDQUFDZSxLQUFLLENBQUMsR0FBR1YsUUFBUVEsSUFBSSxDQUFDakI7UUFDbEMsSUFBSSxDQUFDSSxNQUFNLENBQUNpQixVQUFVLENBQUMsR0FBR1osUUFBUUEsU0FBUyxJQUFJLENBQUNGLE1BQU0sR0FBR0U7UUFDekQsSUFBSSxDQUFDRixNQUFNLElBQUlFO1FBQ2YsT0FBT1Q7SUFDWDtBQUNKO0FBQ0FELHFCQUFxQixHQUFHRSxlQUN4Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXZpbC1lbmdpbmVlcmluZy1wbGF0Zm9ybS8uL25vZGVfbW9kdWxlcy9zb2Nrcy9idWlsZC9jb21tb24vcmVjZWl2ZWJ1ZmZlci5qcz9kZDk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWNlaXZlQnVmZmVyID0gdm9pZCAwO1xuY2xhc3MgUmVjZWl2ZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSA9IDQwOTYpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFNpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gICAgfVxuICAgIGFwcGVuZChkYXRhKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBhcHBlbmQgYSBub24tYnVmZmVyIGluc3RhbmNlIHRvIFJlY2VpdmVCdWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0ICsgZGF0YS5sZW5ndGggPj0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKE1hdGgubWF4KHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMub3JpZ2luYWxTaXplLCB0aGlzLmJ1ZmZlci5sZW5ndGggKyBkYXRhLmxlbmd0aCkpO1xuICAgICAgICAgICAgdG1wLmNvcHkodGhpcy5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuY29weSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQpO1xuICAgICAgICByZXR1cm4gKHRoaXMub2Zmc2V0ICs9IGRhdGEubGVuZ3RoKTtcbiAgICB9XG4gICAgcGVlayhsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byByZWFkIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBtYW5hZ2VkIGludGVybmFsIGRhdGEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIGdldChsZW5ndGgpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byByZWFkIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBtYW5hZ2VkIGludGVybmFsIGRhdGEuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoKS5jb3B5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5idWZmZXIuY29weVdpdGhpbigwLCBsZW5ndGgsIGxlbmd0aCArIHRoaXMub2Zmc2V0IC0gbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5SZWNlaXZlQnVmZmVyID0gUmVjZWl2ZUJ1ZmZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY2VpdmVidWZmZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVjZWl2ZUJ1ZmZlciIsImNvbnN0cnVjdG9yIiwic2l6ZSIsImJ1ZmZlciIsIkJ1ZmZlciIsImFsbG9jVW5zYWZlIiwib2Zmc2V0Iiwib3JpZ2luYWxTaXplIiwibGVuZ3RoIiwiYXBwZW5kIiwiZGF0YSIsImlzQnVmZmVyIiwiRXJyb3IiLCJ0bXAiLCJNYXRoIiwibWF4IiwiY29weSIsInBlZWsiLCJzbGljZSIsImdldCIsImNvcHlXaXRoaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/receivebuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/common/util.js":
/*!*************************************************!*\
  !*** ./node_modules/socks/build/common/util.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shuffleArray = exports.SocksClientError = void 0;\n/**\n * Error wrapper for SocksClient\n */ class SocksClientError extends Error {\n    constructor(message, options){\n        super(message);\n        this.options = options;\n    }\n}\nexports.SocksClientError = SocksClientError;\n/**\n * Shuffles a given array.\n * @param array The array to shuffle.\n */ function shuffleArray(array) {\n    for(let i = array.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [\n            array[j],\n            array[i]\n        ];\n    }\n}\nexports.shuffleArray = shuffleArray; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3ZEOztDQUVDLEdBQ0QsTUFBTUcseUJBQXlCQztJQUMzQkMsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDMUIsS0FBSyxDQUFDRDtRQUNOLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtBQUNKO0FBQ0FQLHdCQUF3QixHQUFHRztBQUMzQjs7O0NBR0MsR0FDRCxTQUFTRCxhQUFhTSxLQUFLO0lBQ3ZCLElBQUssSUFBSUMsSUFBSUQsTUFBTUUsTUFBTSxHQUFHLEdBQUdELElBQUksR0FBR0EsSUFBSztRQUN2QyxNQUFNRSxJQUFJQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBTUwsQ0FBQUEsSUFBSTtRQUMxQyxDQUFDRCxLQUFLLENBQUNDLEVBQUUsRUFBRUQsS0FBSyxDQUFDRyxFQUFFLENBQUMsR0FBRztZQUFDSCxLQUFLLENBQUNHLEVBQUU7WUFBRUgsS0FBSyxDQUFDQyxFQUFFO1NBQUM7SUFDL0M7QUFDSjtBQUNBVCxvQkFBb0IsR0FBR0UsY0FDdkIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2l2aWwtZW5naW5lZXJpbmctcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvY29tbW9uL3V0aWwuanM/NmM5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2h1ZmZsZUFycmF5ID0gZXhwb3J0cy5Tb2Nrc0NsaWVudEVycm9yID0gdm9pZCAwO1xuLyoqXG4gKiBFcnJvciB3cmFwcGVyIGZvciBTb2Nrc0NsaWVudFxuICovXG5jbGFzcyBTb2Nrc0NsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2Nrc0NsaWVudEVycm9yID0gU29ja3NDbGllbnRFcnJvcjtcbi8qKlxuICogU2h1ZmZsZXMgYSBnaXZlbiBhcnJheS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZUFycmF5KGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBbYXJyYXlbaV0sIGFycmF5W2pdXSA9IFthcnJheVtqXSwgYXJyYXlbaV1dO1xuICAgIH1cbn1cbmV4cG9ydHMuc2h1ZmZsZUFycmF5ID0gc2h1ZmZsZUFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzaHVmZmxlQXJyYXkiLCJTb2Nrc0NsaWVudEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiYXJyYXkiLCJpIiwibGVuZ3RoIiwiaiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/common/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/socks/build/index.js":
/*!*******************************************!*\
  !*** ./node_modules/socks/build/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function(m, exports1) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__exportStar(__webpack_require__(/*! ./client/socksclient */ \"(rsc)/./node_modules/socks/build/client/socksclient.js\"), exports); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc29ja3MvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsSUFBSyxJQUFJLElBQUksQ0FBQ0EsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcsZUFBZSxJQUFLLElBQUksSUFBSSxDQUFDQSxZQUFZLElBQUssU0FBU1osQ0FBQyxFQUFFYSxRQUFPO0lBQ2pFLElBQUssSUFBSUMsS0FBS2QsRUFBRyxJQUFJYyxNQUFNLGFBQWEsQ0FBQ2pCLE9BQU9rQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixVQUFTQyxJQUFJbEIsZ0JBQWdCaUIsVUFBU2IsR0FBR2M7QUFDM0g7QUFDQWpCLDhDQUE2QztJQUFFcUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RE4sYUFBYU8sbUJBQU9BLENBQUMsb0ZBQXNCLEdBQUdOLFVBQzlDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NpdmlsLWVuZ2luZWVyaW5nLXBsYXRmb3JtLy4vbm9kZV9tb2R1bGVzL3NvY2tzL2J1aWxkL2luZGV4LmpzP2E3OTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jbGllbnQvc29ja3NjbGllbnRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0U3RhciIsImV4cG9ydHMiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/socks/build/index.js\n");

/***/ })

};
;